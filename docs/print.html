<!DOCTYPE HTML>
<html lang="zh-Hans" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TypeScript 使用指南手册</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="TypeScript Handbook 中文翻译。">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="PREFACE.html">前言</a></li><li class="chapter-item expanded affix "><li class="part-title">快速上手</li><li class="chapter-item expanded "><a href="zh/tutorials/index.html"><strong aria-hidden="true">1.</strong> 快速上手</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zh/tutorials/typescript-in-5-minutes.html"><strong aria-hidden="true">1.1.</strong> 5 分钟了解 TypeScript</a></li><li class="chapter-item expanded "><a href="zh/tutorials/asp.net-core.html"><strong aria-hidden="true">1.2.</strong> ASP.NET Core</a></li><li class="chapter-item expanded "><a href="zh/tutorials/asp.net-4.html"><strong aria-hidden="true">1.3.</strong> ASP.NET 4</a></li><li class="chapter-item expanded "><a href="zh/tutorials/gulp.html"><strong aria-hidden="true">1.4.</strong> Gulp</a></li><li class="chapter-item expanded "><a href="zh/tutorials/knockout.html"><strong aria-hidden="true">1.5.</strong> Knockout.js</a></li><li class="chapter-item expanded "><a href="zh/tutorials/react-and-webpack.html"><strong aria-hidden="true">1.6.</strong> React 与 webpack</a></li><li class="chapter-item expanded "><a href="zh/tutorials/react.html"><strong aria-hidden="true">1.7.</strong> React</a></li><li class="chapter-item expanded "><a href="zh/tutorials/angular-2.html"><strong aria-hidden="true">1.8.</strong> Angular 2</a></li><li class="chapter-item expanded "><a href="zh/tutorials/migrating-from-javascript.html"><strong aria-hidden="true">1.9.</strong> 从 JavaScript 迁移到 TypeScript</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">手册</li><li class="chapter-item expanded "><a href="zh/handbook/index.html"><strong aria-hidden="true">2.</strong> 手册</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zh/handbook/basic-types.html"><strong aria-hidden="true">2.1.</strong> 基础类型</a></li><li class="chapter-item expanded "><a href="zh/handbook/interfaces.html"><strong aria-hidden="true">2.2.</strong> 接口</a></li><li class="chapter-item expanded "><a href="zh/handbook/functions.html"><strong aria-hidden="true">2.3.</strong> 函数</a></li><li class="chapter-item expanded "><a href="zh/handbook/literal-types.html"><strong aria-hidden="true">2.4.</strong> 字面量类型</a></li><li class="chapter-item expanded "><a href="zh/handbook/unions-and-intersections.html"><strong aria-hidden="true">2.5.</strong> 联合类型和交叉类型</a></li><li class="chapter-item expanded "><a href="zh/handbook/classes.html"><strong aria-hidden="true">2.6.</strong> 类</a></li><li class="chapter-item expanded "><a href="zh/handbook/enums.html"><strong aria-hidden="true">2.7.</strong> 枚举</a></li><li class="chapter-item expanded "><a href="zh/handbook/generics.html"><strong aria-hidden="true">2.8.</strong> 泛型</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">手册（进阶）</li><li class="chapter-item expanded "><a href="zh/reference/index.html"><strong aria-hidden="true">3.</strong> 手册（进阶）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zh/reference/advanced-types.html"><strong aria-hidden="true">3.1.</strong> 高级类型</a></li><li class="chapter-item expanded "><a href="zh/reference/utility-types.html"><strong aria-hidden="true">3.2.</strong> 实用工具类型</a></li><li class="chapter-item expanded "><a href="zh/reference/decorators.html"><strong aria-hidden="true">3.3.</strong> Decorators</a></li><li class="chapter-item expanded "><a href="zh/reference/declaration-merging.html"><strong aria-hidden="true">3.4.</strong> 声明合并</a></li><li class="chapter-item expanded "><a href="zh/reference/iterators-and-generators.html"><strong aria-hidden="true">3.5.</strong> Iterators 和 Generators</a></li><li class="chapter-item expanded "><a href="zh/reference/jsx.html"><strong aria-hidden="true">3.6.</strong> JSX</a></li><li class="chapter-item expanded "><a href="zh/reference/mixins.html"><strong aria-hidden="true">3.7.</strong> 混入</a></li><li class="chapter-item expanded "><a href="zh/reference/modules.html"><strong aria-hidden="true">3.8.</strong> 模块</a></li><li class="chapter-item expanded "><a href="zh/reference/module-resolution.html"><strong aria-hidden="true">3.9.</strong> 模块解析</a></li><li class="chapter-item expanded "><a href="zh/reference/namespaces.html"><strong aria-hidden="true">3.10.</strong> 命名空间</a></li><li class="chapter-item expanded "><a href="zh/reference/namespaces-and-modules.html"><strong aria-hidden="true">3.11.</strong> 命名空间和模块</a></li><li class="chapter-item expanded "><a href="zh/reference/symbols.html"><strong aria-hidden="true">3.12.</strong> Symbols</a></li><li class="chapter-item expanded "><a href="zh/reference/triple-slash-directives.html"><strong aria-hidden="true">3.13.</strong> 三斜线指令</a></li><li class="chapter-item expanded "><a href="zh/reference/type-compatibility.html"><strong aria-hidden="true">3.14.</strong> 类型兼容性</a></li><li class="chapter-item expanded "><a href="zh/reference/type-inference.html"><strong aria-hidden="true">3.15.</strong> 类型推论</a></li><li class="chapter-item expanded "><a href="zh/reference/variable-declarations.html"><strong aria-hidden="true">3.16.</strong> 变量声明</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">手册（v2）</li><li class="chapter-item expanded "><a href="zh/handbook-v2/index.html"><strong aria-hidden="true">4.</strong> 手册（v2）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zh/handbook-v2/type-manipulation/template-literal-types.html"><strong aria-hidden="true">4.1.</strong> 模版字面量类型</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">TypeScript 声明文件（.d.ts）</li><li class="chapter-item expanded "><a href="zh/declaration-files/index.html"><strong aria-hidden="true">5.</strong> 如何书写声明文件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zh/declaration-files/introduction.html"><strong aria-hidden="true">5.1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="zh/declaration-files/by-example.html"><strong aria-hidden="true">5.2.</strong> 举例</a></li><li class="chapter-item expanded "><a href="zh/declaration-files/library-structures.html"><strong aria-hidden="true">5.3.</strong> 库结构</a></li><li class="chapter-item expanded "><a href="zh/declaration-files/templates.html"><strong aria-hidden="true">5.4.</strong> 模板</a></li><li class="chapter-item expanded "><a href="zh/declaration-files/do-s-and-don-ts.html"><strong aria-hidden="true">5.5.</strong> 最佳实践</a></li><li class="chapter-item expanded "><a href="zh/declaration-files/deep-dive.html"><strong aria-hidden="true">5.6.</strong> 深入</a></li><li class="chapter-item expanded "><a href="zh/declaration-files/publishing.html"><strong aria-hidden="true">5.7.</strong> 发布</a></li><li class="chapter-item expanded "><a href="zh/declaration-files/consumption.html"><strong aria-hidden="true">5.8.</strong> 使用</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">TypeScript for JavaScript</li><li class="chapter-item expanded "><a href="zh/javascript/type-checking-javascript-files.html"><strong aria-hidden="true">6.</strong> JavaScript 文件里的类型检查</a></li><li class="chapter-item expanded affix "><li class="part-title">工程配置</li><li class="chapter-item expanded "><a href="zh/project-config/index.html"><strong aria-hidden="true">7.</strong> 工程配置</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zh/project-config/tsconfig.json.html"><strong aria-hidden="true">7.1.</strong> tsconfig.json</a></li><li class="chapter-item expanded "><a href="zh/project-config/project-references.html"><strong aria-hidden="true">7.2.</strong> 工程引用</a></li><li class="chapter-item expanded "><a href="zh/project-config/typings-for-npm-packages.html"><strong aria-hidden="true">7.3.</strong> NPM 包的类型</a></li><li class="chapter-item expanded "><a href="zh/project-config/compiler-options.html"><strong aria-hidden="true">7.4.</strong> 编译选项</a></li><li class="chapter-item expanded "><a href="zh/project-config/configuring-watch.html"><strong aria-hidden="true">7.5.</strong> 配置 Watch</a></li><li class="chapter-item expanded "><a href="zh/project-config/compiler-options-in-msbuild.html"><strong aria-hidden="true">7.6.</strong> 在 MSBuild 里使用编译选项</a></li><li class="chapter-item expanded "><a href="zh/project-config/integrating-with-build-tools.html"><strong aria-hidden="true">7.7.</strong> 与其它构建工具整合</a></li><li class="chapter-item expanded "><a href="zh/project-config/nightly-builds.html"><strong aria-hidden="true">7.8.</strong> 使用 TypeScript 的每日构建版本</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">版本发布说明（Release Notes）</li><li class="chapter-item expanded "><a href="zh/release-notes/index.html"><strong aria-hidden="true">8.</strong> 新增功能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zh/release-notes/typescript-5.4.html"><strong aria-hidden="true">8.1.</strong> TypeScript 5.4</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-5.3.html"><strong aria-hidden="true">8.2.</strong> TypeScript 5.3</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-5.2.html"><strong aria-hidden="true">8.3.</strong> TypeScript 5.2</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-5.1.html"><strong aria-hidden="true">8.4.</strong> TypeScript 5.1</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-5.0.html"><strong aria-hidden="true">8.5.</strong> TypeScript 5.0</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-4.9.html"><strong aria-hidden="true">8.6.</strong> TypeScript 4.9</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-4.8.html"><strong aria-hidden="true">8.7.</strong> TypeScript 4.8</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-4.7.html"><strong aria-hidden="true">8.8.</strong> TypeScript 4.7</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-4.6.html"><strong aria-hidden="true">8.9.</strong> TypeScript 4.6</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-4.5.html"><strong aria-hidden="true">8.10.</strong> TypeScript 4.5</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-4.4.html"><strong aria-hidden="true">8.11.</strong> TypeScript 4.4</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-4.3.html"><strong aria-hidden="true">8.12.</strong> TypeScript 4.3</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-4.2.html"><strong aria-hidden="true">8.13.</strong> TypeScript 4.2</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-4.1.html"><strong aria-hidden="true">8.14.</strong> TypeScript 4.1</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-4.0.html"><strong aria-hidden="true">8.15.</strong> TypeScript 4.0</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-3.9.html"><strong aria-hidden="true">8.16.</strong> TypeScript 3.9</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-3.8.html"><strong aria-hidden="true">8.17.</strong> TypeScript 3.8</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-3.7.html"><strong aria-hidden="true">8.18.</strong> TypeScript 3.7</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-3.6.html"><strong aria-hidden="true">8.19.</strong> TypeScript 3.6</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-3.5.html"><strong aria-hidden="true">8.20.</strong> TypeScript 3.5</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-3.4.html"><strong aria-hidden="true">8.21.</strong> TypeScript 3.4</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-3.3.html"><strong aria-hidden="true">8.22.</strong> TypeScript 3.3</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-3.2.html"><strong aria-hidden="true">8.23.</strong> TypeScript 3.2</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-3.1.html"><strong aria-hidden="true">8.24.</strong> TypeScript 3.1</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-3.0.html"><strong aria-hidden="true">8.25.</strong> TypeScript 3.0</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-2.9.html"><strong aria-hidden="true">8.26.</strong> TypeScript 2.9</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-2.8.html"><strong aria-hidden="true">8.27.</strong> TypeScript 2.8</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-2.7.html"><strong aria-hidden="true">8.28.</strong> TypeScript 2.7</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-2.6.html"><strong aria-hidden="true">8.29.</strong> TypeScript 2.6</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-2.5.html"><strong aria-hidden="true">8.30.</strong> TypeScript 2.5</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-2.4.html"><strong aria-hidden="true">8.31.</strong> TypeScript 2.4</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-2.3.html"><strong aria-hidden="true">8.32.</strong> TypeScript 2.3</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-2.2.html"><strong aria-hidden="true">8.33.</strong> TypeScript 2.2</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-2.1.html"><strong aria-hidden="true">8.34.</strong> TypeScript 2.1</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-2.0.html"><strong aria-hidden="true">8.35.</strong> TypeScript 2.0</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-1.8.html"><strong aria-hidden="true">8.36.</strong> TypeScript 1.8</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-1.7.html"><strong aria-hidden="true">8.37.</strong> TypeScript 1.7</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-1.6.html"><strong aria-hidden="true">8.38.</strong> TypeScript 1.6</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-1.5.html"><strong aria-hidden="true">8.39.</strong> TypeScript 1.5</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-1.4.html"><strong aria-hidden="true">8.40.</strong> TypeScript 1.4</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-1.3.html"><strong aria-hidden="true">8.41.</strong> TypeScript 1.3</a></li><li class="chapter-item expanded "><a href="zh/release-notes/typescript-1.1.html"><strong aria-hidden="true">8.42.</strong> TypeScript 1.1</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">破坏性改动（Breaking Changes）</li><li class="chapter-item expanded "><a href="zh/breaking-changes/index.html"><strong aria-hidden="true">9.</strong> Breaking Changes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-3.6.html"><strong aria-hidden="true">9.1.</strong> TypeScript 3.6</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-3.5.html"><strong aria-hidden="true">9.2.</strong> TypeScript 3.5</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-3.4.html"><strong aria-hidden="true">9.3.</strong> TypeScript 3.4</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-3.2.html"><strong aria-hidden="true">9.4.</strong> TypeScript 3.2</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-3.1.html"><strong aria-hidden="true">9.5.</strong> TypeScript 3.1</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-3.0.html"><strong aria-hidden="true">9.6.</strong> TypeScript 3.0</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-2.9.html"><strong aria-hidden="true">9.7.</strong> TypeScript 2.9</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-2.8.html"><strong aria-hidden="true">9.8.</strong> TypeScript 2.8</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-2.7.html"><strong aria-hidden="true">9.9.</strong> TypeScript 2.7</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-2.6.html"><strong aria-hidden="true">9.10.</strong> TypeScript 2.6</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-2.4.html"><strong aria-hidden="true">9.11.</strong> TypeScript 2.4</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-2.3.html"><strong aria-hidden="true">9.12.</strong> TypeScript 2.3</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-2.2.html"><strong aria-hidden="true">9.13.</strong> TypeScript 2.2</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-2.1.html"><strong aria-hidden="true">9.14.</strong> TypeScript 2.1</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-2.0.html"><strong aria-hidden="true">9.15.</strong> TypeScript 2.0</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-1.8.html"><strong aria-hidden="true">9.16.</strong> TypeScript 1.8</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-1.7.html"><strong aria-hidden="true">9.17.</strong> TypeScript 1.7</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-1.6.html"><strong aria-hidden="true">9.18.</strong> TypeScript 1.6</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-1.5.html"><strong aria-hidden="true">9.19.</strong> TypeScript 1.5</a></li><li class="chapter-item expanded "><a href="zh/breaking-changes/typescript-1.4.html"><strong aria-hidden="true">9.20.</strong> TypeScript 1.4</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">TypeScript 使用指南手册</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<blockquote>
<p>Repo: https://github.com/zhongsp/TypeScript</p>
</blockquote>
<p>该工程是对 TypeScript 官方及开源社区书写的编程手册、版本发布说明等综合内容的中文翻译。
感谢 Microsoft 和开源社区的工程师们的工作，为 JavaScript 开发带来了全新的体验！</p>
<p>这个项目是我在 2015 年创建的，没想到已经维护快 7 年了，它已然是我参与过的时间最长的项目。
在 2015 年之前，我都是在使用 JavaScript 语言，主要参与的项目也大都是采用 AngularJS 框架的项目，没有接触过 TypeScript。
那时候，TypeScript 在国内项目里用的好像不多，但是在国外已经有不少项目开始采用这个新技术。
2015 年，我正好参与了一个和国外一起合作的项目，决定使用 TypeScript 1.x。
也正因为这个机会，我开始了 TypeScript 的学习。
学习没多久，我就喜欢上了这个语言，并且确信这个东西一定能火。
因为作为一个多年的 JavaScript 程序员来讲，我很清楚它解决了多少痛点（必须得把 VS Code 一起代上）。</p>
<p>早些时候，TypeScript 的文档也不多。
原因之一，TypeScript 是 JavaScript 的超集，JavaScript 的知识点已经有足够的资料了，TypeScript 一笔代过。
原因之二，早期的 TypeScript 里特性不多，知识点不多。原因之三，它的文档相较于做的好的语言来讲确实较弱，可能没什么专门的团队负责，或者没有专职的 technical writer 去写作。
于是，我决定边学边翻译，一方面为了自己，另一方面为了其它小伙伴。</p>
<h2 id="哪些内容会继续更新"><a class="header" href="#哪些内容会继续更新">哪些内容会继续更新？</a></h2>
<p>我会继续翻译 TypeScript 新版本的 Release Notes。</p>
<h2 id="哪些内容可能不会继续更新"><a class="header" href="#哪些内容可能不会继续更新">哪些内容可能不会继续更新？</a></h2>
<p>这个项目中的 Handbook 是翻译老版本的 Handbook。
TypeScript 官网大约从 2020 年开始要打造新版的官网，其中包括官网的样式，以及要重写大部分的文档。
目前，我不打算再翻译一遍新版的 Handbook。
我看了下新版的手册，确实优化了不少，但也不代表老版本是无用的或错误的。</p>
<p>现在，TypeScript 官网也开始支持国际化了，已经有部分文档翻译成了中文，我之前还翻译了一篇。
本着开源和为社区服务的精神，推荐学有余力的同学直接给官网提交翻译的 Pull Reuqest，造福开发者。</p>
<h2 id="关于typescript入门与实战一书"><a class="header" href="#关于typescript入门与实战一书">关于《TypeScript入门与实战》一书</a></h2>
<p>因为长期维护 TypeScript 更新的内容再加上在项目中一直使用 TypeScript，
所以有机会将知识进行梳理总结成书。</p>
<p>我出版了《TypeScript入门与实战》一书。</p>
<p><a href="https://github.com/zhongsp/TypeScript/issues/310"><img src="./zh/misc/ts-intro.png" alt="TypeScript入门与实战" width="200px" height="200px" style="vertical-align: bottom;"></a></p>
<p>在该书中，尝试着尽可能完整地介绍TypeScript语言的基础知识，并结合了一些本人的使用经验和体会。
它主要面向的是TypeScript语言的初级和中级使用者。
本人还处于TypeScript语言的学习阶段，可能存在理解错误的地方，还请大家指正，一起进步。
但需要强调的是，本书不是对 Handbook 的翻译。</p>
<h2 id="感谢"><a class="header" href="#感谢">感谢</a></h2>
<p>在过去的七年中，有很多素不相识、极富开源精神的小伙伴们曾参与到本工程的翻译与校对工作中。
对你们表示感谢！同时也欢迎其它任何想参与到该工程中的朋友们，贡献你们的力量！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速上手"><a class="header" href="#快速上手">快速上手</a></h1>
<ul>
<li><a href="zh/tutorials/typescript-in-5-minutes.html">5 分钟了解 TypeScript</a></li>
<li><a href="zh/tutorials/asp.net-core.html">ASP.NET Core</a></li>
<li><a href="zh/tutorials/asp.net-4.html">ASP.NET 4</a></li>
<li><a href="zh/tutorials/gulp.html">Gulp</a></li>
<li><a href="zh/tutorials/knockout.html">Knockout.js</a></li>
<li><a href="zh/tutorials/react-and-webpack.html">React 与 webpack</a></li>
<li><a href="zh/tutorials/react.html">React</a></li>
<li><a href="zh/tutorials/angular-2.html">Angular 2</a></li>
<li><a href="zh/tutorials/migrating-from-javascript.html">从 JavaScript 迁移到 TypeScript</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5分钟了解typescript"><a class="header" href="#5分钟了解typescript">5分钟了解TypeScript</a></h1>
<p>让我们使用TypeScript来创建一个简单的Web应用。</p>
<h2 id="安装typescript"><a class="header" href="#安装typescript">安装TypeScript</a></h2>
<p>有两种主要的方式来获取TypeScript工具：</p>
<ul>
<li>通过npm（Node.js包管理器）</li>
<li>安装Visual Studio的TypeScript插件</li>
</ul>
<p>Visual Studio 2017和Visual Studio 2015 Update 3默认包含了TypeScript。 如果你的Visual Studio还没有安装TypeScript，你可以下载它。</p>
<p>针对使用npm的用户：</p>
<pre><code class="language-text">&gt; npm install -g typescript
</code></pre>
<h2 id="构建你的第一个typescript文件"><a class="header" href="#构建你的第一个typescript文件">构建你的第一个TypeScript文件</a></h2>
<p>在编辑器，将下面的代码输入到<code>greeter.ts</code>文件里：</p>
<pre><code class="language-typescript">function greeter(person) {
    return "Hello, " + person;
}

let user = "Jane User";

document.body.textContent = greeter(user);
</code></pre>
<h2 id="编译代码"><a class="header" href="#编译代码">编译代码</a></h2>
<p>我们使用了<code>.ts</code>扩展名，但是这段代码仅仅是JavaScript而已。 你可以直接从现有的JavaScript应用里复制/粘贴这段代码。</p>
<p>在命令行上，运行TypeScript编译器：</p>
<pre><code class="language-text">tsc greeter.ts
</code></pre>
<p>输出结果为一个<code>greeter.js</code>文件，它包含了和输入文件中相同的JavsScript代码。 一切准备就绪，我们可以运行这个使用TypeScript写的JavaScript应用了！</p>
<p>接下来让我们看看TypeScript工具带来的高级功能。 给<code>person</code>函数的参数添加<code>: string</code>类型注解，如下：</p>
<pre><code class="language-typescript">function greeter(person: string) {
    return "Hello, " + person;
}

let user = "Jane User";

document.body.textContent = greeter(user);
</code></pre>
<h2 id="类型注解"><a class="header" href="#类型注解">类型注解</a></h2>
<p>TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望<code>greeter</code>函数接收一个字符串参数。 然后尝试把<code>greeter</code>的调用改成传入一个数组：</p>
<pre><code class="language-typescript">function greeter(person: string) {
    return "Hello, " + person;
}

let user = [0, 1, 2];

document.body.textContent = greeter(user);
</code></pre>
<p>重新编译，你会看到产生了一个错误。</p>
<pre><code class="language-text">error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.
</code></pre>
<p>类似地，尝试删除<code>greeter</code>调用的所有参数。 TypeScript会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p>
<p>要注意的是尽管有错误，<code>greeter.js</code>文件还是被创建了。 就算你的代码里有错误，你仍然可以使用TypeScript。但在这种情况下，TypeScript会警告你代码可能不会按预期执行。</p>
<h2 id="接口"><a class="header" href="#接口">接口</a></h2>
<p>让我们开发这个示例应用。这里我们使用接口来描述一个拥有<code>firstName</code>和<code>lastName</code>字段的对象。 在TypeScript里，只要两个类型内部的结构兼容那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用<code>implements</code>语句。</p>
<pre><code class="language-typescript">interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return "Hello, " + person.firstName + " " + person.lastName;
}

let user = { firstName: "Jane", lastName: "User" };

document.body.textContent = greeter(user);
</code></pre>
<h2 id="类"><a class="header" href="#类">类</a></h2>
<p>最后，让我们使用类来改写这个例子。 TypeScript支持JavaScript的新特性，比如支持基于类的面向对象编程。</p>
<p>让我们创建一个<code>Student</code>类，它带有一个构造函数和一些公共字段。 注意类和接口可以一起工作，程序员可以自行决定抽象的级别。</p>
<p>还要注意的是，在构造函数的参数上使用<code>public</code>等同于创建了同名的成员变量。</p>
<pre><code class="language-typescript">class Student {
    fullName: string;
    constructor(public firstName: string, public middleInitial: string, public lastName: string) {
        this.fullName = firstName + " " + middleInitial + " " + lastName;
    }
}

interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return "Hello, " + person.firstName + " " + person.lastName;
}

let user = new Student("Jane", "M.", "User");

document.body.textContent = greeter(user);
</code></pre>
<p>重新运行<code>tsc greeter.ts</code>，你会看到生成的JavaScript代码和原先的一样。 TypeScript里的类只是JavaScript里常用的基于原型面向对象编程的简写。</p>
<h2 id="运行typescript-web应用"><a class="header" href="#运行typescript-web应用">运行TypeScript Web应用</a></h2>
<p>在<code>greeter.html</code>里输入如下内容：</p>
<pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;&lt;title&gt;TypeScript Greeter&lt;/title&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;script src="greeter.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在浏览器里打开<code>greeter.html</code>运行这个应用！</p>
<p>可选地：在Visual Studio里打开<code>greeter.ts</code>或者把代码复制到TypeScript playground。 将鼠标悬停在标识符上查看它们的类型。 注意在某些情况下它们的类型可以被自动地推断出来。 重新输入一下最后一行代码，看一下自动补全列表和参数列表，它们会根据DOM元素类型而变化。 将光标放在<code>greeter</code>函数上，点击F12可以跟踪到它的定义。 还有一点，你可以右键点击标识，使用重构功能来重命名。</p>
<p>这些类型信息以及工具可以很好的和JavaScript一起工作。 更多的TypeScript功能演示，请查看本网站的示例部分。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aspnet-core"><a class="header" href="#aspnet-core">ASP.NET Core</a></h1>
<h2 id="aspnet-core-1"><a class="header" href="#aspnet-core-1">ASP.NET Core</a></h2>
<h3 id="安装-aspnet-core-和-typescript"><a class="header" href="#安装-aspnet-core-和-typescript">安装 ASP.NET Core 和 TypeScript</a></h3>
<p>首先，若有需要请<a href="https://get.asp.net">安装 ASP.NET Core</a>。此篇指南需要使用Visual Studio 2015或2017。</p>
<p>其次，如果你的Visual Studio不带有最新版本的TypeScript，你可以从<a href="http://www.microsoft.com/en-us/download/details.aspx?id=48593">这里</a>安装。</p>
<h3 id="新建工程"><a class="header" href="#新建工程">新建工程</a></h3>
<ol>
<li>
<p>选择 <strong>File</strong></p>
</li>
<li>
<p>选择 <strong>New Project</strong> （Ctrl + Shift + N）</p>
</li>
<li>
<p>选择 <strong>Visual C#</strong></p>
</li>
<li>
<p>若使用VS2015，选择 <strong>ASP.NET Web Application</strong> &gt; <strong>ASP.NET 5 Empty</strong>，并且取消勾选“Host in the cloud”，因为我们要在本地运行。</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/new-asp-project-empty.png" alt="使用空白模版" /></p>
</li>
<li>
<p>若使用VS2017，选择 <strong>ASP.NET Core Web Application (.NET Core)</strong> &gt; <strong>ASP.NET Core 1.1 Empty</strong>。</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/new-asp-project-empty-17.PNG" alt="使用空白模版VS2017" /></p>
</li>
</ol>
<p>运行此应用以确保它能正常工作。</p>
<h3 id="设置服务项"><a class="header" href="#设置服务项">设置服务项</a></h3>
<h4 id="vs2015"><a class="header" href="#vs2015">VS2015</a></h4>
<p>在 <code>project.json</code> 文件的 <code>"dependencies"</code> 字段里添加:</p>
<pre><code class="language-javascript">"Microsoft.AspNet.StaticFiles": "1.0.0-rc1-final"
</code></pre>
<p>最终的 dependencies 部分应该类似于下面这样：</p>
<pre><code class="language-javascript">"dependencies": {
  "Microsoft.AspNet.IISPlatformHandler": "1.0.0-rc1-final",
  "Microsoft.AspNet.Server.Kestrel": "1.0.0-rc1-final",
  "Microsoft.AspNet.StaticFiles": "1.0.0-rc1-final"
},
</code></pre>
<p>用以下内容替换 <code>Startup.cs</code> 文件里的 <code>Configure</code> 函数：</p>
<pre><code class="language-csharp">public void Configure(IApplicationBuilder app)
{
    app.UseIISPlatformHandler();
    app.UseDefaultFiles();
    app.UseStaticFiles();
}
</code></pre>
<h4 id="vs2017"><a class="header" href="#vs2017">VS2017</a></h4>
<p>打开 <strong>Dependencies</strong> &gt; <strong>Manage NuGet Packages</strong> &gt; <strong>Browse</strong>。搜索并安装<code>Microsoft.AspNetCore.StaticFiles</code> 1.1.2：</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/install-nuget-packages.png" alt="安装Microsoft.AspNetCore.StaticFiles" /></p>
<p>如下替换掉<code>Startup.cs</code>里<code>Configure</code>的内容：</p>
<pre><code class="language-csharp">public void Configure(IApplicationBuilder app)
{
    app.UseDefaultFiles();
    app.UseStaticFiles();
}
</code></pre>
<p>你可能需要重启VS，这样<code>UseDefaultFiles</code>和<code>UseStaticFiles</code>下面的波浪线才会消失。</p>
<h2 id="添加-typescript"><a class="header" href="#添加-typescript">添加 TypeScript</a></h2>
<p>下一步我们为 TypeScript 添加一个文件夹。</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/new-folder.png" alt="Create new folder" /></p>
<p>将文件夹命名为 <code>scripts</code>。</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/scripts-folder.png" alt="scripts folder" /></p>
<h3 id="添加-typescript-代码"><a class="header" href="#添加-typescript-代码">添加 TypeScript 代码</a></h3>
<p>在<code>scripts</code>上右击并选择<strong>New Item</strong>。 接着选择<strong>TypeScript File</strong>（也可能 .NET Core 部分），并将此文件命名为<code>app.ts</code>。</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/new-item.png" alt="New item" /></p>
<h3 id="添加示例代码"><a class="header" href="#添加示例代码">添加示例代码</a></h3>
<p>将以下代码写入app.ts文件。</p>
<pre><code class="language-typescript">function sayHello() {
  const compiler = (document.getElementById("compiler") as HTMLInputElement).value;
  const framework = (document.getElementById("framework") as HTMLInputElement).value;
  return `Hello from ${compiler} and ${framework}!`;
}
</code></pre>
<h3 id="构建设置"><a class="header" href="#构建设置">构建设置</a></h3>
<h4 id="配置-typescript-编译器"><a class="header" href="#配置-typescript-编译器">配置 TypeScript 编译器</a></h4>
<p>我们先来告诉TypeScript怎样构建。 右击scripts文件夹并选择<strong>New Item</strong>。 接着选择<strong>TypeScript Configuration File</strong>，保持文件的默认名字为<code>tsconfig.json</code>。</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/new-tsconfig.png" alt="Create tsconfig.json" /></p>
<p>将默认的<code>tsconfig.json</code>内容改为如下所示：</p>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "noImplicitAny": true,
    "noEmitOnError": true,
    "sourceMap": true,
    "target": "es5"
  },
  "files": [
    "./app.ts"
  ],
  "compileOnSave": true
}
</code></pre>
<p>看起来和默认的设置差不多，但注意以下不同之处：</p>
<ol>
<li>设置<code>"noImplicitAny": true</code>。</li>
<li>显式列出了<code>"files"</code>而不是依据<code>"excludes"</code>。</li>
<li>设置<code>"compileOnSave": true</code>。</li>
</ol>
<p>当你写新代码时，设置<code>"noImplicitAny"</code>选项是个不错的选择 — 这可以确保你不会错写任何新的类型。 设置<code>"compileOnSave"</code>选项可以确保你在运行web程序前自动编译保存变更后的代码。</p>
<h4 id="配置-npm"><a class="header" href="#配置-npm">配置 NPM</a></h4>
<p>现在，我们来配置NPM以使用我们能够下载JavaScript包。 在工程上右击并选择<strong>New Item</strong>。 接着选择<strong>NPM Configuration File</strong>，保持文件的默认名字为<code>package.json</code>。 在<code>"devDependencies"</code>部分添加"gulp"和"del"：</p>
<pre><code class="language-javascript">"devDependencies": {
  "gulp": "3.9.0",
  "del": "2.2.0"
}
</code></pre>
<p>保存这个文件后，Visual Studio将开始安装gulp和del。 若没有自动开始，请右击package.json文件选择<strong>Restore Packages</strong>。</p>
<h4 id="设置-gulp"><a class="header" href="#设置-gulp">设置 gulp</a></h4>
<p>最后，添加一个新JavaScript文件<code>gulpfile.js</code>。 键入以下内容：</p>
<pre><code class="language-javascript">/// &lt;binding AfterBuild='default' Clean='clean' /&gt;
/*
This file is the main entry point for defining Gulp tasks and using Gulp plugins.
Click here to learn more. http://go.microsoft.com/fwlink/?LinkId=518007
*/

var gulp = require('gulp');
var del = require('del');

var paths = {
  scripts: ['scripts/**/*.js', 'scripts/**/*.ts', 'scripts/**/*.map'],
};

gulp.task('clean', function () {
  return del(['wwwroot/scripts/**/*']);
});

gulp.task('default', function () {
  gulp.src(paths.scripts).pipe(gulp.dest('wwwroot/scripts'))
});
</code></pre>
<p>第一行是告诉Visual Studio构建完成后，立即运行'default'任务。 当你应答 Visual Studio 清除构建内容后，它也将运行'clean'任务。</p>
<p>现在，右击<code>gulpfile.js</code>并选择<strong>Task Runner Explorer</strong>。 若'default'和'clean'任务没有显示输出内容的话，请刷新explorer：</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/task-runner-explorer.png" alt="Refresh Task Runner Explorer" /></p>
<h3 id="编写html页"><a class="header" href="#编写html页">编写HTML页</a></h3>
<p>在<code>wwwroot</code>中添加一个新建项 <code>index.html</code>。 在<code>index.html</code>中写入以下代码：</p>
<pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;script src="scripts/app.js"&gt;&lt;/script&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="message"&gt;&lt;/div&gt;
    &lt;div&gt;
        Compiler: &lt;input id="compiler" value="TypeScript" onkeyup="document.getElementById('message').innerText = sayHello()" /&gt;&lt;br /&gt;
        Framework: &lt;input id="framework" value="ASP.NET" onkeyup="document.getElementById('message').innerText = sayHello()" /&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="测试"><a class="header" href="#测试">测试</a></h3>
<ol>
<li>运行项目。</li>
<li>在输入框中键入时，您应该看到一个消息：</li>
</ol>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/running-demo.png" alt="Picture of running demo" /></p>
<h3 id="调试"><a class="header" href="#调试">调试</a></h3>
<ol>
<li>在 Edge 浏览器中，按 F12 键并选择 <strong>Debugger</strong> 标签页。</li>
<li>展开 localhost 列表，选择 scripts/app.ts</li>
<li>在 <code>return</code> 那一行上打一个断点。</li>
<li>在输入框中键入一些内容，确认TypeScript代码命中断点，观察它是否能正确地工作。</li>
</ol>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/paused-demo.png" alt="Demo paused on breakpoint" /></p>
<p>这就是你需要知道的在ASP.NET中使用TypeScript的基本知识了。 接下来，我们引入Angular，写一个简单的Angular程序示例。</p>
<h2 id="添加-angular-2"><a class="header" href="#添加-angular-2">添加 Angular 2</a></h2>
<h3 id="使用-npm-下载依赖的包"><a class="header" href="#使用-npm-下载依赖的包">使用 NPM 下载依赖的包</a></h3>
<p>添加Angular 2和SystemJS到<code>package.json</code>的<code>dependencies</code>里。</p>
<p>对于VS2015，新的<code>dependencies</code>列表如下：</p>
<pre><code class="language-javascript">"dependencies": {
  "angular2": "2.0.0-beta.11",
  "systemjs": "0.19.24",
  "gulp": "3.9.0",
  "del": "2.2.0"
},
</code></pre>
<p>若使用VS2017，因为NPM3反对同行的依赖（peer dependencies），我们需要把Angular 2同行的依赖也直接列为依赖项：</p>
<pre><code class="language-javascript">"dependencies": {
  "angular2": "2.0.0-beta.11",
  "reflect-metadata": "0.1.2",
  "rxjs": "5.0.0-beta.2",
  "zone.js": "^0.6.4",
  "systemjs": "0.19.24",
  "gulp": "3.9.0",
  "del": "2.2.0"
},
</code></pre>
<h3 id="更新-tsconfigjson"><a class="header" href="#更新-tsconfigjson">更新 tsconfig.json</a></h3>
<p>现在安装好了Angular 2及其依赖项，我们需要启用TypeScript中实验性的装饰器支持。 我们还需要添加ES2015的声明，因为Angular使用core-js来支持像<code>Promise</code>的功能。 在未来，装饰器会成为默认设置，那时也就不再需要这些设置了。</p>
<p>添加<code>"experimentalDecorators": true, "emitDecoratorMetadata": true</code>到<code>"compilerOptions"</code>部分。 然后，再添加<code>"lib": ["es2015", "es5", "dom"]</code>到<code>"compilerOptions"</code>，以引入ES2015的声明。 最后，我们需要添加<code>"./model.ts"</code>到<code>"files"</code>里，我们接下来会创建它。 现在<code>tsconfig.json</code>看起来如下：</p>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "noImplicitAny": true,
    "noEmitOnError": true,
    "sourceMap": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "target": "es5",
    "lib": [
      "es2015", "es5", "dom"
    ]
  },
  "files": [
    "./app.ts",
    "./model.ts",
    "./main.ts",
  ],
  "compileOnSave": true
}
</code></pre>
<h3 id="将-angular-添加到-gulp-构建中"><a class="header" href="#将-angular-添加到-gulp-构建中">将 Angular 添加到 gulp 构建中</a></h3>
<p>最后，我们需要确保 Angular 文件作为 build 的一部分复制进来。 我们需要添加：</p>
<ol>
<li>库文件目录。</li>
<li>添加一个 <code>lib</code> 任务来输送文件到 <code>wwwroot</code>。</li>
<li>在 <code>default</code> 任务上添加 <code>lib</code> 任务依赖。</li>
</ol>
<p>更新后的 <code>gulpfile.js</code> 像如下所示：</p>
<pre><code class="language-markup">/// &lt;binding AfterBuild='default' Clean='clean' /&gt;
/*
This file is the main entry point for defining Gulp tasks and using Gulp plugins.
Click here to learn more. http://go.microsoft.com/fwlink/?LinkId=518007
*/

var gulp = require('gulp');
var del = require('del');

var paths = {
    scripts: ['scripts/**/*.js', 'scripts/**/*.ts', 'scripts/**/*.map'],
    libs: ['node_modules/angular2/bundles/angular2.js',
           'node_modules/angular2/bundles/angular2-polyfills.js',
           'node_modules/systemjs/dist/system.src.js',
           'node_modules/rxjs/bundles/Rx.js']
};

gulp.task('lib', function () {
    gulp.src(paths.libs).pipe(gulp.dest('wwwroot/scripts/lib'));
});

gulp.task('clean', function () {
    return del(['wwwroot/scripts/**/*']);
});

gulp.task('default', ['lib'], function () {
    gulp.src(paths.scripts).pipe(gulp.dest('wwwroot/scripts'));
});
</code></pre>
<p>此外，保存了此gulpfile后，要确保 Task Runner Explorer 能看到 <code>lib</code> 任务。</p>
<h3 id="用-typescript-写一个简单的-angular-应用"><a class="header" href="#用-typescript-写一个简单的-angular-应用">用 TypeScript 写一个简单的 Angular 应用</a></h3>
<p>首先，将 <code>app.ts</code> 改成：</p>
<pre><code class="language-typescript">import {Component} from "angular2/core"
import {MyModel} from "./model"

@Component({
    selector: `my-app`,
    template: `&lt;div&gt;Hello from {{getCompiler()}}&lt;/div&gt;`
})
export class MyApp {
    model = new MyModel();
    getCompiler() {
        return this.model.compiler;
    }
}
</code></pre>
<p>接着在<code>scripts</code>中添加TypeScript文件<code>model.ts</code>:</p>
<pre><code class="language-typescript">export class MyModel {
    compiler = "TypeScript";
}
</code></pre>
<p>再在<code>scripts</code>中添加<code>main.ts</code>：</p>
<pre><code class="language-typescript">import {bootstrap} from "angular2/platform/browser";
import {MyApp} from "./app";
bootstrap(MyApp);
</code></pre>
<p>最后，将<code>index.html</code>改成：</p>
<pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;script src="scripts/lib/angular2-polyfills.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/lib/system.src.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/lib/rx.js"&gt;&lt;/script&gt;
    &lt;script src="scripts/lib/angular2.js"&gt;&lt;/script&gt;
    &lt;script&gt;
    System.config({
        packages: {
            'scripts': {
                format: 'cjs',
                defaultExtension: 'js'
            }
        }
    });
    System.import('scripts/main').then(null, console.error.bind(console));
    &lt;/script&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;my-app&gt;Loading...&lt;/my-app&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这里加载了此应用。 运行 ASP.NET 应用，你应该能看到一个div显示"Loading..."紧接着更新成显示"Hello from TypeScript"。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aspnet-4"><a class="header" href="#aspnet-4">ASP.NET 4</a></h1>
<h2 id="aspnet-4-1"><a class="header" href="#aspnet-4-1">ASP.NET 4</a></h2>
<blockquote>
<p>注意： 此教程已从官方删除</p>
</blockquote>
<h3 id="安装-typescript"><a class="header" href="#安装-typescript">安装 TypeScript</a></h3>
<p>如果你使用的 Visual Studio 版本还不支持 TypeScript， 你可以安装 <a href="http://www.microsoft.com/en-us/download/details.aspx?id=48593">Visual Studio 2015</a> 或者 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=48739">Visual Studio 2013</a>。 这个快速上手指南使用的是 Visual Studio 2015。</p>
<h3 id="新建项目"><a class="header" href="#新建项目">新建项目</a></h3>
<ol>
<li>
<p>选择 <strong>File</strong></p>
</li>
<li>
<p>选择 <strong>New Project</strong></p>
</li>
<li>
<p>选择 <strong>Visual C#</strong></p>
</li>
<li>
<p>选择 <strong>ASP.NET Web Application</strong></p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/new-asp-project.png" alt="Create new ASP.NET project" /></p>
</li>
<li>
<p>选择 <strong>MVC</strong></p>
<p>取消复选 "Host in the cloud" 本指南将使用一个本地示例。 <img src="zh/tutorials/../assets/images/tutorials/aspnet/new-asp-project-template.png" alt="Use MVC template" /></p>
</li>
</ol>
<p>运行此应用以确保它能正常工作。</p>
<h2 id="添加-typescript-1"><a class="header" href="#添加-typescript-1">添加 TypeScript</a></h2>
<p>下一步我们为 TypeScript 添加一个文件夹。</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/new-folder.png" alt="Create new folder" /></p>
<p>将文件夹命名为 src。</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/src-folder.png" alt="src folder" /></p>
<h3 id="添加-typescript-代码-1"><a class="header" href="#添加-typescript-代码-1">添加 TypeScript 代码</a></h3>
<p>在 <code>src</code> 上右击并选择 <strong>New Item</strong>。 接着选择 <strong>TypeScript File</strong> 并将此文件命名为 <code>app.ts</code>。</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/new-item.png" alt="New item" /></p>
<h3 id="添加示例代码-1"><a class="header" href="#添加示例代码-1">添加示例代码</a></h3>
<p>将以下代码写入 <code>app.ts</code> 文件。</p>
<pre><code class="language-typescript">function sayHello() {
    const compiler = (document.getElementById("compiler") as HTMLInputElement).value;
    const framework = (document.getElementById("framework") as HTMLInputElement).value;
    return `Hello from ${compiler} and ${framework}!`;
}
</code></pre>
<h3 id="构建设置-1"><a class="header" href="#构建设置-1">构建设置</a></h3>
<p>右击项目并选择 <strong>New Item</strong>。 接着选择 <strong>TypeScript Configuration File</strong> 保持文件的默认名字为 <code>tsconfig.json</code>。</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/new-tsconfig.png" alt="Create tsconfig.json" /></p>
<p>将默认的 <code>tsconfig.json</code> 内容改为如下所示：</p>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "noImplicitAny": true,
    "noEmitOnError": true,
    "sourceMap": true,
    "target": "es5",
    "outDir": "./Scripts/App"
  },
  "files": [
    "./src/app.ts",
  ],
  "compileOnSave": true
}
</code></pre>
<p>看起来和默认的设置差不多，但注意以下不同之处：</p>
<ol>
<li>设置 <code>"noImplicitAny": true</code>。</li>
<li>特别是这里 <code>"outDir": "./Scripts/App"</code>。</li>
<li>显式列出了 <code>"files"</code> 而不是依据 <code>"excludes"</code>选项。</li>
<li>设置 <code>"compileOnSave": true</code>。</li>
</ol>
<p>当你写新代码时，设置 <code>"noImplicitAny"</code> 选项是个好主意 — 这可以确保你不会错写任何新的类型。 设置 <code>"compileOnSave"</code> 选项可以确保你在运行web程序前自动编译保存变更后的代码。 更多信息请参见 <a href="zh/tutorials/../project-config/tsconfig.json.html">the tsconfig.json documentation</a>。</p>
<h3 id="在视图中调用脚本"><a class="header" href="#在视图中调用脚本">在视图中调用脚本</a></h3>
<ol>
<li>
<p>在 <strong>Solution Explorer</strong> 中, 打开 <strong>Views</strong> | <strong>Home</strong> | <code>Index.cshtml</code>。</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/open-index.png" alt="Open Index.cshtml" /></p>
</li>
<li>
<p>修改代码如下：</p>
<pre><code class="language-markup">@{
    ViewBag.Title = "Home Page";
}
&lt;script src="~/Scripts/App/app.js"&gt;&lt;/script&gt;
&lt;div id="message"&gt;&lt;/div&gt;
&lt;div&gt;
    Compiler: &lt;input id="compiler" value="TypeScript" onkeyup="document.getElementById('message').innerText = sayHello()" /&gt;&lt;br /&gt;
    Framework: &lt;input id="framework" value="ASP.NET" onkeyup="document.getElementById('message').innerText = sayHello()" /&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<h3 id="测试-1"><a class="header" href="#测试-1">测试</a></h3>
<ol>
<li>运行项目。</li>
<li>在输入框中键入时，您应该看到一个消息：</li>
</ol>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/running-demo.png" alt="Picture of running demo" /></p>
<h3 id="调试-1"><a class="header" href="#调试-1">调试</a></h3>
<ol>
<li>在 Edge 浏览器中, 按 F12 键并选择 <strong>Debugger</strong> 标签页。</li>
<li>展开 localhost 列表, 选择 src/app.ts</li>
<li>在 <code>return</code> 那一行上打一个断点。</li>
<li>在输入框中键入一些内容，确认TypeScript代码命中断点，观察它是否能正确地工作。</li>
</ol>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/paused-demo.png" alt="Demo paused on breakpoint" /></p>
<p>这就是你需要知道的在ASP.NET中使用TypeScript的基本知识了。接下来，我们引入Angular，写一个简单的Angular程序示例。</p>
<h2 id="添加-angular-2-1"><a class="header" href="#添加-angular-2-1">添加 Angular 2</a></h2>
<h3 id="使用-npm-下载所需的包"><a class="header" href="#使用-npm-下载所需的包">使用 NPM 下载所需的包</a></h3>
<ol>
<li>
<p>安装 <a href="https://github.com/madskristensen/PackageInstaller">PackageInstaller</a>。</p>
</li>
<li>
<p>用 PackageInstaller 来安装 Angular 2， systemjs 和 Typings。</p>
<p>在project上右击, 选择 <strong>Quick Install Package</strong>。</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/packageinstaller-angular2.png" alt="Use PackageInstaller to install angular2" /> <img src="zh/tutorials/../assets/images/tutorials/aspnet/packageinstaller-systemjs.png" alt="Use PackageInstaller to install systemjs" /> <img src="zh/tutorials/../assets/images/tutorials/aspnet/packageinstaller-typings.png" alt="Use PackageInstaller to install Typings" /></p>
</li>
<li>
<p>用 PackageInstaller 安装 es6-shim 的类型文件。</p>
<p>Angular 2 包含 es6-shim 以提供 Promise 支持, 但 TypeScript 还需要它的类型文件。 在 PackageInstaller 中, 选择 Typing 替换 npm 选项。接着键入 "es6-shim"：</p>
<p><img src="zh/tutorials/../assets/images/tutorials/aspnet/packageinstaller-es6-shim.png" alt="Use PackageInstaller to install es6-shim typings" /></p>
</li>
</ol>
<h3 id="更新-tsconfigjson-1"><a class="header" href="#更新-tsconfigjson-1">更新 tsconfig.json</a></h3>
<p>现在安装好了 Angular 2 及其依赖项， 我们还需要启用 TypeScript 中实验性的装饰器支持并且引入 es6-shim 的类型文件。 将来的版本中，装饰器和 ES6 选项将成为默认选项，我们就可以不做此设置了。 添加<code>"experimentalDecorators": true, "emitDecoratorMetadata": true</code>选项到<code>"compilerOptions"</code>，再添加<code>"./typings/index.d.ts"</code>到<code>"files"</code>。 最后，我们要新建<code>"./src/model.ts"</code>文件，并且得把它加到<code>"files"</code>里。 现在<code>tsconfig.json</code>应该是这样：</p>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "noImplicitAny": false,
    "noEmitOnError": true,
    "sourceMap": true,
    "target": "es5",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "outDir": "./Scripts/App"
  },
  "files": [
    "./src/app.ts",
    "./src/model.ts",
    "./src/main.ts",
    "./typings/index.d.ts"
  ]
}
</code></pre>
<h3 id="添加-copyfiles-到-build-中"><a class="header" href="#添加-copyfiles-到-build-中">添加 CopyFiles 到 build 中</a></h3>
<p>最后，我们需要确保 Angular 文件作为 build 的一部分复制进来。这样操作，右击项目选择 'Unload' ，再次右击项目选择 'Edit csproj'。 在 TypeScript 配置项 PropertyGroup 之后，添加一个 ItemGroup 和 Target 配置项来复制 Angular 文件。</p>
<pre><code class="language-markup">&lt;ItemGroup&gt;
  &lt;NodeLib Include="$(MSBuildProjectDirectory)\node_modules\angular2\bundles\angular2.js"/&gt;
  &lt;NodeLib Include="$(MSBuildProjectDirectory)\node_modules\angular2\bundles\angular2-polyfills.js"/&gt;
  &lt;NodeLib Include="$(MSBuildProjectDirectory)\node_modules\systemjs\dist\system.src.js"/&gt;
  &lt;NodeLib Include="$(MSBuildProjectDirectory)\node_modules\rxjs\bundles\Rx.js"/&gt;
&lt;/ItemGroup&gt;
&lt;Target Name="CopyFiles" BeforeTargets="Build"&gt;
  &lt;Copy SourceFiles="@(NodeLib)" DestinationFolder="$(MSBuildProjectDirectory)\Scripts"/&gt;
&lt;/Target&gt;
</code></pre>
<p>现在，在工程上右击选择重新加载项目。 此时应当能在解决方案资源管理器（Solution Explorer）中看到<code>node_modules</code>。</p>
<h3 id="用-typescript-写一个简单的-angular-应用-1"><a class="header" href="#用-typescript-写一个简单的-angular-应用-1">用 TypeScript 写一个简单的 Angular 应用</a></h3>
<p>首先，将 <code>app.ts</code> 改成：</p>
<pre><code class="language-typescript">import {Component} from "angular2/core"
import {MyModel} from "./model"

@Component({
    selector: `my-app`,
    template: `&lt;div&gt;Hello from {{getCompiler()}}&lt;/div&gt;`
})
class MyApp {
    model = new MyModel();
    getCompiler() {
        return this.model.compiler;
    }
}
</code></pre>
<p>接着在 <code>src</code> 中添加 TypeScript 文件 <code>model.ts</code>:</p>
<pre><code class="language-typescript">export class MyModel {
    compiler = "TypeScript";
}
</code></pre>
<p>再在 <code>src</code> 中添加 <code>main.ts</code>：</p>
<pre><code class="language-typescript">import {bootstrap} from "angular2/platform/browser";
import {MyApp} from "./app";
bootstrap(MyApp);
</code></pre>
<p>最后，将 <code>Views/Home/Index.cshtml</code> 改成：</p>
<pre><code class="language-markup">@{
    ViewBag.Title = "Home Page";
}
&lt;script src="~/Scripts/angular2-polyfills.js"&gt;&lt;/script&gt;
&lt;script src="~/Scripts/system.src.js"&gt;&lt;/script&gt;
&lt;script src="~/Scripts/rx.js"&gt;&lt;/script&gt;
&lt;script src="~/Scripts/angular2.js"&gt;&lt;/script&gt;
&lt;script&gt;
    System.config({
        packages: {
            '/Scripts/App': {
                format: 'cjs',
                defaultExtension: 'js'
            }
        }
    });
    System.import('/Scripts/App/main').then(null, console.error.bind(console));
&lt;/script&gt;
&lt;my-app&gt;Loading...&lt;/my-app&gt;
</code></pre>
<p>这里加载了此应用。 运行 ASP.NET 应用，你应该能看到一个 div 显示 "Loading..." 紧接着更新成显示 "Hello from TypeScript"。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gulp"><a class="header" href="#gulp">Gulp</a></h1>
<p>这篇快速上手指南将教你如何使用<a href="http://gulpjs.com">Gulp</a>构建TypeScript，和如何在Gulp管道里添加<a href="http://browserify.org">Browserify</a>，<a href="http://lisperator.net/uglifyjs/">uglify</a>或<a href="https://github.com/substack/watchify">Watchify</a>。 本指南还会展示如何使用<a href="https://github.com/babel/babelify">Babelify</a>来添加<a href="https://babeljs.io/">Babel</a>的功能。</p>
<p>这里假设你已经在使用<a href="https://nodejs.org/">Node.js</a>和<a href="https://www.npmjs.com/">npm</a>了。</p>
<h2 id="创建简单工程"><a class="header" href="#创建简单工程">创建简单工程</a></h2>
<p>我们首先创建一个新目录。 命名为<code>proj</code>，也可以使用任何你喜欢的名字。</p>
<pre><code class="language-text">mkdir proj
cd proj
</code></pre>
<p>我们将以下面的结构开始我们的工程：</p>
<pre><code class="language-text">proj/
   ├─ src/
   └─ dist/
</code></pre>
<p>TypeScript文件放在<code>src</code>文件夹下，经过TypeScript编译器编译生成的目标文件放在<code>dist</code>目录下。</p>
<p>下面让我们来创建这些文件夹：</p>
<pre><code class="language-text">mkdir src
mkdir dist
</code></pre>
<h3 id="初始化工程"><a class="header" href="#初始化工程">初始化工程</a></h3>
<p>现在让我们把这个文件夹转换成npm包：</p>
<pre><code class="language-text">npm init
</code></pre>
<p>你将看到有一些提示操作。 除了入口文件外，其余的都可以使用默认项。 入口文件使用<code>./dist/main.js</code>。 你可以随时在<code>package.json</code>文件里更改生成的配置。</p>
<h3 id="安装依赖项"><a class="header" href="#安装依赖项">安装依赖项</a></h3>
<p>现在我们可以使用<code>npm install</code>命令来安装包。 首先全局安装<code>gulp-cli</code>（如果你使用Unix系统，你可能需要在<code>npm install</code>命令上使用<code>sudo</code>）。</p>
<pre><code class="language-text">npm install -g gulp-cli
</code></pre>
<p>然后安装<code>typescript</code>，<code>gulp</code>和<code>gulp-typescript</code>到开发依赖项。 <a href="https://www.npmjs.com/package/gulp-typescript">Gulp-typescript</a>是TypeScript的一个Gulp插件。</p>
<pre><code class="language-text">npm install --save-dev typescript gulp@4.0.0 gulp-typescript
</code></pre>
<h3 id="写一个简单的例子"><a class="header" href="#写一个简单的例子">写一个简单的例子</a></h3>
<p>让我们写一个Hello World程序。 在<code>src</code>目录下创建<code>main.ts</code>文件：</p>
<pre><code class="language-typescript">function hello(compiler: string) {
    console.log(`Hello from ${compiler}`);
}
hello('TypeScript');
</code></pre>
<p>在工程的根目录<code>proj</code>下新建一个<code>tsconfig.json</code>文件：</p>
<pre><code class="language-javascript">{
    "files": [
        "src/main.ts"
    ],
    "compilerOptions": {
        "noImplicitAny": true,
        "target": "es5"
    }
}
</code></pre>
<h3 id="新建gulpfilejs文件"><a class="header" href="#新建gulpfilejs文件">新建<code>gulpfile.js</code>文件</a></h3>
<p>在工程根目录下，新建一个<code>gulpfile.js</code>文件：</p>
<pre><code class="language-javascript">var gulp = require('gulp');
var ts = require('gulp-typescript');
var tsProject = ts.createProject('tsconfig.json');

gulp.task('default', function () {
    return tsProject.src()
        .pipe(tsProject())
        .js.pipe(gulp.dest('dist'));
});
</code></pre>
<h3 id="测试这个应用"><a class="header" href="#测试这个应用">测试这个应用</a></h3>
<pre><code class="language-text">gulp
node dist/main.js
</code></pre>
<p>程序应该能够打印出“Hello from TypeScript!”。</p>
<h2 id="向代码里添加模块"><a class="header" href="#向代码里添加模块">向代码里添加模块</a></h2>
<p>在使用Browserify前，让我们先构建一下代码然后再添加一些混入的模块。 这个结构将是你在真实应用程序中会用到的。</p>
<p>新建一个<code>src/greet.ts</code>文件：</p>
<pre><code class="language-typescript">export function sayHello(name: string) {
    return `Hello from ${name}`;
}
</code></pre>
<p>更改<code>src/main.ts</code>代码，从<code>greet.ts</code>导入<code>sayHello</code>：</p>
<pre><code class="language-typescript">import { sayHello } from './greet';

console.log(sayHello('TypeScript'));
</code></pre>
<p>最后，将<code>src/greet.ts</code>添加到<code>tsconfig.json</code>：</p>
<pre><code class="language-javascript">{
    "files": [
        "src/main.ts",
        "src/greet.ts"
    ],
    "compilerOptions": {
        "noImplicitAny": true,
        "target": "es5"
    }
}
</code></pre>
<p>确保执行<code>gulp</code>后模块是能工作的，在Node.js下进行测试：</p>
<pre><code class="language-text">gulp
node dist/main.js
</code></pre>
<p>注意，即使我们使用了ES2015的模块语法，TypeScript还是会生成Node.js使用的CommonJS模块。 我们在这个教程里会一直使用CommonJS模块，但是你可以通过修改<code>module</code>选项来改变这个行为。</p>
<h2 id="browserify"><a class="header" href="#browserify">Browserify</a></h2>
<p>现在，让我们把这个工程由Node.js环境移到浏览器环境里。 因此，我们将把所有模块捆绑成一个JavaScript文件。 所幸，这正是Browserify要做的事情。 更方便的是，它支持Node.js的CommonJS模块，这也正是TypeScript默认生成的类型。 也就是说TypeScript和Node.js的设置不需要改变就可以移植到浏览器里。</p>
<p>首先，安装Browserify，<a href="https://www.npmjs.com/package/tsify">tsify</a>和vinyl-source-stream。 tsify是Browserify的一个插件，就像gulp-typescript一样，它能够访问TypeScript编译器。 vinyl-source-stream会将Browserify的输出文件适配成gulp能够解析的格式，它叫做<a href="https://github.com/gulpjs/vinyl">vinyl</a>。</p>
<pre><code class="language-text">npm install --save-dev browserify tsify vinyl-source-stream
</code></pre>
<h3 id="新建一个页面"><a class="header" href="#新建一个页面">新建一个页面</a></h3>
<p>在<code>src</code>目录下新建一个<code>index.html</code>文件：</p>
<pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;title&gt;Hello World!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p id="greeting"&gt;Loading ...&lt;/p&gt;
        &lt;script src="bundle.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>修改<code>main.ts</code>文件来更新这个页面：</p>
<pre><code class="language-typescript">import { sayHello } from './greet';

function showHello(divName: string, name: string) {
    const elt = document.getElementById(divName);
    elt.innerText = sayHello(name);
}

showHello('greeting', 'TypeScript');
</code></pre>
<p><code>showHello</code>调用<code>sayHello</code>函数更改页面上段落的文字。 现在修改gulpfile文件如下：</p>
<pre><code class="language-javascript">var gulp = require('gulp');
var browserify = require('browserify');
var source = require('vinyl-source-stream');
var tsify = require('tsify');
var paths = {
    pages: ['src/*.html']
};

gulp.task('copy-html', function () {
    return gulp.src(paths.pages)
        .pipe(gulp.dest('dist'));
});

gulp.task('default', gulp.series(gulp.parallel('copy-html'), function () {
    return browserify({
        basedir: '.',
        debug: true,
        entries: ['src/main.ts'],
        cache: {},
        packageCache: {}
    })
    .plugin(tsify)
    .bundle()
    .pipe(source('bundle.js'))
    .pipe(gulp.dest('dist'));
}));
</code></pre>
<p>这里增加了<code>copy-html</code>任务并且把它加作<code>default</code>的依赖项。 这样，当<code>default</code>执行时，<code>copy-html</code>会被首先执行。 我们还修改了<code>default</code>任务，让它使用<code>tsify</code>插件调用Browserify，而不是<code>gulp-typescript</code>。 方便的是，两者传递相同的参数对象到TypeScript编译器。</p>
<p>调用<code>bundle</code>后，我们使用<code>source</code>（vinyl-source-stream的别名）把输出文件命名为<code>bundle.js</code>。</p>
<p>测试此页面，运行<code>gulp</code>，然后在浏览器里打开<code>dist/index.html</code>。 你应该能在页面上看到“Hello from TypeScript”。</p>
<p>注意，我们为Broswerify指定了<code>debug: true</code>。 这会让<code>tsify</code>在输出文件里生成<code>source maps</code>。 <code>source maps</code>允许我们在浏览器中直接调试TypeScript源码，而不是在合并后的JavaScript文件上调试。 你要打开调试器并在<code>main.ts</code>里打一个断点，看看<code>source maps</code>是否能工作。 当你刷新页面时，代码会停在断点处，从而你就能够调试<code>greet.ts</code>。</p>
<h2 id="watchifybabel和uglify"><a class="header" href="#watchifybabel和uglify">Watchify，Babel和Uglify</a></h2>
<p>现在代码已经用Browserify和tsify捆绑在一起了，我们可以使用Browserify插件为构建添加一些特性。</p>
<ul>
<li>Watchify启动Gulp并保持运行状态，当你保存文件时自动编译。 帮你进入到编辑-保存-刷新浏览器的循环中。</li>
<li>Babel是个十分灵活的编译器，将ES2015及以上版本的代码转换成ES5和ES3。 你可以添加大量自定义的TypeScript目前不支持的转换器。</li>
<li>Uglify帮你压缩代码，将花费更少的时间去下载它们。</li>
</ul>
<h3 id="watchify"><a class="header" href="#watchify">Watchify</a></h3>
<p>我们启动Watchify，让它在后台帮我们编译：</p>
<pre><code class="language-text">npm install --save-dev watchify fancy-log
</code></pre>
<p>修改gulpfile文件如下：</p>
<pre><code class="language-javascript">var gulp = require('gulp');
var browserify = require('browserify');
var source = require('vinyl-source-stream');
var watchify = require('watchify');
var tsify = require('tsify');
var fancy_log = require('fancy-log');
var paths = {
    pages: ['src/*.html']
};

var watchedBrowserify = watchify(browserify({
    basedir: '.',
    debug: true,
    entries: ['src/main.ts'],
    cache: {},
    packageCache: {}
}).plugin(tsify));

gulp.task('copy-html', function () {
    return gulp.src(paths.pages)
        .pipe(gulp.dest('dist'));
});

function bundle() {
    return watchedBrowserify
        .bundle()
        .on('error', fancy_log)
        .pipe(source('bundle.js'))
        .pipe(gulp.dest('dist'));
}

gulp.task('default', gulp.series(gulp.parallel('copy-html'), bundle));
watchedBrowserify.on('update', bundle);
watchedBrowserify.on('log', fancy_log);
</code></pre>
<p>共有三处改变，但是需要你略微重构一下代码。</p>
<ol>
<li>将<code>browserify</code>实例包裹在<code>watchify</code>的调用里，控制生成的结果。</li>
<li>调用<code>watchedBrowserify.on('update', bundle);</code>，每次TypeScript文件改变时Browserify会执行<code>bundle</code>函数。</li>
<li>调用<code>watchedBrowserify.on('log', fancy_log);</code>将日志打印到控制台。</li>
</ol>
<p>(1)和(2)在一起意味着我们要将<code>browserify</code>调用移出<code>default</code>任务。 然后给函数起个名字，因为Watchify和Gulp都要调用它。 (3)是可选的，但是对于调试来讲很有用。</p>
<p>现在当你执行<code>gulp</code>，它会启动并保持运行状态。 试着改变<code>main.ts</code>文件里<code>showHello</code>的代码并保存。 你会看到这样的输出：</p>
<pre><code class="language-text">proj$ gulp
[10:34:20] Using gulpfile ~/src/proj/gulpfile.js
[10:34:20] Starting 'copy-html'...
[10:34:20] Finished 'copy-html' after 26 ms
[10:34:20] Starting 'default'...
[10:34:21] 2824 bytes written (0.13 seconds)
[10:34:21] Finished 'default' after 1.36 s
[10:35:22] 2261 bytes written (0.02 seconds)
[10:35:24] 2808 bytes written (0.05 seconds)
</code></pre>
<h3 id="uglify"><a class="header" href="#uglify">Uglify</a></h3>
<p>首先安装Uglify。 因为Uglify是用于混淆你的代码，所以我们还要安装vinyl-buffer和gulp-sourcemaps来支持sourcemaps。</p>
<pre><code class="language-text">npm install --save-dev gulp-uglify vinyl-buffer gulp-sourcemaps
</code></pre>
<p>修改gulpfile文件如下：</p>
<pre><code class="language-javascript">var gulp = require('gulp');
var browserify = require('browserify');
var source = require('vinyl-source-stream');
var tsify = require('tsify');
var uglify = require('gulp-uglify');
var sourcemaps = require('gulp-sourcemaps');
var buffer = require('vinyl-buffer');
var paths = {
    pages: ['src/*.html']
};

gulp.task('copy-html', function () {
    return gulp.src(paths.pages)
        .pipe(gulp.dest('dist'));
});

gulp.task('default', gulp.series(gulp.parallel('copy-html'), function () {
    return browserify({
        basedir: '.',
        debug: true,
        entries: ['src/main.ts'],
        cache: {},
        packageCache: {}
    })
    .plugin(tsify)
    .bundle()
    .pipe(source('bundle.js'))
    .pipe(buffer())
    .pipe(sourcemaps.init({loadMaps: true}))
    .pipe(uglify())
    .pipe(sourcemaps.write('./'))
    .pipe(gulp.dest('dist'));
}));
</code></pre>
<p>注意<code>uglify</code>只是调用了自己—<code>buffer</code>和<code>sourcemaps</code>的调用是用于确保sourcemaps可以工作。 这些调用让我们可以使用单独的sourcemap文件，而不是之前的内嵌的sourcemaps。 你现在可以执行<code>gulp</code>来检查<code>bundle.js</code>是否被压缩了：</p>
<pre><code class="language-text">gulp
cat dist/bundle.js
</code></pre>
<h3 id="babel"><a class="header" href="#babel">Babel</a></h3>
<p>首先安装Babelify和ES2015的Babel预置程序。 和Uglify一样，Babelify也会混淆代码，因此我们也需要vinyl-buffer和gulp-sourcemaps。 默认情况下Babelify只会处理扩展名为<code>.js</code>，<code>.es</code>，<code>.es6</code>和<code>.jsx</code>的文件，因此我们需要添加<code>.ts</code>扩展名到Babelify选项。</p>
<pre><code class="language-text">npm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps
</code></pre>
<p>修改gulpfile文件如下：</p>
<pre><code class="language-javascript">var gulp = require('gulp');
var browserify = require('browserify');
var source = require('vinyl-source-stream');
var tsify = require('tsify');
var sourcemaps = require('gulp-sourcemaps');
var buffer = require('vinyl-buffer');
var paths = {
    pages: ['src/*.html']
};

gulp.task('copyHtml', function () {
    return gulp.src(paths.pages)
        .pipe(gulp.dest('dist'));
});

gulp.task('default', gulp.series(gulp.parallel('copy-html'), function () {
    return browserify({
        basedir: '.',
        debug: true,
        entries: ['src/main.ts'],
        cache: {},
        packageCache: {}
    })
    .plugin(tsify)
    .transform('babelify', {
        presets: ['es2015'],
        extensions: ['.ts']
    })
    .bundle()
    .pipe(source('bundle.js'))
    .pipe(buffer())
    .pipe(sourcemaps.init({loadMaps: true}))
    .pipe(sourcemaps.write('./'))
    .pipe(gulp.dest('dist'));
}));
</code></pre>
<p>我们需要设置TypeScript目标为ES2015。 Babel稍后会从TypeScript生成的ES2015代码中生成ES5。 修改<code>tsconfig.json</code>:</p>
<pre><code class="language-javascript">{
    "files": [
        "src/main.ts"
    ],
    "compilerOptions": {
        "noImplicitAny": true,
        "target": "es2015"
    }
}
</code></pre>
<p>对于这样一段简单的代码来说，Babel的ES5输出应该和TypeScript的输出相似。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="knockoutjs"><a class="header" href="#knockoutjs">Knockout.js</a></h1>
<blockquote>
<p>注意： 此教程已从官方删除</p>
</blockquote>
<p>这个快速上手指南会告诉你如何结合使用TypeScript和<a href="http://knockoutjs.com/">Knockout.js</a>。</p>
<p>这里我们假设你已经会使用<a href="https://nodejs.org/">Node.js</a>和<a href="https://www.npmjs.com/">npm</a></p>
<h2 id="新建工程-1"><a class="header" href="#新建工程-1">新建工程</a></h2>
<p>首先，我们新建一个目录。 暂时命名为<code>proj</code>，当然了你可以使用任何喜欢的名字。</p>
<pre><code class="language-text">mkdir proj
cd proj
</code></pre>
<p>接下来，我们按如下方式来组织这个工程：</p>
<pre><code class="language-text">proj/
   ├─ src/
   └─ built/
</code></pre>
<p>TypeScript源码放在<code>src</code>目录下，结过TypeScript编译器编译后，生成的文件放在<code>built</code>目录里。</p>
<p>下面创建目录：</p>
<pre><code class="language-text">mkdir src
mkdir built
</code></pre>
<h2 id="初始化工程-1"><a class="header" href="#初始化工程-1">初始化工程</a></h2>
<p>现在将这个文件夹转换为npm包。</p>
<pre><code class="language-text">npm init
</code></pre>
<p>你会看到一系列提示。 除了入口点外其它设置都可以使用默认值。 你可以随时到生成的<code>package.json</code>文件里修改这些设置。</p>
<h2 id="安装构建依赖"><a class="header" href="#安装构建依赖">安装构建依赖</a></h2>
<p>首先确保TypeScript已经全局安装。</p>
<pre><code class="language-text">npm install -g typescript
</code></pre>
<p>我们还要获取Knockout的声明文件，它描述了这个库的结构供TypeScript使用。</p>
<pre><code class="language-text">npm install --save @types/knockout
</code></pre>
<h2 id="获取运行时依赖"><a class="header" href="#获取运行时依赖">获取运行时依赖</a></h2>
<p>我们需要Knockout和RequireJS。 <a href="http://www.requirejs.org/">RequireJS</a>是一个库，它可以让我们在运行时异步地加载模块。</p>
<p>有以下几种获取方式：</p>
<ol>
<li>手动下载文件并维护它们。</li>
<li>通过像<a href="http://bower.io/">Bower</a>这样的包管理下载并维护它们。</li>
<li>使用内容分发网络（CDN）来维护这两个文件。</li>
</ol>
<p>我们使用第一种方法，它会简单一些，但是Knockout的官方文档上有讲解<a href="http://knockoutjs.com/downloads/index.html">如何使用CDN</a>，更多像RequireJS一样的代码库可以在<a href="https://cdnjs.com/">cdnjs</a>上查找。</p>
<p>下面让我们在工程根目录下创建<code>externals</code>目录。</p>
<pre><code class="language-text">mkdir externals
</code></pre>
<p>然后<a href="http://knockoutjs.com/downloads/index.html">下载Knockout</a>和<a href="http://www.requirejs.org/docs/download.html#latest">下载RequireJS</a>到这个目录里。 最新的压缩后版本就可以。</p>
<h2 id="添加typescript配置文件"><a class="header" href="#添加typescript配置文件">添加TypeScript配置文件</a></h2>
<p>下面我们想把所有的TypeScript文件整合到一起 - 包括自己写的和必须的声明文件。</p>
<p>我们需要创建一个<code>tsconfig.json</code>文件，包含了输入文件列表和编译选项。 在工程根目录下创建一个新文件<code>tsconfig.json</code>，内容如下：</p>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "outDir": "./built/",
        "sourceMap": true,
        "noImplicitAny": true,
        "module": "amd",
        "target": "es5"
    },
    "files": [
        "./src/require-config.ts",
        "./src/hello.ts"
    ]
}
</code></pre>
<p>这里引用了<code>typings/index.d.ts</code>，它是Typings帮我们创建的。 这个文件会自动地包含所有安装的依赖。</p>
<p>你可能会对<code>typings</code>目录下的<code>browser.d.ts</code>文件感到好奇，尤其因为我们将在浏览器里运行代码。 其实原因是这样的，当目标为浏览器的时候，一些包会生成不同的版本。 通常来讲，这些情况很少发生并且在这里我们不会遇到这种情况，所以我们可以忽略<code>browser.d.ts</code>。</p>
<p>你可以在<a href="zh/tutorials/../project-config/tsconfig.json.html">这里</a>查看更多关于<code>tsconfig.json</code>文件的信息</p>
<h2 id="写些代码"><a class="header" href="#写些代码">写些代码</a></h2>
<p>下面我们使用Knockout写一段TypeScript代码。 首先，在<code>src</code>目录里新建一个<code>hello.ts</code>文件。</p>
<pre><code class="language-typescript">import * as ko from "knockout";

class HelloViewModel {
    language: KnockoutObservable&lt;string&gt;
    framework: KnockoutObservable&lt;string&gt;

    constructor(language: string, framework: string) {
        this.language = ko.observable(language);
        this.framework = ko.observable(framework);
    }
}

ko.applyBindings(new HelloViewModel("TypeScript", "Knockout"));
</code></pre>
<p>接下来，在<code>src</code>目录下再新建一个<code>require-config.ts</code>文件。</p>
<pre><code class="language-typescript">declare var require: any;
require.config({
    paths: {
        "knockout": "externals/knockout-3.4.0",
    }
});
</code></pre>
<p>这个文件会告诉RequireJS从哪里导入Knockout，好比我们在<code>hello.ts</code>里做的一样。 你创建的所有页面都应该在RequireJS之后和导入任何东西之前引入它。 为了更好地理解这个文件和如何配置RequireJS，可以查看<a href="http://requirejs.org/docs/api.html#config">文档</a>。</p>
<p>我们还需要一个视图来显示<code>HelloViewModel</code>。 在<code>proj</code>目录的根上创建一个文件<code>index.html</code>，内容如下：</p>
<pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;title&gt;Hello Knockout!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;
            Hello from
            &lt;strong data-bind="text: language"&gt;todo&lt;/strong&gt;
            and
            &lt;strong data-bind="text: framework"&gt;todo&lt;/strong&gt;!
        &lt;/p&gt;

        &lt;p&gt;Language: &lt;input data-bind="value: language" /&gt;&lt;/p&gt;
        &lt;p&gt;Framework: &lt;input data-bind="value: framework" /&gt;&lt;/p&gt;

        &lt;script src="./externals/require.js"&gt;&lt;/script&gt;
        &lt;script src="./built/require-config.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            require(["built/hello"]);
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注意，有两个script标签。 首先，我们引入RequireJS。 然后我们再在<code>require-config.js</code>里映射外部依赖，这样RequireJS就能知道到哪里去查找它们。 最后，使用我们要去加载的模块去调用<code>require</code>。</p>
<h2 id="将所有部分整合在一起"><a class="header" href="#将所有部分整合在一起">将所有部分整合在一起</a></h2>
<p>运行</p>
<pre><code class="language-text">tsc
</code></pre>
<p>现在，在你喜欢的浏览器打开<code>index.html</code>，所有都应该好用了。 你应该可以看到页面上显示“Hello from TypeScript and Knockout!”。 在它下面，你还会看到两个输入框。 当你改变输入和切换焦点时，就会看到原先显示的信息改变了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react与webpack"><a class="header" href="#react与webpack">React与webpack</a></h1>
<p>这篇指南将会教你如何将TypeScript和<a href="https://reactjs.org/">React</a>还有<a href="http://webpack.github.io/">webpack</a>结合在一起使用。</p>
<p>如果你正在做一个全新的工程，可以先阅读这篇<a href="zh/tutorials/react.html">React快速上手指南</a>。</p>
<p>否则，我们假设已经在使用<a href="https://nodejs.org/">Node.js</a>和<a href="https://www.npmjs.com/">npm</a>。</p>
<h2 id="初始化项目结构"><a class="header" href="#初始化项目结构">初始化项目结构</a></h2>
<p>让我们新建一个目录。 将会命名为<code>proj</code>，但是你可以改成任何你喜欢的名字。</p>
<pre><code class="language-text">mkdir proj
cd proj
</code></pre>
<p>我们会像下面的结构组织我们的工程：</p>
<pre><code class="language-text">proj/
├─ dist/
└─ src/
   └─ components/
</code></pre>
<p>TypeScript文件会放在<code>src</code>文件夹里，通过TypeScript编译器编译，然后经webpack处理，最后生成一个<code>main.js</code>文件放在<code>dist</code>目录下。 我们自定义的组件将会放在<code>src/components</code>文件夹下。</p>
<p>下面来创建基本结构：</p>
<pre><code class="language-text">mkdir src
cd src
mkdir components
cd ..
</code></pre>
<p>Webpack会帮助我们生成<code>dist</code>目录。</p>
<h2 id="初始化工程-2"><a class="header" href="#初始化工程-2">初始化工程</a></h2>
<p>现在把这个目录变成npm包。</p>
<pre><code class="language-text">npm init -y
</code></pre>
<p>它会使用默认值生成一个<code>package.json</code>文件。</p>
<h2 id="安装依赖"><a class="header" href="#安装依赖">安装依赖</a></h2>
<p>首先确保已经全局安装了Webpack。</p>
<pre><code class="language-text">npm install --save-dev webpack webpack-cli
</code></pre>
<p>Webpack这个工具可以将你的所有代码和可选择地将依赖捆绑成一个单独的<code>.js</code>文件。</p>
<p>现在我们添加React和React-DOM以及它们的声明文件到<code>package.json</code>文件里做为依赖：</p>
<pre><code class="language-text">npm install --save react react-dom
npm install --save-dev @types/react @types/react-dom
</code></pre>
<p>使用<code>@types/</code>前缀表示我们额外要获取React和React-DOM的声明文件。 通常当你导入像<code>"react"</code>这样的路径，它会查看<code>react</code>包； 然而，并不是所有的包都包含了声明文件，所以TypeScript还会查看<code>@types/react</code>包。 你会发现我们以后将不必在意这些。</p>
<p>接下来，我们要添加开发时依赖<a href="https://www.npmjs.com/package/ts-loader">ts-loader</a>和<a href="https://www.npmjs.com/package/source-map-loader">source-map-loader</a>。</p>
<pre><code class="language-text">npm install --save-dev typescript ts-loader source-map-loader
</code></pre>
<p>这些依赖会让TypeScript和webpack在一起良好地工作。 <code>ts-loader</code>可以让Webpack使用TypeScript的标准配置文件<code>tsconfig.json</code>编译TypeScript代码。 source-map-loader使用TypeScript输出的sourcemap文件来告诉webpack何时生成_自己的_sourcemaps。 这就允许你在调试最终生成的文件时就好像在调试TypeScript源码一样。</p>
<p>请注意，<code>ts-loader</code>并不是唯一的<code>TypeScript</code>加载器。</p>
<p>你还可以选择<a href="https://www.npmjs.com/package/awesome-typescript-loader">awesome-typescript-loader</a>。 可以到<a href="https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader">这里</a>查看它们之间的区别。</p>
<p>注意我们安装TypeScript为一个开发依赖。 我们还可以使用<code>npm link typescript</code>来链接TypeScript到一个全局拷贝，但这不是常见用法。</p>
<h2 id="添加typescript配置文件-1"><a class="header" href="#添加typescript配置文件-1">添加TypeScript配置文件</a></h2>
<p>我们想将TypeScript文件整合到一起 - 这包括我们写的源码和必要的声明文件。</p>
<p>我们需要创建一个<code>tsconfig.json</code>文件，它包含了输入文件列表以及编译选项。 在工程根目录下新建文件<code>tsconfig.json</code>文件，添加以下内容：</p>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "outDir": "./dist/",
        "sourceMap": true,
        "noImplicitAny": true,
        "module": "commonjs",
        "target": "es6",
        "jsx": "react"
    }
}
</code></pre>
<p>你可以在<a href="zh/tutorials/../project-config/tsconfig.json.html">这里</a>了解更多关于<code>tsconfig.json</code>文件的说明。</p>
<h2 id="写些代码-1"><a class="header" href="#写些代码-1">写些代码</a></h2>
<p>下面使用React写一段TypeScript代码。 首先，在<code>src/components</code>目录下创建一个名为<code>Hello.tsx</code>的文件，代码如下：</p>
<pre><code class="language-typescript">import * as React from "react";

export interface HelloProps { compiler: string; framework: string; }

export const Hello = (props: HelloProps) =&gt; &lt;h1&gt;Hello from {props.compiler} and {props.framework}!&lt;/h1&gt;;
</code></pre>
<p>注意这个例子使用了<a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components">函数组件</a>，我们可以让它更像一点_类_。</p>
<pre><code class="language-typescript">import * as React from "react";

export interface HelloProps { compiler: string; framework: string; }

// 'HelloProps' describes the shape of props.
// State is never set so we use the '{}' type.
export class Hello extends React.Component&lt;HelloProps, {}&gt; {
    render() {
        return &lt;h1&gt;Hello from {this.props.compiler} and {this.props.framework}!&lt;/h1&gt;;
    }
}
</code></pre>
<p>接下来，在<code>src</code>下创建<code>index.tsx</code>文件，源码如下：</p>
<pre><code class="language-typescript">import * as React from "react";
import * as ReactDOM from "react-dom";

import { Hello } from "./components/Hello";

ReactDOM.render(
    &lt;Hello compiler="TypeScript" framework="React" /&gt;,
    document.getElementById("example")
);
</code></pre>
<p>我们仅仅将<code>Hello</code>组件导入<code>index.tsx</code>。 注意，不同于<code>"react"</code>或<code>"react-dom"</code>，我们使用<code>Hello.tsx</code>的_相对路径_ - 这很重要。 如果不这样做，TypeScript只会尝试在<code>node_modules</code>文件夹里查找。</p>
<p>我们还需要一个页面来显示<code>Hello</code>组件。 在根目录<code>proj</code>创建一个名为<code>index.html</code>的文件，如下：</p>
<pre><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;title&gt;Hello React!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="example"&gt;&lt;/div&gt;

        &lt;!-- Dependencies --&gt;
        &lt;script src="./node_modules/react/umd/react.development.js"&gt;&lt;/script&gt;
        &lt;script src="./node_modules/react-dom/umd/react-dom.development.js"&gt;&lt;/script&gt;

        &lt;!-- Main --&gt;
        &lt;script src="./dist/main.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>需要注意一点我们是从<code>node_modules</code>引入的文件。 React和React-DOM的npm包里包含了独立的<code>.js</code>文件，你可以在页面上引入它们，这里我们为了快捷就直接引用了。 可以随意地将它们拷贝到其它目录下，或者从CDN上引用。 Facebook在CND上提供了一系列可用的React版本，你可以在这里查看<a href="http://facebook.github.io/react/downloads.html#development-vs.-production-builds">更多内容</a>。</p>
<h2 id="创建一个webpack配置文件"><a class="header" href="#创建一个webpack配置文件">创建一个webpack配置文件</a></h2>
<p>在工程根目录下创建一个<code>webpack.config.js</code>文件。</p>
<pre><code class="language-javascript">module.exports = {
    mode: "production",

    // Enable sourcemaps for debugging webpack's output.
    devtool: "source-map",

    resolve: {
        // Add '.ts' and '.tsx' as resolvable extensions.
        extensions: [".ts", ".tsx"]
    },

    module: {
        rules: [
            {
                test: /\.ts(x?)$/,
                exclude: /node_modules/,
                use: [
                    {
                        loader: "ts-loader"
                    }
                ]
            },
            // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.
            {
                enforce: "pre",
                test: /\.js$/,
                loader: "source-map-loader"
            }
        ]
    },

    // When importing a module whose path matches one of the following, just
    // assume a corresponding global variable exists and use that instead.
    // This is important because it allows us to avoid bundling all of our
    // dependencies, which allows browsers to cache those libraries between builds.
    externals: {
        "react": "React",
        "react-dom": "ReactDOM"
    }
};
</code></pre>
<p>大家可能对<code>externals</code>字段有所疑惑。 我们想要避免把所有的React都放到一个文件里，因为会增加编译时间并且浏览器还能够缓存没有发生改变的库文件。</p>
<p>理想情况下，我们只需要在浏览器里引入React模块，但是大部分浏览器还没有支持模块。 因此大部分代码库会把自己包裹在一个单独的全局变量内，比如：<code>jQuery</code>或<code>_</code>。 这叫做“命名空间”模式，webpack也允许我们继续使用通过这种方式写的代码库。 通过我们的设置<code>"react": "React"</code>，webpack会神奇地将所有对<code>"react"</code>的导入转换成从<code>React</code>全局变量中加载。</p>
<p>你可以在<a href="https://webpack.js.org/concepts">这里</a>了解更多如何配置webpack。</p>
<h2 id="整合在一起"><a class="header" href="#整合在一起">整合在一起</a></h2>
<p>执行：</p>
<pre><code class="language-text">npx webpack
</code></pre>
<p>在浏览器里打开<code>index.html</code>，工程应该已经可以用了！ 你可以看到页面上显示着“Hello from TypeScript and React!”</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react"><a class="header" href="#react">React</a></h1>
<p>这篇快速上手指南会教你如何将TypeScript与<a href="https://reactjs.org/">React</a>结合起来使用。 在最后，你将学到：</p>
<ul>
<li>使用TypeScript和React创建工程</li>
<li>使用<a href="https://github.com/palantir/tslint">TSLint</a>进行代码检查</li>
<li>使用<a href="https://facebook.github.io/jest/">Jest</a>和<a href="http://airbnb.io/enzyme/">Enzyme</a>进行测试，以及</li>
<li>使用<a href="https://github.com/reactjs/react-redux">Redux</a>管理状态</li>
</ul>
<p>我们会使用<a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>工具快速搭建工程环境。</p>
<p>这里假设你已经在使用<a href="https://nodejs.org/">Node.js</a>和<a href="https://www.npmjs.com/">npm</a>。 并且已经了解了<a href="https://reactjs.org/docs/hello-world.html">React的基础知识</a>。</p>
<h2 id="创建新工程"><a class="header" href="#创建新工程">创建新工程</a></h2>
<p>让我们首先创建一个叫做<code>my-app</code>的新工程：</p>
<pre><code class="language-text">npx create-react-app my-app --template typescript
</code></pre>
<p><a href="https://www.npmjs.com/package/react-scripts-ts">react-scripts-ts</a>是一系列适配器，它利用标准的create-react-app工程管道并把TypeScript混入进来。</p>
<p>此时的工程结构应如下所示：</p>
<pre><code class="language-text">my-app/
├─ .gitignore
├─ node_modules/
├─ public/
├─ src/
│  └─ ...
├─ package.json
├─ tsconfig.json
└─ tslint.json
</code></pre>
<p>注意：</p>
<ul>
<li><code>tsconfig.json</code>包含了工程里TypeScript特定的选项。</li>
<li><code>tslint.json</code>保存了要使用的代码检查器的设置，<a href="https://github.com/palantir/tslint">TSLint</a>。</li>
<li><code>package.json</code>包含了依赖，还有一些命令的快捷方式，如测试命令，预览命令和发布应用的命令。</li>
<li><code>public</code>包含了静态资源如HTML页面或图片。除了<code>index.html</code>文件外，其它的文件都可以删除。</li>
<li><code>src</code>包含了TypeScript和CSS源码。<code>index.tsx</code>是强制使用的入口文件。</li>
</ul>
<h2 id="运行工程"><a class="header" href="#运行工程">运行工程</a></h2>
<p>通过下面的方式即可轻松地运行这个工程。</p>
<pre><code class="language-bash">npm run start
</code></pre>
<p>它会执行<code>package.json</code>里面指定的<code>start</code>命令，并且会启动一个服务器，当我们保存文件时还会自动刷新页面。 通常这个服务器的地址是<code>http://localhost:3000</code>，页面应用会被自动地打开。</p>
<p>它会保持监听以方便我们快速地预览改动。</p>
<h2 id="测试工程"><a class="header" href="#测试工程">测试工程</a></h2>
<p>测试也仅仅是一行命令的事儿：</p>
<pre><code class="language-bash">npm run test
</code></pre>
<p>这个命令会运行Jest，一个非常好用的测试工具，它会运行所有扩展名是<code>.test.ts</code>或<code>.spec.ts</code>的文件。 好比是<code>npm run start</code>命令，当检测到有改动的时候Jest会自动地运行。 如果喜欢的话，你还可以同时运行<code>npm run start</code>和<code>npm run test</code>，这样你就可以在预览的同时进行测试。</p>
<h2 id="生成生产环境的构建版本"><a class="header" href="#生成生产环境的构建版本">生成生产环境的构建版本</a></h2>
<p>在使用<code>npm run start</code>运行工程的时候，我们并没有生成一个优化过的版本。 通常我们想给用户一个运行的尽可能快并在体积上尽可能小的代码。 像压缩这样的优化方法可以做到这一点，但是总是要耗费更多的时间。 我们把这样的构建版本称做“生产环境”版本（与开发版本相对）。</p>
<p>要执行生产环境的构建，可以运行如下命令：</p>
<pre><code class="language-bash">npm run build
</code></pre>
<p>这会相应地创建优化过的JS和CSS文件，<code>./build/static/js</code>和<code>./build/static/css</code>。</p>
<p>大多数情况下你不需要生成生产环境的构建版本， 但它可以帮助你衡量应用最终版本的体积大小。</p>
<h2 id="创建一个组件"><a class="header" href="#创建一个组件">创建一个组件</a></h2>
<p>下面我们将要创建一个<code>Hello</code>组件。 这个组件接收任意一个我们想对之打招呼的名字（我们把它叫做<code>name</code>），并且有一个可选数量的感叹号做为结尾（通过<code>enthusiasmLevel</code>）。</p>
<p>若我们这样写<code>&lt;Hello name="Daniel" enthusiasmLevel={3} /&gt;</code>，这个组件大至会渲染成<code>&lt;div&gt;Hello Daniel!!!&lt;/div&gt;</code>。 如果没指定<code>enthusiasmLevel</code>，组件将默认显示一个感叹号。 若<code>enthusiasmLevel</code>为<code>0</code>或负值将抛出一个错误。</p>
<p>下面来写一下<code>Hello.tsx</code>：</p>
<pre><code class="language-typescript">// src/components/Hello.tsx

import * as React from 'react';

export interface Props {
  name: string;
  enthusiasmLevel?: number;
}

function Hello({ name, enthusiasmLevel = 1 }: Props) {
  if (enthusiasmLevel &lt;= 0) {
    throw new Error('You could be a little more enthusiastic. :D');
  }

  return (
    &lt;div className="hello"&gt;
      &lt;div className="greeting"&gt;
        Hello {name + getExclamationMarks(enthusiasmLevel)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default Hello;

// helpers

function getExclamationMarks(numChars: number) {
  return Array(numChars + 1).join('!');
}
</code></pre>
<p>注意我们定义了一个类型<code>Props</code>，它指定了我们组件要用到的属性。 <code>name</code>是必需的且为<code>string</code>类型，同时<code>enthusiasmLevel</code>是可选的且为<code>number</code>类型（你可以通过名字后面加<code>?</code>为指定可选参数）。</p>
<p>我们创建了一个函数组件<code>Hello</code>。 具体来讲，<code>Hello</code>是一个函数，接收一个<code>Props</code>对象并拆解它。 如果<code>Props</code>对象里没有设置<code>enthusiasmLevel</code>，默认值为<code>1</code>。</p>
<p>使用函数是React中定义组件的<a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components">两种方式</a>之一。 如果你喜欢的话，也_可以_通过类的方式定义：</p>
<pre><code class="language-typescript">class Hello extends React.Component&lt;Props, object&gt; {
  render() {
    const { name, enthusiasmLevel = 1 } = this.props;

    if (enthusiasmLevel &lt;= 0) {
      throw new Error('You could be a little more enthusiastic. :D');
    }

    return (
      &lt;div className="hello"&gt;
        &lt;div className="greeting"&gt;
          Hello {name + getExclamationMarks(enthusiasmLevel)}
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>当我们的<a href="https://reactjs.org/docs/state-and-lifecycle.html">组件具有某些状态</a>的时候，使用类的方式是很有用处的。 但在这个例子里我们不需要考虑状态 - 事实上，在<code>React.Component&lt;Props, object&gt;</code>我们把状态指定为了<code>object</code>，因此使用函数组件更简洁。 当在创建可重用的通用UI组件的时候，在表现层使用组件局部状态比较适合。 针对我们应用的生命周期，我们会审视应用是如何通过Redux轻松地管理普通状态的。</p>
<p>现在我们已经写好了组件，让我们仔细看看<code>index.tsx</code>，把<code>&lt;App /&gt;</code>替换成<code>&lt;Hello ... /&gt;</code>。</p>
<p>首先我们在文件头部导入它：</p>
<pre><code class="language-typescript">import Hello from './components/Hello';
</code></pre>
<p>然后修改<code>render</code>调用：</p>
<pre><code class="language-typescript">ReactDOM.render(
  &lt;Hello name="TypeScript" enthusiasmLevel={10} /&gt;,
  document.getElementById('root') as HTMLElement
);
</code></pre>
<h3 id="类型断言"><a class="header" href="#类型断言">类型断言</a></h3>
<p>这里还有一点要指出，就是最后一行<code>document.getElementById('root') as HTMLElement</code>。 这个语法叫做_类型断言_，有时也叫做_转换_。 当你比类型检查器更清楚一个表达式的类型的时候，你可以通过这种方式通知TypeScript。</p>
<p>这里，我们之所以这么做是因为<code>getElementById</code>的返回值类型是<code>HTMLElement | null</code>。 简单地说，<code>getElementById</code>返回<code>null</code>是当无法找对对应<code>id</code>元素的时候。 我们假设<code>getElementById</code>总是成功的，因此我们要使用<code>as</code>语法告诉TypeScript这点。</p>
<p>TypeScript还有一种感叹号（<code>!</code>）结尾的语法，它会从前面的表达式里移除<code>null</code>和<code>undefined</code>。 所以我们也_可以_写成<code>document.getElementById('root')!</code>，但在这里我们想写的更清楚些。</p>
<h2 id="sunglasses添加样式"><a class="header" href="#sunglasses添加样式">:sunglasses:添加样式</a></h2>
<p>通过我们的设置为一个组件添加样式很容易。 若要设置<code>Hello</code>组件的样式，我们可以创建这样一个CSS文件<code>src/components/Hello.css</code>。</p>
<pre><code class="language-css">.hello {
  text-align: center;
  margin: 20px;
  font-size: 48px;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif
}

.hello button {
    margin-left: 25px;
    margin-right: 25px;
    font-size: 40px;
    min-width: 50px;
}
</code></pre>
<p><code>create-react-app</code>包含的工具（Webpack和一些加载器）允许我们导入样式表文件。 当我们构建应用的时候，所有导入的<code>.css</code>文件会被拼接成一个输出文件。 因此在<code>src/components/Hello.tsx</code>，我们需要添加如下导入语句。</p>
<pre><code class="language-typescript">import './Hello.css';
</code></pre>
<h2 id="使用jest编写测试"><a class="header" href="#使用jest编写测试">使用Jest编写测试</a></h2>
<p>如果你没使用过Jest，你可能先要把它安装为开发依赖项。</p>
<pre><code class="language-bash">npm install -D jest jest-cli jest-config
</code></pre>
<p>我们对<code>Hello</code>组件有一些假设。 让我们在此重申一下：</p>
<blockquote>
<ul>
<li>当这样写<code>&lt;Hello name="Daniel" enthusiasmLevel={3} /&gt;</code>时，组件应被渲染成<code>&lt;div&gt;Hello Daniel!!!&lt;/div&gt;</code>。</li>
<li>若未指定<code>enthusiasmLevel</code>，组件应默认显示一个感叹号。</li>
<li>若<code>enthusiasmLevel</code>为<code>0</code>或负值，它应抛出一个错误。</li>
</ul>
</blockquote>
<p>我们将针对这些需求为组件写一些注释。</p>
<p>但首先，我们要安装Enzyme。 <a href="http://airbnb.io/enzyme/">Enzyme</a>是React生态系统里一个通用工具，它方便了针对组件的行为编写测试。 默认地，我们的应用包含了一个叫做jsdom的库，它允许我们模拟DOM以及在非浏览器的环境下测试运行时的行为。 Enzyme与此类似，但是是基于jsdom的，并且方便我们查询组件。</p>
<p>让我们把它安装为开发依赖项。</p>
<pre><code class="language-bash">npm install -D enzyme @types/enzyme enzyme-adapter-react-16 @types/enzyme-adapter-react-16
</code></pre>
<p>如果你的react版本低于15.5.0，还需安装如下</p>
<pre><code class="language-bash">npm install -D react-addons-test-utils
</code></pre>
<p>注意我们同时安装了<code>enzyme</code>和<code>@types/enzyme</code>。 <code>enzyme</code>包指的是包含了实际运行的JavaScript代码包，而<code>@types/enzyme</code>则包含了声明文件（<code>.d.ts</code>文件）的包，以便TypeScript能够了解该如何使用Enzyme。 你可以在<a href="https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html">这里</a>了解更多关于<code>@types</code>包的信息。</p>
<p>我们还需要安装<code>enzyme-adapter</code>和<code>react-addons-test-utils</code>。 它们是使用<code>enzyme</code>所需要安装的包，前者作为配置适配器是必须的，而后者若采用的React版本在15.5.0之上则毋需安装。</p>
<p>现在我们已经设置好了Enzyme，下面开始编写测试！ 先创建一个文件<code>src/components/Hello.test.tsx</code>，与先前的<code>Hello.tsx</code>文件放在一起。</p>
<pre><code class="language-typescript">// src/components/Hello.test.tsx

import * as React from 'react';
import * as enzyme from 'enzyme';
import * as Adapter from 'enzyme-adapter-react-16';
import Hello from './Hello';

enzyme.configure({ adapter: new Adapter() });

it('renders the correct text when no enthusiasm level is given', () =&gt; {
  const hello = enzyme.shallow(&lt;Hello name='Daniel' /&gt;);
  expect(hello.find(".greeting").text()).toEqual('Hello Daniel!')
});

it('renders the correct text with an explicit enthusiasm of 1', () =&gt; {
  const hello = enzyme.shallow(&lt;Hello name='Daniel' enthusiasmLevel={1}/&gt;);
  expect(hello.find(".greeting").text()).toEqual('Hello Daniel!')
});

it('renders the correct text with an explicit enthusiasm level of 5', () =&gt; {
  const hello = enzyme.shallow(&lt;Hello name='Daniel' enthusiasmLevel={5} /&gt;);
  expect(hello.find(".greeting").text()).toEqual('Hello Daniel!!!!!');
});

it('throws when the enthusiasm level is 0', () =&gt; {
  expect(() =&gt; {
    enzyme.shallow(&lt;Hello name='Daniel' enthusiasmLevel={0} /&gt;);
  }).toThrow();
});

it('throws when the enthusiasm level is negative', () =&gt; {
  expect(() =&gt; {
    enzyme.shallow(&lt;Hello name='Daniel' enthusiasmLevel={-1} /&gt;);
  }).toThrow();
});
</code></pre>
<p>这些测试都十分基础，但你可以从中得到启发。</p>
<h2 id="添加state管理"><a class="header" href="#添加state管理">添加state管理</a></h2>
<p>到此为止，如果你使用React的目的是只获取一次数据并显示，那么你已经完成了。 但是如果你想开发一个可以交互的应用，那么你需要添加state管理。</p>
<h3 id="state管理概述"><a class="header" href="#state管理概述">state管理概述</a></h3>
<p>React本身就是一个适合于创建可组合型视图的库。 但是，React并没有任何在应用间同步数据的功能。 就React组件而言，数据是通过每个元素上指定的props向子元素传递。</p>
<p>因为React本身并没有提供内置的state管理功能，React社区选择了Redux和MobX库。</p>
<p><a href="http://redux.js.org">Redux</a>依靠一个统一且不可变的数据存储来同步数据，并且更新那里的数据时会触发应用的更新渲染。 state的更新是以一种不可变的方式进行，它会发布一条明确的action消息，这个消息必须被reducer函数处理。 由于使用了这样明确的方式，很容易弄清楚一个action是如何影响程序的state。</p>
<p><a href="https://mobx.js.org/">MobX</a>借助于函数式响应型模式，state被包装在了可观察对象里，并通过props传递。 通过将state标记为可观察的，即可在所有观察者之间保持state的同步性。 另一个好处是，这个库已经使用TypeScript实现了。</p>
<p>这两者各有优缺点。 但Redux使用得更广泛，因此在这篇教程里，我们主要看如何使用Redux； 但是也鼓励大家两者都去了解一下。</p>
<p>后面的小节学习曲线比较陡。 因此强烈建议大家先去<a href="http://redux.js.org/">熟悉一下Redux</a>。</p>
<h3 id="设置actions"><a class="header" href="#设置actions">设置actions</a></h3>
<p>只有当应用里的state会改变的时候，我们才需要去添加Redux。 我们需要一个action的来源，它将触发改变。 它可以是一个定时器或者UI上的一个按钮。</p>
<p>为此，我们将增加两个按钮来控制<code>Hello</code>组件的感叹级别。</p>
<h3 id="安装redux"><a class="header" href="#安装redux">安装Redux</a></h3>
<p>安装<code>redux</code>和<code>react-redux</code>以及它们的类型文件做为依赖。</p>
<pre><code class="language-bash">npm install -S redux react-redux @types/react-redux
</code></pre>
<p>这里我们不需要安装<code>@types/redux</code>，因为Redux已经自带了声明文件（<code>.d.ts</code>文件）。</p>
<h3 id="定义应用的状态"><a class="header" href="#定义应用的状态">定义应用的状态</a></h3>
<p>我们需要定义Redux保存的state的结构。 创建<code>src/types/index.tsx</code>文件，它保存了类型的定义，我们在整个程序里都可能用到。</p>
<pre><code class="language-typescript">// src/types/index.tsx

export interface StoreState {
    languageName: string;
    enthusiasmLevel: number;
}
</code></pre>
<p>这里我们想让<code>languageName</code>表示应用使用的编程语言（例如，TypeScript或者JavaScript），<code>enthusiasmLevel</code>是可变的。 在写我们的第一个容器的时候，就会明白为什么要令state与props稍有不同。</p>
<h3 id="添加actions"><a class="header" href="#添加actions">添加actions</a></h3>
<p>下面我们创建这个应用将要响应的消息类型，<code>src/constants/index.tsx</code>。</p>
<pre><code class="language-typescript">// src/constants/index.tsx

export const INCREMENT_ENTHUSIASM = 'INCREMENT_ENTHUSIASM';
export type INCREMENT_ENTHUSIASM = typeof INCREMENT_ENTHUSIASM;


export const DECREMENT_ENTHUSIASM = 'DECREMENT_ENTHUSIASM';
export type DECREMENT_ENTHUSIASM = typeof DECREMENT_ENTHUSIASM;
</code></pre>
<p>这里的<code>const</code>/<code>type</code>模式允许我们以容易访问和重构的方式使用TypeScript的字符串字面量类型。</p>
<p>接下来，我们创建一些actions以及创建这些actions的函数，<code>src/actions/index.tsx</code>。</p>
<pre><code class="language-typescript">import * as constants from '../constants'

export interface IncrementEnthusiasm {
    type: constants.INCREMENT_ENTHUSIASM;
}

export interface DecrementEnthusiasm {
    type: constants.DECREMENT_ENTHUSIASM;
}

export type EnthusiasmAction = IncrementEnthusiasm | DecrementEnthusiasm;

export function incrementEnthusiasm(): IncrementEnthusiasm {
    return {
        type: constants.INCREMENT_ENTHUSIASM
    }
}

export function decrementEnthusiasm(): DecrementEnthusiasm {
    return {
        type: constants.DECREMENT_ENTHUSIASM
    }
}
</code></pre>
<p>我们创建了两个类型，它们负责增加操作和减少操作的行为。 我们还定义了一个类型（<code>EnthusiasmAction</code>），它描述了哪些action是可以增加或减少的。 最后，我们定义了两个函数用来创建实际的actions。</p>
<p>这里有一些清晰的模版，你可以参考类似<a href="https://www.npmjs.com/package/redux-actions">redux-actions</a>的库。</p>
<h3 id="添加reducer"><a class="header" href="#添加reducer">添加reducer</a></h3>
<p>现在我们可以开始写第一个reducer了！ Reducers是函数，它们负责生成应用state的拷贝使之产生变化，但它并没有_副作用_。 它们是一种<a href="https://en.wikipedia.org/wiki/Pure_function"><em>纯函数</em></a>。</p>
<p>我们的reducer将放在<code>src/reducers/index.tsx</code>文件里。 它的功能是保证增加操作会让感叹级别加1，减少操作则要将感叹级别减1，但是这个级别永远不能小于1。</p>
<pre><code class="language-typescript">// src/reducers/index.tsx

import { EnthusiasmAction } from '../actions';
import { StoreState } from '../types/index';
import { INCREMENT_ENTHUSIASM, DECREMENT_ENTHUSIASM } from '../constants/index';

export function enthusiasm(state: StoreState, action: EnthusiasmAction): StoreState {
  switch (action.type) {
    case INCREMENT_ENTHUSIASM:
      return { ...state, enthusiasmLevel: state.enthusiasmLevel + 1 };
    case DECREMENT_ENTHUSIASM:
      return { ...state, enthusiasmLevel: Math.max(1, state.enthusiasmLevel - 1) };
  }
  return state;
}
</code></pre>
<p>注意我们使用了_对象展开_（<code>...state</code>），当替换<code>enthusiasmLevel</code>时，它可以对状态进行浅拷贝。 将<code>enthusiasmLevel</code>属性放在末尾是十分关键的，否则它将被旧的状态覆盖。</p>
<p>你可能想要对reducer写一些测试。 因为reducers是纯函数，它们可以传入任意的数据。 针对每个输入，可以测试reducers生成的新的状态。 可以考虑使用Jest的<a href="https://facebook.github.io/jest/docs/en/expect.html#toequalvalue">toEqual</a>方法。</p>
<h3 id="创建容器"><a class="header" href="#创建容器">创建容器</a></h3>
<p>在使用Redux时，我们常常要创建组件和容器。 组件是数据无关的，且工作在表现层。 _容器_通常包裹组件及其使用的数据，用以显示和修改状态。 你可以在这里阅读更多关于这个概念的细节：<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">Dan Abramov写的_表现层的容器组件_</a>。</p>
<p>现在我们修改<code>src/components/Hello.tsx</code>，让它可以修改状态。 我们将添加两个可选的回调属性到<code>Props</code>，它们分别是<code>onIncrement</code>和<code>onDecrement</code>：</p>
<pre><code class="language-typescript">export interface Props {
  name: string;
  enthusiasmLevel?: number;
  onIncrement?: () =&gt; void;
  onDecrement?: () =&gt; void;
}
</code></pre>
<p>然后将这两个回调绑定到两个新按钮上，将按钮添加到我们的组件里。</p>
<pre><code class="language-typescript">function Hello({ name, enthusiasmLevel = 1, onIncrement, onDecrement }: Props) {
  if (enthusiasmLevel &lt;= 0) {
    throw new Error('You could be a little more enthusiastic. :D');
  }

  return (
    &lt;div className="hello"&gt;
      &lt;div className="greeting"&gt;
        Hello {name + getExclamationMarks(enthusiasmLevel)}
      &lt;/div&gt;
      &lt;div&gt;
        &lt;button onClick={onDecrement}&gt;-&lt;/button&gt;
        &lt;button onClick={onIncrement}&gt;+&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>通常情况下，我们应该给<code>onIncrement</code>和<code>onDecrement</code>写一些测试，它们是在各自的按钮被点击时调用。 试一试以便掌握编写测试的窍门。</p>
<p>现在我们的组件更新好了，可以把它放在一个容器里了。 让我们来创建一个文件<code>src/containers/Hello.tsx</code>，在开始的地方使用下列导入语句。</p>
<pre><code class="language-typescript">import Hello from '../components/Hello';
import * as actions from '../actions/';
import { StoreState } from '../types/index';
import { connect, Dispatch } from 'react-redux';
</code></pre>
<p>两个关键点是初始的<code>Hello</code>组件和react-redux的<code>connect</code>函数。 <code>connect</code>可以将我们的<code>Hello</code>组件转换成一个容器，通过以下两个函数：</p>
<ul>
<li><code>mapStateToProps</code>将当前store里的数据以我们的组件需要的形式传递到组件。</li>
<li><code>mapDispatchToProps</code>利用<code>dispatch</code>函数，创建回调props将actions送到store。</li>
</ul>
<p>回想一下，我们的应用包含两个属性：<code>languageName</code>和<code>enthusiasmLevel</code>。 我们的<code>Hello</code>组件，希望得到一个<code>name</code>和一个<code>enthusiasmLevel</code>。 <code>mapStateToProps</code>会从store得到相应的数据，如果需要的话将针对组件的props调整它。 下面让我们继续往下写。</p>
<pre><code class="language-typescript">export function mapStateToProps({ enthusiasmLevel, languageName }: StoreState) {
  return {
    enthusiasmLevel,
    name: languageName,
  }
}
</code></pre>
<p>注意<code>mapStateToProps</code>仅创建了<code>Hello</code>组件需要的四个属性中的两个。 我们还想要传入<code>onIncrement</code>和<code>onDecrement</code>回调函数。 <code>mapDispatchToProps</code>是一个函数，它需要传入一个调度函数。 这个调度函数可以将actions传入store来触发更新，因此我们可以创建一对回调函数，它们会在需要的时候调用调度函数。</p>
<pre><code class="language-typescript">export function mapDispatchToProps(dispatch: Dispatch&lt;actions.EnthusiasmAction&gt;) {
  return {
    onIncrement: () =&gt; dispatch(actions.incrementEnthusiasm()),
    onDecrement: () =&gt; dispatch(actions.decrementEnthusiasm()),
  }
}
</code></pre>
<p>最后，我们可以调用<code>connect</code>了。 <code>connect</code>首先会接收<code>mapStateToProps</code>和<code>mapDispatchToProps</code>，然后返回另一个函数，我们用它来包裹我们的组件。 最终的容器是通过下面的代码定义的：</p>
<pre><code class="language-typescript">export default connect(mapStateToProps, mapDispatchToProps)(Hello);
</code></pre>
<p>现在，我们的文件应该是下面这个样子：</p>
<pre><code class="language-typescript">// src/containers/Hello.tsx

import Hello from '../components/Hello';
import * as actions from '../actions/';
import { StoreState } from '../types/index';
import { connect, Dispatch } from 'react-redux';

export function mapStateToProps({ enthusiasmLevel, languageName }: StoreState) {
  return {
    enthusiasmLevel,
    name: languageName,
  }
}

export function mapDispatchToProps(dispatch: Dispatch&lt;actions.EnthusiasmAction&gt;) {
  return {
    onIncrement: () =&gt; dispatch(actions.incrementEnthusiasm()),
    onDecrement: () =&gt; dispatch(actions.decrementEnthusiasm()),
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(Hello);
</code></pre>
<h3 id="创建store"><a class="header" href="#创建store">创建store</a></h3>
<p>让我们回到<code>src/index.tsx</code>。 要把所有的东西合到一起，我们需要创建一个带初始状态的store，并用我们所有的reducers来设置它。</p>
<pre><code class="language-typescript">import { createStore } from 'redux';
import { enthusiasm } from './reducers/index';
import { StoreState } from './types/index';

const store = createStore&lt;StoreState&gt;(enthusiasm, {
  enthusiasmLevel: 1,
  languageName: 'TypeScript',
});
</code></pre>
<p><code>store</code>可能正如你想的那样，它是我们应用全局状态的核心store。</p>
<p>接下来，我们将要用<code>./src/containers/Hello</code>来包裹<code>./src/components/Hello</code>，然后使用react-redux的<code>Provider</code>将props与容器连通起来。 我们将导入它们：</p>
<pre><code class="language-typescript">import Hello from './containers/Hello';
import { Provider } from 'react-redux';
</code></pre>
<p>将<code>store</code>以<code>Provider</code>的属性形式传入：</p>
<pre><code class="language-typescript">ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;Hello /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root') as HTMLElement
);
</code></pre>
<p>注意，<code>Hello</code>不再需要props了，因为我们使用了<code>connect</code>函数为包裹起来的<code>Hello</code>组件的props适配了应用的状态。</p>
<h2 id="退出"><a class="header" href="#退出">退出</a></h2>
<p>如果你发现create-react-app使一些自定义设置变得困难，那么你就可以选择不使用它，使用你需要配置。 比如，你要添加一个Webpack插件，你就可以利用create-react-app提供的“eject”功能。</p>
<p>运行：</p>
<pre><code class="language-bash">npm run eject
</code></pre>
<p>这样就可以了！</p>
<p>你要注意，在运行eject前最好保存你的代码。 你不能撤销eject命令，因此退出操作是永久性的除非你从一个运行eject前的提交来恢复工程。</p>
<h2 id="下一步"><a class="header" href="#下一步">下一步</a></h2>
<p>create-react-app带有很多很棒的功能。 它们的大多数都在我们工程生成的<code>README.md</code>里面有记录，所以可以简单阅读一下。</p>
<p>如果你想学习更多关于Redux的知识，你可以前往<a href="http://redux.js.org/">官方站点</a>查看文档。 同样的，<a href="https://mobx.js.org/">MobX</a>官方站点。</p>
<p>如果你想要在某个时间点eject，你需要了解再多关于Webpack的知识。 你可以查看<a href="zh/tutorials/react-and-webpack.html">React &amp; Webpack教程</a>。</p>
<p>有时候你需要路由功能。 已经有一些解决方案了，但是对于Redux工程来讲<a href="https://github.com/ReactTraining/react-router">react-router</a>是最流行的，并经常与<a href="https://github.com/reactjs/react-router-redux">react-router-redux</a>联合使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="angular-2"><a class="header" href="#angular-2">Angular 2</a></h1>
<p>即将到来的Angular 2框架是使用TypeScript开发的。 因此Angular和TypeScript一起使用非常简单方便。 Angular团队也在其文档里把TypeScript视为一等公民。</p>
<p>正因为这样，你总是可以在<a href="https://angular.io">Angular 2官网</a>(或<a href="https://angular.cn">Angular 2官网中文版</a>)里查看到最新的结合使用Angular和TypeScript的参考文档。 在这里查看<a href="https://angular.io/docs/ts/latest/quickstart.html">快速上手指南</a>，现在就开始学习吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从javascript迁移到typescript"><a class="header" href="#从javascript迁移到typescript">从JavaScript迁移到TypeScript</a></h1>
<p>TypeScript不是凭空存在的。 它从JavaScript生态系统和大量现存的JavaScript而来。 将JavaScript代码转换成TypeScript虽乏味却不是难事。 接下来这篇教程将教你怎么做。 在开始转换TypeScript之前，我们假设你已经理解了足够多本手册里的内容。</p>
<p>如果你打算要转换一个React工程，推荐你先阅读<a href="https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide">React转换指南</a>。</p>
<h2 id="设置目录"><a class="header" href="#设置目录">设置目录</a></h2>
<p>如果你在写纯JavaScript，你大概是想直接运行这些JavaScript文件， 这些文件存在于<code>src</code>，<code>lib</code>或<code>dist</code>目录里，它们可以按照预想运行。</p>
<p>若如此，那么你写的纯JavaScript文件将做为TypeScript的输入，你将要运行的是TypeScript的输出。 在从JS到TS的转换过程中，我们会分离输入文件以防TypeScript覆盖它们。 你也可以指定输出目录。</p>
<p>你可能还需要对JavaScript做一些中间处理，比如合并或经过Babel再次编译。 在这种情况下，你应该已经有了如下的目录结构。</p>
<p>那么现在，我们假设你已经设置了这样的目录结构：</p>
<pre><code class="language-text">projectRoot
├── src
│   ├── file1.js
│   └── file2.js
├── built
└── tsconfig.json
</code></pre>
<p>如果你在<code>src</code>目录外还有<code>tests</code>文件夹，那么在<code>src</code>里可以有一个<code>tsconfig.json</code>文件，在<code>tests</code>里还可以有一个。</p>
<h2 id="书写配置文件"><a class="header" href="#书写配置文件">书写配置文件</a></h2>
<p>TypeScript使用<code>tsconfig.json</code>文件管理工程配置，例如你想包含哪些文件和进行哪些检查。 让我们先创建一个简单的工程配置文件：</p>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "outDir": "./built",
        "allowJs": true,
        "target": "es5"
    },
    "include": [
        "./src/**/*"
    ]
}
</code></pre>
<p>这里我们为TypeScript设置了一些东西:</p>
<ol>
<li>读取所有可识别的<code>src</code>目录下的文件（通过<code>include</code>）。</li>
<li>接受JavaScript做为输入（通过<code>allowJs</code>）。</li>
<li>生成的所有文件放在<code>built</code>目录下（通过<code>outDir</code>）。</li>
<li>将JavaScript代码降级到低版本比如ECMAScript 5（通过<code>target</code>）。</li>
</ol>
<p>现在，如果你在工程根目录下运行<code>tsc</code>，就可以在<code>built</code>目录下看到生成的文件。 <code>built</code>下的文件应该与<code>src</code>下的文件相同。 现在你的工程里的TypeScript已经可以工作了。</p>
<h3 id="早期收益"><a class="header" href="#早期收益">早期收益</a></h3>
<p>现在你已经可以看到TypeScript带来的好处，它能帮助我们理解当前工程。 如果你打开像<a href="https://code.visualstudio.com">VS Code</a>或<a href="https://visualstudio.com">Visual Studio</a>这样的编译器，你就能使用像自动补全这样的工具。 你还可以配置如下的选项来帮助查找BUG：</p>
<ul>
<li><code>noImplicitReturns</code> 会防止你忘记在函数末尾返回值。</li>
<li><code>noFallthroughCasesInSwitch</code> 会防止在<code>switch</code>代码块里的两个<code>case</code>之间忘记添加<code>break</code>语句。</li>
</ul>
<p>TypeScript还能发现那些执行不到的代码和标签，你可以通过设置<code>allowUnreachableCode</code>和<code>allowUnusedLabels</code>选项来禁用。</p>
<h2 id="与构建工具进行集成"><a class="header" href="#与构建工具进行集成">与构建工具进行集成</a></h2>
<p>在你的构建管道中可能包含多个步骤。 比如为每个文件添加一些内容。 每种工具的使用方法都是不同的，我们会尽可能的包涵主流的工具。</p>
<h3 id="gulp-1"><a class="header" href="#gulp-1">Gulp</a></h3>
<p>如果你在使用时髦的Gulp，我们已经有一篇关于<a href="zh/tutorials/gulp.html">使用Gulp</a>结合TypeScript并与常见构建工具Browserify，Babelify和Uglify进行集成的教程。 请阅读这篇教程。</p>
<h3 id="webpack"><a class="header" href="#webpack">Webpack</a></h3>
<p>Webpack集成非常简单。 你可以使用<code>awesome-typescript-loader</code>，它是一个TypeScript的加载器，结合<code>source-map-loader</code>方便调试。 运行：</p>
<pre><code class="language-text">npm install awesome-typescript-loader source-map-loader
</code></pre>
<p>并将下面的选项合并到你的<code>webpack.config.js</code>文件里：</p>
<pre><code class="language-javascript">module.exports = {
    entry: "./src/index.ts",
    output: {
        filename: "./dist/bundle.js",
    },

    // Enable sourcemaps for debugging webpack's output.
    devtool: "source-map",

    resolve: {
        // Add '.ts' and '.tsx' as resolvable extensions.
        extensions: ["", ".webpack.js", ".web.js", ".ts", ".tsx", ".js"]
    },

    module: {
        loaders: [
            // All files with a '.ts' or '.tsx' extension will be handled by 'awesome-typescript-loader'.
            { test: /\.tsx?$/, loader: "awesome-typescript-loader" }
        ],

        preLoaders: [
            // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.
            { test: /\.js$/, loader: "source-map-loader" }
        ]
    },

    // Other options...
};
</code></pre>
<p>要注意的是，<code>awesome-typescript-loader</code>必须在其它处理<code>.js</code>文件的加载器之前运行。</p>
<p>这与另一个TypeScript的Webpack加载器<a href="https://github.com/TypeStrong/ts-loader">ts-loader</a>是一样的。 你可以到<a href="https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader">这里</a>了解两者之间的差别。</p>
<p>你可以在<a href="zh/tutorials/react-and-webpack.html">React和Webpack教程</a>里找到使用Webpack的例子。</p>
<h2 id="转换到typescript文件"><a class="header" href="#转换到typescript文件">转换到TypeScript文件</a></h2>
<p>到目前为止，你已经做好了使用TypeScript文件的准备。 第一步，将<code>.js</code>文件重命名为<code>.ts</code>文件。 如果你使用了JSX，则重命名为<code>.tsx</code>文件。</p>
<p>第一步达成？ 太棒了! 你已经成功地将一个文件从JavaScript转换成了TypeScript!</p>
<p>当然了，你可能感觉哪里不对劲儿。 如果你在支持TypeScript的编辑器（或运行<code>tsc --pretty</code>）里打开了那个文件，你可能会看到有些行上有红色的波浪线。 你可以把它们当做在Microsoft Word里看到的红色波浪线一样。 但是TypeScript仍然会编译你的代码，就好比Word还是允许你打印你的文档一样。</p>
<p>如果对你来说这种行为太随便了，你可以让它变得严格些。 如果，你_不想_在发生错误的时候，TypeScript还会被编译成JavaScript，你可以使用<code>noEmitOnError</code>选项。 从某种意义上来讲，TypeScript具有一个调整它的严格性的刻度盘，你可以将指针拔动到你想要的位置。</p>
<p>如果你计划使用可用的高度严格的设置，最好现在就启用它们（查看<a href="zh/tutorials/migrating-from-javascript.html#getting-stricter-checks">启用严格检查</a>）。 比如，如果你不想让TypeScript将没有明确指定的类型默默地推断为<code>any</code>类型，可以在修改文件之前启用<code>noImplicitAny</code>。 你可能会觉得这有些过度严格，但是长期收益很快就能显现出来。</p>
<h3 id="去除错误"><a class="header" href="#去除错误">去除错误</a></h3>
<p>我们提到过，若不出所料，在转换后将会看到错误信息。 重要的是我们要逐一的查看它们并决定如何处理。 通常这些都是真正的BUG，但有时必须要告诉TypeScript你要做的是什么。</p>
<h4 id="由模块导入"><a class="header" href="#由模块导入">由模块导入</a></h4>
<p>首先你可能会看到一些类似<code>Cannot find name 'require'.</code>和<code>Cannot find name 'define'.</code>的错误。 遇到这种情况说明你在使用模块。 你仅需要告诉TypeScript它们是存在的：</p>
<pre><code class="language-typescript">// For Node/CommonJS
declare function require(path: string): any;
</code></pre>
<p>或</p>
<pre><code class="language-typescript">// For RequireJS/AMD
declare function define(...args: any[]): any;
</code></pre>
<p>最好是避免使用这些调用而改用TypeScript的导入语法。</p>
<p>首先，你要使用TypeScript的<code>module</code>标记来启用一些模块系统。 可用的选项有<code>commonjs</code>，<code>amd</code>，<code>system</code>，and <code>umd</code>。</p>
<p>如果代码里存在下面的Node/CommonJS代码：</p>
<pre><code class="language-javascript">var foo = require("foo");

foo.doStuff();
</code></pre>
<p>或者下面的RequireJS/AMD代码：</p>
<pre><code class="language-javascript">define(["foo"], function(foo) {
    foo.doStuff();
})
</code></pre>
<p>那么可以写做下面的TypeScript代码：</p>
<pre><code class="language-typescript">import foo = require("foo");

foo.doStuff();
</code></pre>
<h4 id="获取声明文件"><a class="header" href="#获取声明文件">获取声明文件</a></h4>
<p>如果你开始做转换到TypeScript导入，你可能会遇到<code>Cannot find module 'foo'.</code>这样的错误。 问题出在没有_声明文件_来描述你的代码库。 幸运的是这非常简单。 如果TypeScript报怨像是没有<code>lodash</code>包，那你只需这样做</p>
<pre><code class="language-text">npm install -S @types/lodash
</code></pre>
<p>如果你没有使用<code>commonjs</code>模块模块选项，那么就需要将<code>moduleResolution</code>选项设置为<code>node</code>。</p>
<p>之后，你应该就可以导入<code>lodash</code>了，并且会获得精确的自动补全功能。</p>
<h4 id="由模块导出"><a class="header" href="#由模块导出">由模块导出</a></h4>
<p>通常来讲，由模块导出涉及添加属性到<code>exports</code>或<code>module.exports</code>。 TypeScript允许你使用顶级的导出语句。 比如，你要导出下面的函数：</p>
<pre><code class="language-javascript">module.exports.feedPets = function(pets) {
    // ...
}
</code></pre>
<p>那么你可以这样写：</p>
<pre><code class="language-typescript">export function feedPets(pets) {
    // ...
}
</code></pre>
<p>有时你会完全重写导出对象。 这是一个常见模式，这会将模块变为可立即调用的模块：</p>
<pre><code class="language-javascript">var express = require("express");
var app = express();
</code></pre>
<p>之前你可以是这样写的：</p>
<pre><code class="language-javascript">function foo() {
    // ...
}
module.exports = foo;
</code></pre>
<p>在TypeScript里，你可以使用<code>export =</code>来代替。</p>
<pre><code class="language-typescript">function foo() {
    // ...
}
export = foo;
</code></pre>
<h4 id="过多或过少的参数"><a class="header" href="#过多或过少的参数">过多或过少的参数</a></h4>
<p>有时你会发现你在调用一个具有过多或过少参数的函数。 通常，这是一个BUG，但在某些情况下，你可以声明一个使用<code>arguments</code>对象的函数而不需要写出所有参数:</p>
<pre><code class="language-javascript">function myCoolFunction() {
    if (arguments.length == 2 &amp;&amp; !Array.isArray(arguments[1])) {
        var f = arguments[0];
        var arr = arguments[1];
        // ...
    }
    // ...
}

myCoolFunction(function(x) { console.log(x) }, [1, 2, 3, 4]);
myCoolFunction(function(x) { console.log(x) }, 1, 2, 3, 4);
</code></pre>
<p>这种情况下，我们需要利用TypeScript的函数重载来告诉调用者<code>myCoolFunction</code>函数的调用方式。</p>
<pre><code class="language-typescript">function myCoolFunction(f: (x: number) =&gt; void, nums: number[]): void;
function myCoolFunction(f: (x: number) =&gt; void, ...nums: number[]): void;
function myCoolFunction() {
    if (arguments.length == 2 &amp;&amp; !Array.isArray(arguments[1])) {
        var f = arguments[0];
        var arr = arguments[1];
        // ...
    }
    // ...
}
</code></pre>
<p>我们为<code>myCoolFunction</code>函数添加了两个重载签名。 第一个检查<code>myCoolFunction</code>函数是否接收一个函数（它又接收一个<code>number</code>参数）和一个<code>number</code>数组。 第二个同样是接收了一个函数，并且使用剩余参数（<code>...nums</code>）来表示之后的其它所有参数必须是<code>number</code>类型。</p>
<h4 id="连续添加属性"><a class="header" href="#连续添加属性">连续添加属性</a></h4>
<p>有些人可能会因为代码美观性而喜欢先创建一个对象然后立即添加属性：</p>
<pre><code class="language-javascript">var options = {};
options.color = "red";
options.volume = 11;
</code></pre>
<p>TypeScript会提示你不能给<code>color</code>和<code>volumn</code>赋值，因为先前指定<code>options</code>的类型为<code>{}</code>并不带有任何属性。 如果你将声明变成对象字面量的形式将不会产生错误：</p>
<pre><code class="language-typescript">let options = {
    color: "red",
    volume: 11
};
</code></pre>
<p>你还可以定义<code>options</code>的类型并且添加类型断言到对象字面量上。</p>
<pre><code class="language-typescript">interface Options { color: string; volume: number }

let options = {} as Options;
options.color = "red";
options.volume = 11;
</code></pre>
<p>或者，你可以将<code>options</code>指定成<code>any</code>类型，这是最简单的，但也是获益最少的。</p>
<h4 id="anyobject和"><a class="header" href="#anyobject和"><code>any</code>，<code>Object</code>，和<code>{}</code></a></h4>
<p>你可能会试图使用<code>Object</code>或<code>{}</code>来表示一个值可以具有任意属性，因为<code>Object</code>是最通用的类型。 然而在这种情况下**<code>any</code>是真正想要使用的类型**，因为它是最_灵活_的类型。</p>
<p>比如，有一个<code>Object</code>类型的东西，你将不能够在其上调用<code>toLowerCase()</code>。</p>
<p>越普通意味着更少的利用类型，但是<code>any</code>比较特殊，它是最普通的类型但是允许你在上面做任何事情。 也就是说你可以在上面调用，构造它，访问它的属性等等。 记住，当你使用<code>any</code>时，你会失去大多数TypeScript提供的错误检查和编译器支持。</p>
<p>如果你还是决定使用<code>Object</code>和<code>{}</code>，你应该选择<code>{}</code>。 虽说它们基本一样，但是从技术角度上来讲<code>{}</code>在一些深奥的情况里比<code>Object</code>更普通。</p>
<h3 id="启用严格检查"><a class="header" href="#启用严格检查">启用严格检查</a></h3>
<p>TypeScript提供了一些检查来保证安全以及帮助分析你的程序。 当你将代码转换为了TypeScript后，你可以启用这些检查来帮助你获得高度安全性。</p>
<h4 id="没有隐式的any"><a class="header" href="#没有隐式的any">没有隐式的<code>any</code></a></h4>
<p>在某些情况下TypeScript没法确定某些值的类型。 那么TypeScript会使用<code>any</code>类型代替。 这对代码转换来讲是不错，但是使用<code>any</code>意味着失去了类型安全保障，并且你得不到工具的支持。 你可以使用<code>noImplicitAny</code>选项，让TypeScript标记出发生这种情况的地方，并给出一个错误。</p>
<h4 id="严格的null与undefined检查"><a class="header" href="#严格的null与undefined检查">严格的<code>null</code>与<code>undefined</code>检查</a></h4>
<p>默认地，TypeScript把<code>null</code>和<code>undefined</code>当做属于任何类型。 这就是说，声明为<code>number</code>类型的值可以为<code>null</code>和<code>undefined</code>。 因为在JavaScript和TypeScript里，<code>null</code>和<code>undefined</code>经常会导致BUG的产生，所以TypeScript包含了<code>strictNullChecks</code>选项来帮助我们减少对这种情况的担忧。</p>
<p>当启用了<code>strictNullChecks</code>，<code>null</code>和<code>undefined</code>获得了它们自己各自的类型<code>null</code>和<code>undefined</code>。 当任何值_可能_为<code>null</code>，你可以使用联合类型。 比如，某值可能为<code>number</code>或<code>null</code>，你可以声明它的类型为<code>number | null</code>。</p>
<p>假设有一个值TypeScript认为可以为<code>null</code>或<code>undefined</code>，但是你更清楚它的类型，你可以使用<code>!</code>后缀。</p>
<pre><code class="language-typescript">declare var foo: string[] | null;

foo.length;  // error - 'foo' is possibly 'null'

foo!.length; // okay - 'foo!' just has type 'string[]'
</code></pre>
<p>要当心，当你使用<code>strictNullChecks</code>，你的依赖也需要相应地启用<code>strictNullChecks</code>。</p>
<h4 id="this没有隐式的any"><a class="header" href="#this没有隐式的any"><code>this</code>没有隐式的<code>any</code></a></h4>
<p>当你在类的外部使用<code>this</code>关键字时，它会默认获得<code>any</code>类型。 比如，假设有一个<code>Point</code>类，并且我们要添加一个函数做为它的方法：</p>
<pre><code class="language-typescript">class Point {
    constructor(public x, public y) {}
    getDistance(p: Point) {
        let dx = p.x - this.x;
        let dy = p.y - this.y;
        return Math.sqrt(dx ** 2 + dy ** 2);
    }
}
// ...

// Reopen the interface.
interface Point {
    distanceFromOrigin(point: Point): number;
}
Point.prototype.distanceFromOrigin = function(point: Point) {
    return this.getDistance({ x: 0, y: 0});
}
</code></pre>
<p>这就产生了我们上面提到的错误 - 如果我们错误地拼写了<code>getDistance</code>并不会得到一个错误。 正因此，TypeScript有<code>noImplicitThis</code>选项。 当设置了它，TypeScript会产生一个错误当没有明确指定类型（或通过类型推断）的<code>this</code>被使用时。 解决的方法是在接口或函数上使用指定了类型的<code>this</code>参数：</p>
<pre><code class="language-typescript">Point.prototype.distanceFromOrigin = function(this: Point, point: Point) {
    return this.getDistance({ x: 0, y: 0});
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="手册"><a class="header" href="#手册">手册</a></h1>
<ul>
<li><a href="zh/handbook/basic-types.html">基础类型</a></li>
<li><a href="zh/handbook/interfaces.html">接口</a></li>
<li><a href="zh/handbook/functions.html">函数</a></li>
<li><a href="zh/handbook/literal-types.html">字面量类型</a></li>
<li><a href="zh/handbook/unions-and-intersections.html">联合类型和交叉类型</a></li>
<li><a href="zh/handbook/classes.html">类</a></li>
<li><a href="zh/handbook/enums.html">枚举</a></li>
<li><a href="zh/handbook/generics.html">泛型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础类型"><a class="header" href="#基础类型">基础类型</a></h1>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>
<h2 id="boolean"><a class="header" href="#boolean">Boolean</a></h2>
<p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做<code>boolean</code>（其它语言中也一样）。</p>
<pre><code class="language-typescript">let isDone: boolean = false;
</code></pre>
<h2 id="number"><a class="header" href="#number">Number</a></h2>
<p>和JavaScript一样，TypeScript里的所有数字都是浮点数或者大整数 。 这些浮点数的类型是<code>number</code>， 而大整数的类型则是 <code>bigint</code>。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p>
<pre><code class="language-typescript">let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;
let bigLiteral: bigint = 100n;
</code></pre>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用<code>string</code>表示文本数据类型。 和JavaScript一样，可以使用双引号（<code>"</code>）或单引号（<code>'</code>）表示字符串。</p>
<pre><code class="language-typescript">let name: string = "bob";
name = "smith";
</code></pre>
<p>你还可以使用_模版字符串_，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（` `），并且以<code>${ expr }</code>这种形式嵌入表达式</p>
<pre><code class="language-typescript">let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is ${ name }.

I'll be ${ age + 1 } years old next month.`;
</code></pre>
<p>这与下面定义<code>sentence</code>的方式效果相同：</p>
<pre><code class="language-typescript">let sentence: string = "Hello, my name is " + name + ".\n\n" +
    "I'll be " + (age + 1) + " years old next month.";
</code></pre>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上<code>[]</code>，表示由此类型元素组成的一个数组：</p>
<pre><code class="language-typescript">let list: number[] = [1, 2, 3];
</code></pre>
<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>
<pre><code class="language-typescript">let list: Array&lt;number&gt; = [1, 2, 3];
</code></pre>
<h2 id="tuple"><a class="header" href="#tuple">Tuple</a></h2>
<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为<code>string</code>和<code>number</code>类型的元组。</p>
<pre><code class="language-typescript">// Declare a tuple type
let x: [string, number];
// Initialize it
x = ['hello', 10]; // OK
// Initialize it incorrectly
x = [10, 'hello']; // Error
</code></pre>
<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<pre><code class="language-typescript">console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, 'number' does not have 'substr'
</code></pre>
<p>当访问一个越界的元素会报错。</p>
<pre><code class="language-typescript">x[3] = "world"; // Error, Property '3' does not exist on type '[string, number]'.

console.log(x[5].toString()); // Error, Property '5' does not exist on type '[string, number]'.
</code></pre>
<h2 id="enum"><a class="header" href="#enum">Enum</a></h2>
<p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<pre><code class="language-typescript">enum Color {Red, Green, Blue}
let c: Color = Color.Green;
</code></pre>
<p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从<code>1</code>开始编号：</p>
<pre><code class="language-typescript">enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;
</code></pre>
<p>或者，全部都采用手动赋值：</p>
<pre><code class="language-typescript">enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;
</code></pre>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<pre><code class="language-typescript">enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

console.log(colorName);  // 显示'Green'因为上面代码里它的值是2
</code></pre>
<h2 id="unknown"><a class="header" href="#unknown">Unknown</a></h2>
<p>当我们在写应用的时候可能会需要描述一个我们还不知道其类型的变量。这些值可以来自动态内容，例如从用户获得，或者我们想在我们的 API 中接收所有可能类型的值。在这些情况下，我们想要让编译器以及未来的用户知道这个变量可以是任意类型。这个时候我们会对它使用 <code>unknown</code> 类型。</p>
<pre><code class="language-typescript">let notSure: unknown = 4;
notSure = "maybe a string instead";

// OK, definitely a boolean
notSure = false;
</code></pre>
<p>如果你有一个 <code>unknwon</code> 类型的变量，你可以通过进行 <code>typeof</code> 、比较或者更高级的类型检查来将其的类型范围缩小，这些方法会在后续章节中进一步讨论：</p>
<pre><code class="language-typescript">// @errors: 2322 2322 2322
declare const maybe: unknown;
// 'maybe' could be a string, object, boolean, undefined, or other types
const aNumber: number = maybe;

if (maybe === true) {
  // TypeScript knows that maybe is a boolean now
  const aBoolean: boolean = maybe;
  // So, it cannot be a string
  const aString: string = maybe;
}

if (typeof maybe === "string") {
  // TypeScript knows that maybe is a string
  const aString: string = maybe;
  // So, it cannot be a boolean
  const aBoolean: boolean = maybe;
}
</code></pre>
<h2 id="any"><a class="header" href="#any">Any</a></h2>
<p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用<code>any</code>类型来标记这些变量：</p>
<pre><code class="language-typescript">let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean
</code></pre>
<p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为<code>Object</code>有相似的作用，就像它在其它语言中那样。 但是<code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p>
<pre><code class="language-typescript">let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.
</code></pre>
<blockquote>
<p>注意：应避免使用<code>Object</code>，而是使用非原始<code>object</code>类型，正如<a href="zh/handbook/../doc/handbook/declaration%20files/Do&#x27;s%20and%20Don&#x27;ts.html">Do's and Don'ts</a>里所讲的那样。</p>
</blockquote>
<p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<pre><code class="language-typescript">let list: any[] = [1, true, "free"];

list[1] = 100;
</code></pre>
<h2 id="void"><a class="header" href="#void">Void</a></h2>
<p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是<code>void</code>：</p>
<pre><code class="language-typescript">function warnUser(): void {
    console.log("This is my warning message");
}
</code></pre>
<p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>null</code>（只在<code>--strictNullChecks</code>未指定时）和<code>undefined</code>：</p>
<pre><code class="language-typescript">let unusable: void = undefined;
</code></pre>
<h2 id="null-和-undefined"><a class="header" href="#null-和-undefined">Null 和 Undefined</a></h2>
<p>TypeScript里，<code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。 和<code>void</code>相似，它们的本身的类型用处不是很大：</p>
<pre><code class="language-typescript">// Not much else we can assign to these variables!
let u: undefined = undefined;
let n: null = null;
</code></pre>
<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把<code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p>
<p>然而，当你指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>any</code>和它们各自的类型（有一个例外是<code>undefined</code>还可以赋值给<code>void</code>类型）。 这能避免_很多_常见的问题。 也许在某处你想传入一个<code>string</code>或<code>null</code>或<code>undefined</code>，你可以使用联合类型<code>string | null | undefined</code>。</p>
<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>
<blockquote>
<p>注意：我们鼓励尽可能地使用<code>--strictNullChecks</code>，但在本手册里我们假设这个标记是关闭的。</p>
</blockquote>
<h2 id="never"><a class="header" href="#never">Never</a></h2>
<p><code>never</code>类型表示的是那些永不存在的值的类型。 例如，<code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是<code>never</code>类型，当它们被永不为真的类型保护所约束时。</p>
<p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，_没有_类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使<code>any</code>也不可以赋值给<code>never</code>。</p>
<p>下面是一些返回<code>never</code>类型的函数：</p>
<pre><code class="language-typescript">// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
    return error("Something failed");
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {
    }
}
</code></pre>
<h2 id="object"><a class="header" href="#object">Object</a></h2>
<p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>bigint</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p>
<p>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的API。例如：</p>
<pre><code class="language-typescript">declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
</code></pre>
<h2 id="类型断言-1"><a class="header" href="#类型断言-1">类型断言</a></h2>
<p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过_类型断言_这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<pre><code class="language-typescript">let someValue: any = "this is a string";

let strLength: number = (&lt;string&gt;someValue).length;
</code></pre>
<p>另一个为<code>as</code>语法：</p>
<pre><code class="language-typescript">let someValue: any = "this is a string";

let strLength: number = (someValue as string).length;
</code></pre>
<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有<code>as</code>语法断言是被允许的。</p>
<h2 id="关于let"><a class="header" href="#关于let">关于<code>let</code></a></h2>
<p>你可能已经注意到了，我们使用<code>let</code>关键字来代替大家所熟悉的JavaScript关键字<code>var</code>。 <code>let</code>是ES2015引入的关键字，它比<code>var</code>更加安全，因此被看做是声明变量的标准方式。 我们会在以后详细介绍它，很多常见的问题都可以通过使用<code>let</code>来解决，所以尽可能地使用<code>let</code>来代替<code>var</code>吧。</p>
<h2 id="关于-number-string-boolean-symbol-和-object"><a class="header" href="#关于-number-string-boolean-symbol-和-object">关于 Number, String, Boolean, Symbol 和 Object</a></h2>
<p>我们很容易会认为 <code>Number</code>、 <code>String</code>、 <code>Boolean</code>、<code>Symbol</code> 以及 <code>Object</code> 这些类型和我们以上推荐的小写版本的类型是一样的。但这些类型不属于语言的基本类型，并且几乎在任何时候都不应该被用作一个类型：</p>
<pre><code class="language-typescript">// @errors: 2339
function reverse(s: String): String {
  return s.split("").reverse().join("");
}

reverse("hello world");
</code></pre>
<p>相对地，我们应该使用 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>object</code> 和 <code>symbol</code></p>
<pre><code class="language-typescript">function reverse(s: string): string {
  return s.split("").reverse().join("");
}

reverse("hello world");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="接口-1"><a class="header" href="#接口-1">接口</a></h1>
<h2 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h2>
<p>TypeScript 的核心原则之一是对值所具有的_结构_进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<h2 id="接口初探"><a class="header" href="#接口初探">接口初探</a></h2>
<p>下面通过一个简单示例来观察接口是如何工作的：</p>
<pre><code class="language-typescript">function printLabel(labeledObj: { label: string }) {
  console.log(labeledObj.label);
}

let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj);
</code></pre>
<p>类型检查器会查看<code>printLabel</code>的调用。 <code>printLabel</code>有一个参数，并要求这个对象参数有一个名为<code>label</code>类型为<code>string</code>的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候 TypeScript 却并不会这么宽松，我们下面会稍做讲解。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code>属性且类型为<code>string</code>：</p>
<pre><code class="language-typescript">interface LabeledValue {
  label: string;
}

function printLabel(labeledObj: LabeledValue) {
  console.log(labeledObj.label);
}

let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj);
</code></pre>
<p><code>LabeledValue</code>接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个<code>label</code>属性且类型为<code>string</code>的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给<code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>
<h2 id="可选属性"><a class="header" href="#可选属性">可选属性</a></h2>
<p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了“option bags”的例子：</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  let newSquare = { color: "white", area: 100 };
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({ color: "black" });
</code></pre>
<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将<code>createSquare</code>里的<code>color</code>属性名拼错，就会得到一个错误提示：</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  let newSquare = { color: "white", area: 100 };
  if (config.clor) {
    // Error: Property 'clor' does not exist on type 'SquareConfig'
    newSquare.color = config.clor;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({ color: "black" });
</code></pre>
<h2 id="只读属性"><a class="header" href="#只读属性">只读属性</a></h2>
<p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用<code>readonly</code>来指定只读属性:</p>
<pre><code class="language-typescript">interface Point {
  readonly x: number;
  readonly y: number;
}
</code></pre>
<p>你可以通过赋值一个对象字面量来构造一个<code>Point</code>。 赋值后，<code>x</code>和<code>y</code>再也不能被改变了。</p>
<pre><code class="language-typescript">let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
</code></pre>
<p>TypeScript 具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
<pre><code class="language-typescript">let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray&lt;number&gt; = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
</code></pre>
<p>上面代码的最后一行，可以看到就算把整个<code>ReadonlyArray</code>赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
<pre><code class="language-typescript">a = ro as number[];
</code></pre>
<h3 id="readonly-vs-const"><a class="header" href="#readonly-vs-const"><code>readonly</code> vs <code>const</code></a></h3>
<p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用<code>const</code>，若做为属性则使用<code>readonly</code>。</p>
<h2 id="额外的属性检查"><a class="header" href="#额外的属性检查">额外的属性检查</a></h2>
<p>我们在第一个例子里使用了接口，TypeScript 让我们传入<code>{ size: number; label: string; }</code>到仅期望得到<code>{ label: string; }</code>的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p>
<p>然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。比如，拿<code>createSquare</code>例子来说：</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  // ...
}

let mySquare = createSquare({ colour: "red", width: 100 });
</code></pre>
<p>注意传入<code>createSquare</code>的参数拼写为<code>colour</code>而不是<code>color</code>。 在 JavaScript 里，这会默默地失败。</p>
<p>你可能会争辩这个程序已经正确地类型化了，因为<code>width</code>属性是兼容的，不存在<code>color</code>属性，而且额外的<code>colour</code>属性是无意义的。</p>
<p>然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过_额外属性检查_，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<pre><code class="language-typescript">// error: Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });
</code></pre>
<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<pre><code class="language-typescript">let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
</code></pre>
<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果<code>SquareConfig</code>带有上面定义的类型的<code>color</code>和<code>width</code>属性，并且_还会_带有任意数量的其它属性，那么我们可以这样定义它：</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
  [propName: string]: any;
}
</code></pre>
<p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code>可以有任意数量的属性，并且只要它们不是<code>color</code>和<code>width</code>，那么就无所谓它们的类型是什么。</p>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为<code>squareOptions</code>不会经过额外属性检查，所以编译器不会报错。</p>
<pre><code class="language-typescript">let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
</code></pre>
<p>上面的方法只在<code>squareOptions</code>和<code>SquareConfig</code>之间有共同的属性时才好用。 在这个例子中，这个属性为<code>width</code>。如果变量间不存在共同的对象属性将会报错。例如：</p>
<pre><code class="language-typescript">let squareOptions = { colour: "red" };
let mySquare = createSquare(squareOptions);
</code></pre>
<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的 bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入<code>color</code>或<code>colour</code>属性到<code>createSquare</code>，你应该修改<code>SquareConfig</code>定义来体现出这一点。</p>
<h2 id="函数类型"><a class="header" href="#函数类型">函数类型</a></h2>
<p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<pre><code class="language-typescript">interface SearchFunc {
  (source: string, subString: string): boolean;
}
</code></pre>
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<pre><code class="language-typescript">let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result &gt; -1;
};
</code></pre>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>
<pre><code class="language-typescript">let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
  let result = src.search(sub);
  return result &gt; -1;
};
</code></pre>
<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了<code>SearchFunc</code>类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是<code>false</code>和<code>true</code>）。</p>
<pre><code class="language-typescript">let mySearch: SearchFunc;
mySearch = function(src, sub) {
  let result = src.search(sub);
  return result &gt; -1;
};
</code></pre>
<p>如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与<code>SearchFunc</code>接口中的定义不匹配。</p>
<pre><code class="language-typescript">let mySearch: SearchFunc;

// error: Type '(src: string, sub: string) =&gt; string' is not assignable to type 'SearchFunc'.
// Type 'string' is not assignable to type 'boolean'.
mySearch = function(src, sub) {
  let result = src.search(sub);
  return "string";
};
</code></pre>
<h2 id="可索引的类型"><a class="header" href="#可索引的类型">可索引的类型</a></h2>
<p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap["daniel"]</code>。 可索引类型具有一个_索引签名_，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
<pre><code class="language-typescript">interface StringArray {
  [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];
</code></pre>
<p>上面例子里，我们定义了<code>StringArray</code>接口，它具有索引签名。 这个索引签名表示了当用<code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值。</p>
<p>Typescript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用<code>number</code>来索引时，JavaScript 会将它转换成<code>string</code>然后再去索引对象。 也就是说用<code>100</code>（一个<code>number</code>）去索引等同于使用<code>"100"</code>（一个<code>string</code>）去索引，因此两者需要保持一致。</p>
<pre><code class="language-typescript">class Animal {
  name: string;
}
class Dog extends Animal {
  breed: string;
}

// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!
interface NotOkay {
  [x: number]: Animal;
  [x: string]: Dog;
}
</code></pre>
<p>字符串索引签名能够很好的描述<code>dictionary</code>模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了<code>obj.property</code>和<code>obj["property"]</code>两种形式都可以。 下面的例子里，<code>name</code>的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<pre><code class="language-typescript">interface NumberDictionary {
  [index: string]: number;
  length: number; // 可以，length是number类型
  name: string; // 错误，`name`的类型与索引类型返回值的类型不匹配
}
</code></pre>
<p>但如果索引签名是包含属性类型的联合类型，那么使用不同类型的属性就是允许的。</p>
<pre><code class="language-typescript">interface NumberOrStringDictionary {
   [index: string]: number | string;
   length: number;    // ok, length is a number
   name: string;      // ok, name is a string
}
</code></pre>
<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<pre><code class="language-typescript">interface ReadonlyStringArray {
  readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // error!
</code></pre>
<p>你不能设置<code>myArray[2]</code>，因为索引签名是只读的。</p>
<h2 id="类类型"><a class="header" href="#类类型">类类型</a></h2>
<h3 id="实现接口"><a class="header" href="#实现接口">实现接口</a></h3>
<p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p>
<pre><code class="language-typescript">interface ClockInterface {
  currentTime: Date;
}

class Clock implements ClockInterface {
  currentTime: Date = new Date();
  constructor(h: number, m: number) {}
}
</code></pre>
<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的<code>setTime</code>方法一样：</p>
<pre><code class="language-typescript">interface ClockInterface {
  currentTime: Date;
  setTime(d: Date): void;
}

class Clock implements ClockInterface {
  currentTime: Date = new Date();
  setTime(d: Date) {
    this.currentTime = d;
  }
  constructor(h: number, m: number) {}
}
</code></pre>
<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<h3 id="类静态部分与实例部分的区别"><a class="header" href="#类静态部分与实例部分的区别">类静态部分与实例部分的区别</a></h3>
<p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>
<pre><code class="language-typescript">interface ClockConstructor {
  new (hour: number, minute: number);
}

class Clock implements ClockConstructor {
  currentTime: Date;
  constructor(h: number, m: number) {}
}
</code></pre>
<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor 存在于类的静态部分，所以不在检查的范围内。</p>
<p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口，<code>ClockConstructor</code>为构造函数所用和<code>ClockInterface</code>为实例方法所用。 为了方便我们定义一个构造函数<code>createClock</code>，它用传入的类型创建实例。</p>
<pre><code class="language-typescript">interface ClockConstructor {
  new (hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
  tick(): void;
}

function createClock(
  ctor: ClockConstructor,
  hour: number,
  minute: number
): ClockInterface {
  return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
  constructor(h: number, m: number) {}
  tick() {
    console.log("beep beep");
  }
}
class AnalogClock implements ClockInterface {
  constructor(h: number, m: number) {}
  tick() {
    console.log("tick tock");
  }
}

let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);
</code></pre>
<p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，在<code>createClock(AnalogClock, 7, 32)</code>里，会检查<code>AnalogClock</code>是否符合构造函数签名。</p>
<p>另一种简单方式是使用类表达式：</p>
<pre><code class="language-typescript">interface ClockConstructor {
  new (hour: number, minute: number);
}

interface ClockInterface {
  tick();
}

const Clock: ClockConstructor = class Clock implements ClockInterface {
  constructor(h: number, m: number) {}
  tick() {
    console.log("beep beep");
  }
};
</code></pre>
<h2 id="继承接口"><a class="header" href="#继承接口">继承接口</a></h2>
<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<pre><code class="language-typescript">interface Shape {
  color: string;
}

interface Square extends Shape {
  sideLength: number;
}

let square = {} as Square;
square.color = "blue";
square.sideLength = 10;
</code></pre>
<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<pre><code class="language-typescript">interface Shape {
  color: string;
}

interface PenStroke {
  penWidth: number;
}

interface Square extends Shape, PenStroke {
  sideLength: number;
}

let square = {} as Square;
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
</code></pre>
<h2 id="混合类型"><a class="header" href="#混合类型">混合类型</a></h2>
<p>先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>
<p>一个例子就是，一个对象可以同时作为函数和对象使用，并带有额外的属性。</p>
<pre><code class="language-typescript">interface Counter {
  (start: number): string;
  interval: number;
  reset(): void;
}

function getCounter(): Counter {
  let counter = function(start: number) {} as Counter;
  counter.interval = 123;
  counter.reset = function() {};
  return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
</code></pre>
<p>在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。</p>
<h2 id="接口继承类"><a class="header" href="#接口继承类">接口继承类</a></h2>
<p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 除了继承自基类，子类之间不必相关联。 例：</p>
<pre><code class="language-typescript">class Control {
  private state: any;
}

interface SelectableControl extends Control {
  select(): void;
}

class Button extends Control implements SelectableControl {
  select() {}
}

class TextBox extends Control {
  select() {}
}

class ImageControl implements SelectableControl {
// Error: Class 'ImageControl' incorrectly implements interface 'SelectableControl'.
//  Types have separate declarations of a private property 'state'.
  private state: any;
  select() {}
}
</code></pre>
<p>在上面的例子里，<code>SelectableControl</code>包含了<code>Control</code>的所有成员，包括私有成员<code>state</code>。 因为<code>state</code>是私有成员，所以只能够是<code>Control</code>的子类们才能实现<code>SelectableControl</code>接口。 因为只有<code>Control</code>的子类才能够拥有一个声明于<code>Control</code>的私有成员<code>state</code>，这对私有成员的兼容性是必需的。</p>
<p>在<code>Control</code>类内部，是允许通过<code>SelectableControl</code>的实例来访问私有成员<code>state</code>的。 实际上，<code>SelectableControl</code>就像<code>Control</code>一样，并拥有一个<code>select</code>方法。 <code>Button</code>和<code>TextBox</code>类是<code>SelectableControl</code>的子类（因为它们都继承自<code>Control</code>并有<code>select</code>方法）。而对于 <code>ImageControl</code> 类，它有自身的私有成员 <code>state</code> 而不是通过继承 <code>Control</code> 得来的，所以它不可以实现 <code>SelectableControl</code> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<h2 id="介绍-2"><a class="header" href="#介绍-2">介绍</a></h2>
<p>函数是JavaScript应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在TypeScript里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义_行为_的地方。 TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。</p>
<h2 id="函数-1"><a class="header" href="#函数-1">函数</a></h2>
<p>和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。</p>
<p>通过下面的例子可以迅速回想起这两种JavaScript中的函数：</p>
<pre><code class="language-typescript">// Named function
function add(x, y) {
    return x + y;
}

// Anonymous function
let myAdd = function(x, y) { return x + y; };
</code></pre>
<p>在JavaScript里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习JavaScript和TypeScript会很有帮助。</p>
<pre><code class="language-typescript">let z = 100;

function addToZ(x, y) {
    return x + y + z;
}
</code></pre>
<h2 id="函数类型-1"><a class="header" href="#函数类型-1">函数类型</a></h2>
<h3 id="为函数定义类型"><a class="header" href="#为函数定义类型">为函数定义类型</a></h3>
<p>让我们为上面那个函数添加类型：</p>
<pre><code class="language-typescript">function add(x: number, y: number): number {
    return x + y;
}

let myAdd = function(x: number, y: number): number { return x + y; };
</code></pre>
<p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。</p>
<h3 id="书写完整函数类型"><a class="header" href="#书写完整函数类型">书写完整函数类型</a></h3>
<p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p>
<pre><code class="language-typescript">let myAdd: (x:number, y:number) =&gt; number =
    function(x: number, y: number): number { return x + y; };
</code></pre>
<p>函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。 我们也可以这么写：</p>
<pre><code class="language-typescript">let myAdd: (baseValue: number, increment: number) =&gt; number =
    function(x: number, y: number): number { return x + y; };
</code></pre>
<p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p>
<p>第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(<code>=&gt;</code>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为<code>void</code>而不能留空。</p>
<p>函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成API的一部分。</p>
<h3 id="推断类型"><a class="header" href="#推断类型">推断类型</a></h3>
<p>尝试这个例子的时候，你会注意到，就算仅在等式的一侧带有类型，TypeScript编译器仍可正确识别类型：</p>
<pre><code class="language-typescript">// myAdd has the full function type
let myAdd = function(x: number, y: number): number { return x + y; };

// The parameters `x` and `y` have the type number
let myAdd: (baseValue: number, increment: number) =&gt; number =
    function(x, y) { return x + y; };
</code></pre>
<p>这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。</p>
<h2 id="可选参数和默认参数"><a class="header" href="#可选参数和默认参数">可选参数和默认参数</a></h2>
<p>TypeScript里的每个函数参数都是必须的。 这不是指不能传递<code>null</code>或<code>undefined</code>作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>
<pre><code class="language-typescript">function buildName(firstName: string, lastName: string) {
    return firstName + " " + lastName;
}

let result1 = buildName("Bob");                  // error, too few parameters
let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result3 = buildName("Bob", "Adams");         // ah, just right
</code></pre>
<p>JavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 在TypeScript里我们可以在参数名旁使用<code>?</code>实现可选参数的功能。 比如，我们想让last name是可选的：</p>
<pre><code class="language-typescript">function buildName(firstName: string, lastName?: string) {
    if (lastName)
        return firstName + " " + lastName;
    else
        return firstName;
}

let result1 = buildName("Bob");  // works correctly now
let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result3 = buildName("Bob", "Adams");  // ah, just right
</code></pre>
<p>可选参数必须跟在必须参数后面。 如果上例我们想让first name是可选的，那么就必须调整它们的位置，把first name放在后面。</p>
<p>在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是<code>undefined</code>时。 它们叫做有默认初始化值的参数。 让我们修改上例，把last name的默认值设置为<code>"Smith"</code>。</p>
<pre><code class="language-typescript">function buildName(firstName: string, lastName = "Smith") {
    return firstName + " " + lastName;
}

let result1 = buildName("Bob");                  // works correctly now, returns "Bob Smith"
let result2 = buildName("Bob", undefined);       // still works, also returns "Bob Smith"
let result3 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result4 = buildName("Bob", "Adams");         // ah, just right
</code></pre>
<p>在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。 也就是说可选参数与末尾的默认参数共享参数类型。</p>
<pre><code class="language-typescript">function buildName(firstName: string, lastName?: string) {
    // ...
}
</code></pre>
<p>和</p>
<pre><code class="language-typescript">function buildName(firstName: string, lastName = "Smith") {
    // ...
}
</code></pre>
<p>共享同样的类型<code>(firstName: string, lastName?: string) =&gt; string</code>。 在函数类型中，默认参数的默认值不会显示，而只会显示它是一个可选参数。</p>
<p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入<code>undefined</code>值来获得默认值。 例如，我们重写最后一个例子，让<code>firstName</code>是带默认值的参数：</p>
<pre><code class="language-typescript">function buildName(firstName = "Will", lastName: string) {
    return firstName + " " + lastName;
}

let result1 = buildName("Bob");                  // error, too few parameters
let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
let result3 = buildName("Bob", "Adams");         // okay and returns "Bob Adams"
let result4 = buildName(undefined, "Adams");     // okay and returns "Will Adams"
</code></pre>
<h2 id="剩余参数"><a class="header" href="#剩余参数">剩余参数</a></h2>
<p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用<code>arguments</code>来访问所有传入的参数。</p>
<p>在TypeScript里，你可以把所有参数收集到一个变量里：</p>
<pre><code class="language-typescript">function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + " " + restOfName.join(" ");
}

let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");
</code></pre>
<p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（<code>...</code>）后面给定的名字，你可以在函数体内使用这个数组。</p>
<p>这个省略号也会在带有剩余参数的函数类型定义上使用到：</p>
<pre><code class="language-typescript">function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + " " + restOfName.join(" ");
}

let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName;
</code></pre>
<h2 id="this"><a class="header" href="#this"><code>this</code></a></h2>
<p>学习如何在JavaScript里正确使用<code>this</code>就好比一场成年礼。 由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清<code>this</code>工作机制并且当有bug的时候能够找出错误所在。 幸运的是，TypeScript能通知你错误地使用了<code>this</code>的地方。 如果你想了解JavaScript里的<code>this</code>是如何工作的，那么首先阅读Yehuda Katz写的<a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">Understanding JavaScript Function Invocation and "this"</a>。 Yehuda的文章详细的阐述了<code>this</code>的内部工作原理，因此我们这里只做简单介绍。</p>
<h3 id="this和箭头函数"><a class="header" href="#this和箭头函数"><code>this</code>和箭头函数</a></h3>
<p>JavaScript里，<code>this</code>的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p>
<p>下面看一个例子：</p>
<pre><code class="language-typescript">let deck = {
    suits: ["hearts", "spades", "clubs", "diamonds"],
    cards: Array(52),
    createCardPicker: function() {
        return function() {
            let pickedCard = Math.floor(Math.random() * 52);
            let pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card: " + pickedCard.card + " of " + pickedCard.suit);
</code></pre>
<p>可以看到<code>createCardPicker</code>是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为<code>createCardPicker</code>返回的函数里的<code>this</code>被设置成了<code>window</code>而不是<code>deck</code>对象。 因为我们只是独立地调用了<code>cardPicker()</code>。 顶级的非方法式调用会将<code>this</code>视为<code>window</code>。 （注意：在严格模式下，<code>this</code>为<code>undefined</code>而不是<code>window</code>）。</p>
<p>为了解决这个问题，我们可以在函数被返回时就绑好正确的<code>this</code>。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的<code>this</code>值，而不是调用时的值：</p>
<pre><code class="language-typescript">let deck = {
    suits: ["hearts", "spades", "clubs", "diamonds"],
    cards: Array(52),
    createCardPicker: function() {
        // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here
        return () =&gt; {
            let pickedCard = Math.floor(Math.random() * 52);
            let pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card: " + pickedCard.card + " of " + pickedCard.suit);
</code></pre>
<p>更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了<code>--noImplicitThis</code>标记。 它会指出<code>this.suits[pickedSuit]</code>里的<code>this</code>的类型为<code>any</code>。</p>
<h3 id="this参数"><a class="header" href="#this参数"><code>this</code>参数</a></h3>
<p>不幸的是，<code>this.suits[pickedSuit]</code>中的<code>this</code>的类型依旧为<code>any</code>。 这是因为<code>this</code>来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的<code>this</code>参数。 <code>this</code>参数是个假的参数，它出现在参数列表的最前面：</p>
<pre><code class="language-typescript">function f(this: void) {
    // make sure `this` is unusable in this standalone function
}
</code></pre>
<p>让我们往例子里添加一些接口，<code>Card</code> 和 <code>Deck</code>，让类型重用能够变得清晰简单些：</p>
<pre><code class="language-typescript">interface Card {
    suit: string;
    card: number;
}
interface Deck {
    suits: string[];
    cards: number[];
    createCardPicker(this: Deck): () =&gt; Card;
}
let deck: Deck = {
    suits: ["hearts", "spades", "clubs", "diamonds"],
    cards: Array(52),
    // NOTE: The function now explicitly specifies that its callee must be of type Deck
    createCardPicker: function(this: Deck) {
        return () =&gt; {
            let pickedCard = Math.floor(Math.random() * 52);
            let pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card: " + pickedCard.card + " of " + pickedCard.suit);
</code></pre>
<p>现在TypeScript知道<code>createCardPicker</code>期望在某个<code>Deck</code>对象上调用。 也就是说<code>this</code>是<code>Deck</code>类型的，而非<code>any</code>，因此<code>--noImplicitThis</code>不会报错了。</p>
<h4 id="回调函数里的this参数"><a class="header" href="#回调函数里的this参数">回调函数里的<code>this</code>参数</a></h4>
<p>当你将一个函数传递到某个库函数里在稍后被调用时，你可能也见到过回调函数里的<code>this</code>会报错。 因为当回调函数被调用时，它会被当成一个普通函数调用，<code>this</code>将为<code>undefined</code>。 稍做改动，你就可以通过<code>this</code>参数来避免错误。 首先，库函数的作者要指定<code>this</code>的类型：</p>
<pre><code class="language-typescript">interface UIElement {
    addClickListener(onclick: (this: void, e: Event) =&gt; void): void;
}
</code></pre>
<p><code>this: void</code>意味着<code>addClickListener</code>期望<code>onclick</code>是一个函数且它不需要一个<code>this</code>类型。 然后，为调用代码里的<code>this</code>添加类型注解：</p>
<pre><code class="language-typescript">class Handler {
    info: string;
    onClickBad(this: Handler, e: Event) {
        // oops, used this here. using this callback would crash at runtime
        this.info = e.message;
    }
}
let h = new Handler();
uiElement.addClickListener(h.onClickBad); // error!
</code></pre>
<p>指定了<code>this</code>类型后，你显式声明<code>onClickBad</code>必须在<code>Handler</code>的实例上调用。 然后TypeScript会检测到<code>addClickListener</code>要求函数带有<code>this: void</code>。 改变<code>this</code>类型来修复这个错误：</p>
<pre><code class="language-typescript">class Handler {
    info: string;
    onClickGood(this: void, e: Event) {
        // can't use this here because it's of type void!
        console.log('clicked!');
    }
}
let h = new Handler();
uiElement.addClickListener(h.onClickGood);
</code></pre>
<p>因为<code>onClickGood</code>指定了<code>this</code>类型为<code>void</code>，因此传递<code>addClickListener</code>是合法的。 当然了，这也意味着不能使用<code>this.info</code>. 如果你两者都想要，你不得不使用箭头函数了：</p>
<pre><code class="language-typescript">class Handler {
    info: string;
    onClickGood = (e: Event) =&gt; { this.info = e.message }
}
</code></pre>
<p>这是可行的因为箭头函数使用外层的<code>this</code>，所以你总是可以把它们传给期望<code>this: void</code>的函数。 缺点是每个<code>Handler</code>对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到<code>Handler</code>的原型链上。 它们在不同<code>Handler</code>对象间是共享的。</p>
<h2 id="重载"><a class="header" href="#重载">重载</a></h2>
<p>JavaScript本身是个动态语言。 JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。</p>
<pre><code class="language-typescript">let suits = ["hearts", "spades", "clubs", "diamonds"];

function pickCard(x): any {
    // Check to see if we're working with an object/array
    // if so, they gave us the deck and we'll pick the card
    if (typeof x == "object") {
        let pickedCard = Math.floor(Math.random() * x.length);
        return pickedCard;
    }
    // Otherwise just let them pick the card
    else if (typeof x == "number") {
        let pickedSuit = Math.floor(x / 13);
        return { suit: suits[pickedSuit], card: x % 13 };
    }
}

let myDeck = [{ suit: "diamonds", card: 2 }, { suit: "spades", card: 10 }, { suit: "hearts", card: 4 }];
let pickedCard1 = myDeck[pickCard(myDeck)];
alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);

let pickedCard2 = pickCard(15);
alert("card: " + pickedCard2.card + " of " + pickedCard2.suit);
</code></pre>
<p><code>pickCard</code>方法根据传入参数的不同会返回两种不同的类型。 如果传入的是代表纸牌的对象，函数作用是从中抓一张牌。 如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。</p>
<p>方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载<code>pickCard</code>函数。</p>
<pre><code class="language-typescript">let suits = ["hearts", "spades", "clubs", "diamonds"];

function pickCard(x: {suit: string; card: number; }[]): number;
function pickCard(x: number): {suit: string; card: number; };
function pickCard(x): any {
    // Check to see if we're working with an object/array
    // if so, they gave us the deck and we'll pick the card
    if (typeof x == "object") {
        let pickedCard = Math.floor(Math.random() * x.length);
        return pickedCard;
    }
    // Otherwise just let them pick the card
    else if (typeof x == "number") {
        let pickedSuit = Math.floor(x / 13);
        return { suit: suits[pickedSuit], card: x % 13 };
    }
}

let myDeck = [{ suit: "diamonds", card: 2 }, { suit: "spades", card: 10 }, { suit: "hearts", card: 4 }];
let pickedCard1 = myDeck[pickCard(myDeck)];
alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);

let pickedCard2 = pickCard(15);
alert("card: " + pickedCard2.card + " of " + pickedCard2.suit);
</code></pre>
<p>这样改变后，重载的<code>pickCard</code>函数在调用的时候会进行正确的类型检查。</p>
<p>为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p>
<p>注意，<code>function pickCard(x): any</code>并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用<code>pickCard</code>会产生错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字面量类型"><a class="header" href="#字面量类型">字面量类型</a></h1>
<h2 id="介绍-3"><a class="header" href="#介绍-3">介绍</a></h2>
<p>一个字面量是一个集体类型中更为具体的一种子类型。意思是：<code>"Hello World"</code> 是一个 <code>string</code>，但是一个 <code>string</code> 不是类型系统中的 <code>"Hello World"</code>。</p>
<p>目前 TypeScript 中有三种可用的字面量类型集合，分别是：字符串、数字和布尔值。通过使用字面量类型，你可以规定一个字符串、数字或布尔值必须含有的确定值。</p>
<h2 id="字面量收窄"><a class="header" href="#字面量收窄">字面量收窄</a></h2>
<p>当你通过 <code>var</code> 或 <code>let</code> 来声明一个变量时，实际上你在告诉编译器这个变量中的内容有可能会被改变。与之相对地，用 <code>const</code> 来声明对象会让 TypeScript 知道这个对象永远不会被改变。</p>
<pre><code class="language-TypeScript">// We're making a guarantee that this variable
// helloWorld will never change, by using const.

// So, TypeScript sets the type to be "Hello World" not string
const helloWorld = "Hello World";

// On the other hand, a let can change, and so the compiler declares it a string
let hiWorld = "Hi World";
</code></pre>
<p>从无穷多种可能的例子（<code>string</code> 变量的值有无穷多种）到一个更小、确定数量的例子（在上述例子中，<code>"Hello Wrold"</code> 的可能值只有一种）的过程就叫收窄。</p>
<h2 id="字符串字面量类型"><a class="header" href="#字符串字面量类型">字符串字面量类型</a></h2>
<p>字面量类型可以通过联合联系、类型守卫、类型别名来结合实际字符串值。通过这些特性，我们可以获取一种字符串并使其有类似枚举（enum）的行为。</p>
<pre><code class="language-TypeScript">type Easing = "ease-in" | "ease-out" | "ease-in-out";

class UIElement {
  animate(dx: number, dy: number, easing: Easing) {
    if (easing === "ease-in") {
      // ...
    } else if (easing === "ease-out") {
    } else if (easing === "ease-in-out") {
    } else {
      // It's possible that someone could reach this
      // by ignoring your types though.
    }
  }
}

let button = new UIElement();
button.animate(0, 0, "ease-in");
button.animate(0, 0, "uneasy");
// Error: Argument of type '"uneasy"' is not assignable to parameter of type 'Easing'.
</code></pre>
<p>你可以传递三种允许的字符串，但是如果传递其他的字符串会收到如下错误：</p>
<pre><code class="language-TypeScript">Argument of type '"uneasy"' is not assignable to parameter of type '"ease-in" | "ease-out" | "ease-in-out"'
</code></pre>
<p>字符串字面可以通过相同的方式用来分别重载：</p>
<pre><code class="language-TypeScript">function createElement(tagName: "img"): HTMLImageElement;
function createElement(tagName: "input"): HTMLInputElement;
// ... more overloads ...
function createElement(tagName: string): Element {
  // ... code goes here ...
}
</code></pre>
<h2 id="数字字面量类型"><a class="header" href="#数字字面量类型">数字字面量类型</a></h2>
<p>TypeScript 还有数字字面量类型，它的行为和上述字符串字面量类型相同。</p>
<pre><code class="language-TypeScript">function rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {
  return (Math.floor(Math.random() * 6) + 1) as 1 | 2 | 3 | 4 | 5 | 6;
}

const result = rollDice();
</code></pre>
<p>数字字面量类型经常用来描述配置值：</p>
<pre><code class="language-TypeScript">interface MapConfig {
  lng: number;
  lat: number;
  tileSize: 8 | 16 | 32;
}

setupMap({ lng: -73.935242, lat: 40.73061, tileSize: 16 });
</code></pre>
<h2 id="布尔字面量类型"><a class="header" href="#布尔字面量类型">布尔字面量类型</a></h2>
<p>TypeScript 还有布尔值字面量类型，你可以通过他们来约束某些属性之间互有关联的对象。</p>
<pre><code class="language-TypeScript">interface ValidationSuccess {
  isValid: true;
  reason: null;
};

interface ValidationFailure {
  isValid: false;
  reason: string;
};

type ValidationResult =
  | ValidationSuccess
  | ValidationFailure;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="联合类型和交叉类型"><a class="header" href="#联合类型和交叉类型">联合类型和交叉类型</a></h1>
<h2 id="介绍-4"><a class="header" href="#介绍-4">介绍</a></h2>
<p>到目前为止，手册已经涵盖了原子对象的类型。
但是，随着对更多类型进行建模，你会发现自己正在寻找可以组合现有类型的工具，而不是从头开始创建它们。</p>
<p>交叉类型和联合类型是组合类型的方式之一。</p>
<h2 id="联合类型"><a class="header" href="#联合类型">联合类型</a></h2>
<p>有时，你会遇到一个库，它期望一个参数是 <code>number</code> 或 <code>string</code> 。
例如下面的函数：</p>
<pre><code class="language-ts twoslash">/**
 * Takes a string and adds "padding" to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 */
function padLeft(value: string, padding: any) {
  if (typeof padding === "number") {
    return Array(padding + 1).join(" ") + value;
  }
  if (typeof padding === "string") {
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${typeof padding}'.`);
}

padLeft("Hello world", 4); // returns "    Hello world"
</code></pre>
<p>在上面的例子中，<code>padLeft</code>的问题在于其<code>padding</code>参数的类型为<code>any</code>。
这意味着我们可以用<code>number</code>和<code>string</code>之外的参数类型来调用它，而TypeScript也能接受。</p>
<pre><code class="language-ts twoslash">declare function padLeft(value: string, padding: any): string;
// ---cut---
// 编译时通过但是运行时失败。
let indentedString = padLeft("Hello world", true);
</code></pre>
<p>在传统的面向对象编程中，我们会通过创建一个具有层状结构的类型来抽象这两个类型。
虽然这更明确，但也有点矫枉过正。
<code>padLeft</code>的原始版本的一个好处是，我们可以直接传递基本元素。
这意味着用法简单而简洁。
而且如果我们只是想使用一个已经存在于其他地方的函数，这种新方法也无济于事。</p>
<p>为了取代<code>any</code>，我们可以为<code>padding</code>参数使用 <em>联合类型</em>：</p>
<pre><code class="language-ts twoslash">// @errors: 2345
/**
 * Takes a string and adds "padding" to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 */
function padLeft(value: string, padding: string | number) {
  // ...
}

let indentedString = padLeft("Hello world", true);
</code></pre>
<p>一个联合类型表示一个值的类型可以是几个类型中的一个。
我们用竖线（<code>|</code>）来分隔不同类型，所以<code>number | string | boolean</code>是一个可以是<code>number</code>、<code>string</code>或<code>boolean</code>的值的类型。</p>
<h2 id="具有公共字段的联合"><a class="header" href="#具有公共字段的联合">具有公共字段的联合</a></h2>
<p>如果我们有一个联合类型的值，则只能访问联合中所有类型共有的成员。</p>
<pre><code class="language-ts twoslash">// @errors: 2339

interface Bird {
  fly(): void;
  layEggs(): void;
}

interface Fish {
  swim(): void;
  layEggs(): void;
}

declare function getSmallPet(): Fish | Bird;

let pet = getSmallPet();
pet.layEggs();

// 只有两种可能类型中的一种可用
pet.swim();
</code></pre>
<p>联合类型在这里可能有点棘手，但它只是需要一点直觉来适应。
如果一个值的类型是<code>A | B</code>，我们只能 <em>确定</em> 它有<code>A</code> <em>和</em> <code>B</code>都有的成员。
在这个例子中，<code>Bird</code>有一个名为<code>fly</code>的成员。
我们不能确定一个类型为<code>Bird | Fish</code>的变量是否有一个<code>fly</code>方法。
如果该变量在运行时确实是<code>Fish</code>，那么调用<code>pet.fly()</code>将会失败。</p>
<h2 id="可区分联合"><a class="header" href="#可区分联合">可区分联合</a></h2>
<p>使用联合的一种常用技术是使用字面量类型的单个字段，您可以使用该字段来缩小 TypeScript 可能的当前类型。例如，我们将创建一个包含三种类型的联合，这些类型具有一个共享字段。</p>
<pre><code class="language-ts">type NetworkLoadingState = {
  state: "loading";
};

type NetworkFailedState = {
  state: "failed";
  code: number;
};

type NetworkSuccessState = {
  state: "success";
  response: {
    title: string;
    duration: number;
    summary: string;
  };
};

// 创建一个只代表上述类型之一的类型，但你还不确定它是哪个。
type NetworkState =
  | NetworkLoadingState
  | NetworkFailedState
  | NetworkSuccessState;
</code></pre>
<p>上述类型都以一个名为<code>state</code>的字段，然后它们也有自己的字段。</p>
<div class="table-wrapper"><table><thead><tr><th>NetworkLoadingState</th><th>NetworkFailedState</th><th>NetworkSuccessState</th></tr></thead><tbody>
<tr><td>state</td><td>state</td><td>state</td></tr>
<tr><td></td><td>code</td><td>response</td></tr>
</tbody></table>
</div>
<p>鉴于<code>state</code>字段在<code>NetworkState</code>的每个类型中都是通用的--你的代码无需存在检查即可安全访问。</p>
<p>有了<code>state</code>这个字面类型，你可以将<code>state</code>的值与相应的字符串进行比较，TypeScript就会知道当前使用的是哪个类型。</p>
<div class="table-wrapper"><table><thead><tr><th>NetworkLoadingState</th><th>NetworkFailedState</th><th>NetworkSuccessState</th></tr></thead><tbody>
<tr><td>"loading"</td><td>"failed"</td><td>"success"</td></tr>
</tbody></table>
</div>
<p>在这个例子中，你可以使用<code>switch</code>语句来缩小在运行时代表哪种类型：</p>
<pre><code class="language-ts twoslash">// @errors: 2339
type NetworkLoadingState = {
  state: "loading";
};

type NetworkFailedState = {
  state: "failed";
  code: number;
};

type NetworkSuccessState = {
  state: "success";
  response: {
    title: string;
    duration: number;
    summary: string;
  };
};
// ---cut---
type NetworkState =
  | NetworkLoadingState
  | NetworkFailedState
  | NetworkSuccessState;

function logger(state: NetworkState): string {
  // 现在，TypeScript不知道state是三种可能类型中的哪一种。

  // 试图访问一个不是所有类型都共享的属性将引发一个错误
  state.code;

  // 通过选择state，TypeScript可以在代码流分析中缩小联合的范围
  switch (state.state) {
    case "loading":
      return "Downloading...";
    case "failed":
      // 这里的类型一定是NetworkFailedState，所以访问`code`字段是安全的。
      return `Error ${state.code} downloading`;
    case "success":
      return `Downloaded ${state.response.title} - ${state.response.summary}`;
  }
}
</code></pre>
<h2 id="联合的穷尽性检查"><a class="header" href="#联合的穷尽性检查">联合的穷尽性检查</a></h2>
<p>我们希望编译器能在我们没能覆盖可区分联合的所有变体时告诉我们。
比如，如果我们添加<code>NetworkFromCachedState</code>到<code>NetworkState</code>，我们也需要更新<code>logger</code>：</p>
<pre><code class="language-ts twoslash">// @errors: 2366
type NetworkLoadingState = { state: "loading" };
type NetworkFailedState = { state: "failed"; code: number };
type NetworkSuccessState = {
  state: "success";
  response: {
    title: string;
    duration: number;
    summary: string;
  };
};
// ---cut---
type NetworkFromCachedState = {
  state: "from_cache";
  id: string;
  response: NetworkSuccessState["response"];
};

type NetworkState =
  | NetworkLoadingState
  | NetworkFailedState
  | NetworkSuccessState
  | NetworkFromCachedState;

function logger(s: NetworkState) {
  switch (s.state) {
    case "loading":
      return "loading request";
    case "failed":
      return `failed with code ${s.code}`;
    case "success":
      return "got response";
  }
}
</code></pre>
<p>这里有两种方法实现。
第一种方法是打开<a href="zh/handbook//tsconfig#strictNullChecks"><code>strictNullChecks</code></a>并指定返回类型：</p>
<pre><code class="language-ts twoslash">// @errors: 2366
type NetworkLoadingState = { state: "loading" };
type NetworkFailedState = { state: "failed"; code: number };
type NetworkSuccessState = { state: "success" };
type NetworkFromCachedState = { state: "from_cache" };

type NetworkState =
  | NetworkLoadingState
  | NetworkFailedState
  | NetworkSuccessState
  | NetworkFromCachedState;

// ---cut---
function logger(s: NetworkState): string {
  switch (s.state) {
    case "loading":
      return "loading request";
    case "failed":
      return `failed with code ${s.code}`;
    case "success":
      return "got response";
  }
}
</code></pre>
<p>因为<code>switch</code>不再是详尽的，TypeScript知道函数有时可能会返回<code>undefined</code>。
如果你有一个明确的返回类型<code>string</code>，那么你会得到一个错误，返回类型实际上是<code>string | undefined</code>。
然而，这种方法是相当微妙的，此外，<a href="zh/handbook//tsconfig#strictNullChecks"><code>strictNullChecks</code></a>并不总是对旧代码起作用。</p>
<p>第二种方法是使用编译器用来检查穷尽性的<code>never</code>类型：</p>
<pre><code class="language-ts twoslash">// @errors: 2345
type NetworkLoadingState = { state: "loading" };
type NetworkFailedState = { state: "failed"; code: number };
type NetworkSuccessState = { state: "success" };
type NetworkFromCachedState = { state: "from_cache" };

type NetworkState =
  | NetworkLoadingState
  | NetworkFailedState
  | NetworkSuccessState
  | NetworkFromCachedState;
// ---cut---
function assertNever(x: never): never {
  throw new Error("Unexpected object: " + x);
}

function logger(s: NetworkState): string {
  switch (s.state) {
    case "loading":
      return "loading request";
    case "failed":
      return `failed with code ${s.code}`;
    case "success":
      return "got response";
    default:
      return assertNever(s);
  }
}
</code></pre>
<p>在这里，<code>assertNever</code>检查<code>s</code>是否属于<code>never</code>类型—即所有其他情况都被移除后剩下的类型。
如果你忘记了这个情况，那么<code>s</code>将会有一个实际的类型，而你将会得到一个类型错误。
这个方法需要你定义一个额外的函数，但是当你忘记的时候就更明显了，因为错误信息中包括了丢失的类型名称。</p>
<h2 id="交叉类型"><a class="header" href="#交叉类型">交叉类型</a></h2>
<p>交叉类型与联合类型密切相关，但它们的使用方式非常不同。
交叉类型将多个类型合并为一个。
这允许你把现有的类型加在一起，得到一个具有你需要的所有功能的单个类型。
例如，<code>Person &amp; Serializable &amp; Loggable</code>是一种类型，它是<code>Person</code>、<code>Serializable</code><em>和</em><code>Loggable</code>的全部。
这意味着这种类型的对象将拥有这三种类型的所有成员。</p>
<p>例如，如果你有具有一致的错误处理的网络请求，那么你可以将错误处理分离到它自己的类型中，与对应于单个响应类型的类型合并。</p>
<pre><code class="language-ts twoslash">interface ErrorHandling {
  success: boolean;
  error?: { message: string };
}

interface ArtworksData {
  artworks: { title: string }[];
}

interface ArtistsData {
  artists: { name: string }[];
}

// 这些接口被组合后拥有一致的错误处理，和它们自己的数据

type ArtworksResponse = ArtworksData &amp; ErrorHandling;
type ArtistsResponse = ArtistsData &amp; ErrorHandling;

const handleArtistsResponse = (response: ArtistsResponse) =&gt; {
  if (response.error) {
    console.error(response.error.message);
    return;
  }

  console.log(response.artists);
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类-1"><a class="header" href="#类-1">类</a></h1>
<h2 id="介绍-5"><a class="header" href="#介绍-5">介绍</a></h2>
<p>传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。</p>
<h2 id="类-2"><a class="header" href="#类-2">类</a></h2>
<p>下面看一个使用类的例子：</p>
<pre><code class="language-typescript">class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");
</code></pre>
<p>如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个<code>Greeter</code>类。这个类有3个成员：一个叫做<code>greeting</code>的属性，一个构造函数和一个<code>greet</code>方法。</p>
<p>你会注意到，我们在引用任何一个类成员的时候都用了<code>this</code>。 它表示我们访问的是类的成员。</p>
<p>最后一行，我们使用<code>new</code>构造了<code>Greeter</code>类的一个实例。 它会调用之前定义的构造函数，创建一个<code>Greeter</code>类型的新对象，并执行构造函数初始化它。</p>
<h2 id="继承"><a class="header" href="#继承">继承</a></h2>
<p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>
<p>看下面的例子：</p>
<pre><code class="language-typescript">class Animal {
    move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
    }
}

class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
</code></pre>
<p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<code>Dog</code>是一个_派生类_，它派生自<code>Animal</code><em>基类</em>，通过<code>extends</code>关键字。 派生类通常被称作_子类_，基类通常被称作_超类_。</p>
<p>因为<code>Dog</code>继承了<code>Animal</code>的功能，因此我们可以创建一个<code>Dog</code>的实例，它能够<code>bark()</code>和<code>move()</code>。</p>
<p>下面我们来看个更加复杂的例子。</p>
<pre><code class="language-typescript">class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);
</code></pre>
<p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用<code>extends</code>关键字创建了<code>Animal</code>的两个子类：<code>Horse</code>和<code>Snake</code>。</p>
<p>与前一个例子的不同点是，派生类包含了一个构造函数，它_必须_调用<code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问<code>this</code>的属性之前，我们_一定_要调用<code>super()</code>。 这个是TypeScript强制执行的一条重要规则。</p>
<p>这个例子演示了如何在子类里可以重写父类的方法。 <code>Snake</code>类和<code>Horse</code>类都创建了<code>move</code>方法，它们重写了从<code>Animal</code>继承来的<code>move</code>方法，使得<code>move</code>方法根据不同的类而具有不同的功能。 注意，即使<code>tom</code>被声明为<code>Animal</code>类型，但因为它的值是<code>Horse</code>，调用<code>tom.move(34)</code>时，它会调用<code>Horse</code>里重写的方法：</p>
<pre><code class="language-text">Slithering...
Sammy the Python moved 5m.
Galloping...
Tommy the Palomino moved 34m.
</code></pre>
<h2 id="公共私有与受保护的修饰符"><a class="header" href="#公共私有与受保护的修饰符">公共，私有与受保护的修饰符</a></h2>
<h3 id="默认为public"><a class="header" href="#默认为public">默认为<code>public</code></a></h3>
<p>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用<code>public</code>来做修饰；例如，C#要求必须明确地使用<code>public</code>指定成员是可见的。 在TypeScript里，成员都默认为<code>public</code>。</p>
<p>你也可以明确的将一个成员标记成<code>public</code>。 我们可以用下面的方式来重写上面的<code>Animal</code>类：</p>
<pre><code class="language-typescript">class Animal {
    public name: string;
    public constructor(theName: string) { this.name = theName; }
    public move(distanceInMeters: number) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}
</code></pre>
<h3 id="理解private"><a class="header" href="#理解private">理解<code>private</code></a></h3>
<p>当成员被标记成<code>private</code>时，它就不能在声明它的类的外部访问。比如：</p>
<pre><code class="language-typescript">class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal("Cat").name; // 错误: 'name' 是私有的.
</code></pre>
<p>TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p>
<p>然而，当我们比较带有<code>private</code>或<code>protected</code>成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个<code>private</code>成员，那么只有当另外一个类型中也存在这样一个<code>private</code>成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于<code>protected</code>成员也使用这个规则。</p>
<p>下面来看一个例子，更好地说明了这一点：</p>
<pre><code class="language-typescript">class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super("Rhino"); }
}

class Employee {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

let animal = new Animal("Goat");
let rhino = new Rhino();
let employee = new Employee("Bob");

animal = rhino;
animal = employee; // 错误: Animal 与 Employee 不兼容.
</code></pre>
<p>这个例子中有<code>Animal</code>和<code>Rhino</code>两个类，<code>Rhino</code>是<code>Animal</code>类的子类。 还有一个<code>Employee</code>类，其类型看上去与<code>Animal</code>是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为<code>Animal</code>和<code>Rhino</code>共享了来自<code>Animal</code>里的私有成员定义<code>private name: string</code>，因此它们是兼容的。 然而<code>Employee</code>却不是这样。当把<code>Employee</code>赋值给<code>Animal</code>的时候，得到一个错误，说它们的类型不兼容。 尽管<code>Employee</code>里也有一个私有成员<code>name</code>，但它明显不是<code>Animal</code>里面定义的那个。</p>
<h3 id="理解protected"><a class="header" href="#理解protected">理解<code>protected</code></a></h3>
<p><code>protected</code>修饰符与<code>private</code>修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。例如：</p>
<pre><code class="language-typescript">class Person {
    protected name: string;
    constructor(name: string) { this.name = name; }
}

class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name)
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee("Howard", "Sales");
console.log(howard.getElevatorPitch());
console.log(howard.name); // 错误
</code></pre>
<p>注意，我们不能在<code>Person</code>类外使用<code>name</code>，但是我们仍然可以通过<code>Employee</code>类的实例方法访问，因为<code>Employee</code>是由<code>Person</code>派生而来的。</p>
<p>构造函数也可以被标记成<code>protected</code>。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，</p>
<pre><code class="language-typescript">class Person {
    protected name: string;
    protected constructor(theName: string) { this.name = theName; }
}

// Employee 能够继承 Person
class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee("Howard", "Sales");
let john = new Person("John"); // 错误: 'Person' 的构造函数是被保护的.
</code></pre>
<h2 id="readonly修饰符"><a class="header" href="#readonly修饰符">readonly修饰符</a></h2>
<p>你可以使用<code>readonly</code>关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<pre><code class="language-typescript">class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus("Man with the 8 strong legs");
dad.name = "Man with the 3-piece suit"; // 错误! name 是只读的.
</code></pre>
<h3 id="参数属性"><a class="header" href="#参数属性">参数属性</a></h3>
<p>在上面的例子中，我们不得不在在<code>Person</code>类里定义一个只读成员<code>name</code>和一个构造函数参数<code>theName</code>。这样做是为了在<code>Octopus</code>构造函数被执行后，就可以访问<code>theName</code>的值。 这种情况经常会遇到。_参数属性_可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前<code>Animal</code>类的修改版，使用了参数属性：</p>
<pre><code class="language-typescript">class Animal {
    constructor(private name: string) { }
    move(distanceInMeters: number) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}
</code></pre>
<p>注意看我们是如何舍弃了<code>theName</code>，仅在构造函数里使用<code>private name: string</code>参数来创建和初始化<code>name</code>成员。 我们把声明和赋值合并至一处。</p>
<p>参数属性通过给构造函数参数添加一个访问限定符来声明。 使用<code>private</code>限定一个参数属性会声明并初始化一个私有成员；对于<code>public</code>和<code>protected</code>来说也是一样。</p>
<h2 id="存取器"><a class="header" href="#存取器">存取器</a></h2>
<p>TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<p>下面来看如何把一个简单的类改写成使用<code>get</code>和<code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p>
<pre><code class="language-typescript">class Employee {
    fullName: string;
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    console.log(employee.fullName);
}
</code></pre>
<p>允许随意设置<code>fullName</code>虽然方便，但是我们仍想在设置<code>fullName</code>强制执行某些约束。</p>
<p>在这个版本里，我们添加一个<code>setter</code>来检查<code>newName</code>的长度，以确保它满足数据库字段的最大长度限制。若它不满足，那么我们就抛一个错误来告诉客户端出错了。</p>
<p>为保留原有的功能，我们同时添加一个<code>getter</code>用来读取<code>fullName</code>。</p>
<pre><code class="language-typescript">const fullNameMaxLength = 10;

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) {
            throw new Error("fullName has a max length of " + fullNameMaxLength);
        }

        this._fullName = newName;
    }
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    alert(employee.fullName);
}
</code></pre>
<p>为证明我们写的存取器现在能检查长度，我们可以给名字赋一个长度大于<code>10</code>字符的值，并验证是否得到一个错误。</p>
<p>对于存取器有下面几点需要注意的：</p>
<p>首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有<code>get</code>不带有<code>set</code>的存取器自动被推断为<code>readonly</code>。 这在从代码生成<code>.d.ts</code>文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p>
<h2 id="静态属性"><a class="header" href="#静态属性">静态属性</a></h2>
<p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用<code>static</code>定义<code>origin</code>，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在<code>origin</code>前面加上类名。 如同在实例属性上使用<code>this.</code>前缀来访问属性一样，这里我们使用<code>Grid.</code>来访问静态属性。</p>
<pre><code class="language-typescript">class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        let xDist = (point.x - Grid.origin.x);
        let yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

let grid1 = new Grid(1.0);  // 1x scale
let grid2 = new Grid(5.0);  // 5x scale

console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
</code></pre>
<h2 id="抽象类"><a class="header" href="#抽象类">抽象类</a></h2>
<p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节（抽象类中除抽象函数之外，其他函数可以包含具体实现）。 <code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<pre><code class="language-typescript">abstract class Animal {
    abstract makeSound(): void;
    move(): void {
        console.log("roaming the earth...");
    }
}
</code></pre>
<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含<code>abstract</code>关键字并且可以包含访问修饰符。</p>
<pre><code class="language-typescript">abstract class Department {

    constructor(public name: string) {
    }

    printName(): void {
        console.log('Department name: ' + this.name);
    }

    abstract printMeeting(): void; // 必须在派生类中实现
}

class AccountingDepartment extends Department {

    constructor() {
        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()
    }

    printMeeting(): void {
        console.log('The Accounting Department meets each Monday at 10am.');
    }

    generateReports(): void {
        console.log('Generating accounting reports...');
    }
}

let department: Department; // 允许创建一个对抽象类型的引用
department = new Department(); // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
department.printName();
department.printMeeting();
department.generateReports(); // 错误: 方法在声明的抽象类中不存在
</code></pre>
<h2 id="高级技巧"><a class="header" href="#高级技巧">高级技巧</a></h2>
<h3 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h3>
<p>当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的_实例_的类型。</p>
<pre><code class="language-typescript">class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

let greeter: Greeter;
greeter = new Greeter("world");
console.log(greeter.greet());
</code></pre>
<p>这里，我们写了<code>let greeter: Greeter</code>，意思是<code>Greeter</code>类的实例的类型是<code>Greeter</code>。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p>
<p>我们也创建了一个叫做_构造函数_的值。 这个函数会在我们使用<code>new</code>创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p>
<pre><code class="language-typescript">let Greeter = (function () {
    function Greeter(message) {
        this.greeting = message;
    }
    Greeter.prototype.greet = function () {
        return "Hello, " + this.greeting;
    };
    return Greeter;
})();

let greeter;
greeter = new Greeter("world");
console.log(greeter.greet());
</code></pre>
<p>上面的代码里，<code>let Greeter</code>将被赋值为构造函数。 当我们调用<code>new</code>并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有_实例部分_与_静态部分_这两个部分。</p>
<p>让我们稍微改写一下这个例子，看看它们之间的区别：</p>
<pre><code class="language-typescript">class Greeter {
    static standardGreeting = "Hello, there";
    greeting: string;
    greet() {
        if (this.greeting) {
            return "Hello, " + this.greeting;
        }
        else {
            return Greeter.standardGreeting;
        }
    }
}

let greeter1: Greeter;
greeter1 = new Greeter();
console.log(greeter1.greet());

let greeterMaker: typeof Greeter = Greeter;
greeterMaker.standardGreeting = "Hey there!";

let greeter2: Greeter = new greeterMaker();
console.log(greeter2.greet());
</code></pre>
<p>这个例子里，<code>greeter1</code>与之前看到的一样。 我们实例化<code>Greeter</code>类，并使用这个对象。 与我们之前看到的一样。</p>
<p>再之后，我们直接使用类。 我们创建了一个叫做<code>greeterMaker</code>的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用<code>typeof Greeter</code>，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，"告诉我<code>Greeter</code>标识符的类型"，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在<code>greeterMaker</code>上使用<code>new</code>，创建<code>Greeter</code>的实例。</p>
<h3 id="把类当做接口使用"><a class="header" href="#把类当做接口使用">把类当做接口使用</a></h3>
<p>如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p>
<pre><code class="language-typescript">class Point {
    x: number;
    y: number;
}

interface Point3d extends Point {
    z: number;
}

let point3d: Point3d = {x: 1, y: 2, z: 3};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<h2 id="枚举-1"><a class="header" href="#枚举-1">枚举</a></h2>
<p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。</p>
<h3 id="数字枚举"><a class="header" href="#数字枚举">数字枚举</a></h3>
<p>首先我们看看数字枚举，如果你使用过其它编程语言应该会很熟悉。</p>
<pre><code class="language-typescript">enum Direction {
    Up = 1,
    Down,
    Left,
    Right
}
</code></pre>
<p>如上，我们定义了一个数字枚举，<code>Up</code>使用初始化为<code>1</code>。 其余的成员会从<code>1</code>开始自动增长。 换句话说，<code>Direction.Up</code>的值为<code>1</code>，<code>Down</code>为<code>2</code>，<code>Left</code>为<code>3</code>，<code>Right</code>为<code>4</code>。</p>
<p>我们还可以完全不使用初始化器：</p>
<pre><code class="language-typescript">enum Direction {
    Up,
    Down,
    Left,
    Right,
}
</code></pre>
<p>现在，<code>Up</code>的值为<code>0</code>，<code>Down</code>的值为<code>1</code>等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。</p>
<p>使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：</p>
<pre><code class="language-typescript">enum Response {
    No = 0,
    Yes = 1,
}

function respond(recipient: string, message: Response): void {
    // ...
}

respond("Princess Caroline", Response.Yes)
</code></pre>
<p>数字枚举可以被混入到<a href="zh/handbook/enums.html#computed-and-constant-members">计算过的和常量成员（如下所示）</a>。 简短地说，没有初始化器的成员要么在首位，要么必须在用数值常量或其他常量枚举成员初始化的数值枚举之后。 换句话说，下面的情况是不被允许的：</p>
<pre><code class="language-typescript">enum E {
    A = getSomeValue(),
    B, // Error! Enum member must have initializer.
}
</code></pre>
<h3 id="字符串枚举"><a class="header" href="#字符串枚举">字符串枚举</a></h3>
<p>字符串枚举的概念很简单，但是有细微的<a href="zh/handbook/enums.html#enums-at-runtime">运行时的差别</a>。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p>
<pre><code class="language-typescript">enum Direction {
    Up = "UP",
    Down = "DOWN",
    Left = "LEFT",
    Right = "RIGHT",
}
</code></pre>
<p>由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管<a href="zh/handbook/enums.html#enums-at-runtime">反向映射</a>会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。</p>
<h3 id="异构枚举heterogeneous-enums"><a class="header" href="#异构枚举heterogeneous-enums">异构枚举（Heterogeneous enums）</a></h3>
<p>从技术的角度来说，枚举可以混合字符串和数字成员，但是似乎你并不会这么做：</p>
<pre><code class="language-typescript">enum BooleanLikeHeterogeneousEnum {
    No = 0,
    Yes = "YES",
}
</code></pre>
<p>除非你真的想要利用JavaScript运行时的行为，否则我们不建议这样做。</p>
<h3 id="计算的和常量成员"><a class="header" href="#计算的和常量成员">计算的和常量成员</a></h3>
<p>每个枚举成员都带有一个值，它可以是_常量_或_计算出来的_。 当满足如下条件时，枚举成员被当作是常量：</p>
<ul>
<li>
<p>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值<code>0</code>：</p>
<pre><code class="language-typescript">// E.X is constant:
enum E { X }
</code></pre>
</li>
<li>
<p>它不带有初始化器且它之前的枚举成员是一个_数字_常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1。</p>
<pre><code class="language-typescript">// All enum members in 'E1' and 'E2' are constant.

enum E1 { X, Y, Z }

enum E2 {
    A = 1, B, C
}
</code></pre>
</li>
<li>
<p>枚举成员使用_常量枚举表达式_初始化。 常量枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：</p>
<ol>
<li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li>
<li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li>
<li>带括号的常量枚举表达式</li>
<li>一元运算符<code>+</code>, <code>-</code>, <code>~</code>其中之一应用在了常量枚举表达式</li>
<li>常量枚举表达式做为二元运算符<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>的操作对象。</li>
</ol>
<p>若常量枚举表达式求值后为<code>NaN</code>或<code>Infinity</code>，则会在编译阶段报错。</p>
</li>
</ul>
<p>所有其它情况的枚举成员被当作是需要计算得出的值。</p>
<pre><code class="language-typescript">enum FileAccess {
    // constant members
    None,
    Read    = 1 &lt;&lt; 1,
    Write   = 1 &lt;&lt; 2,
    ReadWrite  = Read | Write,
    // computed member
    G = "123".length
}
</code></pre>
<h3 id="联合枚举与枚举成员的类型"><a class="header" href="#联合枚举与枚举成员的类型">联合枚举与枚举成员的类型</a></h3>
<p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为</p>
<ul>
<li>任何字符串字面量（例如：<code>"foo"</code>，<code>"bar"</code>，<code>"baz"</code>）</li>
<li>任何数字字面量（例如：<code>1</code>, <code>100</code>）</li>
<li>应用了一元<code>-</code>符号的数字字面量（例如：<code>-1</code>, <code>-100</code>）</li>
</ul>
<p>当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。</p>
<p>首先，枚举成员成为了类型！ 例如，我们可以说某些成员_只能_是枚举成员的值：</p>
<pre><code class="language-typescript">enum ShapeKind {
    Circle,
    Square,
}

interface Circle {
    kind: ShapeKind.Circle;
    radius: number;
}

interface Square {
    kind: ShapeKind.Square;
    sideLength: number;
}

let c: Circle = {
    kind: ShapeKind.Square, // Error! Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.
    radius: 100,
}
</code></pre>
<p>另一个变化是枚举类型本身变成了每个枚举成员的_联合_。 虽然我们还没有讨论<a href="zh/handbook/advanced-types.html#union-types">联合类型</a>，但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。 因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。 例如：</p>
<pre><code class="language-typescript">enum E {
    Foo,
    Bar,
}

function f(x: E) {
    if (x !== E.Foo || x !== E.Bar) {
        //             ~~~~~~~~~~~
        // Error! This condition will always return 'true' since the types 'E.Foo' and 'E.Bar' have no overlap.
    }
}
</code></pre>
<p>这个例子里，我们先检查<code>x</code>是否不是<code>E.Foo</code>。 如果通过了这个检查，然后<code>||</code>会发生短路效果，<code>if</code>语句体里的内容会被执行。 然而，这个检查没有通过，那么<code>x</code>则_只能_为<code>E.Foo</code>，因此没理由再去检查它是否为<code>E.Bar</code>。</p>
<h3 id="运行时的枚举"><a class="header" href="#运行时的枚举">运行时的枚举</a></h3>
<p>枚举是在运行时真正存在的对象。 例如下面的枚举：</p>
<pre><code class="language-typescript">enum E {
    X, Y, Z
}
</code></pre>
<p>可以传递给函数</p>
<pre><code class="language-typescript">function f(obj: { X: number }) {
    return obj.X;
}

// 没问题，因为 'E'包含一个数值型属性'X'。
f(E);
</code></pre>
<h3 id="编译时的枚举"><a class="header" href="#编译时的枚举">编译时的枚举</a></h3>
<p>尽管一个枚举是在运行时真正存在的对象，但<code>keyof</code>关键字的行为与其作用在对象上时有所不同。应该使用<code>keyof typeof</code>来获取一个表示枚举里所有字符串<code>key</code>的类型。</p>
<pre><code class="language-typescript">enum LogLevel {
    ERROR, WARN, INFO, DEBUG
}

/**
 * 等同于：
 * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';
 */
type LogLevelStrings = keyof typeof LogLevel;

function printImportant(key: LogLevelStrings, message: string) {
    const num = LogLevel[key];
    if (num &lt;= LogLevel.WARN) {
       console.log('Log level key is: ', key);
       console.log('Log level value is: ', num);
       console.log('Log level message is: ', message);
    }
}
printImportant('ERROR', 'This is a message');
</code></pre>
<h4 id="反向映射"><a class="header" href="#反向映射">反向映射</a></h4>
<p>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了_反向映射_，从枚举值到枚举名字。 例如，在下面的例子中：</p>
<pre><code class="language-typescript">enum Enum {
    A
}
let a = Enum.A;
let nameOfA = Enum[a]; // "A"
</code></pre>
<p>TypeScript可能会将这段代码编译为下面的JavaScript：</p>
<pre><code class="language-javascript">var Enum;
(function (Enum) {
    Enum[Enum["A"] = 0] = "A";
})(Enum || (Enum = {}));
var a = Enum.A;
var nameOfA = Enum[a]; // "A"
</code></pre>
<p>生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（<code>name</code> -&gt; <code>value</code>）和反向映射（<code>value</code> -&gt; <code>name</code>）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。</p>
<p>要注意的是_不会_为字符串枚举成员生成反向映射。</p>
<h4 id="const枚举"><a class="header" href="#const枚举"><code>const</code>枚举</a></h4>
<p>大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用<code>const</code>枚举。 常量枚举通过在枚举上使用<code>const</code>修饰符来定义。</p>
<pre><code class="language-typescript">const enum Enum {
    A = 1,
    B = A * 2
}
</code></pre>
<p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</p>
<pre><code class="language-typescript">const enum Directions {
    Up,
    Down,
    Left,
    Right
}

let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]
</code></pre>
<p>生成后的代码为：</p>
<pre><code class="language-javascript">var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];
</code></pre>
<h2 id="外部枚举"><a class="header" href="#外部枚举">外部枚举</a></h2>
<p>外部枚举用来描述已经存在的枚举类型的形状。</p>
<pre><code class="language-typescript">declare enum Enum {
    A = 1,
    B,
    C = 2
}
</code></pre>
<p>外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常量成员。 对于非常量的外部枚举而言，没有初始化方法时被当做需要经过计算的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<h2 id="介绍-6"><a class="header" href="#介绍-6">介绍</a></h2>
<p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>
<p>在像C#和Java这样的语言中，可以使用<code>泛型</code>来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>
<h2 id="泛型之hello-world"><a class="header" href="#泛型之hello-world">泛型之Hello World</a></h2>
<p>下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是<code>echo</code>命令。</p>
<p>不用泛型的话，这个函数可能是下面这样：</p>
<pre><code class="language-typescript">function identity(arg: number): number {
    return arg;
}
</code></pre>
<p>或者，我们使用<code>any</code>类型来定义函数：</p>
<pre><code class="language-typescript">function identity(arg: any): any {
    return arg;
}
</code></pre>
<p>使用<code>any</code>类型会导致这个函数可以接收任何类型的<code>arg</code>参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。 如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p>
<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了_类型变量_，它是一种特殊的变量，只用于表示类型而不是值。</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}
</code></pre>
<p>我们给identity添加了类型变量<code>T</code>。 <code>T</code>帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了<code>T</code>当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。</p>
<p>我们把这个版本的<code>identity</code>函数叫做泛型，因为它可以适用于多个类型。 不同于使用<code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>
<p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p>
<pre><code class="language-typescript">let output = identity&lt;string&gt;("myString");  // type of output will be 'string'
</code></pre>
<p>这里我们明确的指定了<code>T</code>是<code>string</code>类型，并做为一个参数传给函数，使用了<code>&lt;&gt;</code>括起来而不是<code>()</code>。</p>
<p>第二种方法更普遍。利用了_类型推论_ -- 即编译器会根据传入的参数自动地帮助我们确定T的类型：</p>
<pre><code class="language-typescript">let output = identity("myString");  // type of output will be 'string'
</code></pre>
<p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看<code>myString</code>的值，然后把<code>T</code>设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。</p>
<h2 id="使用泛型变量"><a class="header" href="#使用泛型变量">使用泛型变量</a></h2>
<p>使用泛型创建像<code>identity</code>这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p>
<p>看下之前<code>identity</code>例子：</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}
</code></pre>
<p>如果我们想同时打印出<code>arg</code>的长度。 我们很可能会这样做：</p>
<pre><code class="language-typescript">function loggingIdentity&lt;T&gt;(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
</code></pre>
<p>如果这么做，编译器会报错说我们使用了<code>arg</code>的<code>.length</code>属性，但是没有地方指明<code>arg</code>具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有<code>.length</code>属性的。</p>
<p>现在假设我们想操作<code>T</code>类型的数组而不直接是<code>T</code>。由于我们操作的是数组，所以<code>.length</code>属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：</p>
<pre><code class="language-typescript">function loggingIdentity&lt;T&gt;(arg: T[]): T[] {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
</code></pre>
<p>你可以这样理解<code>loggingIdentity</code>的类型：泛型函数<code>loggingIdentity</code>，接收类型参数<code>T</code>和参数<code>arg</code>，它是个元素类型是<code>T</code>的数组，并返回元素类型是<code>T</code>的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时<code>T</code>的的类型为<code>number</code>。 这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性。</p>
<p>我们也可以这样实现上面的例子：</p>
<pre><code class="language-typescript">function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
</code></pre>
<p>使用过其它语言的话，你可能对这种语法已经很熟悉了。 在下一节，会介绍如何创建自定义泛型像<code>Array&lt;T&gt;</code>一样。</p>
<h2 id="泛型类型"><a class="header" href="#泛型类型">泛型类型</a></h2>
<p>上一节，我们创建了identity通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p>
<p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;
</code></pre>
<p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity;
</code></pre>
<p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: {&lt;T&gt;(arg: T): T} = identity;
</code></pre>
<p>这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口：</p>
<pre><code class="language-typescript">interface GenericIdentityFn {
    &lt;T&gt;(arg: T): T;
}

function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn = identity;
</code></pre>
<p>一个相似的例子，我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如：<code>Dictionary&lt;string&gt;而不只是Dictionary</code>）。 这样接口里的其它成员也能知道这个参数的类型了。</p>
<pre><code class="language-typescript">interface GenericIdentityFn&lt;T&gt; {
    (arg: T): T;
}

function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn&lt;number&gt; = identity;
</code></pre>
<p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用<code>GenericIdentityFn</code>的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p>
<p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p>
<h2 id="泛型类"><a class="header" href="#泛型类">泛型类</a></h2>
<p>泛型类看上去与泛型接口差不多。 泛型类使用（<code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p>
<pre><code class="language-typescript">class GenericNumber&lt;T&gt; {
    zeroValue: T;
    add: (x: T, y: T) =&gt; T;
}

let myGenericNumber = new GenericNumber&lt;number&gt;();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
</code></pre>
<p><code>GenericNumber</code>类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用<code>number</code>类型。 也可以使用字符串或其它更复杂的类型。</p>
<pre><code class="language-typescript">let stringNumeric = new GenericNumber&lt;string&gt;();
stringNumeric.zeroValue = "";
stringNumeric.add = function(x, y) { return x + y; };

console.log(stringNumeric.add(stringNumeric.zeroValue, "test"));
</code></pre>
<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>
<p>我们在<a href="zh/handbook/classes.html">类</a>那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>
<h2 id="泛型约束"><a class="header" href="#泛型约束">泛型约束</a></h2>
<p>你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在<code>loggingIdentity</code>例子中，我们想访问<code>arg</code>的<code>length</code>属性，但是编译器并不能证明每种类型都有<code>length</code>属性，所以就报错了。</p>
<pre><code class="language-typescript">function loggingIdentity&lt;T&gt;(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
</code></pre>
<p>相比于操作any所有类型，我们想要限制函数去处理任意带有<code>.length</code>属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。</p>
<p>为此，我们定义一个接口来描述约束条件。 创建一个包含<code>.length</code>属性的接口，使用这个接口和<code>extends</code>关键字来实现约束：</p>
<pre><code class="language-typescript">interface Lengthwise {
    length: number;
}

function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}
</code></pre>
<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>
<pre><code class="language-typescript">loggingIdentity(3);  // Error, number doesn't have a .length property
</code></pre>
<p>我们需要传入符合约束类型的值，必须包含必须的属性：</p>
<pre><code class="language-typescript">loggingIdentity({length: 10, value: 3});
</code></pre>
<h3 id="在泛型约束中使用类型参数"><a class="header" href="#在泛型约束中使用类型参数">在泛型约束中使用类型参数</a></h3>
<p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象<code>obj</code>上，因此我们需要在这两个类型之间使用约束。</p>
<pre><code class="language-typescript">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {
    return obj[key];
}

let x = { a: 1, b: 2, c: 3, d: 4 };

getProperty(x, "a"); // okay
getProperty(x, "m"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.
</code></pre>
<h3 id="在泛型里使用类类型"><a class="header" href="#在泛型里使用类类型">在泛型里使用类类型</a></h3>
<p>在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如，</p>
<pre><code class="language-typescript">function create&lt;T&gt;(c: {new(): T; }): T {
    return new c();
}
</code></pre>
<p>一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。</p>
<pre><code class="language-typescript">class BeeKeeper {
    hasMask: boolean;
}

class ZooKeeper {
    nametag: string;
}

class Animal {
    numLegs: number;
}

class Bee extends Animal {
    keeper: BeeKeeper;
}

class Lion extends Animal {
    keeper: ZooKeeper;
}

function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A {
    return new c();
}

createInstance(Lion).keeper.nametag;  // typechecks!
createInstance(Bee).keeper.hasMask;   // typechecks!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="手册进阶"><a class="header" href="#手册进阶">手册（进阶）</a></h1>
<ul>
<li><a href="zh/reference/advanced-types.html">高级类型</a></li>
<li><a href="zh/reference/utility-types.html">实用工具类型</a></li>
<li><a href="zh/reference/decorators.html">Decorators</a></li>
<li><a href="zh/reference/declaration-merging.html">声明合并</a></li>
<li><a href="zh/reference/iterators-and-generators.html">Iterators 和 Generators</a></li>
<li><a href="zh/reference/jsx.html">JSX</a></li>
<li><a href="zh/reference/mixins.html">混入</a></li>
<li><a href="zh/reference/modules.html">模块</a></li>
<li><a href="zh/reference/module-resolution.html">模块解析</a></li>
<li><a href="zh/reference/namespaces.html">命名空间</a></li>
<li><a href="zh/reference/namespaces-and-modules.html">命名空间和模块</a></li>
<li><a href="zh/reference/symbols.html">Symbols</a></li>
<li><a href="zh/reference/triple-slash-directives.html">三斜线指令</a></li>
<li><a href="zh/reference/type-compatibility.html">类型兼容性</a></li>
<li><a href="zh/reference/type-inference.html">类型推论</a></li>
<li><a href="zh/reference/variable-declarations.html">变量声明</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高级类型"><a class="header" href="#高级类型">高级类型</a></h1>
<h2 id="交叉类型intersection-types"><a class="header" href="#交叉类型intersection-types">交叉类型（Intersection Types）</a></h2>
<p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code>Person &amp; Serializable &amp; Loggable</code>同时是<code>Person</code><em>和</em><code>Serializable</code><em>和</em><code>Loggable</code>。 就是说这个类型的对象同时拥有了这三种类型的成员。</p>
<p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在JavaScript里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子("target": "es5")：</p>
<pre><code class="language-typescript">function extend&lt;First, Second&gt;(first: First, second: Second): First &amp; Second {
    const result: Partial&lt;First &amp; Second&gt; = {};
    for (const prop in first) {
        if (first.hasOwnProperty(prop)) {
            (result as First)[prop] = first[prop];
        }
    }
    for (const prop in second) {
        if (second.hasOwnProperty(prop)) {
            (result as Second)[prop] = second[prop];
        }
    }
    return result as First &amp; Second;
}

class Person {
    constructor(public name: string) { }
}

interface Loggable {
    log(name: string): void;
}

class ConsoleLogger implements Loggable {
    log(name) {
        console.log(`Hello, I'm ${name}.`);
    }
}

const jim = extend(new Person('Jim'), ConsoleLogger.prototype);
jim.log(jim.name);
</code></pre>
<h2 id="联合类型union-types"><a class="header" href="#联合类型union-types">联合类型（Union Types）</a></h2>
<p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入<code>number</code>或<code>string</code>类型的参数。 例如下面的函数：</p>
<pre><code class="language-typescript">/**
 * Takes a string and adds "padding" to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 */
function padLeft(value: string, padding: any) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}

padLeft("Hello world", 4); // returns "    Hello world"
</code></pre>
<p><code>padLeft</code>存在一个问题，<code>padding</code>参数的类型指定成了<code>any</code>。 这就是说我们可以传入一个既不是<code>number</code>也不是<code>string</code>类型的参数，但是TypeScript却不报错。</p>
<pre><code class="language-typescript">let indentedString = padLeft("Hello world", true); // 编译阶段通过，运行时报错
</code></pre>
<p>在传统的面向对象语言里，我们可能会将这两种类型抽象成有层级的类型。 这么做显然是非常清晰的，但同时也存在了过度设计。 <code>padLeft</code>原始版本的好处之一是允许我们传入原始类型。 这样做的话使用起来既简单又方便。 如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。</p>
<p>代替<code>any</code>， 我们可以使用_联合类型_做为<code>padding</code>的参数：</p>
<pre><code class="language-typescript">/**
 * Takes a string and adds "padding" to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 */
function padLeft(value: string, padding: string | number) {
    // ...
}

let indentedString = padLeft("Hello world", true); // errors during compilation
</code></pre>
<p>联合类型表示一个值可以是几种类型之一。 我们用竖线（<code>|</code>）分隔每个类型，所以<code>number | string | boolean</code>表示一个值可以是<code>number</code>，<code>string</code>，或<code>boolean</code>。</p>
<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>
<pre><code class="language-typescript">interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ...
}

let pet = getSmallPet();
pet.layEggs(); // okay
pet.swim();    // errors
</code></pre>
<p>这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是<code>A | B</code>，我们能够_确定_的是它包含了<code>A</code><em>和</em><code>B</code>中共有的成员。 这个例子里，<code>Bird</code>具有一个<code>fly</code>成员。 我们不能确定一个<code>Bird | Fish</code>类型的变量是否有<code>fly</code>方法。 如果变量在运行时是<code>Fish</code>类型，那么调用<code>pet.fly()</code>就出错了。</p>
<h2 id="类型守卫与类型区分type-guards-and-differentiating-types"><a class="header" href="#类型守卫与类型区分type-guards-and-differentiating-types">类型守卫与类型区分（Type Guards and Differentiating Types）</a></h2>
<p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为<code>Fish</code>时怎么办？ JavaScript里常用来区分2个可能值的方法是检查成员是否存在。 如之前提及的，我们只能访问联合类型中共同拥有的成员。</p>
<pre><code class="language-typescript">let pet = getSmallPet();

// 每一个成员访问都会报错
if (pet.swim) {
    pet.swim();
}
else if (pet.fly) {
    pet.fly();
}
</code></pre>
<p>为了让这段代码工作，我们要使用类型断言：</p>
<pre><code class="language-typescript">let pet = getSmallPet();

if ((pet as Fish).swim) {
    (pet as Fish).swim();
} else if ((pet as Bird).fly) {
    (pet as Bird).fly();
}
</code></pre>
<h3 id="用户自定义的类型守卫"><a class="header" href="#用户自定义的类型守卫">用户自定义的类型守卫</a></h3>
<p>这里可以注意到我们不得不多次使用类型断言。 假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道<code>pet</code>的类型的话就好了。</p>
<p>TypeScript里的_类型守卫_机制让它成为了现实。 类型守卫就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。</p>
<h4 id="使用类型判定"><a class="header" href="#使用类型判定">使用类型判定</a></h4>
<p>要定义一个类型守卫，我们只要简单地定义一个函数，它的返回值是一个_类型谓词_：</p>
<pre><code class="language-typescript">function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}
</code></pre>
<p>在这个例子里，<code>pet is Fish</code>就是类型谓词。 谓词为<code>parameterName is Type</code>这种形式，<code>parameterName</code>必须是来自于当前函数签名里的一个参数名。</p>
<p>每当使用一些变量调用<code>isFish</code>时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。</p>
<pre><code class="language-typescript">// 'swim' 和 'fly' 调用都没有问题了

if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}
</code></pre>
<p>注意TypeScript不仅知道在<code>if</code>分支里<code>pet</code>是<code>Fish</code>类型； 它还清楚在<code>else</code>分支里，一定_不是_<code>Fish</code>类型，一定是<code>Bird</code>类型。</p>
<h4 id="使用in操作符"><a class="header" href="#使用in操作符">使用<code>in</code>操作符</a></h4>
<p><code>in</code>操作符可以作为类型细化表达式来使用。</p>
<p>对于<code>n in x</code>表达式，其中<code>n</code>是字符串字面量或字符串字面量类型且<code>x</code>是个联合类型，那么<code>true</code>分支的类型细化为有一个可选的或必须的属性<code>n</code>，<code>false</code>分支的类型细化为有一个可选的或不存在属性<code>n</code>。</p>
<pre><code class="language-typescript">function move(pet: Fish | Bird) {
    if ("swim" in pet) {
        return pet.swim();
    }
    return pet.fly();
}
</code></pre>
<h3 id="typeof类型守卫"><a class="header" href="#typeof类型守卫"><code>typeof</code>类型守卫</a></h3>
<p>现在我们回过头来看看怎么使用联合类型书写<code>padLeft</code>代码。 我们可以像下面这样利用类型断言来写：</p>
<pre><code class="language-typescript">function isNumber(x: any): x is number {
    return typeof x === "number";
}

function isString(x: any): x is string {
    return typeof x === "string";
}

function padLeft(value: string, padding: string | number) {
    if (isNumber(padding)) {
        return Array(padding + 1).join(" ") + value;
    }
    if (isString(padding)) {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
</code></pre>
<p>然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。 幸运的是，现在我们不必将<code>typeof x === "number"</code>抽象成一个函数，因为TypeScript可以将它识别为一个类型守卫。 也就是说我们可以直接在代码里检查类型了。</p>
<pre><code class="language-typescript">function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
</code></pre>
<p>这些_<code>typeof</code>类型守卫_只有两种形式能被识别：<code>typeof v === "typename"</code>和<code>typeof v !== "typename"</code>，<code>"typename"</code>必须是<code>"number"</code>，<code>"string"</code>，<code>"boolean"</code>或<code>"symbol"</code>。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型守卫。</p>
<h3 id="instanceof类型守卫"><a class="header" href="#instanceof类型守卫"><code>instanceof</code>类型守卫</a></h3>
<p>如果你已经阅读了<code>typeof</code>类型守卫并且对JavaScript里的<code>instanceof</code>操作符熟悉的话，你可能已经猜到了这节要讲的内容。</p>
<p>_<code>instanceof</code>类型守卫_是通过构造函数来细化类型的一种方式。 比如，我们借鉴一下之前字符串填充的例子：</p>
<pre><code class="language-typescript">interface Padder {
    getPaddingString(): string
}

class SpaceRepeatingPadder implements Padder {
    constructor(private numSpaces: number) { }
    getPaddingString() {
        return Array(this.numSpaces + 1).join(" ");
    }
}

class StringPadder implements Padder {
    constructor(private value: string) { }
    getPaddingString() {
        return this.value;
    }
}

function getRandomPadder() {
    return Math.random() &lt; 0.5 ?
        new SpaceRepeatingPadder(4) :
        new StringPadder("  ");
}

// 类型为SpaceRepeatingPadder | StringPadder
let padder: Padder = getRandomPadder();

if (padder instanceof SpaceRepeatingPadder) {
    padder; // 类型细化为'SpaceRepeatingPadder'
}
if (padder instanceof StringPadder) {
    padder; // 类型细化为'StringPadder'
}
</code></pre>
<p><code>instanceof</code>的右侧要求是一个构造函数，TypeScript将细化为：</p>
<ol>
<li>此构造函数的<code>prototype</code>属性的类型，如果它的类型不为<code>any</code>的话</li>
<li>构造签名所返回的类型的联合</li>
</ol>
<p>以此顺序。</p>
<h2 id="可以为null的类型"><a class="header" href="#可以为null的类型">可以为<code>null</code>的类型</a></h2>
<p>TypeScript具有两种特殊的类型，<code>null</code>和<code>undefined</code>，它们分别具有值<code>null</code>和<code>undefined</code>. 我们在<a href="zh/reference/basic-types.html">基础类型</a>一节里已经做过简要说明。 默认情况下，类型检查器认为<code>null</code>与<code>undefined</code>可以赋值给任何类型。 <code>null</code>与<code>undefined</code>是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。 <code>null</code>的发明者，Tony Hoare，称它为<a href="https://en.wikipedia.org/wiki/Null_pointer#History">价值亿万美金的错误</a>。</p>
<p><code>--strictNullChecks</code>标记可以解决此错误：当你声明一个变量时，它不会自动地包含<code>null</code>或<code>undefined</code>。 你可以使用联合类型明确的包含它们：</p>
<pre><code class="language-typescript">let s = "foo";
s = null; // 错误, 'null'不能赋值给'string'
let sn: string | null = "bar";
sn = null; // 可以

sn = undefined; // error, 'undefined'不能赋值给'string | null'
</code></pre>
<p>注意，按照JavaScript的语义，TypeScript会把<code>null</code>和<code>undefined</code>区别对待。 <code>string | null</code>，<code>string | undefined</code>和<code>string | undefined | null</code>是不同的类型。</p>
<h3 id="可选参数和可选属性"><a class="header" href="#可选参数和可选属性">可选参数和可选属性</a></h3>
<p>使用了<code>--strictNullChecks</code>，可选参数会被自动地加上<code>| undefined</code>:</p>
<pre><code class="language-typescript">function f(x: number, y?: number) {
    return x + (y || 0);
}
f(1, 2);
f(1);
f(1, undefined);
f(1, null); // error, 'null' is not assignable to 'number | undefined'
</code></pre>
<p>可选属性也会有同样的处理：</p>
<pre><code class="language-typescript">class C {
    a: number;
    b?: number;
}
let c = new C();
c.a = 12;
c.a = undefined; // error, 'undefined' is not assignable to 'number'
c.b = 13;
c.b = undefined; // ok
c.b = null; // error, 'null' is not assignable to 'number | undefined'
</code></pre>
<h3 id="类型守卫和类型断言"><a class="header" href="#类型守卫和类型断言">类型守卫和类型断言</a></h3>
<p>由于可以为<code>null</code>的类型是通过联合类型实现，那么你需要使用类型守卫来去除<code>null</code>。 幸运地是这与在JavaScript里写的代码一致：</p>
<pre><code class="language-typescript">function f(sn: string | null): string {
    if (sn == null) {
        return "default";
    }
    else {
        return sn;
    }
}
</code></pre>
<p>这里很明显地去除了<code>null</code>，你也可以使用短路运算符：</p>
<pre><code class="language-typescript">function f(sn: string | null): string {
    return sn || "default";
}
</code></pre>
<p>如果编译器不能够去除<code>null</code>或<code>undefined</code>，你可以使用类型断言手动去除。 语法是添加<code>!</code>后缀：<code>identifier!</code>从<code>identifier</code>的类型里去除了<code>null</code>和<code>undefined</code>：</p>
<pre><code class="language-typescript">function broken(name: string | null): string {
  function postfix(epithet: string) {
    return name.charAt(0) + '.  the ' + epithet; // error, 'name' is possibly null
  }
  name = name || "Bob";
  return postfix("great");
}

function fixed(name: string | null): string {
  function postfix(epithet: string) {
    return name!.charAt(0) + '.  the ' + epithet; // ok
  }
  name = name || "Bob";
  return postfix("great");
}
</code></pre>
<p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的<code>null</code>（除非是立即调用的函数表达式）。 因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。 如果无法知道函数在哪里被调用，就无法知道调用时<code>name</code>的类型。</p>
<h2 id="类型别名"><a class="header" href="#类型别名">类型别名</a></h2>
<p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p>
<pre><code class="language-typescript">type Name = string;
type NameResolver = () =&gt; string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name {
    if (typeof n === 'string') {
        return n;
    }
    else {
        return n();
    }
}
</code></pre>
<p>起别名不会新建一个类型 - 它创建了一个新_名字_来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p>
<p>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入：</p>
<pre><code class="language-typescript">type Container&lt;T&gt; = { value: T };
</code></pre>
<p>我们也可以使用类型别名来在属性里引用自己：</p>
<pre><code class="language-typescript">type Tree&lt;T&gt; = {
    value: T;
    left: Tree&lt;T&gt;;
    right: Tree&lt;T&gt;;
}
</code></pre>
<p>与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。</p>
<pre><code class="language-typescript">type LinkedList&lt;T&gt; = T &amp; { next: LinkedList&lt;T&gt; };

interface Person {
    name: string;
}

var people: LinkedList&lt;Person&gt;;
var s = people.name;
var s = people.next.name;
var s = people.next.next.name;
var s = people.next.next.next.name;
</code></pre>
<p>然而，类型别名不能出现在声明右侧的任何地方。</p>
<pre><code class="language-typescript">type Yikes = Array&lt;Yikes&gt;; // error
</code></pre>
<h3 id="接口-vs-类型别名"><a class="header" href="#接口-vs-类型别名">接口 vs. 类型别名</a></h3>
<p>像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。</p>
<p>其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在<code>interfaced</code>上，显示它返回的是<code>Interface</code>，但悬停在<code>aliased</code>上时，显示的却是对象字面量类型。</p>
<pre><code class="language-typescript">type Alias = { num: number }
interface Interface {
    num: number;
}
declare function aliased(arg: Alias): Alias;
declare function interfaced(arg: Interface): Interface;
</code></pre>
<p>在旧版本的TypeScript里，类型别名不能被继承和实现（它们也不能继承和实现其它类型）。从TypeScript 2.7开始，类型别名可以被继承并生成新的交叉类型。例如：<code>type Cat = Animal &amp; { purrs: true }</code>。</p>
<p>因为<a href="https://en.wikipedia.org/wiki/Open/closed_principle">软件中的对象应该对于扩展是开放的，但是对于修改是封闭的</a>，你应该尽量去使用接口代替类型别名。</p>
<p>另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</p>
<h2 id="字符串字面量类型-1"><a class="header" href="#字符串字面量类型-1">字符串字面量类型</a></h2>
<p>字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型守卫和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>
<pre><code class="language-typescript">type Easing = "ease-in" | "ease-out" | "ease-in-out";
class UIElement {
    animate(dx: number, dy: number, easing: Easing) {
        if (easing === "ease-in") {
            // ...
        }
        else if (easing === "ease-out") {
        }
        else if (easing === "ease-in-out") {
        }
        else {
            // error! should not pass null or undefined.
        }
    }
}

let button = new UIElement();
button.animate(0, 0, "ease-in");
button.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here
</code></pre>
<p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p>
<pre><code class="language-text">Argument of type '"uneasy"' is not assignable to parameter of type '"ease-in" | "ease-out" | "ease-in-out"'
</code></pre>
<p>字符串字面量类型还可以用于区分函数重载：</p>
<pre><code class="language-typescript">function createElement(tagName: "img"): HTMLImageElement;
function createElement(tagName: "input"): HTMLInputElement;
// ... more overloads ...
function createElement(tagName: string): Element {
    // ... code goes here ...
}
</code></pre>
<h2 id="数字字面量类型-1"><a class="header" href="#数字字面量类型-1">数字字面量类型</a></h2>
<p>TypeScript还具有数字字面量类型。</p>
<pre><code class="language-typescript">function rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {
    // ...
}
</code></pre>
<p>我们很少直接这样使用，但它们可以用在缩小范围调试bug的时候：</p>
<pre><code class="language-typescript">function foo(x: number) {
    if (x !== 1 || x !== 2) {
        //         ~~~~~~~
        // Operator '!==' cannot be applied to types '1' and '2'.
    }
}
</code></pre>
<p>换句话说，当<code>x</code>与<code>2</code>进行比较的时候，它的值必须为<code>1</code>，这就意味着上面的比较检查是非法的。</p>
<h2 id="枚举成员类型"><a class="header" href="#枚举成员类型">枚举成员类型</a></h2>
<p>如我们在<a href="zh/reference/enums.html#union-enums-and-enum-member-types">枚举</a>一节里提到的，当每个枚举成员都是用字面量初始化的时候枚举成员是具有类型的。</p>
<p>在我们谈及“单例类型”的时候，多数是指枚举成员类型和数字/字符串字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。</p>
<h2 id="可辨识联合discriminated-unions"><a class="header" href="#可辨识联合discriminated-unions">可辨识联合（Discriminated Unions）</a></h2>
<p>你可以合并单例类型，联合类型，类型守卫和类型别名来创建一个叫做_可辨识联合_的高级模式，它也称做_标签联合_或_代数数据类型_。 可辨识联合在函数式编程里很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：</p>
<ol>
<li>具有普通的单例类型属性—<em>可辨识的特征</em>。</li>
<li>一个类型别名包含了那些类型的联合—<em>联合</em>。</li>
<li>此属性上的类型守卫。</li>
</ol>
<pre><code class="language-typescript">interface Square {
    kind: "square";
    size: number;
}
interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}
interface Circle {
    kind: "circle";
    radius: number;
}
</code></pre>
<p>首先我们声明了将要联合的接口。 每个接口都有<code>kind</code>属性但有不同的字符串字面量类型。 <code>kind</code>属性称做_可辨识的特征_或_标签_。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起：</p>
<pre><code class="language-typescript">type Shape = Square | Rectangle | Circle;
</code></pre>
<p>现在我们使用可辨识联合:</p>
<pre><code class="language-typescript">function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
}
</code></pre>
<h3 id="完整性检查"><a class="header" href="#完整性检查">完整性检查</a></h3>
<p>当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了<code>Triangle</code>到<code>Shape</code>，我们同时还需要更新<code>area</code>:</p>
<pre><code class="language-typescript">type Shape = Square | Rectangle | Circle | Triangle;
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
    // should error here - we didn't handle case "triangle"
}
</code></pre>
<p>有两种方式可以实现。 首先是启用<code>--strictNullChecks</code>并且指定一个返回值类型：</p>
<pre><code class="language-typescript">function area(s: Shape): number { // error: returns number | undefined
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
}
</code></pre>
<p>因为<code>switch</code>没有包含所有情况，所以TypeScript认为这个函数有时候会返回<code>undefined</code>。 如果你明确地指定了返回值类型为<code>number</code>，那么你会看到一个错误，因为实际上返回值的类型为<code>number | undefined</code>。 然而，这种方法存在些微妙之处且<code>--strictNullChecks</code>对旧代码支持不好。</p>
<p>第二种方法使用<code>never</code>类型，编译器用它来进行完整性检查：</p>
<pre><code class="language-typescript">function assertNever(x: never): never {
    throw new Error("Unexpected object: " + x);
}
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
        default: return assertNever(s); // error here if there are missing cases
    }
}
</code></pre>
<p>这里，<code>assertNever</code>检查<code>s</code>是否为<code>never</code>类型—即为除去所有可能情况后剩下的类型。 如果你忘记了某个case，那么<code>s</code>将具有一个真实的类型并且你会得到一个错误。 这种方式需要你定义一个额外的函数，但是在你忘记某个case的时候也更加明显。</p>
<h2 id="多态的this类型"><a class="header" href="#多态的this类型">多态的<code>this</code>类型</a></h2>
<p>多态的<code>this</code>类型表示的是某个包含类或接口的_子类型_。 这被称做_F_-bounded多态性。 它能很容易的表现连贯接口间的继承，比如。 在计算器的例子里，在每个操作之后都返回<code>this</code>类型：</p>
<pre><code class="language-typescript">class BasicCalculator {
    public constructor(protected value: number = 0) { }
    public currentValue(): number {
        return this.value;
    }
    public add(operand: number): this {
        this.value += operand;
        return this;
    }
    public multiply(operand: number): this {
        this.value *= operand;
        return this;
    }
    // ... other operations go here ...
}

let v = new BasicCalculator(2)
            .multiply(5)
            .add(1)
            .currentValue();
</code></pre>
<p>由于这个类使用了<code>this</code>类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变。</p>
<pre><code class="language-typescript">class ScientificCalculator extends BasicCalculator {
    public constructor(value = 0) {
        super(value);
    }
    public sin() {
        this.value = Math.sin(this.value);
        return this;
    }
    // ... other operations go here ...
}

let v = new ScientificCalculator(2)
        .multiply(5)
        .sin()
        .add(1)
        .currentValue();
</code></pre>
<p>如果没有<code>this</code>类型，<code>ScientificCalculator</code>就不能够在继承<code>BasicCalculator</code>的同时还保持接口的连贯性。 <code>multiply</code>将会返回<code>BasicCalculator</code>，它并没有<code>sin</code>方法。 然而，使用<code>this</code>类型，<code>multiply</code>会返回<code>this</code>，在这里就是<code>ScientificCalculator</code>。</p>
<h2 id="索引类型index-types"><a class="header" href="#索引类型index-types">索引类型（Index types）</a></h2>
<p>使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的JavaScript模式是从对象中选取属性的子集。</p>
<pre><code class="language-javascript">function pluck(o, propertyNames) {
    return propertyNames.map(n =&gt; o[n]);
}
</code></pre>
<p>下面是如何在TypeScript里使用此函数，通过<strong>索引类型查询</strong>和<strong>索引访问</strong>操作符：</p>
<pre><code class="language-typescript">function pluck&lt;T, K extends keyof T&gt;(o: T, propertyNames: K[]): T[K][] {
  return propertyNames.map(n =&gt; o[n]);
}

interface Car {
    manufacturer: string;
    model: string;
    year: number;
}
let taxi: Car = {
    manufacturer: 'Toyota',
    model: 'Camry',
    year: 2014
};

// Manufacturer and model are both of type string,
// so we can pluck them both into a typed string array
let makeAndModel: string[] = pluck(taxi, ['manufacturer', 'model']);

// If we try to pluck model and year, we get an
// array of a union type: (string | number)[]
let modelYear = pluck(taxi, ['model', 'year'])
</code></pre>
<p>编译器会检查<code>manufacturer</code>和<code>model</code>是否真的是<code>Car</code>上的一个属性。 本例还引入了几个新的类型操作符。 首先是<code>keyof T</code>，<strong>索引类型查询操作符</strong>。 对于任何类型<code>T</code>，<code>keyof T</code>的结果为<code>T</code>上已知的公共属性名的联合。 例如：</p>
<pre><code class="language-typescript">let carProps: keyof Car; // the union of ('manufacturer' | 'model' | 'year')
</code></pre>
<p><code>keyof Car</code>是完全可以与<code>'manufacturer' | 'model' | 'year'</code>互相替换的。 不同的是如果你添加了其它的属性到<code>Car</code>，例如<code>ownersAddress: string</code>，那么<code>keyof Car</code>会自动变为<code>'manufacturer' | 'model' | 'year' | 'ownersAddress'</code>。 你可以在像<code>pluck</code>函数这类上下文里使用<code>keyof</code>，因为在使用之前你并不清楚可能出现的属性名。 但编译器会检查你是否传入了正确的属性名给<code>pluck</code>：</p>
<pre><code class="language-typescript">// error, 'unknown' is not in 'manufacturer' | 'model' | 'year'
pluck(taxi, ['year', 'unknown']);
</code></pre>
<p>第二个操作符是<code>T[K]</code>，<strong>索引访问操作符</strong>。 在这里，类型语法反映了表达式语法。 这意味着<code>person['name']</code>具有类型<code>Person['name']</code> — 在我们的例子里则为<code>string</code>类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用<code>T[K]</code>，这正是它的强大所在。 你只要确保类型变量<code>K extends keyof T</code>就可以了。 例如下面<code>getProperty</code>函数的例子：</p>
<pre><code class="language-typescript">function getProperty&lt;T, K extends keyof T&gt;(o: T, propertyName: K): T[K] {
    return o[propertyName]; // o[propertyName] is of type T[K]
}
</code></pre>
<p><code>getProperty</code>里的<code>o: T</code>和<code>propertyName: K</code>，意味着<code>o[propertyName]: T[K]</code>。 当你返回<code>T[K]</code>的结果，编译器会实例化键的真实类型，因此<code>getProperty</code>的返回值类型会随着你需要的属性改变。</p>
<pre><code class="language-typescript">let name: string = getProperty(taxi, 'manufacturer');
let year: number = getProperty(taxi, 'year');

// error, 'unknown' is not in 'manufacturer' | 'model' | 'year'
let unknown = getProperty(taxi, 'unknown');
</code></pre>
<h3 id="索引类型和字符串索引签名"><a class="header" href="#索引类型和字符串索引签名">索引类型和字符串索引签名</a></h3>
<p><code>keyof</code>和<code>T[K]</code>与字符串索引签名进行交互。索引签名的参数类型必须为<code>number</code>或<code>string</code>。 如果你有一个带有字符串索引签名的类型，那么<code>keyof T</code>会是<code>string | number</code>。 (并非只有<code>string</code>，因为在JavaScript里，你可以使用字符串<code>object['42']</code>或 数字<code>object[42]</code>索引来访问对象属性)。 并且<code>T[string]</code>为索引签名的类型：</p>
<pre><code class="language-typescript">interface Dictionary&lt;T&gt; {
    [key: string]: T;
}
let keys: keyof Dictionary&lt;number&gt;; // string | number
let value: Dictionary&lt;number&gt;['foo']; // number
</code></pre>
<p>如果一个类型带有数字索引签名，那么<code>keyof T</code>为<code>number</code>。</p>
<pre><code class="language-typescript">interface Dictionary&lt;T&gt; {
    [key: number]: T;
}
let keys: keyof Dictionary&lt;number&gt;; // number
let value: Dictionary&lt;number&gt;['foo']; // Error, Property 'foo' does not exist on type 'Dictionary&lt;number&gt;'.
let value: Dictionary&lt;number&gt;[42]; // number
</code></pre>
<h2 id="映射类型"><a class="header" href="#映射类型">映射类型</a></h2>
<p>一个常见的任务是将一个已知的类型每个属性都变为可选的：</p>
<pre><code class="language-typescript">interface PersonPartial {
    name?: string;
    age?: number;
}
</code></pre>
<p>或者我们想要一个只读版本：</p>
<pre><code class="language-typescript">interface PersonReadonly {
    readonly name: string;
    readonly age: number;
}
</code></pre>
<p>这在JavaScript里经常出现，TypeScript提供了从旧类型中创建新类型的一种方式 — <strong>映射类型</strong>。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。 例如，你可以令每个属性成为<code>readonly</code>类型或可选的。 下面是一些例子：</p>
<pre><code class="language-typescript">type Readonly&lt;T&gt; = {
    readonly [P in keyof T]: T[P];
}
type Partial&lt;T&gt; = {
    [P in keyof T]?: T[P];
}
</code></pre>
<p>像下面这样使用：</p>
<pre><code class="language-typescript">type PersonPartial = Partial&lt;Person&gt;;
type ReadonlyPerson = Readonly&lt;Person&gt;;
</code></pre>
<p>需要注意的是这个语法描述的是类型而非成员。 若想添加成员，则可以使用交叉类型：</p>
<pre><code class="language-typescript">// 这样使用
type PartialWithNewMember&lt;T&gt; = {
  [P in keyof T]?: T[P];
} &amp; { newMember: boolean }
// 不要这样使用
// 这会报错！
type PartialWithNewMember&lt;T&gt; = {
  [P in keyof T]?: T[P];
  newMember: boolean;
}
</code></pre>
<p>下面来看看最简单的映射类型和它的组成部分：</p>
<pre><code class="language-typescript">type Keys = 'option1' | 'option2';
type Flags = { [K in Keys]: boolean };
</code></pre>
<p>它的语法与索引签名的语法类型，内部使用了<code>for .. in</code>。 具有三个部分：</p>
<ol>
<li>类型变量<code>K</code>，它会依次绑定到每个属性。</li>
<li>字符串字面量联合的<code>Keys</code>，它包含了要迭代的属性名的集合。</li>
<li>属性的结果类型。</li>
</ol>
<p>在个简单的例子里，<code>Keys</code>是硬编码的属性名列表并且属性类型永远是<code>boolean</code>，因此这个映射类型等同于：</p>
<pre><code class="language-typescript">type Flags = {
    option1: boolean;
    option2: boolean;
}
</code></pre>
<p>在真正的应用里，可能不同于上面的<code>Readonly</code>或<code>Partial</code>。 它们会基于一些已存在的类型，且按照一定的方式转换字段。 这就是<code>keyof</code>和索引访问类型要做的事情：</p>
<pre><code class="language-typescript">type NullablePerson = { [P in keyof Person]: Person[P] | null }
type PartialPerson = { [P in keyof Person]?: Person[P] }
</code></pre>
<p>但它更有用的地方是可以有一些通用版本。</p>
<pre><code class="language-typescript">type Nullable&lt;T&gt; = { [P in keyof T]: T[P] | null }
type Partial&lt;T&gt; = { [P in keyof T]?: T[P] }
</code></pre>
<p>在这些例子里，属性列表是<code>keyof T</code>且结果类型是<code>T[P]</code>的变体。 这是使用通用映射类型的一个好模版。 因为这类转换是<a href="https://en.wikipedia.org/wiki/Homomorphism">同态</a>的，映射只作用于<code>T</code>的属性而没有其它的。 编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。 例如，假设<code>Person.name</code>是只读的，那么<code>Partial&lt;Person&gt;.name</code>也将是只读的且为可选的。</p>
<p>下面是另一个例子，<code>T[P]</code>被包装在<code>Proxy&lt;T&gt;</code>类里：</p>
<pre><code class="language-typescript">type Proxy&lt;T&gt; = {
    get(): T;
    set(value: T): void;
}
type Proxify&lt;T&gt; = {
    [P in keyof T]: Proxy&lt;T[P]&gt;;
}
function proxify&lt;T&gt;(o: T): Proxify&lt;T&gt; {
   // ... wrap proxies ...
}
let proxyProps = proxify(props);
</code></pre>
<p>注意<code>Readonly&lt;T&gt;</code>和<code>Partial&lt;T&gt;</code>用处不小，因此它们与<code>Pick</code>和<code>Record</code>一同被包含进了TypeScript的标准库里：</p>
<pre><code class="language-typescript">type Pick&lt;T, K extends keyof T&gt; = {
    [P in K]: T[P];
}
type Record&lt;K extends keyof any, T&gt; = {
    [P in K]: T;
}
</code></pre>
<p><code>Readonly</code>，<code>Partial</code>和<code>Pick</code>是同态的，但<code>Record</code>不是。 因为<code>Record</code>并不需要输入类型来拷贝属性，所以它不属于同态：</p>
<pre><code class="language-typescript">type ThreeStringProps = Record&lt;'prop1' | 'prop2' | 'prop3', string&gt;
</code></pre>
<p>非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。</p>
<h3 id="由映射类型进行推断"><a class="header" href="#由映射类型进行推断">由映射类型进行推断</a></h3>
<p>现在你了解了如何包装一个类型的属性，那么接下来就是如何拆包。 其实这也非常容易：</p>
<pre><code class="language-typescript">function unproxify&lt;T&gt;(t: Proxify&lt;T&gt;): T {
    let result = {} as T;
    for (const k in t) {
        result[k] = t[k].get();
    }
    return result;
}

let originalProps = unproxify(proxyProps);
</code></pre>
<p>注意这个拆包推断只适用于同态的映射类型。 如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数。</p>
<h3 id="有条件类型"><a class="header" href="#有条件类型">有条件类型</a></h3>
<p>TypeScript 2.8引入了_有条件类型_，它能够表示非统一的类型。 有条件的类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：</p>
<pre><code class="language-typescript">T extends U ? X : Y
</code></pre>
<p>上面的类型意思是，若<code>T</code>能够赋值给<code>U</code>，那么类型是<code>X</code>，否则为<code>Y</code>。</p>
<p>有条件的类型<code>T extends U ? X : Y</code>或者_解析_为<code>X</code>，或者_解析_为<code>Y</code>，再或者_延迟_解析，因为它可能依赖一个或多个类型变量。 若<code>T</code>或<code>U</code>包含类型参数，那么是否解析为<code>X</code>或<code>Y</code>或推迟，取决于类型系统是否有足够的信息来确定<code>T</code>总是可以赋值给<code>U</code>。</p>
<p>下面是一些类型可以被立即解析的例子：</p>
<pre><code class="language-typescript">declare function f&lt;T extends boolean&gt;(x: T): T extends true ? string : number;

// Type is 'string | number
let x = f(Math.random() &lt; 0.5)
</code></pre>
<p>另外一个例子涉及<code>TypeName</code>类型别名，它使用了嵌套了有条件类型：</p>
<pre><code class="language-typescript">type TypeName&lt;T&gt; =
    T extends string ? "string" :
    T extends number ? "number" :
    T extends boolean ? "boolean" :
    T extends undefined ? "undefined" :
    T extends Function ? "function" :
    "object";

type T0 = TypeName&lt;string&gt;;  // "string"
type T1 = TypeName&lt;"a"&gt;;  // "string"
type T2 = TypeName&lt;true&gt;;  // "boolean"
type T3 = TypeName&lt;() =&gt; void&gt;;  // "function"
type T4 = TypeName&lt;string[]&gt;;  // "object"
</code></pre>
<p>下面是一个有条件类型被推迟解析的例子:</p>
<pre><code class="language-typescript">interface Foo {
    propA: boolean;
    propB: boolean;
}

declare function f&lt;T&gt;(x: T): T extends Foo ? string : number;

function foo&lt;U&gt;(x: U) {
    // Has type 'U extends Foo ? string : number'
    let a = f(x);

    // This assignment is allowed though!
    let b: string | number = a;
}
</code></pre>
<p>这里，<code>a</code>变量含有未确定的有条件类型。 当有另一段代码调用<code>foo</code>，它会用其它类型替换<code>U</code>，TypeScript将重新计算有条件类型，决定它是否可以选择一个分支。</p>
<p>与此同时，我们可以将有条件类型赋值给其它类型，只要有条件类型的每个分支都可以赋值给目标类型。 因此在我们的例子里，我们可以将<code>U extends Foo ? string : number</code>赋值给<code>string | number</code>，因为不管这个有条件类型最终结果是什么，它只能是<code>string</code>或<code>number</code>。</p>
<h4 id="分布式有条件类型"><a class="header" href="#分布式有条件类型">分布式有条件类型</a></h4>
<p>如果有条件类型里待检查的类型是<code>naked type parameter</code>，那么它也被称为“分布式有条件类型”。 分布式有条件类型在实例化时会自动分发成联合类型。 例如，实例化<code>T extends U ? X : Y</code>，<code>T</code>的类型为<code>A | B | C</code>，会被解析为<code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>。</p>
<p><strong>例子</strong></p>
<pre><code class="language-typescript">type T10 = TypeName&lt;string | (() =&gt; void)&gt;;  // "string" | "function"
type T12 = TypeName&lt;string | string[] | undefined&gt;;  // "string" | "object" | "undefined"
type T11 = TypeName&lt;string[] | number[]&gt;;  // "object"
</code></pre>
<p>在<code>T extends U ? X : Y</code>的实例化里，对<code>T</code>的引用被解析为联合类型的一部分（比如，<code>T</code>指向某一单个部分，在有条件类型分布到联合类型之后）。 此外，在<code>X</code>内对<code>T</code>的引用有一个附加的类型参数约束<code>U</code>（例如，<code>T</code>被当成在<code>X</code>内可赋值给<code>U</code>）。</p>
<p><strong>例子</strong></p>
<pre><code class="language-typescript">type BoxedValue&lt;T&gt; = { value: T };
type BoxedArray&lt;T&gt; = { array: T[] };
type Boxed&lt;T&gt; = T extends any[] ? BoxedArray&lt;T[number]&gt; : BoxedValue&lt;T&gt;;

type T20 = Boxed&lt;string&gt;;  // BoxedValue&lt;string&gt;;
type T21 = Boxed&lt;number[]&gt;;  // BoxedArray&lt;number&gt;;
type T22 = Boxed&lt;string | number[]&gt;;  // BoxedValue&lt;string&gt; | BoxedArray&lt;number&gt;;
</code></pre>
<p>注意在<code>Boxed&lt;T&gt;</code>的<code>true</code>分支里，<code>T</code>有个额外的约束<code>any[]</code>，因此它适用于<code>T[number]</code>数组元素类型。同时也注意一下有条件类型是如何分布成联合类型的。</p>
<p>有条件类型的分布式的属性可以方便地用来_过滤_联合类型：</p>
<pre><code class="language-typescript">type Diff&lt;T, U&gt; = T extends U ? never : T;  // Remove types from T that are assignable to U
type Filter&lt;T, U&gt; = T extends U ? T : never;  // Remove types from T that are not assignable to U

type T30 = Diff&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "b" | "d"
type T31 = Filter&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "a" | "c"
type T32 = Diff&lt;string | number | (() =&gt; void), Function&gt;;  // string | number
type T33 = Filter&lt;string | number | (() =&gt; void), Function&gt;;  // () =&gt; void

type NonNullable&lt;T&gt; = Diff&lt;T, null | undefined&gt;;  // Remove null and undefined from T

type T34 = NonNullable&lt;string | number | undefined&gt;;  // string | number
type T35 = NonNullable&lt;string | string[] | null | undefined&gt;;  // string | string[]

function f1&lt;T&gt;(x: T, y: NonNullable&lt;T&gt;) {
    x = y;  // Ok
    y = x;  // Error
}

function f2&lt;T extends string | undefined&gt;(x: T, y: NonNullable&lt;T&gt;) {
    x = y;  // Ok
    y = x;  // Error
    let s1: string = x;  // Error
    let s2: string = y;  // Ok
}
</code></pre>
<p>有条件类型与映射类型结合时特别有用：</p>
<pre><code class="language-typescript">type FunctionPropertyNames&lt;T&gt; = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];
type FunctionProperties&lt;T&gt; = Pick&lt;T, FunctionPropertyNames&lt;T&gt;&gt;;

type NonFunctionPropertyNames&lt;T&gt; = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];
type NonFunctionProperties&lt;T&gt; = Pick&lt;T, NonFunctionPropertyNames&lt;T&gt;&gt;;

interface Part {
    id: number;
    name: string;
    subparts: Part[];
    updatePart(newName: string): void;
}

type T40 = FunctionPropertyNames&lt;Part&gt;;  // "updatePart"
type T41 = NonFunctionPropertyNames&lt;Part&gt;;  // "id" | "name" | "subparts"
type T42 = FunctionProperties&lt;Part&gt;;  // { updatePart(newName: string): void }
type T43 = NonFunctionProperties&lt;Part&gt;;  // { id: number, name: string, subparts: Part[] }
</code></pre>
<p>与联合类型和交叉类型相似，有条件类型不允许递归地引用自己。比如下面的错误。</p>
<p><strong>例子</strong></p>
<pre><code class="language-typescript">// 在 TypeScript 4.1 之前的版本会报错。
// TypeScript 4.1 改进了对递归的有条件类型的支持，详情参考 4.1 版本发布说明
type ElementType&lt;T&gt; = T extends any[] ? ElementType&lt;T[number]&gt; : T;
</code></pre>
<h4 id="有条件类型中的类型推断"><a class="header" href="#有条件类型中的类型推断">有条件类型中的类型推断</a></h4>
<p>现在在有条件类型的<code>extends</code>子语句中，允许出现<code>infer</code>声明，它会引入一个待推断的类型变量。 这个推断的类型变量可以在有条件类型的true分支中被引用。 允许出现多个同类型变量的<code>infer</code>。</p>
<p>例如，下面代码会提取函数类型的返回值类型：</p>
<pre><code class="language-typescript">type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;
</code></pre>
<p>有条件类型可以嵌套来构成一系列的匹配模式，按顺序进行求值：</p>
<pre><code class="language-typescript">type Unpacked&lt;T&gt; =
    T extends (infer U)[] ? U :
    T extends (...args: any[]) =&gt; infer U ? U :
    T extends Promise&lt;infer U&gt; ? U :
    T;

type T0 = Unpacked&lt;string&gt;;  // string
type T1 = Unpacked&lt;string[]&gt;;  // string
type T2 = Unpacked&lt;() =&gt; string&gt;;  // string
type T3 = Unpacked&lt;Promise&lt;string&gt;&gt;;  // string
type T4 = Unpacked&lt;Promise&lt;string&gt;[]&gt;;  // Promise&lt;string&gt;
type T5 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;;  // string
</code></pre>
<p>下面的例子解释了在协变位置上，同一个类型变量的多个候选类型会被推断为联合类型：</p>
<pre><code class="language-typescript">type Foo&lt;T&gt; = T extends { a: infer U, b: infer U } ? U : never;
type T10 = Foo&lt;{ a: string, b: string }&gt;;  // string
type T11 = Foo&lt;{ a: string, b: number }&gt;;  // string | number
</code></pre>
<p>相似地，在抗变位置上，同一个类型变量的多个候选类型会被推断为交叉类型：</p>
<pre><code class="language-typescript">type Bar&lt;T&gt; = T extends { a: (x: infer U) =&gt; void, b: (x: infer U) =&gt; void } ? U : never;
type T20 = Bar&lt;{ a: (x: string) =&gt; void, b: (x: string) =&gt; void }&gt;;  // string
type T21 = Bar&lt;{ a: (x: string) =&gt; void, b: (x: number) =&gt; void }&gt;;  // string &amp; number
</code></pre>
<p>当推断具有多个调用签名（例如函数重载类型）的类型时，用_最后_的签名（大概是最自由的包含所有情况的签名）进行推断。 无法根据参数类型列表来解析重载。</p>
<pre><code class="language-typescript">declare function foo(x: string): number;
declare function foo(x: number): string;
declare function foo(x: string | number): string | number;
type T30 = ReturnType&lt;typeof foo&gt;;  // string | number
</code></pre>
<p>无法在正常类型参数的约束子语句中使用<code>infer</code>声明：</p>
<pre><code class="language-typescript">type ReturnType&lt;T extends (...args: any[]) =&gt; infer R&gt; = R;  // 错误，不支持
</code></pre>
<p>但是，可以这样达到同样的效果，在约束里删掉类型变量，用有条件类型替换：</p>
<pre><code class="language-typescript">type AnyFunction = (...args: any[]) =&gt; any;
type ReturnType&lt;T extends AnyFunction&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;
</code></pre>
<h4 id="预定义的有条件类型"><a class="header" href="#预定义的有条件类型">预定义的有条件类型</a></h4>
<p>TypeScript 2.8在<code>lib.d.ts</code>里增加了一些预定义的有条件类型：</p>
<ul>
<li><code>Exclude&lt;T, U&gt;</code> -- 从<code>T</code>中剔除可以赋值给<code>U</code>的类型。</li>
<li><code>Extract&lt;T, U&gt;</code> -- 提取<code>T</code>中可以赋值给<code>U</code>的类型。</li>
<li><code>NonNullable&lt;T&gt;</code> -- 从<code>T</code>中剔除<code>null</code>和<code>undefined</code>。</li>
<li><code>ReturnType&lt;T&gt;</code> -- 获取函数返回值类型。</li>
<li><code>InstanceType&lt;T&gt;</code> -- 获取构造函数类型的实例类型。</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="language-typescript">type T00 = Exclude&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "b" | "d"
type T01 = Extract&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "a" | "c"

type T02 = Exclude&lt;string | number | (() =&gt; void), Function&gt;;  // string | number
type T03 = Extract&lt;string | number | (() =&gt; void), Function&gt;;  // () =&gt; void

type T04 = NonNullable&lt;string | number | undefined&gt;;  // string | number
type T05 = NonNullable&lt;(() =&gt; string) | string[] | null | undefined&gt;;  // (() =&gt; string) | string[]

function f1(s: string) {
    return { a: 1, b: s };
}

class C {
    x = 0;
    y = 0;
}

type T10 = ReturnType&lt;() =&gt; string&gt;;  // string
type T11 = ReturnType&lt;(s: string) =&gt; void&gt;;  // void
type T12 = ReturnType&lt;(&lt;T&gt;() =&gt; T)&gt;;  // {}
type T13 = ReturnType&lt;(&lt;T extends U, U extends number[]&gt;() =&gt; T)&gt;;  // number[]
type T14 = ReturnType&lt;typeof f1&gt;;  // { a: number, b: string }
type T15 = ReturnType&lt;any&gt;;  // any
type T16 = ReturnType&lt;never&gt;;  // never
type T17 = ReturnType&lt;string&gt;;  // Error
type T18 = ReturnType&lt;Function&gt;;  // Error

type T20 = InstanceType&lt;typeof C&gt;;  // C
type T21 = InstanceType&lt;any&gt;;  // any
type T22 = InstanceType&lt;never&gt;;  // never
type T23 = InstanceType&lt;string&gt;;  // Error
type T24 = InstanceType&lt;Function&gt;;  // Error
</code></pre>
<blockquote>
<p>注意：<code>Exclude</code>类型是<a href="https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458">建议的</a><code>Diff</code>类型的一种实现。我们使用<code>Exclude</code>这个名字是为了避免破坏已经定义了<code>Diff</code>的代码，并且我们感觉这个名字能更好地表达类型的语义。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实用工具类型"><a class="header" href="#实用工具类型">实用工具类型</a></h1>
<p>TypeScript 提供一些工具类型来帮助常见的类型转换。这些类型是全局可见的。</p>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="zh/reference/utility-types.html#partialtype"><code>Partial&lt;T&gt;</code>，TypeScript 2.1</a></li>
<li><a href="zh/reference/utility-types.html#readonlytype"><code>Readonly&lt;Type&gt;</code>，TypeScript 2.1</a></li>
<li><a href="zh/reference/utility-types.html#recordkeys-type"><code>Record&lt;Keys, Type&gt;</code>，TypeScript 2.1</a></li>
<li><a href="zh/reference/utility-types.html#picktype-keys"><code>Pick&lt;Type, Keys&gt;</code>，TypeScript 2.1</a></li>
<li><a href="zh/reference/utility-types.html#omittype-keys"><code>Omit&lt;Type, Keys&gt;</code>，TypeScript 3.5</a></li>
<li><a href="zh/reference/utility-types.html#excludetype-excludedunion"><code>Exclude&lt;Type, ExcludedUnion&gt;</code>，TypeScript 2.8</a></li>
<li><a href="zh/reference/utility-types.html#extracttype-union"><code>Extract&lt;Type, Union&gt;</code>，TypeScript 2.8</a></li>
<li><a href="zh/reference/utility-types.html#nonnullabletype"><code>NonNullable&lt;Type&gt;</code>，TypeScript 2.8</a></li>
<li><a href="zh/reference/utility-types.html#parameterstype"><code>Parameters&lt;Type&gt;</code></a></li>
<li><a href="zh/reference/utility-types.html#constructorparameterstype"><code>ConstructorParameters&lt;Type&gt;</code></a></li>
<li><a href="zh/reference/utility-types.html#returntypetype"><code>ReturnType&lt;Type&gt;</code>，TypeScript 2.8</a></li>
<li><a href="zh/reference/utility-types.html#instancetypetype"><code>InstanceType&lt;Type&gt;</code>，TypeScript 2.8</a></li>
<li><a href="zh/reference/utility-types.html#requiredtype"><code>Required&lt;Type&gt;</code>，TypeScript 2.8</a></li>
<li><a href="zh/reference/utility-types.html#thisparametertypetype"><code>ThisParameterType&lt;Type&gt;</code></a></li>
<li><a href="zh/reference/utility-types.html#omitthisparametertype"><code>OmitThisParameter&lt;Type&gt;</code></a></li>
<li><a href="zh/reference/utility-types.html#thistypetype"><code>ThisType&lt;Type&gt;</code>，TypeScript 2.8</a></li>
<li><a href="zh/reference/utility-types.html#%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%B1%BB%E5%9E%8B">操作字符串的类型</a></li>
</ul>
<h2 id="partialtype"><a class="header" href="#partialtype"><code>Partial&lt;Type&gt;</code></a></h2>
<p>构造类型<code>Type</code>，并将它所有的属性设置为可选的。它的返回类型表示输入类型的所有子类型。</p>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<pre><code class="language-typescript">interface Todo {
    title: string;
    description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) {
    return { ...todo, ...fieldsToUpdate };
}

const todo1 = {
    title: 'organize desk',
    description: 'clear clutter',
};

const todo2 = updateTodo(todo1, {
    description: 'throw out trash',
});
</code></pre>
<h2 id="readonlytype"><a class="header" href="#readonlytype"><code>Readonly&lt;Type&gt;</code></a></h2>
<p>构造类型<code>Type</code>，并将它所有的属性设置为<code>readonly</code>，也就是说构造出的类型的属性不能被再次赋值。</p>
<h3 id="例子-1"><a class="header" href="#例子-1">例子</a></h3>
<pre><code class="language-typescript">interface Todo {
    title: string;
}

const todo: Readonly&lt;Todo&gt; = {
    title: 'Delete inactive users',
};

todo.title = 'Hello'; // Error: cannot reassign a readonly property
</code></pre>
<p>这个工具可用来表示在运行时会失败的赋值表达式（比如，当尝试给<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">冻结对象</a>的属性再次赋值时）。</p>
<h3 id="objectfreeze"><a class="header" href="#objectfreeze"><code>Object.freeze</code></a></h3>
<pre><code class="language-typescript">function freeze&lt;T&gt;(obj: T): Readonly&lt;T&gt;;
</code></pre>
<h2 id="recordkeys-type"><a class="header" href="#recordkeys-type"><code>Record&lt;Keys, Type&gt;</code></a></h2>
<p>构造一个类型，其属性名的类型为<code>K</code>，属性值的类型为<code>T</code>。这个工具可用来将某个类型的属性映射到另一个类型上。</p>
<h3 id="例子-2"><a class="header" href="#例子-2">例子</a></h3>
<pre><code class="language-typescript">interface PageInfo {
    title: string;
}

type Page = 'home' | 'about' | 'contact';

const x: Record&lt;Page, PageInfo&gt; = {
    about: { title: 'about' },
    contact: { title: 'contact' },
    home: { title: 'home' },
};
</code></pre>
<h2 id="picktype-keys"><a class="header" href="#picktype-keys"><code>Pick&lt;Type, Keys&gt;</code></a></h2>
<p>从类型<code>Type</code>中挑选部分属性<code>Keys</code>来构造类型。</p>
<h3 id="例子-3"><a class="header" href="#例子-3">例子</a></h3>
<pre><code class="language-typescript">interface Todo {
    title: string;
    description: string;
    completed: boolean;
}

type TodoPreview = Pick&lt;Todo, 'title' | 'completed'&gt;;

const todo: TodoPreview = {
    title: 'Clean room',
    completed: false,
};
</code></pre>
<h2 id="omittype-keys"><a class="header" href="#omittype-keys"><code>Omit&lt;Type, Keys&gt;</code></a></h2>
<p>从类型<code>Type</code>中获取所有属性，然后从中剔除<code>Keys</code>属性后构造一个类型。</p>
<h3 id="例子-4"><a class="header" href="#例子-4">例子</a></h3>
<pre><code class="language-typescript">interface Todo {
    title: string;
    description: string;
    completed: boolean;
}

type TodoPreview = Omit&lt;Todo, 'description'&gt;;

const todo: TodoPreview = {
    title: 'Clean room',
    completed: false,
};
</code></pre>
<h2 id="excludetype-excludedunion"><a class="header" href="#excludetype-excludedunion"><code>Exclude&lt;Type, ExcludedUnion&gt;</code></a></h2>
<p>从类型<code>Type</code>中剔除所有可以赋值给<code>ExcludedUnion</code>的属性，然后构造一个类型。</p>
<h3 id="例子-5"><a class="header" href="#例子-5">例子</a></h3>
<pre><code class="language-typescript">type T0 = Exclude&lt;'a' | 'b' | 'c', 'a'&gt;; // "b" | "c"
type T1 = Exclude&lt;'a' | 'b' | 'c', 'a' | 'b'&gt;; // "c"
type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;; // string | number
</code></pre>
<h2 id="extracttype-union"><a class="header" href="#extracttype-union"><code>Extract&lt;Type, Union&gt;</code></a></h2>
<p>从类型<code>Type</code>中提取所有可以赋值给<code>Union</code>的类型，然后构造一个类型。</p>
<h3 id="例子-6"><a class="header" href="#例子-6">例子</a></h3>
<pre><code class="language-typescript">type T0 = Extract&lt;'a' | 'b' | 'c', 'a' | 'f'&gt;; // "a"
type T1 = Extract&lt;string | number | (() =&gt; void), Function&gt;; // () =&gt; void
</code></pre>
<h2 id="nonnullabletype"><a class="header" href="#nonnullabletype"><code>NonNullable&lt;Type&gt;</code></a></h2>
<p>从类型<code>Type</code>中剔除<code>null</code>和<code>undefined</code>，然后构造一个类型。</p>
<h3 id="例子-7"><a class="header" href="#例子-7">例子</a></h3>
<pre><code class="language-typescript">type T0 = NonNullable&lt;string | number | undefined&gt;; // string | number
type T1 = NonNullable&lt;string[] | null | undefined&gt;; // string[]
</code></pre>
<h2 id="parameterstype"><a class="header" href="#parameterstype"><code>Parameters&lt;Type&gt;</code></a></h2>
<p>由函数类型<code>Type</code>的参数类型来构建出一个元组类型。</p>
<h3 id="例子-8"><a class="header" href="#例子-8">例子</a></h3>
<pre><code class="language-ts">declare function f1(arg: { a: number; b: string }): void;

type T0 = Parameters&lt;() =&gt; string&gt;;
//    []
type T1 = Parameters&lt;(s: string) =&gt; void&gt;;
//    [s: string]
type T2 = Parameters&lt;&lt;T&gt;(arg: T) =&gt; T&gt;;
//    [arg: unknown]
type T3 = Parameters&lt;typeof f1&gt;;
//    [arg: { a: number; b: string; }]
type T4 = Parameters&lt;any&gt;;
//    unknown[]
type T5 = Parameters&lt;never&gt;;
//    never
type T6 = Parameters&lt;string&gt;;
//   never
//   Type 'string' does not satisfy the constraint '(...args: any) =&gt; any'.
type T7 = Parameters&lt;Function&gt;;
//   never
//   Type 'Function' does not satisfy the constraint '(...args: any) =&gt; any'.
</code></pre>
<h2 id="constructorparameterstype"><a class="header" href="#constructorparameterstype"><code>ConstructorParameters&lt;Type&gt;</code></a></h2>
<p>由构造函数类型来构建出一个元组类型或数组类型。
由构造函数类型<code>Type</code>的参数类型来构建出一个元组类型。（若<code>Type</code>不是构造函数类型，则返回<code>never</code>）。</p>
<h3 id="例子-9"><a class="header" href="#例子-9">例子</a></h3>
<pre><code class="language-ts">type T0 = ConstructorParameters&lt;ErrorConstructor&gt;;
//    [message?: string | undefined]
type T1 = ConstructorParameters&lt;FunctionConstructor&gt;;
//    string[]
type T2 = ConstructorParameters&lt;RegExpConstructor&gt;;
//    [pattern: string | RegExp, flags?: string | undefined]
type T3 = ConstructorParameters&lt;any&gt;;
//   unknown[]

type T4 = ConstructorParameters&lt;Function&gt;;
//    never
// Type 'Function' does not satisfy the constraint 'new (...args: any) =&gt; any'.
</code></pre>
<h2 id="returntypetype"><a class="header" href="#returntypetype"><code>ReturnType&lt;Type&gt;</code></a></h2>
<p>由函数类型<code>Type</code>的返回值类型构建一个新类型。</p>
<h3 id="例子-10"><a class="header" href="#例子-10">例子</a></h3>
<pre><code>type T0 = ReturnType&lt;() =&gt; string&gt;;  // string
type T1 = ReturnType&lt;(s: string) =&gt; void&gt;;  // void
type T2 = ReturnType&lt;(&lt;T&gt;() =&gt; T)&gt;;  // {}
type T3 = ReturnType&lt;(&lt;T extends U, U extends number[]&gt;() =&gt; T)&gt;;  // number[]
type T4 = ReturnType&lt;typeof f1&gt;;  // { a: number, b: string }
type T5 = ReturnType&lt;any&gt;;  // any
type T6 = ReturnType&lt;never&gt;;  // any
type T7 = ReturnType&lt;string&gt;;  // Error
type T8 = ReturnType&lt;Function&gt;;  // Error
</code></pre>
<h2 id="instancetypetype"><a class="header" href="#instancetypetype"><code>InstanceType&lt;Type&gt;</code></a></h2>
<p>由构造函数类型<code>Type</code>的实例类型来构建一个新类型。</p>
<h3 id="例子-11"><a class="header" href="#例子-11">例子</a></h3>
<pre><code class="language-typescript">class C {
    x = 0;
    y = 0;
}

type T0 = InstanceType&lt;typeof C&gt;; // C
type T1 = InstanceType&lt;any&gt;; // any
type T2 = InstanceType&lt;never&gt;; // any
type T3 = InstanceType&lt;string&gt;; // Error
type T4 = InstanceType&lt;Function&gt;; // Error
</code></pre>
<h2 id="requiredtype"><a class="header" href="#requiredtype"><code>Required&lt;Type&gt;</code></a></h2>
<p>构建一个类型，使类型<code>Type</code>的所有属性为<code>required</code>。
与此相反的是<a href="zh/reference/utility-types.html#partialtype"><code>Partial</code></a>。</p>
<h3 id="例子-12"><a class="header" href="#例子-12">例子</a></h3>
<pre><code class="language-typescript">interface Props {
    a?: number;
    b?: string;
}

const obj: Props = { a: 5 }; // OK

const obj2: Required&lt;Props&gt; = { a: 5 }; // Error: property 'b' missing
</code></pre>
<h2 id="thisparametertypetype"><a class="header" href="#thisparametertypetype"><code>ThisParameterType&lt;Type&gt;</code></a></h2>
<p>从函数类型中提取 <a href="zh/reference/../handbook/functions.html#this%E5%8F%82%E6%95%B0">this</a> 参数的类型。
若函数类型不包含 <code>this</code> 参数，则返回 <a href="zh/reference/../handbook/basic-types.html#unknown">unknown</a> 类型。</p>
<h3 id="例子-13"><a class="header" href="#例子-13">例子</a></h3>
<pre><code class="language-ts">function toHex(this: Number) {
    return this.toString(16);
}

function numberToString(n: ThisParameterType&lt;typeof toHex&gt;) {
    return toHex.apply(n);
}
</code></pre>
<h2 id="omitthisparametertype"><a class="header" href="#omitthisparametertype"><code>OmitThisParameter&lt;Type&gt;</code></a></h2>
<p>从<code>Type</code>类型中剔除 <a href="zh/reference/../handbook/functions.html#this%E5%8F%82%E6%95%B0"><code>this</code></a> 参数。
若未声明 <code>this</code> 参数，则结果类型为 <code>Type</code> 。
否则，由<code>Type</code>类型来构建一个不带<code>this</code>参数的类型。
泛型会被忽略，并且只有最后的重载签名会被采用。</p>
<h3 id="例子-14"><a class="header" href="#例子-14">例子</a></h3>
<pre><code class="language-ts">function toHex(this: Number) {
    return this.toString(16);
}

const fiveToHex: OmitThisParameter&lt;typeof toHex&gt; = toHex.bind(5);

console.log(fiveToHex());
</code></pre>
<h2 id="thistypetype"><a class="header" href="#thistypetype"><code>ThisType&lt;Type&gt;</code></a></h2>
<p>这个工具不会返回一个转换后的类型。
它做为上下文的<a href="zh/reference/../handbook/functions.html#this"><code>this</code></a>类型的一个标记。
注意，若想使用此类型，必须启用<code>--noImplicitThis</code>。</p>
<h3 id="例子-15"><a class="header" href="#例子-15">例子</a></h3>
<pre><code class="language-typescript">// Compile with --noImplicitThis

type ObjectDescriptor&lt;D, M&gt; = {
    data?: D;
    methods?: M &amp; ThisType&lt;D &amp; M&gt;; // Type of 'this' in methods is D &amp; M
};

function makeObject&lt;D, M&gt;(desc: ObjectDescriptor&lt;D, M&gt;): D &amp; M {
    let data: object = desc.data || {};
    let methods: object = desc.methods || {};
    return { ...data, ...methods } as D &amp; M;
}

let obj = makeObject({
    data: { x: 0, y: 0 },
    methods: {
        moveBy(dx: number, dy: number) {
            this.x += dx; // Strongly typed this
            this.y += dy; // Strongly typed this
        },
    },
});

obj.x = 10;
obj.y = 20;
obj.moveBy(5, 5);
</code></pre>
<p>上面例子中，<code>makeObject</code>参数里的<code>methods</code>对象具有一个上下文类型<code>ThisType&lt;D &amp; M&gt;</code>，因此<code>methods</code>对象的方法里<code>this</code>的类型为<code>{ x: number, y: number } &amp; { moveBy(dx: number, dy: number): number }</code>。</p>
<p>在<code>lib.d.ts</code>里，<code>ThisType&lt;T&gt;</code>标识接口是个简单的空接口声明。除了在被识别为对象字面量的上下文类型之外，这个接口与一般的空接口没有什么不同。</p>
<h2 id="操作字符串的类型"><a class="header" href="#操作字符串的类型">操作字符串的类型</a></h2>
<p>为了便于操作模版字符串字面量，TypeScript 引入了一些能够操作字符串的类型。
更多详情，请阅读<a href="zh/reference/../handbook-v2/type-manipulation/template-literal-types.html#%E5%9B%BA%E6%9C%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B">模版字面量类型</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decorators"><a class="header" href="#decorators">Decorators</a></h1>
<h2 id="介绍-7"><a class="header" href="#介绍-7">介绍</a></h2>
<p>随着TypeScript和ES6里引入了类，在一些场景下我们需要额外的特性来支持标注或修改类及其成员。 装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。 Javascript里的装饰器目前处在<a href="https://github.com/tc39/proposal-decorators">建议征集的第二阶段</a>，但在TypeScript里已做为一项实验性特性予以支持。</p>
<blockquote>
<p>注意  装饰器是一项实验性特性，在未来的版本中可能会发生改变。</p>
</blockquote>
<p>若要启用实验性的装饰器特性，你必须在命令行或<code>tsconfig.json</code>里启用<code>experimentalDecorators</code>编译器选项：</p>
<p><strong>命令行</strong>:</p>
<pre><code class="language-text">tsc --target ES5 --experimentalDecorators
</code></pre>
<p><strong>tsconfig.json</strong>:</p>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "target": "ES5",
        "experimentalDecorators": true
    }
}
</code></pre>
<h2 id="装饰器"><a class="header" href="#装饰器">装饰器</a></h2>
<p>_装饰器_是一种特殊类型的声明，它能够被附加到<a href="zh/reference/decorators.html#class-decorators">类声明</a>，<a href="zh/reference/decorators.html#method-decorators">方法</a>，<a href="zh/reference/decorators.html#accessor-decorators">访问符</a>，<a href="zh/reference/decorators.html#property-decorators">属性</a>或<a href="zh/reference/decorators.html#parameter-decorators">参数</a>上。 装饰器使用<code>@expression</code>这种形式，<code>expression</code>求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p>
<p>例如，有一个<code>@sealed</code>装饰器，我们会这样定义<code>sealed</code>函数：</p>
<pre><code class="language-typescript">function sealed(target) {
    // do something with "target" ...
}
</code></pre>
<blockquote>
<p>注意  后面<a href="zh/reference/decorators.html#class-decorators">类装饰器</a>小节里有一个更加详细的例子。</p>
</blockquote>
<h3 id="装饰器工厂"><a class="header" href="#装饰器工厂">装饰器工厂</a></h3>
<p>如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 _装饰器工厂_就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p>
<p>我们可以通过下面的方式来写一个装饰器工厂函数：</p>
<pre><code class="language-typescript">function color(value: string) { // 这是一个装饰器工厂
    return function (target) { //  这是装饰器
        // do something with "target" and "value"...
    }
}
</code></pre>
<blockquote>
<p>注意  下面<a href="zh/reference/decorators.html#method-decorators">方法装饰器</a>小节里有一个更加详细的例子。</p>
</blockquote>
<h3 id="装饰器组合"><a class="header" href="#装饰器组合">装饰器组合</a></h3>
<p>多个装饰器可以同时应用到一个声明上，就像下面的示例：</p>
<ul>
<li>书写在同一行上：</li>
</ul>
<pre><code class="language-typescript">@f @g x
</code></pre>
<ul>
<li>书写在多行上：</li>
</ul>
<pre><code class="language-typescript">@f
@g
x
</code></pre>
<p>当多个装饰器应用于一个声明上，它们求值方式与<a href="http://en.wikipedia.org/wiki/Function_composition">复合函数</a>相似。在这个模型下，当复合_f_和_g_时，复合的结果(<em>f</em> ∘ <em>g</em>)(<em>x</em>)等同于_f_(<em>g</em>(<em>x</em>))。</p>
<p>同样的，在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p>
<ol>
<li>由上至下依次对装饰器表达式求值。</li>
<li>求值的结果会被当作函数，由下至上依次调用。</li>
</ol>
<p>如果我们使用<a href="zh/reference/decorators.html#decorator-factories">装饰器工厂</a>的话，可以通过下面的例子来观察它们求值的顺序：</p>
<pre><code class="language-typescript">function f() {
    console.log("f(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("f(): called");
    }
}

function g() {
    console.log("g(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("g(): called");
    }
}

class C {
    @f()
    @g()
    method() {}
}
</code></pre>
<p>在控制台里会打印出如下结果：</p>
<pre><code class="language-text">f(): evaluated
g(): evaluated
g(): called
f(): called
</code></pre>
<h3 id="装饰器求值"><a class="header" href="#装饰器求值">装饰器求值</a></h3>
<p>类中不同声明上的装饰器将按以下规定的顺序应用：</p>
<ol>
<li><em>参数装饰器</em>，然后依次是_方法装饰器_，<em>访问符装饰器</em>，或_属性装饰器_应用到每个实例成员。</li>
<li><em>参数装饰器</em>，然后依次是_方法装饰器_，<em>访问符装饰器</em>，或_属性装饰器_应用到每个静态成员。</li>
<li>_参数装饰器_应用到构造函数。</li>
<li>_类装饰器_应用到类。</li>
</ol>
<h3 id="类装饰器"><a class="header" href="#类装饰器">类装饰器</a></h3>
<p>_类装饰器_在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 类装饰器不能用在声明文件中(<code>.d.ts</code>)，也不能用在任何外部上下文中（比如<code>declare</code>的类）。</p>
<p>类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。</p>
<p>如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</p>
<blockquote>
<p>注意  如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。 在运行时的装饰器调用逻辑中_不会_为你做这些。</p>
</blockquote>
<p>下面是使用类装饰器(<code>@sealed</code>)的例子，应用在<code>Greeter</code>类：</p>
<pre><code class="language-typescript">@sealed
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}
</code></pre>
<p>我们可以这样定义<code>@sealed</code>装饰器：</p>
<pre><code class="language-typescript">function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}
</code></pre>
<p>当<code>@sealed</code>被执行的时候，它将密封此类的构造函数和原型。(注：参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal">Object.seal</a>)</p>
<p>下面是一个重载构造函数的例子。</p>
<pre><code class="language-typescript">function classDecorator&lt;T extends {new(...args:any[]):{}}&gt;(constructor:T) {
    return class extends constructor {
        newProperty = "new property";
        hello = "override";
    }
}

@classDecorator
class Greeter {
    property = "property";
    hello: string;
    constructor(m: string) {
        this.hello = m;
    }
}

console.log(new Greeter("world"));
</code></pre>
<h3 id="方法装饰器"><a class="header" href="#方法装饰器">方法装饰器</a></h3>
<p>_方法装饰器_声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的_属性描述符_上，可以用来监视，修改或者替换方法定义。 方法装饰器不能用在声明文件(<code>.d.ts</code>)，重载或者任何外部上下文（比如<code>declare</code>的类）中。</p>
<p>方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>成员的_属性描述符_。</li>
</ol>
<blockquote>
<p>注意  如果代码输出目标版本小于<code>ES5</code>，_属性描述符_将会是<code>undefined</code>。</p>
</blockquote>
<p>如果方法装饰器返回一个值，它会被用作方法的_属性描述符_。</p>
<blockquote>
<p>注意  如果代码输出目标版本小于<code>ES5</code>返回值会被忽略。</p>
</blockquote>
<p>下面是一个方法装饰器（<code>@enumerable</code>）的例子，应用于<code>Greeter</code>类的方法上：</p>
<pre><code class="language-typescript">class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }

    @enumerable(false)
    greet() {
        return "Hello, " + this.greeting;
    }
}
</code></pre>
<p>我们可以用下面的函数声明来定义<code>@enumerable</code>装饰器：</p>
<pre><code class="language-typescript">function enumerable(value: boolean) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.enumerable = value;
    };
}
</code></pre>
<p>这里的<code>@enumerable(false)</code>是一个<a href="zh/reference/decorators.html#decorator-factories">装饰器工厂</a>。 当装饰器<code>@enumerable(false)</code>被调用时，它会修改属性描述符的<code>enumerable</code>属性。</p>
<h3 id="访问器装饰器"><a class="header" href="#访问器装饰器">访问器装饰器</a></h3>
<p>_访问器装饰器_声明在一个访问器的声明之前（紧靠着访问器声明）。 访问器装饰器应用于访问器的_属性描述符_并且可以用来监视，修改或替换一个访问器的定义。 访问器装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如<code>declare</code>的类）里。</p>
<blockquote>
<p>注意  TypeScript不允许同时装饰一个成员的<code>get</code>和<code>set</code>访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个_属性描述符_时，它联合了<code>get</code>和<code>set</code>访问器，而不是分开声明的。</p>
</blockquote>
<p>访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>成员的_属性描述符_。</li>
</ol>
<blockquote>
<p>注意  如果代码输出目标版本小于<code>ES5</code>，_Property Descriptor_将会是<code>undefined</code>。</p>
</blockquote>
<p>如果访问器装饰器返回一个值，它会被用作方法的_属性描述符_。</p>
<blockquote>
<p>注意  如果代码输出目标版本小于<code>ES5</code>返回值会被忽略。</p>
</blockquote>
<p>下面是使用了访问器装饰器（<code>@configurable</code>）的例子，应用于<code>Point</code>类的成员上：</p>
<pre><code class="language-typescript">class Point {
    private _x: number;
    private _y: number;
    constructor(x: number, y: number) {
        this._x = x;
        this._y = y;
    }

    @configurable(false)
    get x() { return this._x; }

    @configurable(false)
    get y() { return this._y; }
}
</code></pre>
<p>我们可以通过如下函数声明来定义<code>@configurable</code>装饰器：</p>
<pre><code class="language-typescript">function configurable(value: boolean) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.configurable = value;
    };
}
</code></pre>
<h3 id="属性装饰器"><a class="header" href="#属性装饰器">属性装饰器</a></h3>
<p>_属性装饰器_声明在一个属性声明之前（紧靠着属性声明）。 属性装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如<code>declare</code>的类）里。</p>
<p>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
</ol>
<blockquote>
<p>注意  _属性描述符_不会做为参数传入属性装饰器，这与TypeScript是如何初始化属性装饰器的有关。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。 因此，属性描述符只能用来监视类中是否声明了某个名字的属性。</p>
</blockquote>
<p>如果访问符装饰器返回一个值，它会被用作方法的_属性描述符_。</p>
<p>我们可以用它来记录这个属性的元数据，如下例所示：</p>
<pre><code class="language-typescript">class Greeter {
    @format("Hello, %s")
    greeting: string;

    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        let formatString = getFormat(this, "greeting");
        return formatString.replace("%s", this.greeting);
    }
}
</code></pre>
<p>然后定义<code>@format</code>装饰器和<code>getFormat</code>函数：</p>
<pre><code class="language-typescript">import "reflect-metadata";

const formatMetadataKey = Symbol("format");

function format(formatString: string) {
    return Reflect.metadata(formatMetadataKey, formatString);
}

function getFormat(target: any, propertyKey: string) {
    return Reflect.getMetadata(formatMetadataKey, target, propertyKey);
}
</code></pre>
<p>这个<code>@format("Hello, %s")</code>装饰器是个 <a href="zh/reference/decorators.html#decorator-factories">装饰器工厂</a>。 当<code>@format("Hello, %s")</code>被调用时，它添加一条这个属性的元数据，通过<code>reflect-metadata</code>库里的<code>Reflect.metadata</code>函数。 当<code>getFormat</code>被调用时，它读取格式的元数据。</p>
<blockquote>
<p>注意  这个例子需要使用<code>reflect-metadata</code>库。 查看<a href="zh/reference/decorators.html#metadata">元数据</a>了解<code>reflect-metadata</code>库更详细的信息。</p>
</blockquote>
<h3 id="参数装饰器"><a class="header" href="#参数装饰器">参数装饰器</a></h3>
<p>_参数装饰器_声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。 参数装饰器不能用在声明文件（.d.ts），重载或其它外部上下文（比如<code>declare</code>的类）里。</p>
<p>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>参数在函数参数列表中的索引。</li>
</ol>
<blockquote>
<p>注意  参数装饰器只能用来监视一个方法的参数是否被传入。</p>
</blockquote>
<p>参数装饰器的返回值会被忽略。</p>
<p>下例定义了参数装饰器（<code>@required</code>）并应用于<code>Greeter</code>类方法的一个参数：</p>
<pre><code class="language-typescript">class Greeter {
    greeting: string;

    constructor(message: string) {
        this.greeting = message;
    }

    @validate
    greet(@required name: string) {
        return "Hello " + name + ", " + this.greeting;
    }
}
</code></pre>
<p>然后我们使用下面的函数定义 <code>@required</code> 和 <code>@validate</code> 装饰器：</p>
<pre><code class="language-typescript">import "reflect-metadata";

const requiredMetadataKey = Symbol("required");

function required(target: Object, propertyKey: string | symbol, parameterIndex: number) {
    let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];
    existingRequiredParameters.push(parameterIndex);
    Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);
}

function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor&lt;Function&gt;) {
    let method = descriptor.value;
    descriptor.value = function () {
        let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);
        if (requiredParameters) {
            for (let parameterIndex of requiredParameters) {
                if (parameterIndex &gt;= arguments.length || arguments[parameterIndex] === undefined) {
                    throw new Error("Missing required argument.");
                }
            }
        }

        return method.apply(this, arguments);
    }
}
</code></pre>
<p><code>@required</code>装饰器添加了元数据实体把参数标记为必需的。 <code>@validate</code>装饰器把<code>greet</code>方法包裹在一个函数里在调用原先的函数前验证函数参数。</p>
<blockquote>
<p>注意  这个例子使用了<code>reflect-metadata</code>库。 查看<a href="zh/reference/decorators.html#metadata">元数据</a>了解<code>reflect-metadata</code>库的更多信息。</p>
</blockquote>
<h3 id="元数据"><a class="header" href="#元数据">元数据</a></h3>
<p>一些例子使用了<code>reflect-metadata</code>库来支持<a href="https://github.com/rbuckton/ReflectDecorators">实验性的metadata API</a>。 这个库还不是ECMAScript (JavaScript)标准的一部分。 然而，当装饰器被ECMAScript官方标准采纳后，这些扩展也将被推荐给ECMAScript以采纳。</p>
<p>你可以通过npm安装这个库：</p>
<pre><code class="language-text">npm i reflect-metadata --save
</code></pre>
<p>TypeScript支持为带有装饰器的声明生成元数据。 你需要在命令行或<code>tsconfig.json</code>里启用<code>emitDecoratorMetadata</code>编译器选项。</p>
<p><strong>Command Line</strong>:</p>
<pre><code class="language-text">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata
</code></pre>
<p><strong>tsconfig.json</strong>:</p>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "target": "ES5",
        "experimentalDecorators": true,
        "emitDecoratorMetadata": true
    }
}
</code></pre>
<p>当启用后，只要<code>reflect-metadata</code>库被引入了，设计阶段添加的类型信息可以在运行时使用。</p>
<p>如下例所示：</p>
<pre><code class="language-typescript">import "reflect-metadata";

class Point {
    x: number;
    y: number;
}

class Line {
    private _p0: Point;
    private _p1: Point;

    @validate
    set p0(value: Point) { this._p0 = value; }
    get p0() { return this._p0; }

    @validate
    set p1(value: Point) { this._p1 = value; }
    get p1() { return this._p1; }
}

function validate&lt;T&gt;(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;T&gt;) {
    let set = descriptor.set;
    descriptor.set = function (value: T) {
        let type = Reflect.getMetadata("design:type", target, propertyKey);
        if (!(value instanceof type)) {
            throw new TypeError("Invalid type.");
        }
        set.call(target, value);
    }
}
</code></pre>
<p>TypeScript编译器可以通过<code>@Reflect.metadata</code>装饰器注入设计阶段的类型信息。 你可以认为它相当于下面的TypeScript：</p>
<pre><code class="language-typescript">class Line {
    private _p0: Point;
    private _p1: Point;

    @validate
    @Reflect.metadata("design:type", Point)
    set p0(value: Point) { this._p0 = value; }
    get p0() { return this._p0; }

    @validate
    @Reflect.metadata("design:type", Point)
    set p1(value: Point) { this._p1 = value; }
    get p1() { return this._p1; }
}
</code></pre>
<blockquote>
<p>注意  装饰器元数据是个实验性的特性并且可能在以后的版本中发生破坏性的改变（breaking changes）。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="声明合并"><a class="header" href="#声明合并">声明合并</a></h1>
<h2 id="介绍-8"><a class="header" href="#介绍-8">介绍</a></h2>
<p>TypeScript中有些独特的概念可以在类型层面上描述JavaScript对象的模型。 这其中尤其独特的一个例子是“声明合并”的概念。 理解了这个概念，将有助于操作现有的JavaScript代码。 同时，也会有助于理解更多高级抽象的概念。</p>
<p>对本文件来讲，“声明合并”是指编译器将针对同一个名字的两个独立声明合并为单一声明。 合并后的声明同时拥有原先两个声明的特性。 任何数量的声明都可被合并；不局限于两个声明。</p>
<h2 id="基础概念"><a class="header" href="#基础概念">基础概念</a></h2>
<p>TypeScript中的声明会创建以下三种实体之一：命名空间，类型或值。 创建命名空间的声明会新建一个命名空间，它包含了用（.）符号来访问时使用的名字。 创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。 最后，创建值的声明会创建在JavaScript输出中看到的值。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Declaration Type</th><th style="text-align: center">Namespace</th><th style="text-align: center">Type</th><th style="text-align: center">Value</th></tr></thead><tbody>
<tr><td style="text-align: left">Namespace</td><td style="text-align: center">X</td><td style="text-align: center"></td><td style="text-align: center">X</td></tr>
<tr><td style="text-align: left">Class</td><td style="text-align: center"></td><td style="text-align: center">X</td><td style="text-align: center">X</td></tr>
<tr><td style="text-align: left">Enum</td><td style="text-align: center"></td><td style="text-align: center">X</td><td style="text-align: center">X</td></tr>
<tr><td style="text-align: left">Interface</td><td style="text-align: center"></td><td style="text-align: center">X</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left">Type Alias</td><td style="text-align: center"></td><td style="text-align: center">X</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: left">Function</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">X</td></tr>
<tr><td style="text-align: left">Variable</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">X</td></tr>
</tbody></table>
</div>
<p>理解每个声明创建了什么，有助于理解当声明合并时有哪些东西被合并了。</p>
<h2 id="合并接口"><a class="header" href="#合并接口">合并接口</a></h2>
<p>最简单也最常见的声明合并类型是接口合并。 从根本上说，合并的机制是把双方的成员放到一个同名的接口里。</p>
<pre><code class="language-typescript">interface Box {
    height: number;
    width: number;
}

interface Box {
    scale: number;
}

let box: Box = {height: 5, width: 6, scale: 10};
</code></pre>
<p>接口的非函数的成员应该是唯一的。 如果它们不是唯一的，那么它们必须是相同的类型。 如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。</p>
<p>对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。 同时需要注意，当接口<code>A</code>与后来的接口<code>A</code>合并时，后面的接口具有更高的优先级。</p>
<p>如下例所示：</p>
<pre><code class="language-typescript">interface Cloner {
    clone(animal: Animal): Animal;
}

interface Cloner {
    clone(animal: Sheep): Sheep;
}

interface Cloner {
    clone(animal: Dog): Dog;
    clone(animal: Cat): Cat;
}
</code></pre>
<p>这三个接口合并成一个声明：</p>
<pre><code class="language-typescript">interface Cloner {
    clone(animal: Dog): Dog;
    clone(animal: Cat): Cat;
    clone(animal: Sheep): Sheep;
    clone(animal: Animal): Animal;
}
</code></pre>
<p>注意每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前位置。</p>
<p>这个规则有一个例外是当出现特殊的函数签名时。 如果签名里有一个参数的类型是_单一_的字符串字面量（比如，不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端。</p>
<p>比如，下面的接口会合并到一起：</p>
<pre><code class="language-typescript">interface Document {
    createElement(tagName: any): Element;
}
interface Document {
    createElement(tagName: "div"): HTMLDivElement;
    createElement(tagName: "span"): HTMLSpanElement;
}
interface Document {
    createElement(tagName: string): HTMLElement;
    createElement(tagName: "canvas"): HTMLCanvasElement;
}
</code></pre>
<p>合并后的<code>Document</code>将会像下面这样：</p>
<pre><code class="language-typescript">interface Document {
    createElement(tagName: "canvas"): HTMLCanvasElement;
    createElement(tagName: "div"): HTMLDivElement;
    createElement(tagName: "span"): HTMLSpanElement;
    createElement(tagName: string): HTMLElement;
    createElement(tagName: any): Element;
}
</code></pre>
<h2 id="合并命名空间"><a class="header" href="#合并命名空间">合并命名空间</a></h2>
<p>与接口相似，同名的命名空间也会合并其成员。 命名空间会创建出命名空间和值，我们需要知道这两者都是怎么合并的。</p>
<p>对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。</p>
<p>对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。</p>
<p><code>Animals</code>声明合并示例：</p>
<pre><code class="language-typescript">namespace Animals {
    export class Zebra { }
}

namespace Animals {
    export interface Legged { numberOfLegs: number; }
    export class Dog { }
}
</code></pre>
<p>等同于：</p>
<pre><code class="language-typescript">namespace Animals {
    export interface Legged { numberOfLegs: number; }

    export class Zebra { }
    export class Dog { }
}
</code></pre>
<p>除了这些合并外，你还需要了解非导出成员是如何处理的。 非导出成员仅在其原有的（合并前的）命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。</p>
<p>下例提供了更清晰的说明：</p>
<pre><code class="language-typescript">namespace Animal {
    let haveMuscles = true;

    export function animalsHaveMuscles() {
        return haveMuscles;
    }
}

namespace Animal {
    export function doAnimalsHaveMuscles() {
        return haveMuscles;  // Error, because haveMuscles is not accessible here
    }
}
</code></pre>
<p>因为<code>haveMuscles</code>并没有导出，只有<code>animalsHaveMuscles</code>函数共享了原始未合并的命名空间可以访问这个变量。 <code>doAnimalsHaveMuscles</code>函数虽是合并命名空间的一部分，但是访问不了未导出的成员。</p>
<h2 id="命名空间与类和函数和枚举类型合并"><a class="header" href="#命名空间与类和函数和枚举类型合并">命名空间与类和函数和枚举类型合并</a></h2>
<p>命名空间可以与其它类型的声明进行合并。 只要命名空间的定义符合将要合并类型的定义。合并结果包含两者的声明类型。 TypeScript使用这个功能去实现一些JavaScript里的设计模式。</p>
<h3 id="合并命名空间和类"><a class="header" href="#合并命名空间和类">合并命名空间和类</a></h3>
<p>这让我们可以表示内部类。</p>
<pre><code class="language-typescript">class Album {
    label: Album.AlbumLabel;
}
namespace Album {
    export class AlbumLabel { }
}
</code></pre>
<p>合并规则与上面<code>合并命名空间</code>小节里讲的规则一致，我们必须导出<code>AlbumLabel</code>类，好让合并的类能访问。 合并结果是一个类并带有一个内部类。 你也可以使用命名空间为类增加一些静态属性。</p>
<p>除了内部类的模式，你在JavaScript里，创建一个函数稍后扩展它增加一些属性也是很常见的。 TypeScript使用声明合并来达到这个目的并保证类型安全。</p>
<pre><code class="language-typescript">function buildLabel(name: string): string {
    return buildLabel.prefix + name + buildLabel.suffix;
}

namespace buildLabel {
    export let suffix = "";
    export let prefix = "Hello, ";
}

console.log(buildLabel("Sam Smith"));
</code></pre>
<p>相似的，命名空间可以用来扩展枚举型：</p>
<pre><code class="language-typescript">enum Color {
    red = 1,
    green = 2,
    blue = 4
}

namespace Color {
    export function mixColor(colorName: string) {
        if (colorName == "yellow") {
            return Color.red + Color.green;
        }
        else if (colorName == "white") {
            return Color.red + Color.green + Color.blue;
        }
        else if (colorName == "magenta") {
            return Color.red + Color.blue;
        }
        else if (colorName == "cyan") {
            return Color.green + Color.blue;
        }
    }
}
</code></pre>
<h2 id="非法的合并"><a class="header" href="#非法的合并">非法的合并</a></h2>
<p>TypeScript并非允许所有的合并。 目前，类不能与其它类或变量合并。 想要了解如何模仿类的合并，请参考<a href="zh/reference/mixins.html">TypeScript的混入</a>。</p>
<h2 id="模块扩展"><a class="header" href="#模块扩展">模块扩展</a></h2>
<p>虽然JavaScript不支持合并，但你可以为导入的对象打补丁以更新它们。让我们考察一下这个玩具性的示例：</p>
<pre><code class="language-typescript">// observable.ts
export class Observable&lt;T&gt; {
    // ... implementation left as an exercise for the reader ...
}

// map.ts
import { Observable } from "./observable";
Observable.prototype.map = function (f) {
    // ... another exercise for the reader
}
</code></pre>
<p>它也可以很好地工作在TypeScript中， 但编译器对 <code>Observable.prototype.map</code>一无所知。 你可以使用扩展模块来将它告诉编译器：</p>
<pre><code class="language-typescript">// observable.ts
export class Observable&lt;T&gt; {
    // ... implementation left as an exercise for the reader ...
}

// map.ts
import { Observable } from "./observable";
declare module "./observable" {
    interface Observable&lt;T&gt; {
        map&lt;U&gt;(f: (x: T) =&gt; U): Observable&lt;U&gt;;
    }
}
Observable.prototype.map = function (f) {
    // ... another exercise for the reader
}


// consumer.ts
import { Observable } from "./observable";
import "./map";
let o: Observable&lt;number&gt;;
o.map(x =&gt; x.toFixed());
</code></pre>
<p>模块名的解析和用<code>import</code>/<code>export</code>解析模块标识符的方式是一致的。 更多信息请参考 <a href="zh/reference/modules.html">Modules</a>。 当这些声明在扩展中合并时，就如同在原始位置被声明一样。 但是，有两点限制需要注意：</p>
<ol>
<li>你不能在扩展中声明新的顶级声明－仅可以扩展模块中已经存在的声明。</li>
<li>默认导出也不能扩展，只有命名的导出才可以（因为你需要使用导出的名字来进行扩展，并且<code>default</code>是保留关键字 - 详情查看<a href="https://github.com/Microsoft/TypeScript/issues/14080">#14080</a>）</li>
</ol>
<h3 id="全局扩展"><a class="header" href="#全局扩展">全局扩展</a></h3>
<p>你也以在模块内部添加声明到全局作用域中。</p>
<pre><code class="language-typescript">// observable.ts
export class Observable&lt;T&gt; {
    // ... still no implementation ...
}

declare global {
    interface Array&lt;T&gt; {
        toObservable(): Observable&lt;T&gt;;
    }
}

Array.prototype.toObservable = function () {
    // ...
}
</code></pre>
<p>全局扩展与模块扩展的行为和限制是相同的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators-和-generators"><a class="header" href="#iterators-和-generators">Iterators 和 Generators</a></h1>
<p>当一个对象实现了<a href="zh/reference/symbols.html#symboliterator"><code>Symbol.iterator</code></a>属性时，我们认为它是可迭代的。 一些内置的类型如<code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>Int32Array</code>，<code>Uint32Array</code>等都已经实现了各自的<code>Symbol.iterator</code>。 对象上的<code>Symbol.iterator</code>函数负责返回供迭代的值。</p>
<h2 id="forof-语句"><a class="header" href="#forof-语句"><code>for..of</code> 语句</a></h2>
<p><code>for..of</code>会遍历可迭代的对象，调用对象上的<code>Symbol.iterator</code>方法。 下面是在数组上使用<code>for..of</code>的简单例子：</p>
<pre><code class="language-typescript">let someArray = [1, "string", false];

for (let entry of someArray) {
    console.log(entry); // 1, "string", false
}
</code></pre>
<h3 id="forof-vs-forin-语句"><a class="header" href="#forof-vs-forin-语句"><code>for..of</code> vs. <code>for..in</code> 语句</a></h3>
<p><code>for..of</code>和<code>for..in</code>均可迭代一个列表；但是用于迭代的值却不同，<code>for..in</code>迭代的是对象的 <em>键</em> 的列表，而<code>for..of</code>则迭代对象的键对应的值。</p>
<p>下面的例子展示了两者之间的区别：</p>
<pre><code class="language-typescript">let list = [4, 5, 6];

for (let i in list) {
    console.log(i); // "0", "1", "2",
}

for (let i of list) {
    console.log(i); // "4", "5", "6"
}
</code></pre>
<p>另一个区别是<code>for..in</code>可以操作任何对象；它提供了查看对象属性的一种方法。 但是<code>for..of</code>关注于迭代对象的值。内置对象<code>Map</code>和<code>Set</code>已经实现了<code>Symbol.iterator</code>方法，让我们可以访问它们保存的值。</p>
<pre><code class="language-typescript">let pets = new Set(["Cat", "Dog", "Hamster"]);
pets["species"] = "mammals";

for (let pet in pets) {
    console.log(pet); // "species"
}

for (let pet of pets) {
    console.log(pet); // "Cat", "Dog", "Hamster"
}
</code></pre>
<h3 id="代码生成"><a class="header" href="#代码生成">代码生成</a></h3>
<h4 id="目标为-es5-和-es3"><a class="header" href="#目标为-es5-和-es3">目标为 ES5 和 ES3</a></h4>
<p>当生成目标为ES5或ES3，迭代器只允许在<code>Array</code>类型上使用。 在非数组值上使用<code>for..of</code>语句会得到一个错误，就算这些非数组值已经实现了<code>Symbol.iterator</code>属性。</p>
<p>编译器会生成一个简单的<code>for</code>循环做为<code>for..of</code>循环，比如：</p>
<pre><code class="language-typescript">let numbers = [1, 2, 3];
for (let num of numbers) {
    console.log(num);
}
</code></pre>
<p>生成的代码为：</p>
<pre><code class="language-javascript">var numbers = [1, 2, 3];
for (var _i = 0; _i &lt; numbers.length; _i++) {
    var num = numbers[_i];
    console.log(num);
}
</code></pre>
<h4 id="目标为-ecmascript-2015-或更高"><a class="header" href="#目标为-ecmascript-2015-或更高">目标为 ECMAScript 2015 或更高</a></h4>
<p>当目标为兼容ECMAScipt 2015的引擎时，编译器会生成相应引擎的<code>for..of</code>内置迭代器实现方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsx"><a class="header" href="#jsx">JSX</a></h1>
<h2 id="介绍-9"><a class="header" href="#介绍-9">介绍</a></h2>
<p><a href="https://facebook.github.io/jsx/">JSX</a>是一种嵌入式的类似XML的语法。 它可以被转换成合法的JavaScript，尽管转换的语义是依据不同的实现而定的。 JSX因<a href="https://reactjs.org/">React</a>框架而流行，但也存在其它的实现。 TypeScript支持内嵌，类型检查以及将JSX直接编译为JavaScript。</p>
<h2 id="基本用法"><a class="header" href="#基本用法">基本用法</a></h2>
<p>想要使用JSX必须做两件事：</p>
<ol>
<li>给文件一个<code>.tsx</code>扩展名</li>
<li>启用<code>jsx</code>选项</li>
</ol>
<p>TypeScript具有三种JSX模式：<code>preserve</code>，<code>react</code>和<code>react-native</code>。 这些模式只在代码生成阶段起作用 - 类型检查并不受影响。 在<code>preserve</code>模式下生成代码中会保留JSX以供后续的转换操作使用（比如：<a href="https://babeljs.io/">Babel</a>）。 另外，输出文件会带有<code>.jsx</code>扩展名。 <code>react</code>模式会生成<code>React.createElement</code>，在使用前不需要再进行转换操作了，输出文件的扩展名为<code>.js</code>。 <code>react-native</code>相当于<code>preserve</code>，它也保留了所有的JSX，但是输出文件的扩展名是<code>.js</code>。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">模式</th><th style="text-align: left">输入</th><th style="text-align: left">输出</th><th style="text-align: left">输出文件扩展名</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>preserve</code></td><td style="text-align: left"><code>&lt;div /&gt;</code></td><td style="text-align: left"><code>&lt;div /&gt;</code></td><td style="text-align: left"><code>.jsx</code></td></tr>
<tr><td style="text-align: left"><code>react</code></td><td style="text-align: left"><code>&lt;div /&gt;</code></td><td style="text-align: left"><code>React.createElement("div")</code></td><td style="text-align: left"><code>.js</code></td></tr>
<tr><td style="text-align: left"><code>react-native</code></td><td style="text-align: left"><code>&lt;div /&gt;</code></td><td style="text-align: left"><code>&lt;div /&gt;</code></td><td style="text-align: left"><code>.js</code></td></tr>
</tbody></table>
</div>
<p>你可以通过在命令行里使用<code>--jsx</code>标记或<a href="zh/reference/../project-config/tsconfig.json.html">tsconfig.json</a>里的选项来指定模式。</p>
<blockquote>
<p>*注意：当输出目标为<code>react JSX</code>时，你可以使用<code>--jsxFactory</code>指定JSX工厂函数（默认值为<code>React.createElement</code>）</p>
</blockquote>
<h2 id="as操作符"><a class="header" href="#as操作符"><code>as</code>操作符</a></h2>
<p>回想一下怎么写类型断言：</p>
<pre><code class="language-typescript">var foo = &lt;foo&gt;bar;
</code></pre>
<p>这里断言<code>bar</code>变量是<code>foo</code>类型的。 因为TypeScript也使用尖括号来表示类型断言，在结合JSX的语法后将带来解析上的困难。因此，TypeScript在<code>.tsx</code>文件里禁用了使用尖括号的类型断言。</p>
<p>由于不能够在<code>.tsx</code>文件里使用上述语法，因此我们应该使用另一个类型断言操作符：<code>as</code>。 上面的例子可以很容易地使用<code>as</code>操作符改写：</p>
<pre><code class="language-typescript">var foo = bar as foo;
</code></pre>
<p><code>as</code>操作符在<code>.ts</code>和<code>.tsx</code>里都可用，并且与尖括号类型断言行为是等价的。</p>
<h2 id="类型检查"><a class="header" href="#类型检查">类型检查</a></h2>
<p>为了理解JSX的类型检查，你必须首先理解固有元素与基于值的元素之间的区别。 假设有这样一个JSX表达式<code>&lt;expr /&gt;</code>，<code>expr</code>可能引用环境自带的某些东西（比如，在DOM环境里的<code>div</code>或<code>span</code>）或者是你自定义的组件。 这是非常重要的，原因有如下两点：</p>
<ol>
<li>
<p>对于React，固有元素会生成字符串（<code>React.createElement("div")</code>），然而由你自定义的组件却不会生成（<code>React.createElement(MyComponent)</code>）。</p>
</li>
<li>
<p>传入JSX元素里的属性类型的查找方式不同。</p>
<p>固有元素属性_本身_就支持，然而自定义的组件会自己去指定它们具有哪个属性。</p>
</li>
</ol>
<p>TypeScript使用<a href="http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components">与React相同的规范</a> 来区别它们。 固有元素总是以一个小写字母开头，基于值的元素总是以一个大写字母开头。</p>
<h3 id="固有元素"><a class="header" href="#固有元素">固有元素</a></h3>
<p>固有元素使用特殊的接口<code>JSX.IntrinsicElements</code>来查找。 默认地，如果这个接口没有指定，会全部通过，不对固有元素进行类型检查。 然而，如果这个接口存在，那么固有元素的名字需要在<code>JSX.IntrinsicElements</code>接口的属性里查找。 例如：</p>
<pre><code class="language-typescript">declare namespace JSX {
    interface IntrinsicElements {
        foo: any
    }
}

&lt;foo /&gt;; // 正确
&lt;bar /&gt;; // 错误
</code></pre>
<p>在上例中，<code>&lt;foo /&gt;</code>没有问题，但是<code>&lt;bar /&gt;</code>会报错，因为它没在<code>JSX.IntrinsicElements</code>里指定。</p>
<blockquote>
<p>注意：你也可以在<code>JSX.IntrinsicElements</code>上指定一个用来捕获所有字符串索引：</p>
</blockquote>
<pre><code class="language-typescript">declare namespace JSX {
    interface IntrinsicElements {
        [elemName: string]: any;
    }
}
</code></pre>
<h3 id="基于值的元素"><a class="header" href="#基于值的元素">基于值的元素</a></h3>
<p>基于值的元素会简单的在它所在的作用域里按标识符查找。</p>
<pre><code class="language-typescript">import MyComponent from "./myComponent";

&lt;MyComponent /&gt;; // 正确
&lt;SomeOtherComponent /&gt;; // 错误
</code></pre>
<p>有两种方式可以定义基于值的元素：</p>
<ol>
<li>函数组件 (FC)</li>
<li>类组件</li>
</ol>
<p>由于这两种基于值的元素在JSX表达式里无法区分，因此TypeScript首先会尝试将表达式做为函数组件进行解析。如果解析成功，那么TypeScript就完成了表达式到其声明的解析操作。如果按照函数组件解析失败，那么TypeScript会继续尝试以类组件的形式进行解析。如果依旧失败，那么将输出一个错误。</p>
<h4 id="函数组件"><a class="header" href="#函数组件">函数组件</a></h4>
<p>正如其名，组件被定义成JavaScript函数，它的第一个参数是<code>props</code>对象。 TypeScript会强制它的返回值可以赋值给<code>JSX.Element</code>。</p>
<pre><code class="language-typescript">interface FooProp {
  name: string;
  X: number;
  Y: number;
}

declare function AnotherComponent(prop: {name: string});
function ComponentFoo(prop: FooProp) {
  return &lt;AnotherComponent name={prop.name} /&gt;;
}

const Button = (prop: {value: string}, context: { color: string }) =&gt; &lt;button&gt;
</code></pre>
<p>由于函数组件是简单的JavaScript函数，所以我们还可以利用函数重载。</p>
<pre><code class="language-typescript">interface ClickableProps {
  children: JSX.Element[] | JSX.Element
}

interface HomeProps extends ClickableProps {
  home: JSX.Element;
}

interface SideProps extends ClickableProps {
  side: JSX.Element | string;
}

function MainButton(prop: HomeProps): JSX.Element;
function MainButton(prop: SideProps): JSX.Element {
  ...
}
</code></pre>
<blockquote>
<p>注意：函数组件之前叫做无状态函数组件（SFC）。由于在当前React版本里，函数组件不再被当作是无状态的，因此类型<code>SFC</code>和它的别名<code>StatelessComponent</code>被废弃了。</p>
</blockquote>
<h4 id="类组件"><a class="header" href="#类组件">类组件</a></h4>
<p>我们可以定义类组件的类型。 然而，我们首先最好弄懂两个新的术语：<em>元素类的类型_和_元素实例的类型</em>。</p>
<p>现在有<code>&lt;Expr /&gt;</code>，_元素类的类型_为<code>Expr</code>的类型。 所以在上面的例子里，如果<code>MyComponent</code>是ES6的类，那么类类型就是类的构造函数和静态部分。 如果<code>MyComponent</code>是个工厂函数，类类型为这个函数。</p>
<p>一旦建立起了类类型，实例类型由类构造器或调用签名（如果存在的话）的返回值的联合构成。 再次说明，在ES6类的情况下，实例类型为这个类的实例的类型，并且如果是工厂函数，实例类型为这个函数返回值类型。</p>
<pre><code class="language-typescript">class MyComponent {
  render() {}
}

// 使用构造签名
var myComponent = new MyComponent();

// 元素类的类型 =&gt; MyComponent
// 元素实例的类型 =&gt; { render: () =&gt; void }

function MyFactoryFunction() {
  return {
    render: () =&gt; {
    }
  }
}

// 使用调用签名
var myComponent = MyFactoryFunction();

// 元素类的类型 =&gt; MyFactoryFunction
// 元素实例的类型 =&gt; { render: () =&gt; void }
</code></pre>
<p>元素的实例类型很有趣，因为它必须赋值给<code>JSX.ElementClass</code>或抛出一个错误。 默认的<code>JSX.ElementClass</code>为<code>{}</code>，但是它可以被扩展用来限制JSX的类型以符合相应的接口。</p>
<pre><code class="language-typescript">declare namespace JSX {
  interface ElementClass {
    render: any;
  }
}

class MyComponent {
  render() {}
}
function MyFactoryFunction() {
  return { render: () =&gt; {} }
}

&lt;MyComponent /&gt;; // 正确
&lt;MyFactoryFunction /&gt;; // 正确

class NotAValidComponent {}
function NotAValidFactoryFunction() {
  return {};
}

&lt;NotAValidComponent /&gt;; // 错误
&lt;NotAValidFactoryFunction /&gt;; // 错误
</code></pre>
<h3 id="属性类型检查"><a class="header" href="#属性类型检查">属性类型检查</a></h3>
<p>属性类型检查的第一步是确定_元素属性类型_。 这在固有元素和基于值的元素之间稍有不同。</p>
<p>对于固有元素，这是<code>JSX.IntrinsicElements</code>属性的类型。</p>
<pre><code class="language-typescript">declare namespace JSX {
  interface IntrinsicElements {
    foo: { bar?: boolean }
  }
}

// `foo`的元素属性类型为`{bar?: boolean}`
&lt;foo bar /&gt;;
</code></pre>
<p>对于基于值的元素，就稍微复杂些。 它取决于先前确定的在元素实例类型上的某个属性的类型。 至于该使用哪个属性来确定类型取决于<code>JSX.ElementAttributesProperty</code>。 它应该使用单一的属性来定义。 这个属性名之后会被使用。 TypeScript 2.8，如果未指定<code>JSX.ElementAttributesProperty</code>，那么将使用类元素构造函数或函数组件调用的第一个参数的类型。</p>
<pre><code class="language-typescript">declare namespace JSX {
  interface ElementAttributesProperty {
    props; // 指定用来使用的属性名
  }
}

class MyComponent {
  // 在元素实例类型上指定属性
  props: {
    foo?: string;
  }
}

// `MyComponent`的元素属性类型为`{foo?: string}`
&lt;MyComponent foo="bar" /&gt;
</code></pre>
<p>元素属性类型用于的JSX里进行属性的类型检查。 支持可选属性和必须属性。</p>
<pre><code class="language-typescript">declare namespace JSX {
  interface IntrinsicElements {
    foo: { requiredProp: string; optionalProp?: number }
  }
}

&lt;foo requiredProp="bar" /&gt;; // 正确
&lt;foo requiredProp="bar" optionalProp={0} /&gt;; // 正确
&lt;foo /&gt;; // 错误, 缺少 requiredProp
&lt;foo requiredProp={0} /&gt;; // 错误, requiredProp 应该是字符串
&lt;foo requiredProp="bar" unknownProp /&gt;; // 错误, unknownProp 不存在
&lt;foo requiredProp="bar" some-unknown-prop /&gt;; // 正确, `some-unknown-prop`不是个合法的标识符
</code></pre>
<blockquote>
<p>注意：如果一个属性名不是个合法的JS标识符（像<code>data-*</code>属性），并且它没出现在元素属性类型里时不会当做一个错误。</p>
</blockquote>
<p>另外，JSX还会使用<code>JSX.IntrinsicAttributes</code>接口来指定额外的属性，这些额外的属性通常不会被组件的props或arguments使用 - 比如React里的<code>key</code>。还有，<code>JSX.IntrinsicClassAttributes&lt;T&gt;</code>泛型类型也可以用来为类组件（非函数组件）指定相同种类的额外属性。这里的泛型参数表示类实例类型。在React里，它用来允许<code>Ref&lt;T&gt;</code>类型上的<code>ref</code>属性。通常来讲，这些接口上的所有属性都是可选的，除非你想要用户在每个JSX标签上都提供一些属性。</p>
<p>延展操作符也可以使用：</p>
<pre><code class="language-jsx">var props = { requiredProp: 'bar' };
&lt;foo {...props} /&gt;; // 正确

var badProps = {};
&lt;foo {...badProps} /&gt;; // 错误
</code></pre>
<h3 id="子孙类型检查"><a class="header" href="#子孙类型检查">子孙类型检查</a></h3>
<p>从TypeScript 2.3开始，我们引入了_children_类型检查。_children_是_元素属性(attribute)类型_的一个特殊属性(property)，子_JSXExpression_将会被插入到属性里。 与使用<code>JSX.ElementAttributesProperty</code>来决定_props_名类似，我们可以利用<code>JSX.ElementChildrenAttribute</code>来决定_children_名。 <code>JSX.ElementChildrenAttribute</code>应该被声明在单一的属性(property)里。</p>
<pre><code class="language-typescript">declare namespace JSX {
  interface ElementChildrenAttribute {
    children: {};  // specify children name to use
  }
}
</code></pre>
<p>如不特殊指定子孙的类型，我们将使用<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react">React typings</a>里的默认类型。</p>
<pre><code class="language-typescript">&lt;div&gt;
  &lt;h1&gt;Hello&lt;/h1&gt;
&lt;/div&gt;;

&lt;div&gt;
  &lt;h1&gt;Hello&lt;/h1&gt;
  World
&lt;/div&gt;;

const CustomComp = (props) =&gt; &lt;div&gt;{props.children}&lt;/div&gt;
&lt;CustomComp&gt;
  &lt;div&gt;Hello World&lt;/div&gt;
  {"This is just a JS expression..." + 1000}
&lt;/CustomComp&gt;
</code></pre>
<pre><code class="language-typescript">interface PropsType {
  children: JSX.Element
  name: string
}

class Component extends React.Component&lt;PropsType, {}&gt; {
  render() {
    return (
      &lt;h2&gt;
        {this.props.children}
      &lt;/h2&gt;
    )
  }
}

// OK
&lt;Component name="foo"&gt;
  &lt;h1&gt;Hello World&lt;/h1&gt;
&lt;/Component&gt;

// Error: children is of type JSX.Element not array of JSX.Element
&lt;Component name="bar"&gt;
  &lt;h1&gt;Hello World&lt;/h1&gt;
  &lt;h2&gt;Hello World&lt;/h2&gt;
&lt;/Component&gt;

// Error: children is of type JSX.Element not array of JSX.Element or string.
&lt;Component name="baz"&gt;
  &lt;h1&gt;Hello&lt;/h1&gt;
  World
&lt;/Component&gt;
</code></pre>
<h2 id="jsx结果类型"><a class="header" href="#jsx结果类型">JSX结果类型</a></h2>
<p>默认地JSX表达式结果的类型为<code>any</code>。 你可以自定义这个类型，通过指定<code>JSX.Element</code>接口。 然而，不能够从接口里检索元素，属性或JSX的子元素的类型信息。 它是一个黑盒。</p>
<h2 id="嵌入的表达式"><a class="header" href="#嵌入的表达式">嵌入的表达式</a></h2>
<p>JSX允许你使用<code>{ }</code>标签来内嵌表达式。</p>
<pre><code class="language-jsx">var a = &lt;div&gt;
  {['foo', 'bar'].map(i =&gt; &lt;span&gt;{i / 2}&lt;/span&gt;)}
&lt;/div&gt;
</code></pre>
<p>上面的代码产生一个错误，因为你不能用数字来除以一个字符串。 输出如下，若你使用了<code>preserve</code>选项：</p>
<pre><code class="language-jsx">var a = &lt;div&gt;
  {['foo', 'bar'].map(function (i) { return &lt;span&gt;{i / 2}&lt;/span&gt;; })}
&lt;/div&gt;
</code></pre>
<h2 id="react整合"><a class="header" href="#react整合">React整合</a></h2>
<p>要想一起使用JSX和React，你应该使用<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react">React类型定义</a>。 这些类型声明定义了<code>JSX</code>合适命名空间来使用React。</p>
<pre><code class="language-typescript">/// &lt;reference path="react.d.ts" /&gt;

interface Props {
  foo: string;
}

class MyComponent extends React.Component&lt;Props, {}&gt; {
  render() {
    return &lt;span&gt;{this.props.foo}&lt;/span&gt;
  }
}

&lt;MyComponent foo="bar" /&gt;; // 正确
&lt;MyComponent foo={0} /&gt;; // 错误
</code></pre>
<h2 id="工厂函数"><a class="header" href="#工厂函数">工厂函数</a></h2>
<p><code>jsx: react</code>编译选项使用的工厂函数是可以配置的。可以使用<code>jsxFactory</code>命令行选项，或内联的<code>@jsx</code>注释指令在每个文件上设置。比如，给<code>createElement</code>设置<code>jsxFactory</code>，<code>&lt;div /&gt;</code>会使用<code>createElement("div")</code>来生成，而不是<code>React.createElement("div")</code>。</p>
<p>注释指令可以像下面这样使用（在TypeScript 2.8里）：</p>
<pre><code class="language-typescript">import preact = require("preact");
/* @jsx preact.h */
const x = &lt;div /&gt;;
</code></pre>
<p>生成：</p>
<pre><code class="language-typescript">const preact = require("preact");
const x = preact.h("div", null);
</code></pre>
<p>工厂函数的选择同样会影响<code>JSX</code>命名空间的查找（类型检查）。如果工厂函数使用<code>React.createElement</code>定义（默认），编译器会先检查<code>React.JSX</code>，之后才检查全局的<code>JSX</code>。如果工厂函数定义为<code>h</code>，那么在检查全局的<code>JSX</code>之前先检查<code>h.JSX</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="混入"><a class="header" href="#混入">混入</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<p><a href="zh/reference/mixins.html#introduction">介绍</a></p>
<p><a href="zh/reference/mixins.html#mixin-sample">混入示例</a></p>
<p><a href="zh/reference/mixins.html#understanding-the-sample">理解示例</a></p>
<h2 id="介绍-10"><a class="header" href="#介绍-10">介绍</a></h2>
<p><a href="zh/reference/mixins.html#table-of-contents"><strong>↥ 回到顶端</strong></a></p>
<p>除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。 你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。</p>
<h2 id="混入示例"><a class="header" href="#混入示例">混入示例</a></h2>
<p><a href="zh/reference/mixins.html#table-of-contents"><strong>↥ 回到顶端</strong></a></p>
<p>下面的代码演示了如何在TypeScript里使用混入。 后面我们还会解释这段代码是怎么工作的。</p>
<pre><code class="language-typescript">// Disposable Mixin
class Disposable {
    isDisposed: boolean;
    dispose() {
        this.isDisposed = true;
    }

}

// Activatable Mixin
class Activatable {
    isActive: boolean;
    activate() {
        this.isActive = true;
    }
    deactivate() {
        this.isActive = false;
    }
}

class SmartObject {
    constructor() {
        setInterval(() =&gt; console.log(this.isActive + " : " + this.isDisposed), 500);
    }

    interact() {
        this.activate();
    }
}

interface SmartObject extends Disposable, Activatable {}
applyMixins(SmartObject, [Disposable, Activatable]);

let smartObj = new SmartObject();
setTimeout(() =&gt; smartObj.interact(), 1000);

////////////////////////////////////////
// In your runtime library somewhere
////////////////////////////////////////

function applyMixins(derivedCtor: any, baseCtors: any[]) {
    baseCtors.forEach(baseCtor =&gt; {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {
            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
        });
    });
}
</code></pre>
<h2 id="理解示例"><a class="header" href="#理解示例">理解示例</a></h2>
<p><a href="zh/reference/mixins.html#table-of-contents"><strong>↥ 回到顶端</strong></a></p>
<p>代码里首先定义了两个类，它们将做为mixins。 可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。</p>
<pre><code class="language-typescript">// Disposable Mixin
class Disposable {
    isDisposed: boolean;
    dispose() {
        this.isDisposed = true;
    }

}

// Activatable Mixin
class Activatable {
    isActive: boolean;
    activate() {
        this.isActive = true;
    }
    deactivate() {
        this.isActive = false;
    }
}
</code></pre>
<p>下面创建一个类，结合了这两个mixins。 下面来看一下具体是怎么操作的：</p>
<pre><code class="language-typescript">class SmartObject {
    ...
}

interface SmartObject extends Disposable, Activatable {}
</code></pre>
<p>首先注意到的是，我们没有在<code>SmartObject</code>类里面继承<code>Disposable</code>和<code>Activatable</code>，而是在<code>SmartObject</code>接口里面继承的。由于<a href="zh/reference/declaration-merging.html">声明合并</a>的存在，<code>SmartObject</code>接口会被混入到<code>SmartObject</code>类里面。</p>
<p>它将类视为接口，且只会混入Disposable和Activatable背后的类型到SmartObject类型里，不会混入实现。也就是说，我们要在类里面去实现。 这正是我们想要在混入时避免的行为。</p>
<p>最后，我们将混入融入到了类的实现中去。</p>
<pre><code class="language-typescript">// Disposable
isDisposed: boolean = false;
dispose: () =&gt; void;
// Activatable
isActive: boolean = false;
activate: () =&gt; void;
deactivate: () =&gt; void;
</code></pre>
<p>最后，把mixins混入定义的类，完成全部实现部分。</p>
<pre><code class="language-typescript">applyMixins(SmartObject, [Disposable, Activatable]);
</code></pre>
<p>最后，创建这个帮助函数，帮我们做混入操作。 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。</p>
<pre><code class="language-typescript">function applyMixins(derivedCtor: any, baseCtors: any[]) {
    baseCtors.forEach(baseCtor =&gt; {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {
            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
        })
    });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块"><a class="header" href="#模块">模块</a></h1>
<blockquote>
<p><strong>关于术语的一点说明:</strong> 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与<a href="http://www.ecma-international.org/ecma-262/6.0/">ECMAScript 2015</a>里的术语保持一致，(也就是说 <code>module X {</code> 相当于现在推荐的写法 <code>namespace X {</code>)。</p>
</blockquote>
<h2 id="介绍-11"><a class="header" href="#介绍-11">介绍</a></h2>
<p>从ECMAScript 2015开始，JavaScript引入了模块的概念。TypeScript也沿用这个概念。</p>
<p>模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用<a href="zh/reference/modules.html#export"><code>export</code>形式</a>之一导出它们。 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用<a href="zh/reference/modules.html#import"><code>import</code>形式</a>之一。</p>
<p>模块是自声明的；两个模块之间的关系是通过在文件级别上使用imports和exports建立的。</p>
<p>模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 众所周知的JavaScript模块加载器有：作用于<a href="https://en.wikipedia.org/wiki/CommonJS">CommonJS</a>模块的Node.js加载器和在Web应用里作用于<a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD</a>模块的<a href="http://requirejs.org/">RequireJS</a>加载器。</p>
<p>TypeScript与ECMAScript 2015一样，任何包含顶级<code>import</code>或者<code>export</code>的文件都被当成一个模块。 相反地，如果一个文件不带有顶级的<code>import</code>或者<code>export</code>声明，那么它的内容被视为全局可见的（因此对模块也是可见的）。</p>
<h2 id="导出"><a class="header" href="#导出">导出</a></h2>
<h3 id="导出声明"><a class="header" href="#导出声明">导出声明</a></h3>
<p>任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加<code>export</code>关键字来导出。</p>
<p><strong>StringValidator.ts</strong></p>
<pre><code class="language-typescript">export interface StringValidator {
    isAcceptable(s: string): boolean;
}
</code></pre>
<p><strong>ZipCodeValidator.ts</strong></p>
<pre><code class="language-typescript">import { StringValidator } from "./StringValidator";

export const numberRegexp = /^[0-9]+$/;

export class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
</code></pre>
<h3 id="导出语句"><a class="header" href="#导出语句">导出语句</a></h3>
<p>导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：</p>
<pre><code class="language-typescript">class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
export { ZipCodeValidator };
export { ZipCodeValidator as mainValidator };
</code></pre>
<h3 id="重新导出"><a class="header" href="#重新导出">重新导出</a></h3>
<p>我们经常会去扩展其它模块，并且只导出那个模块的部分内容。 重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。</p>
<p><strong>ParseIntBasedZipCodeValidator.ts</strong></p>
<pre><code class="language-typescript">export class ParseIntBasedZipCodeValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; parseInt(s).toString() === s;
    }
}

// 导出原先的验证器但做了重命名
export {ZipCodeValidator as RegExpBasedZipCodeValidator} from "./ZipCodeValidator";
</code></pre>
<p>或者一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法：<code>export * from "module"</code>。</p>
<p><strong>AllValidators.ts</strong></p>
<pre><code class="language-typescript">export * from "./StringValidator"; // exports 'StringValidator' interface
export * from "./ZipCodeValidator";  // exports 'ZipCodeValidator' and const 'numberRegexp' class
export * from "./ParseIntBasedZipCodeValidator"; //  exports the 'ParseIntBasedZipCodeValidator' class
                                                 // and re-exports 'RegExpBasedZipCodeValidator' as alias
                                                 // of the 'ZipCodeValidator' class from 'ZipCodeValidator.ts'
</code></pre>
<h2 id="导入"><a class="header" href="#导入">导入</a></h2>
<p>模块的导入操作与导出一样简单。 可以使用以下<code>import</code>形式之一来导入其它模块中的导出内容。</p>
<h3 id="导入一个模块中的某个导出内容"><a class="header" href="#导入一个模块中的某个导出内容">导入一个模块中的某个导出内容</a></h3>
<pre><code class="language-typescript">import { ZipCodeValidator } from "./ZipCodeValidator";

let myValidator = new ZipCodeValidator();
</code></pre>
<p>可以对导入内容重命名</p>
<pre><code class="language-typescript">import { ZipCodeValidator as ZCV } from "./ZipCodeValidator";
let myValidator = new ZCV();
</code></pre>
<h3 id="将整个模块导入到一个变量并通过它来访问模块的导出部分"><a class="header" href="#将整个模块导入到一个变量并通过它来访问模块的导出部分">将整个模块导入到一个变量，并通过它来访问模块的导出部分</a></h3>
<pre><code class="language-typescript">import * as validator from "./ZipCodeValidator";
let myValidator = new validator.ZipCodeValidator();
</code></pre>
<h3 id="具有副作用的导入模块"><a class="header" href="#具有副作用的导入模块">具有副作用的导入模块</a></h3>
<p>尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。 这些模块可能没有任何的导出或用户根本就不关注它的导出。 使用下面的方法来导入这类模块：</p>
<pre><code class="language-typescript">import "./my-module.js";
</code></pre>
<h2 id="默认导出"><a class="header" href="#默认导出">默认导出</a></h2>
<p>每个模块都可以有一个<code>default</code>导出。 默认导出使用<code>default</code>关键字标记；并且一个模块只能够有一个<code>default</code>导出。 需要使用一种特殊的导入形式来导入<code>default</code>导出。</p>
<p><code>default</code>导出十分便利。 比如，像jQuery这样的类库可能有一个默认导出<code>jQuery</code>或<code>$</code>，并且我们基本上也会使用同样的名字<code>jQuery</code>或<code>$</code>导出jQuery。</p>
<p><strong>jQuery.d.ts</strong></p>
<pre><code class="language-typescript">declare let $: jQuery;
export default $;
</code></pre>
<p><strong>App.ts</strong></p>
<pre><code class="language-typescript">import $ from "jQuery";

$("button.continue").html( "Next Step..." );
</code></pre>
<p>类和函数声明可以直接被标记为默认导出。 标记为默认导出的类和函数的名字是可以省略的。</p>
<p><strong>ZipCodeValidator.ts</strong></p>
<pre><code class="language-typescript">export default class ZipCodeValidator {
    static numberRegexp = /^[0-9]+$/;
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; ZipCodeValidator.numberRegexp.test(s);
    }
}
</code></pre>
<p><strong>Test.ts</strong></p>
<pre><code class="language-typescript">import validator from "./ZipCodeValidator";

let myValidator = new validator();
</code></pre>
<p>或者</p>
<p><strong>StaticZipCodeValidator.ts</strong></p>
<pre><code class="language-typescript">const numberRegexp = /^[0-9]+$/;

export default function (s: string) {
    return s.length === 5 &amp;&amp; numberRegexp.test(s);
}
</code></pre>
<p><strong>Test.ts</strong></p>
<pre><code class="language-typescript">import validate from "./StaticZipCodeValidator";

let strings = ["Hello", "98052", "101"];

// Use function validate
strings.forEach(s =&gt; {
  console.log(`"${s}" ${validate(s) ? "matches" : "does not match"}`);
});
</code></pre>
<p><code>default</code>导出也可以是一个值</p>
<p><strong>OneTwoThree.ts</strong></p>
<pre><code class="language-typescript">export default "123";
</code></pre>
<p><strong>Log.ts</strong></p>
<pre><code class="language-typescript">import num from "./OneTwoThree";

console.log(num); // "123"
</code></pre>
<h2 id="export--和-import--require"><a class="header" href="#export--和-import--require"><code>export =</code> 和 <code>import = require()</code></a></h2>
<p>CommonJS和AMD的环境里都有一个<code>exports</code>变量，这个变量包含了一个模块的所有导出内容。</p>
<p>CommonJS和AMD的<code>exports</code>都可以被赋值为一个<code>对象</code>, 这种情况下其作用就类似于 es6 语法里的默认导出，即 <code>export default</code>语法了。虽然作用相似，但是 <code>export default</code> 语法并不能兼容CommonJS和AMD的<code>exports</code>。</p>
<p>为了支持CommonJS和AMD的<code>exports</code>, TypeScript提供了<code>export =</code>语法。</p>
<p><code>export =</code>语法定义一个模块的导出<code>对象</code>。 这里的<code>对象</code>一词指的是类，接口，命名空间，函数或枚举。</p>
<p>若使用<code>export =</code>导出一个模块，则必须使用TypeScript的特定语法<code>import module = require("module")</code>来导入此模块。</p>
<p><strong>ZipCodeValidator.ts</strong></p>
<pre><code class="language-typescript">let numberRegexp = /^[0-9]+$/;
class ZipCodeValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
export = ZipCodeValidator;
</code></pre>
<p><strong>Test.ts</strong></p>
<pre><code class="language-typescript">import zip = require("./ZipCodeValidator");

// Some samples to try
let strings = ["Hello", "98052", "101"];

// Validators to use
let validator = new zip();

// Show whether each string passed each validator
strings.forEach(s =&gt; {
  console.log(`"${ s }" - ${ validator.isAcceptable(s) ? "matches" : "does not match" }`);
});
</code></pre>
<h2 id="生成模块代码"><a class="header" href="#生成模块代码">生成模块代码</a></h2>
<p>根据编译时指定的模块目标参数，编译器会生成相应的供Node.js (<a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS</a>)，Require.js (<a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a>)，<a href="https://github.com/umdjs/umd">UMD</a>, <a href="https://github.com/systemjs/systemjs">SystemJS</a>或<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-modules">ECMAScript 2015 native modules</a> (ES6)模块加载系统使用的代码。 想要了解生成代码中<code>define</code>，<code>require</code> 和 <code>register</code>的意义，请参考相应模块加载器的文档。</p>
<p>下面的例子说明了导入导出语句里使用的名字是怎么转换为相应的模块加载器代码的。</p>
<p><strong>SimpleModule.ts</strong></p>
<pre><code class="language-typescript">import m = require("mod");
export let t = m.something + 1;
</code></pre>
<p><strong>AMD / RequireJS SimpleModule.js</strong></p>
<pre><code class="language-javascript">define(["require", "exports", "./mod"], function (require, exports, mod_1) {
    exports.t = mod_1.something + 1;
});
</code></pre>
<p><strong>CommonJS / Node SimpleModule.js</strong></p>
<pre><code class="language-javascript">let mod_1 = require("./mod");
exports.t = mod_1.something + 1;
</code></pre>
<p><strong>UMD SimpleModule.js</strong></p>
<pre><code class="language-javascript">(function (factory) {
    if (typeof module === "object" &amp;&amp; typeof module.exports === "object") {
        let v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" &amp;&amp; define.amd) {
        define(["require", "exports", "./mod"], factory);
    }
})(function (require, exports) {
    let mod_1 = require("./mod");
    exports.t = mod_1.something + 1;
});
</code></pre>
<p><strong>System SimpleModule.js</strong></p>
<pre><code class="language-javascript">System.register(["./mod"], function(exports_1) {
    let mod_1;
    let t;
    return {
        setters:[
            function (mod_1_1) {
                mod_1 = mod_1_1;
            }],
        execute: function() {
            exports_1("t", t = mod_1.something + 1);
        }
    }
});
</code></pre>
<p><strong>Native ECMAScript 2015 modules SimpleModule.js</strong></p>
<pre><code class="language-javascript">import { something } from "./mod";
export let t = something + 1;
</code></pre>
<h2 id="简单示例"><a class="header" href="#简单示例">简单示例</a></h2>
<p>下面我们来整理一下前面的验证器实现，每个模块只有一个命名的导出。</p>
<p>为了编译，我们必需要在命令行上指定一个模块目标。对于Node.js来说，使用<code>--module commonjs</code>； 对于Require.js来说，使用<code>--module amd</code>。比如：</p>
<pre><code class="language-text">tsc --module commonjs Test.ts
</code></pre>
<p>编译完成后，每个模块会生成一个单独的<code>.js</code>文件。 好比使用了reference标签，编译器会根据<code>import</code>语句编译相应的文件。</p>
<p><strong>Validation.ts</strong></p>
<pre><code class="language-typescript">export interface StringValidator {
    isAcceptable(s: string): boolean;
}
</code></pre>
<p><strong>LettersOnlyValidator.ts</strong></p>
<pre><code class="language-typescript">import { StringValidator } from "./Validation";

const lettersRegexp = /^[A-Za-z]+$/;

export class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
        return lettersRegexp.test(s);
    }
}
</code></pre>
<p><strong>ZipCodeValidator.ts</strong></p>
<pre><code class="language-typescript">import { StringValidator } from "./Validation";

const numberRegexp = /^[0-9]+$/;

export class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
</code></pre>
<p><strong>Test.ts</strong></p>
<pre><code class="language-typescript">import { StringValidator } from "./Validation";
import { ZipCodeValidator } from "./ZipCodeValidator";
import { LettersOnlyValidator } from "./LettersOnlyValidator";

// Some samples to try
let strings = ["Hello", "98052", "101"];

// Validators to use
let validators: { [s: string]: StringValidator; } = {};
validators["ZIP code"] = new ZipCodeValidator();
validators["Letters only"] = new LettersOnlyValidator();

// Show whether each string passed each validator
strings.forEach(s =&gt; {
    for (let name in validators) {
        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);
    }
});
</code></pre>
<h2 id="可选的模块加载和其它高级加载场景"><a class="header" href="#可选的模块加载和其它高级加载场景">可选的模块加载和其它高级加载场景</a></h2>
<p>有时候，你只想在某种条件下才加载某个模块。 在TypeScript里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且可以保证类型完全。</p>
<p>编译器会检测是否每个模块都会在生成的JavaScript中用到。 如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成<code>require</code>这个模块的代码。 省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。</p>
<p>这种模式的核心是<code>import id = require("...")</code>语句可以让我们访问模块导出的类型。 模块加载器会被动态调用（通过<code>require</code>），就像下面<code>if</code>代码块里那样。 它利用了省略引用的优化，所以模块只在被需要时加载。 为了让这个模块工作，一定要注意<code>import</code>定义的标识符只能在表示类型处使用（不能在会转换成JavaScript的地方）。</p>
<p>为了确保类型安全性，我们可以使用<code>typeof</code>关键字。 <code>typeof</code>关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。</p>
<p><strong>示例：Node.js里的动态模块加载</strong></p>
<pre><code class="language-typescript">declare function require(moduleName: string): any;

import { ZipCodeValidator as Zip } from "./ZipCodeValidator";

if (needZipValidation) {
    let ZipCodeValidator: typeof Zip = require("./ZipCodeValidator");
    let validator = new ZipCodeValidator();
    if (validator.isAcceptable("...")) { /* ... */ }
}
</code></pre>
<p><strong>示例：require.js里的动态模块加载</strong></p>
<pre><code class="language-typescript">declare function require(moduleNames: string[], onLoad: (...args: any[]) =&gt; void): void;

import * as Zip from "./ZipCodeValidator";

if (needZipValidation) {
    require(["./ZipCodeValidator"], (ZipCodeValidator: typeof Zip) =&gt; {
        let validator = new ZipCodeValidator.ZipCodeValidator();
        if (validator.isAcceptable("...")) { /* ... */ }
    });
}
</code></pre>
<p><strong>示例：System.js里的动态模块加载</strong></p>
<pre><code class="language-typescript">declare const System: any;

import { ZipCodeValidator as Zip } from "./ZipCodeValidator";

if (needZipValidation) {
    System.import("./ZipCodeValidator").then((ZipCodeValidator: typeof Zip) =&gt; {
        var x = new ZipCodeValidator();
        if (x.isAcceptable("...")) { /* ... */ }
    });
}
</code></pre>
<h2 id="使用其它的javascript库"><a class="header" href="#使用其它的javascript库">使用其它的JavaScript库</a></h2>
<p>要想描述非TypeScript编写的类库的类型，我们需要声明类库所暴露出的API。</p>
<p>我们叫它声明因为它不是“外部程序”的具体实现。 它们通常是在<code>.d.ts</code>文件里定义的。 如果你熟悉C/C++，你可以把它们当做<code>.h</code>文件。 让我们看一些例子。</p>
<h3 id="外部模块"><a class="header" href="#外部模块">外部模块</a></h3>
<p>在Node.js里大部分工作是通过加载一个或多个模块实现的。 我们可以使用顶级的<code>export</code>声明来为每个模块都定义一个<code>.d.ts</code>文件，但最好还是写在一个大的<code>.d.ts</code>文件里。 我们使用与构造一个外部命名空间相似的方法，但是这里使用<code>module</code>关键字并且把名字用引号括起来，方便之后<code>import</code>。 例如：</p>
<p><strong>node.d.ts (simplified excerpt)</strong></p>
<pre><code class="language-typescript">declare module "url" {
    export interface Url {
        protocol?: string;
        hostname?: string;
        pathname?: string;
    }

    export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;
}

declare module "path" {
    export function normalize(p: string): string;
    export function join(...paths: any[]): string;
    export let sep: string;
}
</code></pre>
<p>现在我们可以<code>/// &lt;reference&gt;</code> <code>node.d.ts</code>并且使用<code>import url = require("url");</code>或<code>import * as URL from "url"</code>加载模块。</p>
<pre><code class="language-typescript">/// &lt;reference path="node.d.ts"/&gt;
import * as URL from "url";
let myUrl = URL.parse("http://www.typescriptlang.org");
</code></pre>
<h4 id="外部模块简写"><a class="header" href="#外部模块简写">外部模块简写</a></h4>
<p>假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。</p>
<p><strong>declarations.d.ts</strong></p>
<pre><code class="language-typescript">declare module "hot-new-module";
</code></pre>
<p>简写模块里所有导出的类型将是<code>any</code>。</p>
<pre><code class="language-typescript">import x, {y} from "hot-new-module";
x(y);
</code></pre>
<h4 id="模块声明通配符"><a class="header" href="#模块声明通配符">模块声明通配符</a></h4>
<p>某些模块加载器如<a href="https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax">SystemJS</a> 和<a href="https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md">AMD</a>支持导入非JavaScript内容。 它们通常会使用一个前缀或后缀来表示特殊的加载语法。 模块声明通配符可以用来表示这些情况。</p>
<pre><code class="language-typescript">declare module "*!text" {
    const content: string;
    export default content;
}
// Some do it the other way around.
declare module "json!*" {
    const value: any;
    export default value;
}
</code></pre>
<p>现在你可以就导入匹配<code>"*!text"</code>或<code>"json!*"</code>的内容了。</p>
<pre><code class="language-typescript">import fileContent from "./xyz.txt!text";
import data from "json!http://example.com/data.json";
console.log(data, fileContent);
</code></pre>
<h4 id="umd模块"><a class="header" href="#umd模块">UMD模块</a></h4>
<p>有些模块被设计成兼容多个模块加载器，或者不使用模块加载器（全局变量）。 它们以<a href="https://github.com/umdjs/umd">UMD</a>模块为代表。 这些库可以通过导入的形式或全局变量的形式访问。 例如：</p>
<p><strong>math-lib.d.ts</strong></p>
<pre><code class="language-typescript">export function isPrime(x: number): boolean;
export as namespace mathLib;
</code></pre>
<p>之后，这个库可以在某个模块里通过导入来使用：</p>
<pre><code class="language-typescript">import { isPrime } from "math-lib";
isPrime(2);
mathLib.isPrime(2); // ERROR: can't use the global definition from inside a module
</code></pre>
<p>它同样可以通过全局变量的形式使用，但只能在某个脚本里。 （脚本是指一个不带有导入或导出的文件。）</p>
<pre><code class="language-typescript">mathLib.isPrime(2);
</code></pre>
<h2 id="创建模块结构指导"><a class="header" href="#创建模块结构指导">创建模块结构指导</a></h2>
<h3 id="尽可能地在顶层导出"><a class="header" href="#尽可能地在顶层导出">尽可能地在顶层导出</a></h3>
<p>用户应该更容易地使用你模块导出的内容。 嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。</p>
<p>从你的模块中导出一个命名空间就是一个增加嵌套的例子。 虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层。 这对用户来说是很不便的并且通常是多余的。</p>
<p>导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。 除非它能方便表述或便于清晰使用，否则请考虑直接导出一个辅助方法。</p>
<h4 id="如果仅导出单个-class-或-function使用-export-default"><a class="header" href="#如果仅导出单个-class-或-function使用-export-default">如果仅导出单个 <code>class</code> 或 <code>function</code>，使用 <code>export default</code></a></h4>
<p>就像“在顶层上导出”帮助减少用户使用的难度，一个默认的导出也能起到这个效果。 如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。 这会令模块的导入和使用变得些许简单。 比如：</p>
<p><strong>MyClass.ts</strong></p>
<pre><code class="language-typescript">export default class SomeType {
  constructor() { ... }
}
</code></pre>
<p><strong>MyFunc.ts</strong></p>
<pre><code class="language-typescript">export default function getThing() { return 'thing'; }
</code></pre>
<p><strong>Consumer.ts</strong></p>
<pre><code class="language-typescript">import t from "./MyClass";
import f from "./MyFunc";
let x = new t();
console.log(f());
</code></pre>
<p>对用户来说这是最理想的。他们可以随意命名导入模块的类型（本例为<code>t</code>）并且不需要多余的（.）来找到相关对象。</p>
<h4 id="如果要导出多个对象把它们放在顶层里导出"><a class="header" href="#如果要导出多个对象把它们放在顶层里导出">如果要导出多个对象，把它们放在顶层里导出</a></h4>
<p><strong>MyThings.ts</strong></p>
<pre><code class="language-typescript">export class SomeType { /* ... */ }
export function someFunc() { /* ... */ }
</code></pre>
<p>相反地，当导入的时候：</p>
<h4 id="明确地列出导入的名字"><a class="header" href="#明确地列出导入的名字">明确地列出导入的名字</a></h4>
<p><strong>Consumer.ts</strong></p>
<pre><code class="language-typescript">import { SomeType, SomeFunc } from "./MyThings";
let x = new SomeType();
let y = someFunc();
</code></pre>
<h4 id="使用命名空间导入模式当你要导出大量内容的时候"><a class="header" href="#使用命名空间导入模式当你要导出大量内容的时候">使用命名空间导入模式当你要导出大量内容的时候</a></h4>
<p><strong>MyLargeModule.ts</strong></p>
<pre><code class="language-typescript">export class Dog { ... }
export class Cat { ... }
export class Tree { ... }
export class Flower { ... }
</code></pre>
<p><strong>Consumer.ts</strong></p>
<pre><code class="language-typescript">import * as myLargeModule from "./MyLargeModule.ts";
let x = new myLargeModule.Dog();
</code></pre>
<h3 id="使用重新导出进行扩展"><a class="header" href="#使用重新导出进行扩展">使用重新导出进行扩展</a></h3>
<p>你可能经常需要去扩展一个模块的功能。 JS里常用的一个模式是jQuery那样去扩展原对象。 如我们之前提到的，模块不会像全局命名空间对象那样去_合并_。 推荐的方案是_不要_去改变原来的对象，而是导出一个新的实体来提供新的功能。</p>
<p>假设<code>Calculator.ts</code>模块里定义了一个简单的计算器实现。 这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。</p>
<p><strong>Calculator.ts</strong></p>
<pre><code class="language-typescript">export class Calculator {
    private current = 0;
    private memory = 0;
    private operator: string;

    protected processDigit(digit: string, currentValue: number) {
        if (digit &gt;= "0" &amp;&amp; digit &lt;= "9") {
            return currentValue * 10 + (digit.charCodeAt(0) - "0".charCodeAt(0));
        }
    }

    protected processOperator(operator: string) {
        if (["+", "-", "*", "/"].indexOf(operator) &gt;= 0) {
            return operator;
        }
    }

    protected evaluateOperator(operator: string, left: number, right: number): number {
        switch (this.operator) {
            case "+": return left + right;
            case "-": return left - right;
            case "*": return left * right;
            case "/": return left / right;
        }
    }

    private evaluate() {
        if (this.operator) {
            this.memory = this.evaluateOperator(this.operator, this.memory, this.current);
        }
        else {
            this.memory = this.current;
        }
        this.current = 0;
    }

    public handleChar(char: string) {
        if (char === "=") {
            this.evaluate();
            return;
        }
        else {
            let value = this.processDigit(char, this.current);
            if (value !== undefined) {
                this.current = value;
                return;
            }
            else {
                let value = this.processOperator(char);
                if (value !== undefined) {
                    this.evaluate();
                    this.operator = value;
                    return;
                }
            }
        }
        throw new Error(`Unsupported input: '${char}'`);
    }

    public getResult() {
        return this.memory;
    }
}

export function test(c: Calculator, input: string) {
    for (let i = 0; i &lt; input.length; i++) {
        c.handleChar(input[i]);
    }

    console.log(`result of '${input}' is '${c.getResult()}'`);
}
</code></pre>
<p>下面使用导出的<code>test</code>函数来测试计算器。</p>
<p><strong>TestCalculator.ts</strong></p>
<pre><code class="language-typescript">import { Calculator, test } from "./Calculator";


let c = new Calculator();
test(c, "1+2*33/11="); // prints 9
</code></pre>
<p>现在扩展它，添加支持输入其它进制（十进制以外），让我们来创建<code>ProgrammerCalculator.ts</code>。</p>
<p><strong>ProgrammerCalculator.ts</strong></p>
<pre><code class="language-typescript">import { Calculator } from "./Calculator";

class ProgrammerCalculator extends Calculator {
    static digits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];

    constructor(public base: number) {
        super();
        const maxBase = ProgrammerCalculator.digits.length;
        if (base &lt;= 0 || base &gt; maxBase) {
            throw new Error(`base has to be within 0 to ${maxBase} inclusive.`);
        }
    }

    protected processDigit(digit: string, currentValue: number) {
        if (ProgrammerCalculator.digits.indexOf(digit) &gt;= 0) {
            return currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit);
        }
    }
}

// Export the new extended calculator as Calculator
export { ProgrammerCalculator as Calculator };

// Also, export the helper function
export { test } from "./Calculator";
</code></pre>
<p>新的<code>ProgrammerCalculator</code>模块导出的API与原先的<code>Calculator</code>模块很相似，但却没有改变原模块里的对象。 下面是测试ProgrammerCalculator类的代码：</p>
<p><strong>TestProgrammerCalculator.ts</strong></p>
<pre><code class="language-typescript">import { Calculator, test } from "./ProgrammerCalculator";

let c = new Calculator(2);
test(c, "001+010="); // prints 3
</code></pre>
<h3 id="模块里不要使用命名空间"><a class="header" href="#模块里不要使用命名空间">模块里不要使用命名空间</a></h3>
<p>当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。 模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。 记住这点，命名空间在使用模块时几乎没什么价值。</p>
<p>在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型进行分组是很便利的。 例如，在C#里，你会从<code>System.Collections</code>里找到所有集合的类型。 通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。 然而，模块本身已经存在于文件系统之中，这是必须的。 我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。 我们可以创建<code>/collections/generic/</code>文件夹，把相应模块放在这里面。</p>
<p>命名空间对解决全局作用域里命名冲突来说是很重要的。 比如，你可以有一个<code>My.Application.Customer.AddForm</code>和<code>My.Application.Order.AddForm</code> -- 两个类型的名字相同，但命名空间不同。 然而，这对于模块来说却不是一个问题。 在一个模块里，没有理由两个对象拥有同一个名字。 从模块的使用角度来说，使用者会挑出他们用来引用模块的名字，所以也没有理由发生重名的情况。</p>
<blockquote>
<p>更多关于模块和命名空间的资料查看<a href="zh/reference/namespaces-and-modules.html">命名空间和模块</a></p>
</blockquote>
<h3 id="危险信号"><a class="header" href="#危险信号">危险信号</a></h3>
<p>以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间：</p>
<ul>
<li>文件的顶层声明是<code>export namespace Foo { ... }</code> （删除<code>Foo</code>并把所有内容向上层移动一层）©</li>
<li>多个文件的顶层具有同样的<code>export namespace Foo {</code> （不要以为这些会合并到一个<code>Foo</code>中！）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块解析"><a class="header" href="#模块解析">模块解析</a></h1>
<blockquote>
<p>这节假设你已经了解了模块的一些基本知识 请阅读<a href="zh/reference/modules.html">模块</a>文档了解更多信息。</p>
</blockquote>
<p>_模块解析_是指编译器在查找导入模块内容时所遵循的流程。 假设有一个导入语句<code>import { a } from "moduleA"</code>; 为了去检查任何对<code>a</code>的使用，编译器需要准确的知道它表示什么，并且需要检查它的定义<code>moduleA</code>。</p>
<p>这时候，编译器会有个疑问“<code>moduleA</code>的结构是怎样的？” 这听上去很简单，但<code>moduleA</code>可能在你写的某个<code>.ts</code>/<code>.tsx</code>文件里或者在你的代码所依赖的<code>.d.ts</code>里。</p>
<p>首先，编译器会尝试定位表示导入模块的文件。 编译器会遵循以下二种策略之一：<a href="zh/reference/module-resolution.html#classic">Classic</a>或<a href="zh/reference/module-resolution.html#node">Node</a>。 这些策略会告诉编译器到_哪里_去查找<code>moduleA</code>。</p>
<p>如果上面的解析失败了并且模块名是非相对的（且是在<code>"moduleA"</code>的情况下），编译器会尝试定位一个<a href="zh/reference/modules.html#ambient-modules">外部模块声明</a>。 我们接下来会讲到非相对导入。</p>
<p>最后，如果编译器还是不能解析这个模块，它会记录一个错误。 在这种情况下，错误可能为<code>error TS2307: Cannot find module 'moduleA'.</code></p>
<h2 id="相对-vs-非相对模块导入"><a class="header" href="#相对-vs-非相对模块导入">相对 vs. 非相对模块导入</a></h2>
<p>根据模块引用是相对的还是非相对的，模块导入会以不同的方式解析。</p>
<p>_相对导入_是以<code>/</code>，<code>./</code>或<code>../</code>开头的。 下面是一些例子：</p>
<ul>
<li><code>import Entry from "./components/Entry";</code></li>
<li><code>import { DefaultHeaders } from "../constants/http";</code></li>
<li><code>import "/mod";</code></li>
</ul>
<p>所有其它形式的导入被当作_非相对_的。 下面是一些例子：</p>
<ul>
<li><code>import * as $ from "jQuery";</code></li>
<li><code>import { Component } from "@angular/core";</code></li>
</ul>
<p>相对导入在解析时是相对于导入它的文件，并且_不能_解析为一个外部模块声明。 你应该为你自己写的模块使用相对导入，这样能确保它们在运行时的相对位置。</p>
<p>非相对模块的导入可以相对于<code>baseUrl</code>或通过下文会讲到的路径映射来进行解析。 它们还可以被解析成<a href="zh/reference/modules.html#ambient-modules">外部模块声明</a>。 使用非相对路径来导入你的外部依赖。</p>
<h2 id="模块解析策略"><a class="header" href="#模块解析策略">模块解析策略</a></h2>
<p>共有两种可用的模块解析策略：<a href="zh/reference/module-resolution.html#node">Node</a>和<a href="zh/reference/module-resolution.html#classic">Classic</a>。 你可以使用<code>--moduleResolution</code>标记来指定使用哪种模块解析策略。 若未指定，那么在使用了<code>--module AMD | System | ES2015</code>时的默认值为<a href="zh/reference/module-resolution.html#classic">Classic</a>，其它情况时则为<a href="zh/reference/module-resolution.html#node">Node</a>。</p>
<h3 id="classic"><a class="header" href="#classic">Classic</a></h3>
<p>这种策略在以前是TypeScript默认的解析策略。 现在，它存在的理由主要是为了向后兼容。</p>
<p>相对导入的模块是相对于导入它的文件进行解析的。 因此<code>/root/src/folder/A.ts</code>文件里的<code>import { b } from "./moduleB"</code>会使用下面的查找流程：</p>
<ol>
<li><code>/root/src/folder/moduleB.ts</code></li>
<li><code>/root/src/folder/moduleB.d.ts</code></li>
</ol>
<p>对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。</p>
<p>比如：</p>
<p>有一个对<code>moduleB</code>的非相对导入<code>import { b } from "moduleB"</code>，它是在<code>/root/src/folder/A.ts</code>文件里，会以如下的方式来定位<code>"moduleB"</code>：</p>
<ol>
<li><code>/root/src/folder/moduleB.ts</code></li>
<li><code>/root/src/folder/moduleB.d.ts</code></li>
<li><code>/root/src/moduleB.ts</code></li>
<li><code>/root/src/moduleB.d.ts</code></li>
<li><code>/root/moduleB.ts</code></li>
<li><code>/root/moduleB.d.ts</code></li>
<li><code>/moduleB.ts</code></li>
<li><code>/moduleB.d.ts</code></li>
</ol>
<h3 id="node"><a class="header" href="#node">Node</a></h3>
<p>这个解析策略试图在运行时模仿<a href="https://nodejs.org/">Node.js</a>模块解析机制。 完整的Node.js解析算法可以在<a href="https://nodejs.org/api/modules.html#modules_all_together">Node.js module documentation</a>找到。</p>
<h4 id="nodejs如何解析模块"><a class="header" href="#nodejs如何解析模块">Node.js如何解析模块</a></h4>
<p>为了理解TypeScript编译依照的解析步骤，先弄明白Node.js模块是非常重要的。 通常，在Node.js里导入是通过<code>require</code>函数调用进行的。 Node.js会根据<code>require</code>的是相对路径还是非相对路径做出不同的行为。</p>
<p>相对路径很简单。 例如，假设有一个文件路径为<code>/root/src/moduleA.js</code>，包含了一个导入<code>var x = require("./moduleB");</code> Node.js以下面的顺序解析这个导入：</p>
<ol>
<li>检查<code>/root/src/moduleB.js</code>文件是否存在。</li>
<li>检查<code>/root/src/moduleB</code>目录是否包含一个<code>package.json</code>文件，且<code>package.json</code>文件指定了一个<code>"main"</code>模块。 在我们的例子里，如果Node.js发现文件<code>/root/src/moduleB/package.json</code>包含了<code>{ "main": "lib/mainModule.js" }</code>，那么Node.js会引用<code>/root/src/moduleB/lib/mainModule.js</code>。</li>
<li>检查<code>/root/src/moduleB</code>目录是否包含一个<code>index.js</code>文件。 这个文件会被隐式地当作那个文件夹下的"main"模块。</li>
</ol>
<p>你可以阅读Node.js文档了解更多详细信息：<a href="https://nodejs.org/api/modules.html#modules_file_modules">file modules</a> 和 <a href="https://nodejs.org/api/modules.html#modules_folders_as_modules">folder modules</a>。</p>
<p>但是，<a href="zh/reference/module-resolution.html#relative-vs-non-relative-module-imports">非相对模块名</a>的解析是个完全不同的过程。 Node会在一个特殊的文件夹<code>node_modules</code>里查找你的模块。 <code>node_modules</code>可能与当前文件在同一级目录下，或者在上层目录里。 Node会向上级目录遍历，查找每个<code>node_modules</code>直到它找到要加载的模块。</p>
<p>还是用上面例子，但假设<code>/root/src/moduleA.js</code>里使用的是非相对路径导入<code>var x = require("moduleB");</code>。 Node则会以下面的顺序去解析<code>moduleB</code>，直到有一个匹配上。</p>
<ol>
<li><code>/root/src/node_modules/moduleB.js</code></li>
<li><code>/root/src/node_modules/moduleB/package.json</code> (如果指定了<code>"main"</code>属性)</li>
<li><code>/root/src/node_modules/moduleB/index.js</code></li>
<li><code>/root/node_modules/moduleB.js</code></li>
<li><code>/root/node_modules/moduleB/package.json</code> (如果指定了<code>"main"</code>属性)</li>
<li><code>/root/node_modules/moduleB/index.js</code></li>
<li><code>/node_modules/moduleB.js</code></li>
<li><code>/node_modules/moduleB/package.json</code> (如果指定了<code>"main"</code>属性)</li>
<li><code>/node_modules/moduleB/index.js</code></li>
</ol>
<p>注意Node.js在步骤（4）和（7）会向上跳一级目录。</p>
<p>你可以阅读Node.js文档了解更多详细信息：<a href="https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders">loading modules from <code>node_modules</code></a>。</p>
<h4 id="typescript如何解析模块"><a class="header" href="#typescript如何解析模块">TypeScript如何解析模块</a></h4>
<p>TypeScript是模仿Node.js运行时的解析策略来在编译阶段定位模块定义文件。 因此，TypeScript在Node解析逻辑基础上增加了TypeScript源文件的扩展名（<code>.ts</code>，<code>.tsx</code>和<code>.d.ts</code>）。 同时，TypeScript在<code>package.json</code>里使用字段<code>"types"</code>来表示类似<code>"main"</code>的意义 - 编译器会使用它来找到要使用的"main"定义文件。</p>
<p>比如，有一个导入语句<code>import { b } from "./moduleB"</code>在<code>/root/src/moduleA.ts</code>里，会以下面的流程来定位<code>"./moduleB"</code>：</p>
<ol>
<li><code>/root/src/moduleB.ts</code></li>
<li><code>/root/src/moduleB.tsx</code></li>
<li><code>/root/src/moduleB.d.ts</code></li>
<li><code>/root/src/moduleB/package.json</code> (如果指定了<code>"types"</code>属性)</li>
<li><code>/root/src/moduleB/index.ts</code></li>
<li><code>/root/src/moduleB/index.tsx</code></li>
<li><code>/root/src/moduleB/index.d.ts</code></li>
</ol>
<p>回想一下Node.js先查找<code>moduleB.js</code>文件，然后是合适的<code>package.json</code>，再之后是<code>index.js</code>。</p>
<p>类似地，非相对的导入会遵循Node.js的解析逻辑，首先查找文件，然后是合适的文件夹。 因此<code>/root/src/moduleA.ts</code>文件里的<code>import { b } from "moduleB"</code>会以下面的查找顺序解析：</p>
<ol>
<li><code>/root/src/node_modules/moduleB.ts</code></li>
<li><code>/root/src/node_modules/moduleB.tsx</code></li>
<li><code>/root/src/node_modules/moduleB.d.ts</code></li>
<li><code>/root/src/node_modules/moduleB/package.json</code> (如果指定了<code>"types"</code>属性)</li>
<li><code>/root/src/node_modules/@types/moduleB.d.ts</code></li>
<li><code>/root/src/node_modules/moduleB/index.ts</code></li>
<li><code>/root/src/node_modules/moduleB/index.tsx</code></li>
<li><code>/root/src/node_modules/moduleB/index.d.ts</code></li>
<li><code>/root/node_modules/moduleB.ts</code></li>
<li><code>/root/node_modules/moduleB.tsx</code></li>
<li><code>/root/node_modules/moduleB.d.ts</code></li>
<li><code>/root/node_modules/moduleB/package.json</code> (如果指定了<code>"types"</code>属性)</li>
<li><code>/root/node_modules/@types/moduleB.d.ts</code></li>
<li><code>/root/node_modules/moduleB/index.ts</code></li>
<li><code>/root/node_modules/moduleB/index.tsx</code></li>
<li><code>/root/node_modules/moduleB/index.d.ts</code></li>
<li><code>/node_modules/moduleB.ts</code></li>
<li><code>/node_modules/moduleB.tsx</code></li>
<li><code>/node_modules/moduleB.d.ts</code></li>
<li><code>/node_modules/moduleB/package.json</code> (如果指定了<code>"types"</code>属性)</li>
<li><code>/node_modules/@types/moduleB.d.ts</code></li>
<li><code>/node_modules/moduleB/index.ts</code></li>
<li><code>/node_modules/moduleB/index.tsx</code></li>
<li><code>/node_modules/moduleB/index.d.ts</code></li>
</ol>
<p>不要被这里步骤的数量吓到 - TypeScript只是在步骤（9）和（17）向上跳了两次目录。 这并不比Node.js里的流程复杂。</p>
<h2 id="附加的模块解析标记"><a class="header" href="#附加的模块解析标记">附加的模块解析标记</a></h2>
<p>有时工程源码结构与输出结构不同。 通常是要经过一系统的构建步骤最后生成输出。 它们包括将<code>.ts</code>编译成<code>.js</code>，将不同位置的依赖拷贝至一个输出位置。 最终结果就是运行时的模块名与包含它们声明的源文件里的模块名不同。 或者最终输出文件里的模块路径与编译时的源文件路径不同了。</p>
<p>TypeScript编译器有一些额外的标记用来_通知_编译器在源码编译成最终输出的过程中都发生了哪个转换。</p>
<p>有一点要特别注意的是编译器_不会_进行这些转换操作； 它只是利用这些信息来指导模块的导入。</p>
<h3 id="base-url"><a class="header" href="#base-url">Base URL</a></h3>
<p>在利用AMD模块加载器的应用里使用<code>baseUrl</code>是常见做法，它要求在运行时模块都被放到了一个文件夹里。 这些模块的源码可以在不同的目录下，但是构建脚本会将它们集中到一起。</p>
<p>设置<code>baseUrl</code>来告诉编译器到哪里去查找模块。 所有非相对模块导入都会被当做相对于<code>baseUrl</code>。</p>
<p>_baseUrl_的值由以下两者之一决定：</p>
<ul>
<li>命令行中_baseUrl_的值（如果给定的路径是相对的，那么将相对于当前路径进行计算）</li>
<li>‘tsconfig.json’里的_baseUrl_属性（如果给定的路径是相对的，那么将相对于‘tsconfig.json’路径进行计算）</li>
</ul>
<p>注意相对模块的导入不会被设置的<code>baseUrl</code>所影响，因为它们总是相对于导入它们的文件。</p>
<p>阅读更多关于<code>baseUrl</code>的信息<a href="http://requirejs.org/docs/api.html#config-baseUrl">RequireJS</a>和<a href="https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#baseurl">SystemJS</a>。</p>
<h3 id="路径映射"><a class="header" href="#路径映射">路径映射</a></h3>
<p>有时模块不是直接放在_baseUrl_下面。 比如，充分<code>"jquery"</code>模块地导入，在运行时可能被解释为<code>"node_modules/jquery/dist/jquery.slim.min.js"</code>。 加载器使用映射配置来将模块名映射到运行时的文件，查看<a href="http://requirejs.org/docs/api.html#config-paths">RequireJs documentation</a>和<a href="https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths">SystemJS documentation</a>。</p>
<p>TypeScript编译器通过使用<code>tsconfig.json</code>文件里的<code>"paths"</code>来支持这样的声明映射。 下面是一个如何指定<code>jquery</code>的<code>"paths"</code>的例子。</p>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "baseUrl": ".", // This must be specified if "paths" is.
    "paths": {
      "jquery": ["node_modules/jquery/dist/jquery"] // 此处映射是相对于"baseUrl"
    }
  }
}
</code></pre>
<p>请注意<code>"paths"</code>是相对于<code>"baseUrl"</code>进行解析。 如果<code>"baseUrl"</code>被设置成了除<code>"."</code>外的其它值，比如<code>tsconfig.json</code>所在的目录，那么映射必须要做相应的改变。 如果你在上例中设置了<code>"baseUrl": "./src"</code>，那么jquery应该映射到<code>"../node_modules/jquery/dist/jquery"</code>。</p>
<p>通过<code>"paths"</code>我们还可以指定复杂的映射，包括指定多个回退位置。 假设在一个工程配置里，有一些模块位于一处，而其它的则在另个的位置。 构建过程会将它们集中至一处。 工程结构可能如下：</p>
<pre><code class="language-text">projectRoot
├── folder1
│   ├── file1.ts (imports 'folder1/file2' and 'folder2/file3')
│   └── file2.ts
├── generated
│   ├── folder1
│   └── folder2
│       └── file3.ts
└── tsconfig.json
</code></pre>
<p>相应的<code>tsconfig.json</code>文件如下：</p>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "*": [
        "*",
        "generated/*"
      ]
    }
  }
}
</code></pre>
<p>它告诉编译器所有匹配<code>"*"</code>（所有的值）模式的模块导入会在以下两个位置查找：</p>
<ol>
<li><code>"*"</code>： 表示名字不发生改变，所以映射为<code>&lt;moduleName&gt;</code> =&gt; <code>&lt;baseUrl&gt;/&lt;moduleName&gt;</code></li>
<li><code>"generated/*"</code>表示模块名添加了“generated”前缀，所以映射为<code>&lt;moduleName&gt;</code> =&gt; <code>&lt;baseUrl&gt;/generated/&lt;moduleName&gt;</code></li>
</ol>
<p>按照这个逻辑，编译器将会如下尝试解析这两个导入：</p>
<ul>
<li>导入'folder1/file2'
<ol>
<li>匹配'*'模式且通配符捕获到整个名字。</li>
<li>尝试列表里的第一个替换：'*' -&gt; <code>folder1/file2</code>。</li>
<li>替换结果为非相对名 - 与_baseUrl_合并 -&gt; <code>projectRoot/folder1/file2.ts</code>。</li>
<li>文件存在。完成。</li>
</ol>
</li>
<li>导入'folder2/file3'
<ol>
<li>匹配'*'模式且通配符捕获到整个名字。</li>
<li>尝试列表里的第一个替换：'*' -&gt; <code>folder2/file3</code>。</li>
<li>替换结果为非相对名 - 与_baseUrl_合并 -&gt; <code>projectRoot/folder2/file3.ts</code>。</li>
<li>文件不存在，跳到第二个替换。</li>
<li>第二个替换：'generated/*' -&gt; <code>generated/folder2/file3</code>。</li>
<li>替换结果为非相对名 - 与_baseUrl_合并 -&gt; <code>projectRoot/generated/folder2/file3.ts</code>。</li>
<li>文件存在。完成。</li>
</ol>
</li>
</ul>
<h3 id="利用rootdirs指定虚拟目录"><a class="header" href="#利用rootdirs指定虚拟目录">利用<code>rootDirs</code>指定虚拟目录</a></h3>
<p>有时多个目录下的工程源文件在编译时会进行合并放在某个输出目录下。 这可以看做一些源目录创建了一个“虚拟”目录。</p>
<p>利用<code>rootDirs</code>，可以告诉编译器生成这个虚拟目录的_roots_； 因此编译器可以在“虚拟”目录下解析相对模块导入，就_好像_它们被合并在了一起一样。</p>
<p>比如，有下面的工程结构：</p>
<pre><code class="language-text"> src
 └── views
     └── view1.ts (imports './template1')
     └── view2.ts

 generated
 └── templates
         └── views
             └── template1.ts (imports './view2')
</code></pre>
<p><code>src/views</code>里的文件是用于控制UI的用户代码。 <code>generated/templates</code>是UI模版，在构建时通过模版生成器自动生成。 构建中的一步会将<code>/src/views</code>和<code>/generated/templates/views</code>的输出拷贝到同一个目录下。 在运行时，视图可以假设它的模版与它同在一个目录下，因此可以使用相对导入<code>"./template"</code>。</p>
<p>可以使用<code>"rootDirs"</code>来告诉编译器。 <code>"rootDirs"</code>指定了一个_roots_列表，列表里的内容会在运行时被合并。 因此，针对这个例子，<code>tsconfig.json</code>如下：</p>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "rootDirs": [
      "src/views",
      "generated/templates/views"
    ]
  }
}
</code></pre>
<p>每当编译器在某一<code>rootDirs</code>的子目录下发现了相对模块导入，它就会尝试从每一个<code>rootDirs</code>中导入。</p>
<p><code>rootDirs</code>的灵活性不仅仅局限于其指定了要在逻辑上合并的物理目录列表。它提供的数组可以包含任意数量的任何名字的目录，不论它们是否存在。这允许编译器以类型安全的方式处理复杂捆绑(bundles)和运行时的特性，比如条件引入和工程特定的加载器插件。</p>
<p>设想这样一个国际化的场景，构建工具自动插入特定的路径记号来生成针对不同区域的捆绑，比如将<code>#{locale}</code>做为相对模块路径<code>./#{locale}/messages</code>的一部分。在这个假定的设置下，工具会枚举支持的区域，将抽像的路径映射成<code>./zh/messages</code>，<code>./de/messages</code>等。</p>
<p>假设每个模块都会导出一个字符串的数组。比如<code>./zh/messages</code>可能包含：</p>
<pre><code class="language-typescript">export default [
    "您好吗",
    "很高兴认识你"
];
</code></pre>
<p>利用<code>rootDirs</code>我们可以让编译器了解这个映射关系，从而也允许编译器能够安全地解析<code>./#{locale}/messages</code>，就算这个目录永远都不存在。比如，使用下面的<code>tsconfig.json</code>：</p>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "rootDirs": [
      "src/zh",
      "src/de",
      "src/#{locale}"
    ]
  }
}
</code></pre>
<p>编译器现在可以将<code>import messages from './#{locale}/messages'</code>解析为<code>import messages from './zh/messages'</code>用做工具支持的目的，并允许在开发时不必了解区域信息。</p>
<h2 id="跟踪模块解析"><a class="header" href="#跟踪模块解析">跟踪模块解析</a></h2>
<p>如之前讨论，编译器在解析模块时可能访问当前文件夹外的文件。 这会导致很难诊断模块为什么没有被解析，或解析到了错误的位置。 通过<code>--traceResolution</code>启用编译器的模块解析跟踪，它会告诉我们在模块解析过程中发生了什么。</p>
<p>假设我们有一个使用了<code>typescript</code>模块的简单应用。 <code>app.ts</code>里有一个这样的导入<code>import * as ts from "typescript"</code>。</p>
<pre><code class="language-text">│   tsconfig.json
├───node_modules
│   └───typescript
│       └───lib
│               typescript.d.ts
└───src
        app.ts
</code></pre>
<p>使用<code>--traceResolution</code>调用编译器。</p>
<pre><code class="language-text">tsc --traceResolution
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-text">======== Resolving module 'typescript' from 'src/app.ts'. ========
Module resolution kind is not specified, using 'NodeJs'.
Loading module 'typescript' from 'node_modules' folder.
File 'src/node_modules/typescript.ts' does not exist.
File 'src/node_modules/typescript.tsx' does not exist.
File 'src/node_modules/typescript.d.ts' does not exist.
File 'src/node_modules/typescript/package.json' does not exist.
File 'node_modules/typescript.ts' does not exist.
File 'node_modules/typescript.tsx' does not exist.
File 'node_modules/typescript.d.ts' does not exist.
Found 'package.json' at 'node_modules/typescript/package.json'.
'package.json' has 'types' field './lib/typescript.d.ts' that references 'node_modules/typescript/lib/typescript.d.ts'.
File 'node_modules/typescript/lib/typescript.d.ts' exist - use it as a module resolution result.
======== Module name 'typescript' was successfully resolved to 'node_modules/typescript/lib/typescript.d.ts'. ========
</code></pre>
<h4 id="需要留意的地方"><a class="header" href="#需要留意的地方">需要留意的地方</a></h4>
<ul>
<li>
<p>导入的名字及位置</p>
<blockquote>
<p>======== Resolving module <strong>'typescript'</strong> from <strong>'src/app.ts'</strong>. ========</p>
</blockquote>
</li>
<li>
<p>编译器使用的策略</p>
<blockquote>
<p>Module resolution kind is not specified, using <strong>'NodeJs'</strong>.</p>
</blockquote>
</li>
<li>
<p>从npm加载types</p>
<blockquote>
<p>'package.json' has <strong>'types'</strong> field './lib/typescript.d.ts' that references 'node_modules/typescript/lib/typescript.d.ts'.</p>
</blockquote>
</li>
<li>
<p>最终结果</p>
<blockquote>
<p>======== Module name 'typescript' was <strong>successfully resolved</strong> to 'node_modules/typescript/lib/typescript.d.ts'. ========</p>
</blockquote>
</li>
</ul>
<h2 id="使用--noresolve"><a class="header" href="#使用--noresolve">使用<code>--noResolve</code></a></h2>
<p>正常来讲编译器会在开始编译之前解析模块导入。 每当它成功地解析了对一个文件<code>import</code>，这个文件被会加到一个文件列表里，以供编译器稍后处理。</p>
<p><code>--noResolve</code>编译选项告诉编译器不要添加任何不是在命令行上传入的文件到编译列表。 编译器仍然会尝试解析模块，但是只要没有指定这个文件，那么它就不会被包含在内。</p>
<p>比如</p>
<h4 id="appts"><a class="header" href="#appts">app.ts</a></h4>
<pre><code class="language-typescript">import * as A from "moduleA" // OK, moduleA passed on the command-line
import * as B from "moduleB" // Error TS2307: Cannot find module 'moduleB'.
</code></pre>
<pre><code class="language-text">tsc app.ts moduleA.ts --noResolve
</code></pre>
<p>使用<code>--noResolve</code>编译<code>app.ts</code>：</p>
<ul>
<li>可能正确找到<code>moduleA</code>，因为它在命令行上指定了。</li>
<li>找不到<code>moduleB</code>，因为没有在命令行上传递。</li>
</ul>
<h2 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h2>
<h3 id="为什么在exclude列表里的模块还会被编译器使用"><a class="header" href="#为什么在exclude列表里的模块还会被编译器使用">为什么在<code>exclude</code>列表里的模块还会被编译器使用</a></h3>
<p><code>tsconfig.json</code>将文件夹转变一个“工程” 如果不指定任何<code>“exclude”</code>或<code>“files”</code>，文件夹里的所有文件包括<code>tsconfig.json</code>和所有的子目录都会在编译列表里。 如果你想利用<code>“exclude”</code>排除某些文件，甚至你想指定所有要编译的文件列表，请使用<code>“files”</code>。</p>
<p>有些是被<code>tsconfig.json</code>自动加入的。 它不会涉及到上面讨论的模块解析。 如果编译器识别出一个文件是模块导入目标，它就会加到编译列表里，不管它是否被排除了。</p>
<p>因此，要从编译列表中排除一个文件，你需要在排除它的同时，还要排除所有对它进行<code>import</code>或使用了<code>/// &lt;reference path="..." /&gt;</code>指令的文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h1>
<blockquote>
<p><strong>关于术语的一点说明:</strong> 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与<a href="http://www.ecma-international.org/ecma-262/6.0/">ECMAScript 2015</a>里的术语保持一致，(也就是说 <code>module X {</code> 相当于现在推荐的写法 <code>namespace X {</code>)。</p>
</blockquote>
<h2 id="介绍-12"><a class="header" href="#介绍-12">介绍</a></h2>
<p>这篇文章描述了如何在TypeScript里使用命名空间（之前叫做“内部模块”）来组织你的代码。 就像我们在术语说明里提到的那样，“内部模块”现在叫做“命名空间”。 另外，任何使用<code>module</code>关键字来声明一个内部模块的地方都应该使用<code>namespace</code>关键字来替换。 这就避免了让新的使用者被相似的名称所迷惑。</p>
<h2 id="第一步"><a class="header" href="#第一步">第一步</a></h2>
<p>我们先来写一段程序并将在整篇文章中都使用这个例子。 我们定义几个简单的字符串验证器，假设你会使用它们来验证表单里的用户输入或验证外部数据。</p>
<h3 id="所有的验证器都放在一个文件里"><a class="header" href="#所有的验证器都放在一个文件里">所有的验证器都放在一个文件里</a></h3>
<pre><code class="language-typescript">interface StringValidator {
    isAcceptable(s: string): boolean;
}

let lettersRegexp = /^[A-Za-z]+$/;
let numberRegexp = /^[0-9]+$/;

class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
        return lettersRegexp.test(s);
    }
}

class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}

// Some samples to try
let strings = ["Hello", "98052", "101"];

// Validators to use
let validators: { [s: string]: StringValidator; } = {};
validators["ZIP code"] = new ZipCodeValidator();
validators["Letters only"] = new LettersOnlyValidator();

// Show whether each string passed each validator
for (let s of strings) {
    for (let name in validators) {
        let isMatch = validators[name].isAcceptable(s);
        console.log(`'${ s }' ${ isMatch ? "matches" : "does not match" } '${ name }'.`);
    }
}
</code></pre>
<h2 id="命名空间-1"><a class="header" href="#命名空间-1">命名空间</a></h2>
<p>随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。 因此，我们把验证器包裹到一个命名空间内，而不是把它们放在全局命名空间下。</p>
<p>下面的例子里，把所有与验证器相关的类型都放到一个叫做<code>Validation</code>的命名空间里。 因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用<code>export</code>。 相反的，变量<code>lettersRegexp</code>和<code>numberRegexp</code>是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。 在文件末尾的测试代码里，由于是在命名空间之外访问，因此需要限定类型的名称，比如<code>Validation.LettersOnlyValidator</code>。</p>
<h3 id="使用命名空间的验证器"><a class="header" href="#使用命名空间的验证器">使用命名空间的验证器</a></h3>
<pre><code class="language-typescript">namespace Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }

    const lettersRegexp = /^[A-Za-z]+$/;
    const numberRegexp = /^[0-9]+$/;

    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }

    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}

// Some samples to try
let strings = ["Hello", "98052", "101"];

// Validators to use
let validators: { [s: string]: Validation.StringValidator; } = {};
validators["ZIP code"] = new Validation.ZipCodeValidator();
validators["Letters only"] = new Validation.LettersOnlyValidator();

// Show whether each string passed each validator
for (let s of strings) {
    for (let name in validators) {
        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);
    }
}
</code></pre>
<h2 id="分离到多文件"><a class="header" href="#分离到多文件">分离到多文件</a></h2>
<p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。</p>
<h3 id="多文件中的命名空间"><a class="header" href="#多文件中的命名空间">多文件中的命名空间</a></h3>
<p>现在，我们把<code>Validation</code>命名空间分割成多个文件。 尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。 因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。 我们的测试代码保持不变。</p>
<h4 id="validationts"><a class="header" href="#validationts">Validation.ts</a></h4>
<pre><code class="language-typescript">namespace Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }
}
</code></pre>
<h4 id="lettersonlyvalidatorts"><a class="header" href="#lettersonlyvalidatorts">LettersOnlyValidator.ts</a></h4>
<pre><code class="language-typescript">/// &lt;reference path="Validation.ts" /&gt;
namespace Validation {
    const lettersRegexp = /^[A-Za-z]+$/;
    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }
}
</code></pre>
<h4 id="zipcodevalidatorts"><a class="header" href="#zipcodevalidatorts">ZipCodeValidator.ts</a></h4>
<pre><code class="language-typescript">/// &lt;reference path="Validation.ts" /&gt;
namespace Validation {
    const numberRegexp = /^[0-9]+$/;
    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}
</code></pre>
<h4 id="testts"><a class="header" href="#testts">Test.ts</a></h4>
<pre><code class="language-typescript">/// &lt;reference path="Validation.ts" /&gt;
/// &lt;reference path="LettersOnlyValidator.ts" /&gt;
/// &lt;reference path="ZipCodeValidator.ts" /&gt;

// Some samples to try
let strings = ["Hello", "98052", "101"];

// Validators to use
let validators: { [s: string]: Validation.StringValidator; } = {};
validators["ZIP code"] = new Validation.ZipCodeValidator();
validators["Letters only"] = new Validation.LettersOnlyValidator();

// Show whether each string passed each validator
for (let s of strings) {
    for (let name in validators) {
        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);
    }
}
</code></pre>
<p>当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。 我们有两种方式。</p>
<p>第一种方式，把所有的输入文件编译为一个输出文件，需要使用<code>--outFile</code>标记：</p>
<pre><code class="language-text">tsc --outFile sample.js Test.ts
</code></pre>
<p>编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。</p>
<pre><code class="language-text">tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts
</code></pre>
<p>第二种方式，我们可以编译每一个文件（默认方式），那么每个源文件都会对应生成一个JavaScript文件。 然后，在页面上通过<code>&lt;script&gt;</code>标签把所有生成的JavaScript文件按正确的顺序引进来，比如：</p>
<h4 id="mytestpagehtml-excerpt"><a class="header" href="#mytestpagehtml-excerpt">MyTestPage.html (excerpt)</a></h4>
<pre><code class="language-markup">    &lt;script src="Validation.js" type="text/javascript" /&gt;
    &lt;script src="LettersOnlyValidator.js" type="text/javascript" /&gt;
    &lt;script src="ZipCodeValidator.js" type="text/javascript" /&gt;
    &lt;script src="Test.js" type="text/javascript" /&gt;
</code></pre>
<h2 id="别名"><a class="header" href="#别名">别名</a></h2>
<p>另一种简化命名空间操作的方法是使用<code>import q = x.y.z</code>给常用的对象起一个短的名字。 不要与用来加载模块的<code>import x = require('name')</code>语法弄混了，这里的语法是为指定的符号创建一个别名。 你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。</p>
<pre><code class="language-typescript">namespace Shapes {
    export namespace Polygons {
        export class Triangle { }
        export class Square { }
    }
}

import polygons = Shapes.Polygons;
let sq = new polygons.Square(); // Same as "new Shapes.Polygons.Square()"
</code></pre>
<p>注意，我们并没有使用<code>require</code>关键字，而是直接使用导入符号的限定名赋值。 这与使用<code>var</code>相似，但它还适用于类型和导入的具有命名空间含义的符号。 重要的是，对于值来讲，<code>import</code>会生成与原始符号不同的引用，所以改变别名的<code>var</code>值并不会影响原始变量的值。</p>
<h2 id="使用其它的javascript库-1"><a class="header" href="#使用其它的javascript库-1">使用其它的JavaScript库</a></h2>
<p>为了描述不是用TypeScript编写的类库的类型，我们需要声明类库导出的API。 由于大部分程序库只提供少数的顶级对象，命名空间是用来表示它们的一个好办法。</p>
<p>我们称其为声明是因为它不是外部程序的具体实现。 我们通常在<code>.d.ts</code>里写这些声明。 如果你熟悉C/C++，你可以把它们当做<code>.h</code>文件。 让我们看一些例子。</p>
<h3 id="外部命名空间"><a class="header" href="#外部命名空间">外部命名空间</a></h3>
<p>流行的程序库D3在全局对象<code>d3</code>里定义它的功能。 因为这个库通过一个<code>&lt;script&gt;</code>标签加载（不是通过模块加载器），它的声明文件使用内部模块来定义它的类型。 为了让TypeScript编译器识别它的类型，我们使用外部命名空间声明。 比如，我们可以像下面这样写：</p>
<h4 id="d3dts-部分摘录"><a class="header" href="#d3dts-部分摘录">D3.d.ts (部分摘录)</a></h4>
<pre><code class="language-typescript">declare namespace D3 {
    export interface Selectors {
        select: {
            (selector: string): Selection;
            (element: EventTarget): Selection;
        };
    }

    export interface Event {
        x: number;
        y: number;
    }

    export interface Base extends Selectors {
        event: Event;
    }
}

declare var d3: D3.Base;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名空间和模块"><a class="header" href="#命名空间和模块">命名空间和模块</a></h1>
<blockquote>
<p><strong>关于术语的一点说明:</strong> 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与<a href="http://www.ecma-international.org/ecma-262/6.0/">ECMAScript 2015</a>里的术语保持一致，(也就是说 <code>module X {</code> 相当于现在推荐的写法 <code>namespace X {</code>)。</p>
</blockquote>
<h2 id="介绍-13"><a class="header" href="#介绍-13">介绍</a></h2>
<p>这篇文章将概括介绍在TypeScript里使用模块与命名空间来组织代码的方法。 我们也会谈及命名空间和模块的高级使用场景，和在使用它们的过程中常见的陷阱。</p>
<p>查看<a href="zh/reference/modules.html">模块</a>章节了解关于模块的更多信息。 查看<a href="zh/reference/namespaces.html">命名空间</a>章节了解关于命名空间的更多信息。</p>
<h2 id="使用命名空间"><a class="header" href="#使用命名空间">使用命名空间</a></h2>
<p>命名空间是位于全局命名空间下的一个普通的带有名字的JavaScript对象。 这令命名空间十分容易使用。 它们可以在多文件中同时使用，并通过<code>--outFile</code>结合在一起。 命名空间是帮你组织Web应用不错的方式，你可以把所有依赖都放在HTML页面的<code>&lt;script&gt;</code>标签里。</p>
<p>但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中。</p>
<h2 id="使用模块"><a class="header" href="#使用模块">使用模块</a></h2>
<p>像命名空间一样，模块可以包含代码和声明。 不同的是模块可以_声明_它的依赖。</p>
<p>模块会把依赖添加到模块加载器上（例如CommonJs / Require.js）。 对于小型的JS应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。 模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。</p>
<p>对于Node.js应用来说，模块是默认并推荐的组织代码的方式。</p>
<p>从ECMAScript 2015开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。 因此，对于新项目来说推荐使用模块做为组织代码的方式。</p>
<h2 id="命名空间和模块的陷阱"><a class="header" href="#命名空间和模块的陷阱">命名空间和模块的陷阱</a></h2>
<p>这部分我们会描述常见的命名空间和模块的使用陷阱和如何去避免它们。</p>
<h3 id="对模块使用-reference"><a class="header" href="#对模块使用-reference">对模块使用<code>/// &lt;reference&gt;</code></a></h3>
<p>一个常见的错误是使用<code>/// &lt;reference&gt;</code>引用模块文件，应该使用<code>import</code>。 要理解这之间的区别，我们首先应该弄清编译器是如何根据<code>import</code>路径（例如，<code>import x from "...";</code>或<code>import x = require("...")</code>里面的<code>...</code>，等等）来定位模块的类型信息的。</p>
<p>编译器首先尝试去查找相应路径下的<code>.ts</code>，<code>.tsx</code>再或者<code>.d.ts</code>。 如果这些文件都找不到，编译器会查找_外部模块声明_。 回想一下，它们是在<code>.d.ts</code>文件里声明的。</p>
<ul>
<li><code>myModules.d.ts</code></li>
</ul>
<pre><code class="language-typescript">// In a .d.ts file or .ts file that is not a module:
declare module "SomeModule" {
    export function fn(): string;
}
</code></pre>
<ul>
<li><code>myOtherModule.ts</code></li>
</ul>
<pre><code class="language-typescript">/// &lt;reference path="myModules.d.ts" /&gt;
import * as m from "SomeModule";
</code></pre>
<p>这里的引用标签指定了外来模块的位置。 这就是一些TypeScript例子中引用<code>node.d.ts</code>的方法。</p>
<h3 id="不必要的命名空间"><a class="header" href="#不必要的命名空间">不必要的命名空间</a></h3>
<p>如果你想把命名空间转换为模块，它可能会像下面这个文件：</p>
<ul>
<li><code>shapes.ts</code></li>
</ul>
<pre><code class="language-typescript">export namespace Shapes {
    export class Triangle { /* ... */ }
    export class Square { /* ... */ }
}
</code></pre>
<p>顶层的模块<code>Shapes</code>包裹了<code>Triangle</code>和<code>Square</code>。 对于使用它的人来说这是令人迷惑和讨厌的：</p>
<ul>
<li><code>shapeConsumer.ts</code></li>
</ul>
<pre><code class="language-typescript">import * as shapes from "./shapes";
let t = new shapes.Shapes.Triangle(); // shapes.Shapes?
</code></pre>
<p>TypeScript里模块的一个特点是不同的模块永远也不会在相同的作用域内使用相同的名字。 因为使用模块的人会为它们命名，所以完全没有必要把导出的符号包裹在一个命名空间里。</p>
<p>再次重申，不应该对模块使用命名空间，使用命名空间是为了提供逻辑分组和避免命名冲突。 模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。</p>
<p>下面是改进的例子：</p>
<ul>
<li><code>shapes.ts</code></li>
</ul>
<pre><code class="language-typescript">export class Triangle { /* ... */ }
export class Square { /* ... */ }
</code></pre>
<ul>
<li><code>shapeConsumer.ts</code></li>
</ul>
<pre><code class="language-typescript">import * as shapes from "./shapes";
let t = new shapes.Triangle();
</code></pre>
<h3 id="模块的取舍"><a class="header" href="#模块的取舍">模块的取舍</a></h3>
<p>就像每个JS文件对应一个模块一样，TypeScript里模块文件与生成的JS文件也是一一对应的。 这会产生一种影响，根据你指定的目标模块系统的不同，你可能无法连接多个模块源文件。 例如当目标模块系统为<code>commonjs</code>或<code>umd</code>时，无法使用<code>outFile</code>选项，但是在TypeScript 1.8以上的版本<a href="zh/reference/../doc/handbook/release%20notes/TypeScript%201.8.html#concatenate-amd-and-system-modules-with---outfile">能够</a>使用<code>outFile</code>当目标为<code>amd</code>或<code>system</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="symbols"><a class="header" href="#symbols">Symbols</a></h1>
<h2 id="介绍-14"><a class="header" href="#介绍-14">介绍</a></h2>
<p>自ECMAScript 2015起，<code>symbol</code>成为了一种新的原生类型，就像<code>number</code>和<code>string</code>一样。</p>
<p><code>symbol</code>类型的值是通过<code>Symbol</code>构造函数创建的。</p>
<pre><code class="language-typescript">let sym1 = Symbol();

let sym2 = Symbol("key"); // 可选的字符串key
</code></pre>
<p>Symbols是不可改变且唯一的。</p>
<pre><code class="language-typescript">let sym2 = Symbol("key");
let sym3 = Symbol("key");

sym2 === sym3; // false, symbols是唯一的
</code></pre>
<p>像字符串一样，symbols也可以被用做对象属性的键。</p>
<pre><code class="language-typescript">const sym = Symbol();

let obj = {
    [sym]: "value"
};

console.log(obj[sym]); // "value"
</code></pre>
<p>Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员。</p>
<pre><code class="language-typescript">const getClassNameSymbol = Symbol();

class C {
    [getClassNameSymbol](){
       return "C";
    }
}

let c = new C();
let className = c[getClassNameSymbol](); // "C"
</code></pre>
<h2 id="众所周知的symbols"><a class="header" href="#众所周知的symbols">众所周知的Symbols</a></h2>
<p>除了用户定义的symbols，还有一些已经众所周知的内置symbols。 内置symbols用来表示语言内部的行为。</p>
<p>以下为这些symbols的列表：</p>
<h3 id="symbolhasinstance"><a class="header" href="#symbolhasinstance"><code>Symbol.hasInstance</code></a></h3>
<p>方法，会被<code>instanceof</code>运算符调用。构造器对象用来识别一个对象是否是其实例。</p>
<h3 id="symbolisconcatspreadable"><a class="header" href="#symbolisconcatspreadable"><code>Symbol.isConcatSpreadable</code></a></h3>
<p>布尔值，表示当在一个对象上调用<code>Array.prototype.concat</code>时，这个对象的数组元素是否可展开。</p>
<h3 id="symboliterator"><a class="header" href="#symboliterator"><code>Symbol.iterator</code></a></h3>
<p>方法，被<code>for-of</code>语句调用。返回对象的默认迭代器。</p>
<h3 id="symbolmatch"><a class="header" href="#symbolmatch"><code>Symbol.match</code></a></h3>
<p>方法，被<code>String.prototype.match</code>调用。正则表达式用来匹配字符串。</p>
<h3 id="symbolreplace"><a class="header" href="#symbolreplace"><code>Symbol.replace</code></a></h3>
<p>方法，被<code>String.prototype.replace</code>调用。正则表达式用来替换字符串中匹配的子串。</p>
<h3 id="symbolsearch"><a class="header" href="#symbolsearch"><code>Symbol.search</code></a></h3>
<p>方法，被<code>String.prototype.search</code>调用。正则表达式返回被匹配部分在字符串中的索引。</p>
<h3 id="symbolspecies"><a class="header" href="#symbolspecies"><code>Symbol.species</code></a></h3>
<p>函数值，为一个构造函数。用来创建派生对象。</p>
<h3 id="symbolsplit"><a class="header" href="#symbolsplit"><code>Symbol.split</code></a></h3>
<p>方法，被<code>String.prototype.split</code>调用。正则表达式来用分割字符串。</p>
<h3 id="symboltoprimitive"><a class="header" href="#symboltoprimitive"><code>Symbol.toPrimitive</code></a></h3>
<p>方法，被<code>ToPrimitive</code>抽象操作调用。把对象转换为相应的原始值。</p>
<h3 id="symboltostringtag"><a class="header" href="#symboltostringtag"><code>Symbol.toStringTag</code></a></h3>
<p>方法，被内置方法<code>Object.prototype.toString</code>调用。返回创建对象时默认的字符串描述。</p>
<h3 id="symbolunscopables"><a class="header" href="#symbolunscopables"><code>Symbol.unscopables</code></a></h3>
<p>对象，它自己拥有的属性会被<code>with</code>作用域排除在外。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三斜线指令"><a class="header" href="#三斜线指令">三斜线指令</a></h1>
<p>三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。</p>
<p>三斜线指令_仅_可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。</p>
<h2 id="-reference-path-"><a class="header" href="#-reference-path-"><code>/// &lt;reference path="..." /&gt;</code></a></h2>
<p><code>/// &lt;reference path="..." /&gt;</code>指令是三斜线指令中最常见的一种。 它用于声明文件间的_依赖_。</p>
<p>三斜线引用告诉编译器在编译过程中要引入的额外的文件。</p>
<p>当使用<code>--out</code>或<code>--outFile</code>时，它也可以做为调整输出内容顺序的一种方法。 文件在输出文件内容中的位置与经过预处理后的输入顺序一致。</p>
<h3 id="预处理输入文件"><a class="header" href="#预处理输入文件">预处理输入文件</a></h3>
<p>编译器会对输入文件进行预处理来解析所有三斜线引用指令。 在这个过程中，额外的文件会加到编译过程中。</p>
<p>这个过程会以一些_根文件_开始； 它们是在命令行中指定的文件或是在<code>tsconfig.json</code>中的<code>"files"</code>列表里的文件。 这些根文件按指定的顺序进行预处理。 在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。 三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。</p>
<p>一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。</p>
<h3 id="错误"><a class="header" href="#错误">错误</a></h3>
<p>引用不存在的文件会报错。 一个文件用三斜线指令引用自己会报错。</p>
<h3 id="使用---noresolve"><a class="header" href="#使用---noresolve">使用 <code>--noResolve</code></a></h3>
<p>如果指定了<code>--noResolve</code>编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。</p>
<h2 id="-reference-types-"><a class="header" href="#-reference-types-"><code>/// &lt;reference types="..." /&gt;</code></a></h2>
<p>与<code>/// &lt;reference path="..." /&gt;</code>指令相似（用于声明_依赖_），<code>/// &lt;reference types="..." /&gt;</code>指令声明了对某个包的依赖。</p>
<p>对这些包的名字的解析与在<code>import</code>语句里对模块名的解析类似。 可以简单地把三斜线类型引用指令当做<code>import</code>声明的包。</p>
<p>例如，把<code>/// &lt;reference types="node" /&gt;</code>引入到声明文件，表明这个文件使用了<code>@types/node/index.d.ts</code>里面声明的名字； 并且，这个包需要在编译阶段与声明文件一起被包含进来。</p>
<p>仅当在你需要写一个<code>d.ts</code>文件时才使用这个指令。</p>
<p>对于那些在编译阶段生成的声明文件，编译器会自动地添加<code>/// &lt;reference types="..." /&gt;</code>； _当且仅当_结果文件中使用了引用的包里的声明时才会在生成的声明文件里添加<code>/// &lt;reference types="..." /&gt;</code>语句。</p>
<p>若要在<code>.ts</code>文件里声明一个对<code>@types</code>包的依赖，使用<code>--types</code>命令行选项或在<code>tsconfig.json</code>里指定。 查看<a href="zh/reference/../project-config/tsconfig.json.html#types-typeroots-and-types">在<code>tsconfig.json</code>里使用<code>@types</code>，<code>typeRoots</code>和<code>types</code></a>了解详情。</p>
<h2 id="-reference-no-default-libtrue"><a class="header" href="#-reference-no-default-libtrue"><code>/// &lt;reference no-default-lib="true"/&gt;</code></a></h2>
<p>这个指令把一个文件标记成_默认库_。 你会在<code>lib.d.ts</code>文件和它不同的变体的顶端看到这个注释。</p>
<p>这个指令告诉编译器在编译过程中_不要_包含这个默认库（比如，<code>lib.d.ts</code>）。 这与在命令行上使用<code>--noLib</code>相似。</p>
<p>还要注意，当传递了<code>--skipDefaultLibCheck</code>时，编译器只会忽略检查带有<code>/// &lt;reference no-default-lib="true"/&gt;</code>的文件。</p>
<h2 id="-amd-module-"><a class="header" href="#-amd-module-"><code>/// &lt;amd-module /&gt;</code></a></h2>
<p>默认情况下生成的AMD模块都是匿名的。 但是，当一些工具需要处理生成的模块时会产生问题，比如<code>r.js</code>。</p>
<p><code>amd-module</code>指令允许给编译器传入一个可选的模块名：</p>
<h4 id="amdmodulets"><a class="header" href="#amdmodulets">amdModule.ts</a></h4>
<pre><code class="language-typescript">///&lt;amd-module name='NamedModule'/&gt;
export class C {
}
</code></pre>
<p>这会将<code>NamedModule</code>传入到AMD <code>define</code>函数里：</p>
<h4 id="amdmodulejs"><a class="header" href="#amdmodulejs">amdModule.js</a></h4>
<pre><code class="language-javascript">define("NamedModule", ["require", "exports"], function (require, exports) {
    var C = (function () {
        function C() {
        }
        return C;
    })();
    exports.C = C;
});
</code></pre>
<h2 id="-amd-dependency-"><a class="header" href="#-amd-dependency-"><code>/// &lt;amd-dependency /&gt;</code></a></h2>
<blockquote>
<p><strong>注意</strong>：这个指令被废弃了。使用<code>import "moduleName";</code>语句代替。</p>
</blockquote>
<p><code>/// &lt;amd-dependency path="x" /&gt;</code>告诉编译器有一个非TypeScript模块依赖需要被注入，做为目标模块<code>require</code>调用的一部分。</p>
<p><code>amd-dependency</code>指令也可以带一个可选的<code>name</code>属性；它允许我们为amd-dependency传入一个可选名字：</p>
<pre><code class="language-typescript">/// &lt;amd-dependency path="legacy/moduleA" name="moduleA"/&gt;
declare var moduleA:MyType
moduleA.callStuff()
</code></pre>
<p>生成的JavaScript代码：</p>
<pre><code class="language-javascript">define(["require", "exports", "legacy/moduleA"], function (require, exports, moduleA) {
    moduleA.callStuff()
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型兼容性"><a class="header" href="#类型兼容性">类型兼容性</a></h1>
<h2 id="介绍-15"><a class="header" href="#介绍-15">介绍</a></h2>
<p>TypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。） 看下面的例子：</p>
<pre><code class="language-typescript">interface Named {
    name: string;
}

class Person {
    name: string;
}

let p: Named;
// OK, because of structural typing
p = new Person();
</code></pre>
<p>在使用基于名义类型的语言，比如C#或Java中，这段代码会报错，因为Person类没有明确说明其实现了Named接口。</p>
<p>TypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的。 因为JavaScript里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。</p>
<h3 id="关于可靠性的注意事项"><a class="header" href="#关于可靠性的注意事项">关于可靠性的注意事项</a></h3>
<p>TypeScript的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。</p>
<h2 id="开始"><a class="header" href="#开始">开始</a></h2>
<p>TypeScript结构化类型系统的基本规则是，如果<code>x</code>要兼容<code>y</code>，那么<code>y</code>至少具有与<code>x</code>相同的属性。比如：</p>
<pre><code class="language-typescript">interface Named {
    name: string;
}

let x: Named;
// y's inferred type is { name: string; location: string; }
let y = { name: 'Alice', location: 'Seattle' };
x = y;
</code></pre>
<p>这里要检查<code>y</code>是否能赋值给<code>x</code>，编译器检查<code>x</code>中的每个属性，看是否能在<code>y</code>中也找到对应属性。 在这个例子中，<code>y</code>必须包含名字是<code>name</code>的<code>string</code>类型成员。<code>y</code>满足条件，因此赋值正确。</p>
<p>检查函数参数时使用相同的规则：</p>
<pre><code class="language-typescript">function greet(n: Named) {
    console.log('Hello, ' + n.name);
}
greet(y); // OK
</code></pre>
<p>注意，<code>y</code>有个额外的<code>location</code>属性，但这不会引发错误。 只有目标类型（这里是<code>Named</code>）的成员会被一一检查是否兼容。</p>
<p>这个比较过程是递归进行的，检查每个成员及子成员。</p>
<h2 id="比较两个函数"><a class="header" href="#比较两个函数">比较两个函数</a></h2>
<p>相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。 下面我们从两个简单的函数入手，它们仅是参数列表略有不同：</p>
<pre><code class="language-typescript">let x = (a: number) =&gt; 0;
let y = (b: number, s: string) =&gt; 0;

y = x; // OK
x = y; // Error
</code></pre>
<p>要查看<code>x</code>是否能赋值给<code>y</code>，首先看它们的参数列表。 <code>x</code>的每个参数必须能在<code>y</code>里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，<code>x</code>的每个参数在<code>y</code>中都能找到对应的参数，所以允许赋值。</p>
<p>第二个赋值错误，因为<code>y</code>有个必需的第二个参数，但是<code>x</code>并没有，所以不允许赋值。</p>
<p>你可能会疑惑为什么允许<code>忽略</code>参数，像例子<code>y = x</code>中那样。 原因是忽略额外的参数在JavaScript里是很常见的。 例如，<code>Array#forEach</code>给回调函数传3个参数：数组元素，索引和整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：</p>
<pre><code class="language-typescript">let items = [1, 2, 3];

// Don't force these extra arguments
items.forEach((item, index, array) =&gt; console.log(item));

// Should be OK!
items.forEach((item) =&gt; console.log(item));
</code></pre>
<p>下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数：</p>
<pre><code class="language-typescript">let x = () =&gt; ({name: 'Alice'});
let y = () =&gt; ({name: 'Alice', location: 'Seattle'});

x = y; // OK
y = x; // Error, because x() lacks a location property
</code></pre>
<p>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。</p>
<h3 id="函数参数双向协变"><a class="header" href="#函数参数双向协变">函数参数双向协变</a></h3>
<p>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。例如：</p>
<pre><code class="language-typescript">enum EventType { Mouse, Keyboard }

interface Event { timestamp: number; }
interface MouseEvent extends Event { x: number; y: number }
interface KeyEvent extends Event { keyCode: number }

function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) {
    /* ... */
}

// Unsound, but useful and common
listenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x + ',' + e.y));

// Undesirable alternatives in presence of soundness
listenEvent(EventType.Mouse, (e: Event) =&gt; console.log((e as MouseEvent).x + "," + (e as MouseEvent).y));
listenEvent(EventType.Mouse, ((e: MouseEvent) =&gt; console.log(e.x + "," + e.y)) as (e: Event) =&gt; void);

// Still disallowed (clear error). Type safety enforced for wholly incompatible types
listenEvent(EventType.Mouse, (e: number) =&gt; console.log(e));
</code></pre>
<p>你可以使用<code>strictFunctionTypes</code>编译选项，使TypeScript在这种情况下报错。</p>
<h3 id="可选参数及剩余参数"><a class="header" href="#可选参数及剩余参数">可选参数及剩余参数</a></h3>
<p>比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。</p>
<p>当一个函数有剩余参数时，它被当做无限个可选参数。</p>
<p>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些<code>undefinded</code>。</p>
<p>有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数但对类型系统来说是不确定的参数来调用：</p>
<pre><code class="language-typescript">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) {
    /* ... Invoke callback with 'args' ... */
}

// Unsound - invokeLater "might" provide any number of arguments
invokeLater([1, 2], (x, y) =&gt; console.log(x + ', ' + y));

// Confusing (x and y are actually required) and undiscoverable
invokeLater([1, 2], (x?, y?) =&gt; console.log(x + ', ' + y));
</code></pre>
<h3 id="函数重载"><a class="header" href="#函数重载">函数重载</a></h3>
<p>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。</p>
<h2 id="枚举-2"><a class="header" href="#枚举-2">枚举</a></h2>
<p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。比如，</p>
<pre><code class="language-typescript">enum Status { Ready, Waiting };
enum Color { Red, Blue, Green };

let status = Status.Ready;
status = Color.Green;  // Error
</code></pre>
<h2 id="类-3"><a class="header" href="#类-3">类</a></h2>
<p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。</p>
<pre><code class="language-typescript">class Animal {
    feet: number;
    constructor(name: string, numFeet: number) { }
}

class Size {
    feet: number;
    constructor(numFeet: number) { }
}

let a: Animal;
let s: Size;

a = s;  // OK
s = a;  // OK
</code></pre>
<h3 id="类的私有成员和受保护成员"><a class="header" href="#类的私有成员和受保护成员">类的私有成员和受保护成员</a></h3>
<p>类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p>
<h2 id="泛型-1"><a class="header" href="#泛型-1">泛型</a></h2>
<p>因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如，</p>
<pre><code class="language-typescript">interface Empty&lt;T&gt; {
}
let x: Empty&lt;number&gt;;
let y: Empty&lt;string&gt;;

x = y;  // OK, because y matches structure of x
</code></pre>
<p>上面代码里，<code>x</code>和<code>y</code>是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了：</p>
<pre><code class="language-typescript">interface NotEmpty&lt;T&gt; {
    data: T;
}
let x: NotEmpty&lt;number&gt;;
let y: NotEmpty&lt;string&gt;;

x = y;  // Error, because x and y are not compatible
</code></pre>
<p>在这里，泛型类型在使用时就好比不是一个泛型类型。</p>
<p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成<code>any</code>比较。 然后用结果类型进行比较，就像上面第一个例子。</p>
<p>比如，</p>
<pre><code class="language-typescript">let identity = function&lt;T&gt;(x: T): T {
    // ...
}

let reverse = function&lt;U&gt;(y: U): U {
    // ...
}

identity = reverse;  // OK, because (x: any) =&gt; any matches (y: any) =&gt; any
</code></pre>
<h2 id="高级主题"><a class="header" href="#高级主题">高级主题</a></h2>
<h3 id="子类型与赋值"><a class="header" href="#子类型与赋值">子类型与赋值</a></h3>
<p>目前为止，我们使用了“兼容性”，它在语言规范里没有定义。 在TypeScript里，有两种兼容性：子类型和赋值。 它们的不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和<code>any</code>来回赋值，以及<code>enum</code>和对应数字值之间的来回赋值。</p>
<p>语言里的不同地方分别使用了它们之中的机制。 实际上，类型兼容性是由赋值兼容性来控制的，即使在<code>implements</code>和<code>extends</code>语句也不例外。</p>
<p>更多信息，请参阅<a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md">TypeScript语言规范</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型推论"><a class="header" href="#类型推论">类型推论</a></h1>
<h2 id="介绍-16"><a class="header" href="#介绍-16">介绍</a></h2>
<p>这节介绍TypeScript里的类型推论。即，类型是在哪里如何被推断的。</p>
<h2 id="基础"><a class="header" href="#基础">基础</a></h2>
<p>TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子</p>
<pre><code class="language-typescript">let x = 3;
</code></pre>
<p>变量<code>x</code>的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p>
<p>大多数情况下，类型推论是直截了当地。 后面的小节，我们会浏览类型推论时的细微差别。</p>
<h2 id="最佳通用类型"><a class="header" href="#最佳通用类型">最佳通用类型</a></h2>
<p>当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，</p>
<pre><code class="language-typescript">let x = [0, 1, null];
</code></pre>
<p>为了推断<code>x</code>的类型，我们必须考虑所有元素的类型。 这里有两种选择：<code>number</code>和<code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>
<p>由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如：</p>
<pre><code class="language-typescript">let zoo = [new Rhino(), new Elephant(), new Snake()];
</code></pre>
<p>这里，我们想让zoo被推断为<code>Animal[]</code>类型，但是这个数组里没有对象是<code>Animal</code>类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：</p>
<pre><code class="language-typescript">let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
</code></pre>
<p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Rhino | Elephant | Snake)[]</code>。</p>
<h2 id="上下文归类"><a class="header" href="#上下文归类">上下文归类</a></h2>
<p>TypeScript类型推论也可能按照相反的方向进行。 这被叫做“上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如：</p>
<pre><code class="language-typescript">window.onmousedown = function(mouseEvent) {
    console.log(mouseEvent.button);   //&lt;- OK
    console.log(mouseEvent.kangaroo); //&lt;- Error!
};
</code></pre>
<p>在这个例子里，TypeScript类型检查器会使用<code>Window.onmousedown</code>函数的类型来推断右边函数表达式的类型。 所以它能够推断出<code>mouseEvent</code>参数的<a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent">类型</a>中包含了<code>button</code>属性而不包含<code>kangaroo</code>属性。</p>
<p>TypeScript还能够很好地推断出其它上下文中的类型。</p>
<pre><code class="language-typescript">window.onscroll = function(uiEvent) {
    console.log(uiEvent.button); //&lt;- Error!
}
</code></pre>
<p>上面的函数被赋值给<code>window.onscroll</code>，<code>TypeScript</code>能够知道<code>uiEvent</code>是<a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent">UIEvent</a>，而不是<a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent">MouseEvent</a>。<code>UIEvent</code>对象不包含<code>button</code>属性，因此TypeScript会报错。</p>
<p>如果这个函数不是在上下文归类的位置上，那么这个函数的参数类型将隐式的成为<code>any</code>类型，而且也不会报错（除非你开启了<code>--noImplicitAny</code>选项）：</p>
<pre><code class="language-typescript">const handler = function(uiEvent) {
    console.log(uiEvent.button); //&lt;- OK
}
</code></pre>
<p>我们也可以明确地为函数参数类型赋值来覆写上下文类型：</p>
<pre><code class="language-typescript">window.onscroll = function(uiEvent: any) {
    console.log(uiEvent.button);  //&lt;- Now, no error is given
};
</code></pre>
<p>但这段代码会打印<code>undefined</code>，因为<code>uiEvent</code>并不包含<code>button</code>属性。</p>
<p>上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如：</p>
<pre><code class="language-typescript">function createZoo(): Animal[] {
    return [new Rhino(), new Elephant(), new Snake()];
}
</code></pre>
<p>这个例子里，最佳通用类型有4个候选者：<code>Animal</code>，<code>Rhino</code>，<code>Elephant</code>和<code>Snake</code>。 当然，<code>Animal</code>会被做为最佳通用类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量声明"><a class="header" href="#变量声明">变量声明</a></h1>
<h2 id="变量声明-1"><a class="header" href="#变量声明-1">变量声明</a></h2>
<p><code>let</code>和<code>const</code>是JavaScript里相对较新的变量声明方式。 <a href="zh/reference/basic-types.html#a-note-about-let">像我们之前提到过的</a>，<code>let</code>在很多方面与<code>var</code>是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 <code>const</code>是对<code>let</code>的一个增强，它能阻止对一个变量再次赋值。</p>
<p>因为TypeScript是JavaScript的超集，所以它本身就支持<code>let</code>和<code>const</code>。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替<code>var</code>。</p>
<p>如果你之前使用JavaScript时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对<code>var</code>声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p>
<h2 id="var-声明"><a class="header" href="#var-声明"><code>var</code> 声明</a></h2>
<p>一直以来我们都是通过<code>var</code>关键字定义JavaScript变量。</p>
<pre><code class="language-typescript">var a = 10;
</code></pre>
<p>大家都能理解，这里定义了一个名为<code>a</code>值为<code>10</code>的变量。</p>
<p>我们也可以在函数内部定义变量：</p>
<pre><code class="language-typescript">function f() {
    var message = "Hello, world!";

    return message;
}
</code></pre>
<p>并且我们也可以在其它函数内部访问相同的变量。</p>
<pre><code class="language-typescript">function f() {
    var a = 10;
    return function g() {
        var b = a + 1;
        return b;
    }
}

var g = f();
g(); // returns 11;
</code></pre>
<p>上面的例子里，<code>g</code>可以获取到<code>f</code>函数里定义的<code>a</code>变量。 每当<code>g</code>被调用时，它都可以访问到<code>f</code>里的<code>a</code>变量。 即使当<code>g</code>在<code>f</code>已经执行完后才被调用，它仍然可以访问及修改<code>a</code>。</p>
<pre><code class="language-typescript">function f() {
    var a = 1;

    a = 2;
    var b = g();
    a = 3;

    return b;

    function g() {
        return a;
    }
}

f(); // returns 2
</code></pre>
<h3 id="作用域规则"><a class="header" href="#作用域规则">作用域规则</a></h3>
<p>对于熟悉其它语言的人来说，<code>var</code>声明有些奇怪的作用域规则。 看下面的例子：</p>
<pre><code class="language-typescript">function f(shouldInitialize: boolean) {
    if (shouldInitialize) {
        var x = 10;
    }

    return x;
}

f(true);  // returns '10'
f(false); // returns 'undefined'
</code></pre>
<p>有些读者可能要多看几遍这个例子。 变量<code>x</code>是定义在_<code>if</code>语句里面_，但是我们却可以在语句的外面访问它。 这是因为<code>var</code>声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为_<code>var</code>作用域_或_函数作用域_。 函数参数也使用函数作用域。</p>
<p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p>
<pre><code class="language-typescript">function sumMatrix(matrix: number[][]) {
    var sum = 0;
    for (var i = 0; i &lt; matrix.length; i++) {
        var currentRow = matrix[i];
        for (var i = 0; i &lt; currentRow.length; i++) {
            sum += currentRow[i];
        }
    }

    return sum;
}
</code></pre>
<p>这里很容易看出一些问题，里层的<code>for</code>循环会覆盖变量<code>i</code>，因为所有<code>i</code>都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p>
<h3 id="捕获变量怪异之处"><a class="header" href="#捕获变量怪异之处">捕获变量怪异之处</a></h3>
<p>快速的猜一下下面的代码会返回什么：</p>
<pre><code class="language-typescript">for (var i = 0; i &lt; 10; i++) {
    setTimeout(function() { console.log(i); }, 100 * i);
}
</code></pre>
<p>介绍一下，<code>setTimeout</code>会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。</p>
<p>好吧，看一下结果：</p>
<pre><code class="language-text">10
10
10
10
10
10
10
10
10
10
</code></pre>
<p>很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：</p>
<pre><code class="language-text">0
1
2
3
4
5
6
7
8
9
</code></pre>
<p>还记得我们上面提到的捕获变量吗？ 我们传给<code>setTimeout</code>的每一个函数表达式实际上都引用了相同作用域里的同一个<code>i</code>。</p>
<p>让我们花点时间思考一下这是为什么。 <code>setTimeout</code>在若干毫秒后执行一个函数，并且是在<code>for</code>循环结束后。 <code>for</code>循环结束后，<code>i</code>的值为<code>10</code>。 所以当函数被调用的时候，它会打印出<code>10</code>！</p>
<p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时<code>i</code>的值：</p>
<pre><code class="language-typescript">for (var i = 0; i &lt; 10; i++) {
    // capture the current state of 'i'
    // by invoking a function with its current value
    (function(i) {
        setTimeout(function() { console.log(i); }, 100 * i);
    })(i);
}
</code></pre>
<p>这种奇怪的形式我们已经司空见惯了。 参数<code>i</code>会覆盖<code>for</code>循环里的<code>i</code>，但是因为我们起了同样的名字，所以我们不用怎么改<code>for</code>循环体里的代码。</p>
<h2 id="let-声明"><a class="header" href="#let-声明"><code>let</code> 声明</a></h2>
<p>现在你已经知道了<code>var</code>存在一些问题，这恰好说明了为什么用<code>let</code>语句来声明变量。 除了名字不同外，<code>let</code>与<code>var</code>的写法一致。</p>
<pre><code class="language-typescript">let hello = "Hello!";
</code></pre>
<p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p>
<h3 id="块作用域"><a class="header" href="#块作用域">块作用域</a></h3>
<p>当用<code>let</code>声明一个变量，它使用的是_词法作用域_或_块作用域_。 不同于使用<code>var</code>声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或<code>for</code>循环之外是不能访问的。</p>
<pre><code class="language-typescript">function f(input: boolean) {
    let a = 100;

    if (input) {
        // Still okay to reference 'a'
        let b = a + 1;
        return b;
    }

    // Error: 'b' doesn't exist here
    return b;
}
</code></pre>
<p>这里我们定义了2个变量<code>a</code>和<code>b</code>。 <code>a</code>的作用域是<code>f</code>函数体内，而<code>b</code>的作用域是<code>if</code>语句块里。</p>
<p>在<code>catch</code>语句里声明的变量也具有同样的作用域规则。</p>
<pre><code class="language-typescript">try {
    throw "oh no!";
}
catch (e) {
    console.log("Oh well.");
}

// Error: 'e' doesn't exist here
console.log(e);
</code></pre>
<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于_暂时性死区_。 它只是用来说明我们不能在<code>let</code>语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。</p>
<pre><code class="language-typescript">a++; // illegal to use 'a' before it's declared;
let a;
</code></pre>
<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前_获取_它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。</p>
<pre><code class="language-typescript">function foo() {
    // okay to capture 'a'
    return a;
}

// 不能在'a'被声明前调用'foo'
// 运行时应该抛出错误
foo();

let a;
</code></pre>
<p>关于_暂时性死区_的更多信息，查看这里<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let">Mozilla Developer Network</a>.</p>
<h3 id="重声明及屏蔽"><a class="header" href="#重声明及屏蔽">重声明及屏蔽</a></h3>
<p>我们提过使用<code>var</code>声明时，它不在乎你声明多少次；你只会得到1个。</p>
<pre><code class="language-typescript">function f(x) {
    var x;
    var x;

    if (true) {
        var x;
    }
}
</code></pre>
<p>在上面的例子里，所有<code>x</code>的声明实际上都引用一个_相同_的<code>x</code>，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是，<code>let</code>声明就不会这么宽松了。</p>
<pre><code class="language-typescript">let x = 10;
let x = 20; // 错误，不能在1个作用域里多次声明`x`
</code></pre>
<p>并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。</p>
<pre><code class="language-typescript">function f(x) {
    let x = 100; // error: interferes with parameter declaration
}

function g() {
    let x = 100;
    var x = 100; // error: can't have both declarations of 'x'
}
</code></pre>
<p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p>
<pre><code class="language-typescript">function f(condition, x) {
    if (condition) {
        let x = 100;
        return x;
    }

    return x;
}

f(false, 0); // returns 0
f(true, 0);  // returns 100
</code></pre>
<p>在一个嵌套作用域里引入一个新名字的行为称做_屏蔽_。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用<code>let</code>重写之前的<code>sumMatrix</code>函数。</p>
<pre><code class="language-typescript">function sumMatrix(matrix: number[][]) {
    let sum = 0;
    for (let i = 0; i &lt; matrix.length; i++) {
        var currentRow = matrix[i];
        for (let i = 0; i &lt; currentRow.length; i++) {
            sum += currentRow[i];
        }
    }

    return sum;
}
</code></pre>
<p>这个版本的循环能得到正确的结果，因为内层循环的<code>i</code>可以屏蔽掉外层循环的<code>i</code>。</p>
<p>_通常_来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。</p>
<h3 id="块级作用域变量的获取"><a class="header" href="#块级作用域变量的获取">块级作用域变量的获取</a></h3>
<p>在我们最初谈及获取用<code>var</code>声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的_环境_。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p>
<pre><code class="language-typescript">function theCityThatAlwaysSleeps() {
    let getCity;

    if (true) {
        let city = "Seattle";
        getCity = function() {
            return city;
        }
    }

    return getCity();
}
</code></pre>
<p>因为我们已经在<code>city</code>的环境里获取到了<code>city</code>，所以就算<code>if</code>语句执行结束后我们仍然可以访问它。</p>
<p>回想一下前面<code>setTimeout</code>的例子，我们最后需要使用立即执行的函数表达式来获取每次<code>for</code>循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。</p>
<p>当<code>let</code>声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对_每次迭代_都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在<code>setTimeout</code>例子里我们仅使用<code>let</code>声明就可以了。</p>
<pre><code class="language-typescript">for (let i = 0; i &lt; 10 ; i++) {
    setTimeout(function() {console.log(i); }, 100 * i);
}
</code></pre>
<p>会输出与预料一致的结果：</p>
<pre><code class="language-text">0
1
2
3
4
5
6
7
8
9
</code></pre>
<h2 id="const-声明"><a class="header" href="#const-声明"><code>const</code> 声明</a></h2>
<p><code>const</code> 声明是声明变量的另一种方式。</p>
<pre><code class="language-typescript">const numLivesForCat = 9;
</code></pre>
<p>它们与<code>let</code>声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与<code>let</code>相同的作用域规则，但是不能对它们重新赋值。</p>
<p>这很好理解，它们引用的值是_不可变的_。</p>
<pre><code class="language-typescript">const numLivesForCat = 9;
const kitty = {
    name: "Aurora",
    numLives: numLivesForCat,
}

// Error
kitty = {
    name: "Danielle",
    numLives: numLivesForCat
};

// all "okay"
kitty.name = "Rory";
kitty.name = "Kitty";
kitty.name = "Cat";
kitty.numLives--;
</code></pre>
<p>除非你使用特殊的方法去避免，实际上<code>const</code>变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 <a href="zh/reference/interfaces.html">接口</a>一章有详细说明。</p>
<h2 id="let-vs-const"><a class="header" href="#let-vs-const"><code>let</code> vs. <code>const</code></a></h2>
<p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。</p>
<p>使用<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">最小特权原则</a>，所有变量除了你计划去修改的都应该使用<code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用<code>const</code>也可以让我们更容易的推测数据的流动。</p>
<p>跟据你的自己判断，如果合适的话，与团队成员商议一下。</p>
<p>这个手册大部分地方都使用了<code>let</code>声明。</p>
<h2 id="解构"><a class="header" href="#解构">解构</a></h2>
<p>TypeScript 包含的另一个 ECMAScript 2015 特性就是解构。完整列表请参见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">the article on the Mozilla Developer Network</a>。 本章，我们将给出一个简短的概述。</p>
<h3 id="解构数组"><a class="header" href="#解构数组">解构数组</a></h3>
<p>最简单的解构莫过于数组的解构赋值了：</p>
<pre><code class="language-typescript">let input = [1, 2];
let [first, second] = input;
console.log(first); // outputs 1
console.log(second); // outputs 2
</code></pre>
<p>这创建了2个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p>
<pre><code class="language-typescript">first = input[0];
second = input[1];
</code></pre>
<p>解构也可以作用于已声明的变量：</p>
<pre><code class="language-typescript">// swap variables
[first, second] = [second, first];
</code></pre>
<p>类似地，也可以作用于函数参数：</p>
<pre><code class="language-typescript">function f([first, second]: [number, number]) {
    console.log(first);
    console.log(second);
}
f([1, 2]);
</code></pre>
<p>你可以在数组里使用<code>...</code>语法创建剩余变量：</p>
<pre><code class="language-typescript">let [first, ...rest] = [1, 2, 3, 4];
console.log(first); // outputs 1
console.log(rest); // outputs [ 2, 3, 4 ]
</code></pre>
<p>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p>
<pre><code class="language-typescript">let [first] = [1, 2, 3, 4];
console.log(first); // outputs 1
</code></pre>
<p>或其它元素：</p>
<pre><code class="language-typescript">let [, second, , fourth] = [1, 2, 3, 4];
console.log(second); // outputs 2
console.log(fourth); // outputs 4
</code></pre>
<h3 id="解构元组"><a class="header" href="#解构元组">解构元组</a></h3>
<p>元组可以像数组一样解构；解构后的变量获得对应元组元素的类型：</p>
<pre><code class="language-typescript">let tuple: [number, string, boolean] = [7, "hello", true];

let [a, b, c] = tuple; // a: number, b: string, c: boolean
</code></pre>
<p>当解构元组时，若超出元组索引范围将报错：</p>
<pre><code class="language-typescript">let [a, b, c, d] = tuple; // 错误，没有索引为3的元素
</code></pre>
<p>与数组一样，可以作用<code>...</code>来解构元组的剩余元素，从而得到一个短的元组：</p>
<pre><code class="language-typescript">let [a, ...bc] = tuple; // bc: [string, boolean]
let [a, b, c, ...d] = tuple; // d: [], the empty tuple
</code></pre>
<p>或者，忽略末尾元素或其它元素：</p>
<pre><code class="language-typescript">let [a] = tuple; // a: number
let [, b] = tuple; // b: string
</code></pre>
<h3 id="对象解构"><a class="header" href="#对象解构">对象解构</a></h3>
<p>你也可以解构对象：</p>
<pre><code class="language-typescript">let o = {
    a: "foo",
    b: 12,
    c: "bar"
};
let { a, b } = o;
</code></pre>
<p>这通过 <code>o.a</code> and <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p>
<p>就像数组解构，你可以用没有声明的赋值：</p>
<pre><code class="language-typescript">({ a, b } = { a: "baz", b: 101 });
</code></pre>
<p>注意，我们需要用括号将它括起来，因为Javascript通常会将以 <code>{</code> 起始的语句解析为一个块。</p>
<p>你可以在对象里使用<code>...</code>语法创建剩余变量：</p>
<pre><code class="language-typescript">let { a, ...passthrough } = o;
let total = passthrough.b + passthrough.c.length;
</code></pre>
<h4 id="属性重命名"><a class="header" href="#属性重命名">属性重命名</a></h4>
<p>你也可以给属性以不同的名字：</p>
<pre><code class="language-typescript">let { a: newName1, b: newName2 } = o;
</code></pre>
<p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 "<code>a</code> 作为 <code>newName1</code>"。 方向是从左到右，好像你写成了以下样子：</p>
<pre><code class="language-typescript">let newName1 = o.a;
let newName2 = o.b;
</code></pre>
<p>令人困惑的是，这里的冒号_不是_指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p>
<pre><code class="language-typescript">let {a, b}: {a: string, b: number} = o;
</code></pre>
<h4 id="默认值"><a class="header" href="#默认值">默认值</a></h4>
<p>我们可以为属性指定一个默认值，当属性值为<code>undefined</code>时，将使用该默认值：</p>
<pre><code class="language-typescript">function keepWholeObject(wholeObject: { a: string, b?: number }) {
    let { a, b = 1001 } = wholeObject;
}
</code></pre>
<p>此例中，<code>b?</code>表明<code>b</code>是可选的，因此它可能为<code>undefined</code>。 现在，即使 <code>b</code> 为 undefined ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p>
<h3 id="函数声明"><a class="header" href="#函数声明">函数声明</a></h3>
<p>解构也能用于函数声明。 看以下简单的情况：</p>
<pre><code class="language-typescript">type C = { a: string, b?: number }
function f({ a, b }: C): void {
    // ...
}
</code></pre>
<p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p>
<pre><code class="language-typescript">function f({ a="", b=0 } = {}): void {
    // ...
}
f();
</code></pre>
<blockquote>
<p>上面的代码是一个类型推断的例子，将在本手册后文介绍。</p>
</blockquote>
<p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 <code>C</code> 的定义有一个 <code>b</code> 可选属性：</p>
<pre><code class="language-typescript">function f({ a, b = 0 } = { a: "" }): void {
    // ...
}
f({ a: "yes" }); // ok, default b = 0
f(); // ok, default to {a: ""}, which then defaults b = 0
f({}); // error, 'a' is required if you supply an argument
</code></pre>
<p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。</p>
<h3 id="展开"><a class="header" href="#展开">展开</a></h3>
<p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p>
<pre><code class="language-typescript">let first = [1, 2];
let second = [3, 4];
let bothPlus = [0, ...first, ...second, 5];
</code></pre>
<p>这会令<code>bothPlus</code>的值为<code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了<code>first</code>和<code>second</code>的一份浅拷贝。 它们不会被展开操作所改变。</p>
<p>你还可以展开对象：</p>
<pre><code class="language-typescript">let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { ...defaults, food: "rich" };
</code></pre>
<p><code>search</code>的值为<code>{ food: "rich", price: "$$", ambiance: "noisy" }</code>。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>
<pre><code class="language-typescript">let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { food: "rich", ...defaults };
</code></pre>
<p>那么，<code>defaults</code>里的<code>food</code>属性会重写<code>food: "rich"</code>，在这里这并不是我们想要的结果。</p>
<p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">自身的可枚举属性</a>。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>
<pre><code class="language-typescript">class C {
  p = 12;
  m() {
  }
}
let c = new C();
let clone = { ...c };
clone.p; // ok
clone.m(); // error!
</code></pre>
<p>其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="手册-v2"><a class="header" href="#手册-v2">手册 v2</a></h1>
<ul>
<li><a href="zh/handbook-v2/the-handbook.html">TypeScript 手册</a></li>
<li><a href="zh/handbook-v2/basics.html">基础</a></li>
<li><a href="zh/handbook-v2/everyday-types.html">常见类型</a></li>
<li><a href="zh/handbook-v2/narrowing.html">缩小类型范围</a></li>
<li><a href="zh/handbook-v2/more-on-functions.html">函数进阶</a></li>
<li><a href="zh/handbook-v2/object-types.html">对象类型</a></li>
<li>类型操纵
<ul>
<li><a href="zh/handbook-v2/type-manipulation/_creating-types-from-types.html">用现有类型创建新类型</a></li>
<li><a href="zh/handbook-v2/type-manipulation/generics.html">泛型</a></li>
<li><a href="zh/handbook-v2/type-manipulation/keyof-type-operator.html">keyof 类型运算符</a></li>
<li><a href="zh/handbook-v2/type-manipulation/typeof-type-operator.html">typeof 类型运算符</a></li>
<li><a href="zh/handbook-v2/type-manipulation/indexed-access-types.html">索引访问类型</a></li>
<li><a href="zh/handbook-v2/type-manipulation/conditional-types.html">条件类型</a></li>
<li><a href="zh/handbook-v2/type-manipulation/mapped-types.html">映射类型</a></li>
<li><a href="zh/handbook-v2/type-manipulation/template-literal-types.html">模版字面量类型</a></li>
</ul>
</li>
<li><a href="zh/handbook-v2/classes.html">类</a></li>
<li><a href="zh/handbook-v2/modules.html">模块</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模版字面量类型"><a class="header" href="#模版字面量类型">模版字面量类型</a></h1>
<blockquote>
<p>从 TypeScript 4.1 开始支持</p>
</blockquote>
<p>模版字面量类型以<a href="zh/handbook-v2/type-manipulation/../../handbook/literal-types.html">字符串字面量类型</a>为基础，且可以展开为多个字符串类型的联合类型。</p>
<p>其语法与 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">JavaScript 中的模版字面量</a>是一致的，但是是用在类型的位置上。
当与某个具体的字面量类型一起使用时，模版字面量会将文本连接从而生成一个新的字符串字面量类型。</p>
<pre><code class="language-ts">type World = 'world';

type Greeting = `hello ${World}`;
//   'hello world'
</code></pre>
<p>如果在替换字符串的位置是联合类型，那么结果类型是由每个联合类型成员构成的字符串字面量的集合：</p>
<pre><code class="language-ts">type EmailLocaleIDs = 'welcome_email' | 'email_heading';
type FooterLocaleIDs = 'footer_title' | 'footer_sendoff';

type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
// "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id"
</code></pre>
<p>多个替换字符串的位置上的多个联合类型会进行交叉相乘：</p>
<pre><code class="language-ts">type EmailLocaleIDs = 'welcome_email' | 'email_heading';
type FooterLocaleIDs = 'footer_title' | 'footer_sendoff';

type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
type Lang = 'en' | 'ja' | 'pt';

type LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;
//   type EmailLocaleIDs = "welcome_email" | "email_heading";
type FooterLocaleIDs = 'footer_title' | 'footer_sendoff';

type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
type Lang = 'en' | 'ja' | 'pt';

type LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;
//   "en_welcome_email_id" | "en_email_heading_id" | "en_footer_title_id" | "en_footer_sendoff_id" | "ja_welcome_email_id" | "ja_email_heading_id" | "ja_footer_title_id" | "ja_footer_sendoff_id" | "pt_welcome_email_id" | "pt_email_heading_id" | "pt_footer_title_id" | "pt_footer_sendoff_id"
</code></pre>
<p>我们还是建议开发者要提前生成数量巨大的字符串联合类型，但如果数量较少，那么上面介绍的方法会有所帮助。</p>
<h3 id="类型中的字符串联合类型"><a class="header" href="#类型中的字符串联合类型">类型中的字符串联合类型</a></h3>
<p>模版字面量的强大之处在于它能够基于给定的字符串来创建新的字符串。</p>
<p>例如，JavaScript 中有一个常见的模式是基于对象的现有属性来扩展它。
下面我们定义一个函数类型<code>on</code>，它用于监听值的变化。</p>
<pre><code class="language-ts">declare function makeWatchedObject(obj: any): any;

const person = makeWatchedObject({
    firstName: 'Saoirse',
    lastName: 'Ronan',
    age: 26,
});

person.on('firstNameChanged', (newValue) =&gt; {
    console.log(`firstName was changed to ${newValue}!`);
});
</code></pre>
<p>注意，<code>on</code>会监听<code>"firstNameChanged"</code>事件，而不是<code>"firstName"</code>。
模版字面量提供了操作字符串类型的能力：</p>
<pre><code class="language-ts">type PropEventSource&lt;Type&gt; = {
    on(
        eventName: `${string &amp; keyof Type}Changed`,
        callback: (newValue: any) =&gt; void
    ): void;
};

/// Create a "watched object" with an 'on' method
/// so that you can watch for changes to properties.
declare function makeWatchedObject&lt;Type&gt;(
    obj: Type
): Type &amp; PropEventSource&lt;Type&gt;;
</code></pre>
<p>这样做之后，当传入了错误的属性名会产生一个错误：</p>
<pre><code class="language-ts">type PropEventSource&lt;Type&gt; = {
    on(
        eventName: `${string &amp; keyof Type}Changed`,
        callback: (newValue: any) =&gt; void
    ): void;
};

declare function makeWatchedObject&lt;T&gt;(obj: T): T &amp; PropEventSource&lt;T&gt;;

const person = makeWatchedObject({
    firstName: 'Saoirse',
    lastName: 'Ronan',
    age: 26,
});

person.on('firstNameChanged', () =&gt; {});

// 以下存在拼写错误
person.on('firstName', () =&gt; {});
person.on('frstNameChanged', () =&gt; {});
</code></pre>
<h3 id="模版字面量类型推断"><a class="header" href="#模版字面量类型推断">模版字面量类型推断</a></h3>
<p>注意，上例中没有使用原属性值的类型，在回调函数中仍使用<code>any</code>类型。
模版字面量类型能够从替换字符串的位置推断出类型。</p>
<p>下面，我们将上例修改成泛型，它会从<code>eventName</code>字符串来推断出属性名。</p>
<pre><code class="language-ts">type PropEventSource&lt;Type&gt; = {
    on&lt;Key extends string &amp; keyof Type&gt;(
        eventName: `${Key}Changed`,
        callback: (newValue: Type[Key]) =&gt; void
    ): void;
};

declare function makeWatchedObject&lt;Type&gt;(
    obj: Type
): Type &amp; PropEventSource&lt;Type&gt;;

const person = makeWatchedObject({
    firstName: 'Saoirse',
    lastName: 'Ronan',
    age: 26,
});

person.on('firstNameChanged', (newName) =&gt; {
    //                        string
    console.log(`new name is ${newName.toUpperCase()}`);
});

person.on('ageChanged', (newAge) =&gt; {
    //                  number
    if (newAge &lt; 0) {
        console.warn('warning! negative age');
    }
});
</code></pre>
<p>这里，我们将<code>on</code>改为泛型方法。</p>
<p>当用户使用字符串<code>"firstNameChanged'</code>来调用时，TypeScript 会尝试推断<code>K</code>的类型。
为此，TypeScript 尝试将<code>Key</code>与<code>"Changed"</code>之前的部分进行匹配，并且推断出字符串<code>"firstName"</code>。
当 TypeScript 推断出了类型后，<code>on</code>方法就能够获取<code>firstName</code>属性的类型，即<code>string</code>类型。
相似的，当使用<code>"ageChanged"</code>调用时，TypeScript 能够知道<code>age</code>属性的类型是<code>number</code>。</p>
<p>类型推断可以以多种方式组合，例如拆解字符串然后以其它方式重新构造字符串。</p>
<h2 id="操作固有字符串的类型"><a class="header" href="#操作固有字符串的类型">操作固有字符串的类型</a></h2>
<p>为了方便字符串操作，TypeScript 提供了一系列操作字符串的类型。
这些类型内置于编译器之中，以便提高性能。
它们不存在于 TypeScript 提供的<code>.d.ts</code>文件中。</p>
<h3 id="uppercasestringtype"><a class="header" href="#uppercasestringtype"><code>Uppercase&lt;StringType&gt;</code></a></h3>
<p>将字符串中的每个字符转换为大写字母。</p>
<h5 id="example"><a class="header" href="#example">Example</a></h5>
<pre><code class="language-ts">type Greeting = 'Hello, world';
type ShoutyGreeting = Uppercase&lt;Greeting&gt;;
//   "HELLO, WORLD"

type ASCIICacheKey&lt;Str extends string&gt; = `ID-${Uppercase&lt;Str&gt;}`;
type MainID = ASCIICacheKey&lt;'my_app'&gt;;
//   "ID-MY_APP"
</code></pre>
<h3 id="lowercasestringtype"><a class="header" href="#lowercasestringtype"><code>Lowercase&lt;StringType&gt;</code></a></h3>
<p>将字符串中的每个字符转换为小写字母。</p>
<pre><code class="language-ts">type Greeting = 'Hello, world';
type QuietGreeting = Lowercase&lt;Greeting&gt;;
//   "hello, world"

type ASCIICacheKey&lt;Str extends string&gt; = `id-${Lowercase&lt;Str&gt;}`;
type MainID = ASCIICacheKey&lt;'MY_APP'&gt;;
//   "id-my_app"
</code></pre>
<h3 id="capitalizestringtype"><a class="header" href="#capitalizestringtype"><code>Capitalize&lt;StringType&gt;</code></a></h3>
<p>将字符串中的首字母转换为大写字母。</p>
<h5 id="example-1"><a class="header" href="#example-1">Example</a></h5>
<pre><code class="language-ts">type LowercaseGreeting = 'hello, world';
type Greeting = Capitalize&lt;LowercaseGreeting&gt;;
//   "Hello, world"
</code></pre>
<h3 id="uncapitalizestringtype"><a class="header" href="#uncapitalizestringtype"><code>Uncapitalize&lt;StringType&gt;</code></a></h3>
<p>将字符串中的首字母转换为小写字母。</p>
<h5 id="example-2"><a class="header" href="#example-2">Example</a></h5>
<pre><code class="language-ts twoslash">type UppercaseGreeting = 'HELLO WORLD';
type UncomfortableGreeting = Uncapitalize&lt;UppercaseGreeting&gt;;
//   "hELLO WORLD"
</code></pre>
<details>
    <summary>固有字符串操作类型的技术细节</summary>
    <p>在TypeScript 4.1中会直接使用JavaScript中的字符串操作函数来操作固有字符串，且不会考虑本地化字符。</p>
    <code><pre>
function applyStringMapping(symbol: Symbol, str: string) {
    switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {
        case IntrinsicTypeKind.Uppercase: return str.toUpperCase();
        case IntrinsicTypeKind.Lowercase: return str.toLowerCase();
        case IntrinsicTypeKind.Capitalize: return str.charAt(0).toUpperCase() + str.slice(1);
        case IntrinsicTypeKind.Uncapitalize: return str.charAt(0).toLowerCase() + str.slice(1);
    }
    return str;
}</pre></code>
</details>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="zh/declaration-files/./README.html">如何书写声明文件</a>
<ul>
<li><a href="zh/declaration-files/./introduction.html">介绍</a></li>
<li><a href="zh/declaration-files/./by-example.html">举例</a></li>
<li><a href="zh/declaration-files/./library-structures.html">库结构</a></li>
<li><a href="zh/declaration-files/./templates.html">模板</a></li>
<li><a href="zh/declaration-files/./do-s-and-don-ts.html">最佳实践</a></li>
<li><a href="zh/declaration-files/./deep-dive.html">深入</a></li>
<li><a href="zh/declaration-files/./publishing.html">发布</a></li>
<li><a href="zh/declaration-files/./consumption.html">使用</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>声明文件一章的目的是教你如何编写高质量的 TypeScript 声明文件。
我们假设你对 TypeScript 已经有了基本的了解。</p>
<p>如果没有，请先阅读<a href="zh/declaration-files/../handbook/basic-types.html">TypeScript 手册</a> 来了解一些基本知识，尤其是类型和模块的部分。</p>
<p>需要编写<code>.d.ts</code>文件的常见场景是为某个 npm 包添加类型信息。
如果是这种情况，你可以直接阅读<a href="zh/declaration-files/./templates/module.d.ts.html">Modules .d.ts</a></p>
<p>这篇指南被分成了以下章节。</p>
<h2 id="示例"><a class="header" href="#示例"><a href="zh/declaration-files/./by-example.html">示例</a></a></h2>
<p>在编写声明文件时，我们经常遇到以下情况，那就是需要根据代码库提供的示例来编写声明文件。
<a href="zh/declaration-files/./by-example.html">示例</a>一节展示了了许多常见的 API 模式，以及如何为它们编写声明文件。
该指南面向的是 TypeScript 的初学者，这些人可能并不熟悉 TypeScript 语言的每个特性。</p>
<h2 id="结构"><a class="header" href="#结构"><a href="zh/declaration-files/./library-structures.html">结构</a></a></h2>
<p><a href="zh/declaration-files/./library-structures.html">结构</a>一节将帮助你了解常见库的格式以及如何为每种格式书写正确的声明文件。
如果你正在编辑一个已有文件，那么你可能不需要阅读此章节。
如果你在编写新的声明文件，那么强烈建议阅读此章节以理解库的不同格式是如何影响声明文件的编写的。</p>
<h2 id="模版"><a class="header" href="#模版"><a href="zh/declaration-files/./templates.html">模版</a></a></h2>
<p>在<a href="zh/declaration-files/./templates.html">模版</a>一节里，你能找到一些声明文件，它们对于编写新的声明文件来讲会有所帮助。
如果你已经了解了库的结构，那么可以阅读相应的模版文件：</p>
<ul>
<li><a href="zh/declaration-files/templates/global-modifying-module.d.ts.html">global-modifying-module.d.ts</a></li>
<li><a href="zh/declaration-files/templates/global-plugin.d.ts.html">global-plugin.d.ts</a></li>
<li><a href="zh/declaration-files/templates/global.d.ts.html">global.d.ts</a></li>
<li><a href="zh/declaration-files/templates/module-class.d.ts.html">module-class.d.ts</a></li>
<li><a href="zh/declaration-files/templates/module-function.d.ts.html">module-function.d.ts</a></li>
<li><a href="zh/declaration-files/templates/module-plugin.d.ts.html">module-plugin.d.ts</a></li>
<li><a href="zh/declaration-files/templates/module.d.ts.html">module.d.ts</a></li>
</ul>
<h2 id="规范"><a class="header" href="#规范"><a href="zh/declaration-files/./do-s-and-don-ts.html">规范</a></a></h2>
<p>声明文件里有些常见错误是很容易就可以避免的。
<a href="zh/declaration-files/./do-s-and-don-ts.html">规范</a>一节列出了常见的错误，并且描述了如何检测以及修复它们。
每个人都应该阅读这个章节以了解如何避免常见错误。</p>
<h2 id="深入"><a class="header" href="#深入"><a href="zh/declaration-files/./deep-dive.html">深入</a></a></h2>
<p>针对那些对声明文件底层工作机制感兴趣的老手们，<a href="zh/declaration-files/./deep-dive.html">深入</a>一节解释了编写声明文件时的很多高级概念，
并且展示了如何利用这些概念来创建整洁和直观的声明文件。</p>
<h2 id="发布到-npm"><a class="header" href="#发布到-npm"><a href="zh/declaration-files/./publishing.html">发布到 npm</a></a></h2>
<p><a href="zh/declaration-files/./publishing.html">发布</a>一节讲解了如何将声明文件发布为 npm 包，以及如何管理包的依赖。</p>
<h2 id="查找与安装声明文件"><a class="header" href="#查找与安装声明文件"><a href="zh/declaration-files/./consumption.html">查找与安装声明文件</a></a></h2>
<p>对于 JavaScript 库的使用者来讲，<a href="zh/declaration-files/./consumption.html">使用</a>一节提供了一些简单步骤来查找与安装相应的声明文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="举例"><a class="header" href="#举例">举例</a></h1>
<p>这篇指南的目的是教你如何书写高质量的 TypeScript 声明文件。
我们在这里会展示一些 API 的文档，以及它们的使用示例，
并且阐述了如何为它们书写声明文件。</p>
<p>这些例子是按复杂度递增的顺序组织的。</p>
<ul>
<li><a href="zh/declaration-files/by-example.html#%E5%B8%A6%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AF%B9%E8%B1%A1">带属性的对象</a></li>
<li><a href="zh/declaration-files/by-example.html#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">函数重载</a></li>
<li><a href="zh/declaration-files/by-example.html#%E5%8F%AF%E9%87%8D%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3">可重用类型（接口）</a></li>
<li><a href="zh/declaration-files/by-example.html#%E5%8F%AF%E9%87%8D%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D">可重用类型（类型别名）</a></li>
<li><a href="zh/declaration-files/by-example.html#%E7%BB%84%E7%BB%87%E7%B1%BB%E5%9E%8B">组织类型</a></li>
<li><a href="zh/declaration-files/by-example.html#%E7%B1%BB">类</a></li>
<li><a href="zh/declaration-files/by-example.html#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">全局变量</a></li>
<li><a href="zh/declaration-files/by-example.html#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0">全局函数</a></li>
</ul>
<h2 id="带属性的对象"><a class="header" href="#带属性的对象">带属性的对象</a></h2>
<p><em>文档</em></p>
<blockquote>
<p>全局变量<code>myLib</code>包含一个用于创建祝福的<code>makeGreeting</code>函数，
以及表示祝福数量的<code>numberOfGreetings</code>属性。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="language-ts">let result = myLib.makeGreeting('hello, world');
console.log('The computed greeting is:' + result);

let count = myLib.numberOfGreetings;
</code></pre>
<p><em>声明</em></p>
<p>使用<code>declare namespace</code>来描述用点表示法访问的类型或值。</p>
<pre><code class="language-ts">declare namespace myLib {
    function makeGreeting(s: string): string;
    let numberOfGreetings: number;
}
</code></pre>
<h2 id="函数重载-1"><a class="header" href="#函数重载-1">函数重载</a></h2>
<p><em>文档</em></p>
<blockquote>
<p><code>getWidget</code>函数接收一个数字参数并返回一个组件；或者接收一个字符串参数并返回一个组件数组。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="language-ts">let x: Widget = getWidget(43);

let arr: Widget[] = getWidget('all of them');
</code></pre>
<p><em>声明</em></p>
<pre><code class="language-ts">declare function getWidget(n: number): Widget;
declare function getWidget(s: string): Widget[];
</code></pre>
<h2 id="可重用类型接口"><a class="header" href="#可重用类型接口">可重用类型（接口）</a></h2>
<p><em>文档</em></p>
<blockquote>
<p>当指定一个祝福词时，你必须传入一个<code>GreetingSettings</code>对象。
这个对象具有以下几个属性：</p>
<p>1- greeting：必需的字符串</p>
<p>2- duration: 可选的持续时间（以毫秒表示）</p>
<p>3- color: 可选的字符串，比如'#ff00ff'</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="language-ts">greet({
    greeting: 'hello world',
    duration: 4000,
});
</code></pre>
<p><em>声明</em></p>
<p>使用<code>interface</code>定义一个带有属性的类型。</p>
<pre><code class="language-ts">interface GreetingSettings {
    greeting: string;
    duration?: number;
    color?: string;
}

declare function greet(setting: GreetingSettings): void;
</code></pre>
<h2 id="可重用类型类型别名"><a class="header" href="#可重用类型类型别名">可重用类型（类型别名）</a></h2>
<p><em>文档</em></p>
<blockquote>
<p>在任何需要祝福词的地方，你可以提供一个<code>string</code>，一个返回<code>string</code>的函数或一个<code>Greeter</code>实例。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="language-ts">function getGreeting() {
    return 'howdy';
}
class MyGreeter extends Greeter {}

greet('hello');
greet(getGreeting);
greet(new MyGreeter());
</code></pre>
<p><em>声明</em></p>
<p>你可以使用类型别名来定义类型的短名：</p>
<pre><code class="language-ts">type GreetingLike = string | (() =&gt; string) | MyGreeter;

declare function greet(g: GreetingLike): void;
</code></pre>
<h2 id="组织类型"><a class="header" href="#组织类型">组织类型</a></h2>
<p><em>文档</em></p>
<blockquote>
<p><code>greeter</code>对象能够记录到文件或显示一个警告。
你可以为<code>.log(...)</code>提供 log 选项以及为<code>.alert(...)</code>提供 alert 选项。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="language-ts">const g = new Greeter('Hello');
g.log({ verbose: true });
g.alert({ modal: false, title: 'Current Greeting' });
</code></pre>
<p><em>声明</em></p>
<p>使用命名空间组织类型。</p>
<pre><code class="language-ts">declare namespace GreetingLib {
    interface LogOptions {
        verbose?: boolean;
    }
    interface AlertOptions {
        modal: boolean;
        title?: string;
        color?: string;
    }
}
</code></pre>
<p>你也可以在一个声明中创建嵌套的命名空间：</p>
<pre><code class="language-ts">declare namespace GreetingLib.Options {
    // Refer to via GreetingLib.Options.Log
    interface Log {
        verbose?: boolean;
    }
    interface Alert {
        modal: boolean;
        title?: string;
        color?: string;
    }
}
</code></pre>
<h2 id="类-4"><a class="header" href="#类-4">类</a></h2>
<p><em>文档</em></p>
<blockquote>
<p>你可以通过实例化<code>Greeter</code>对象来创建祝福语，或者继承<code>Greeter</code>对象来自定义祝福语。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="language-ts">const myGreeter = new Greeter('hello, world');
myGreeter.greeting = 'howdy';
myGreeter.showGreeting();

class SpecialGreeter extends Greeter {
    constructor() {
        super('Very special greetings');
    }
}
</code></pre>
<p><em>声明</em></p>
<p>使用<code>declare class</code>来描述一个类或像类一样的对象。
类可以有属性和方法，就和构造函数一样。</p>
<pre><code class="language-ts">declare class Greeter {
    constructor(greeting: string);

    greeting: string;
    showGreeting(): void;
}
</code></pre>
<h2 id="全局变量"><a class="header" href="#全局变量">全局变量</a></h2>
<p><em>文档</em></p>
<blockquote>
<p>全局变量<code>foo</code>包含了存在的组件总数。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="language-ts">console.log('Half the number of widgets is ' + foo / 2);
</code></pre>
<p><em>声明</em></p>
<p>使用<code>declare var</code>声明变量。
如果变量是只读的，那么可以使用<code>declare const</code>。
你还可以使用<code>declare let</code>，如果变量拥有块级作用域。</p>
<pre><code class="language-ts">/** The number of widgets present */
declare var foo: number;
</code></pre>
<h2 id="全局函数"><a class="header" href="#全局函数">全局函数</a></h2>
<p><em>文档</em></p>
<blockquote>
<p>你可以使用一个字符串参数来调用<code>greet</code>函数，并向用户显示一条祝福语。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="language-ts">greet('hello, world');
</code></pre>
<p><em>声明</em></p>
<p>使用<code>declare function</code>来声明函数。</p>
<pre><code class="language-ts">declare function greet(greeting: string): void;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码库结构"><a class="header" href="#代码库结构">代码库结构</a></h1>
<p>一般来讲，<em>组织</em>声明文件的方式取决于代码库是如何被使用的。
在 JavaScript 中一个代码库有很多使用方式，这就需要你书写声明文件去匹配它们。
这篇指南涵盖了如何识别常见代码库的模式，以及怎样书写符合相应模式的声明文件。</p>
<p>针对代码库的每种主要的组织模式，在<a href="zh/declaration-files/./templates.html">模版</a>一节都有对应的文件。
你可以利用它们帮助你快速上手。</p>
<h2 id="识别代码库的类型"><a class="header" href="#识别代码库的类型">识别代码库的类型</a></h2>
<p>首先，我们先看一下 TypeScript 声明文件能够表示的库的类型。
这里会简单展示每种类型的代码库的使用方式，以及如何去书写，还有一些真实案例。</p>
<p>识别代码库的类型是书写声明文件的第一步。
我们将会给出一些提示，关于怎样通过代码库的<em>使用方法</em>及其<em>源码</em>来识别库的类型。
根据库的文档及组织结构的不同，在这两种方式中可能一个会比另外的一个简单一些。
我们推荐你使用任意你喜欢的方式。</p>
<h2 id="你应该寻找什么"><a class="header" href="#你应该寻找什么">你应该寻找什么？</a></h2>
<p>在为代码库编写声明文件时，你需要问自己以下几个问题。</p>
<ol>
<li>
<p>如何获取代码库？</p>
<p>比如，是否只能够从 npm 或 CDN 获取。</p>
</li>
<li>
<p>如何导入代码库？</p>
<p>它是否添加了某个全局对象？它是否使用了<code>require</code>或<code>import</code>/<code>export</code>语句？</p>
</li>
</ol>
<h2 id="针对不同类型的代码库的示例"><a class="header" href="#针对不同类型的代码库的示例">针对不同类型的代码库的示例</a></h2>
<h3 id="模块化代码库"><a class="header" href="#模块化代码库">模块化代码库</a></h3>
<p>几乎所有的 Node.js 代码库都属于这一类。
这类代码库只能工作在有模块加载器的环境下。
比如，<code>express</code>只能在 Node.js 里工作，所以必须使用 CommonJS 的<code>require</code>函数加载。</p>
<p>ECMAScript 2015（也就是 ES2015，ECMAScript 6 或 ES6），CommonJS 和 RequireJS 具有相似的<em>导入</em>一个<em>模块</em>的写法。
例如，对于 JavaScript CommonJS （Node.js），写法如下：</p>
<pre><code class="language-js">var fs = require('fs');
</code></pre>
<p>对于 TypeScript 或 ES6，<code>import</code>关键字也具有相同的作用：</p>
<pre><code class="language-ts">import * as fs from 'fs';
</code></pre>
<p>你通常会在模块化代码库的文档里看到如下说明：</p>
<pre><code class="language-js">var someLib = require('someLib');
</code></pre>
<p>或</p>
<pre><code class="language-js">define(..., ['someLib'], function(someLib) {

});
</code></pre>
<p>与全局模块一样，你也可能会在 <a href="zh/declaration-files/library-structures.html#umd">UMD</a> 模块的文档里看到这些例子，因此要仔细查看源码和文档。</p>
<h4 id="从代码上识别模块化代码库"><a class="header" href="#从代码上识别模块化代码库">从代码上识别模块化代码库</a></h4>
<p>模块化代码库至少会包含以下代表性条目之一：</p>
<ul>
<li>无条件的调用<code>require</code>或<code>define</code></li>
<li>像<code>import * as a from 'b';</code>或<code>export c;</code>这样的声明</li>
<li>赋值给<code>exports</code>或<code>module.exports</code></li>
</ul>
<p>它们极少包含：</p>
<ul>
<li>对<code>window</code>或<code>global</code>的赋值</li>
</ul>
<h4 id="模块化代码库的模版"><a class="header" href="#模块化代码库的模版">模块化代码库的模版</a></h4>
<p>有以下四个模版可用：</p>
<ul>
<li><a href="zh/declaration-files/./templates/module.d.ts.html"><code>module.d.ts</code></a></li>
<li><a href="zh/declaration-files/./templates/module-class.d.ts.html"><code>module-class.d.ts</code></a></li>
<li><a href="zh/declaration-files/./templates/module-function.d.ts.html"><code>module-function.d.ts</code></a></li>
<li><a href="zh/declaration-files/./templates/module-plugin.d.ts.html"><code>module-plugin.d.ts</code></a></li>
</ul>
<p>你应该先阅读<a href="zh/declaration-files/./templates/module.d.ts.html"><code>module.d.ts</code></a>以便从整体上了解它们的工作方式。</p>
<p>然后，若一个模块可以当作函数调用，则使用<a href="zh/declaration-files/./templates/module-function.d.ts.html"><code>module-function.d.ts</code></a>。</p>
<pre><code class="language-js">const x = require('foo');
// Note: calling 'x' as a function
const y = x(42);
</code></pre>
<p>如果一个模块可以使用<code>new</code>来构造，则使用<a href="zh/declaration-files/./templates/module-class.d.ts.html"><code>module-class.d.ts</code></a>。</p>
<pre><code class="language-js">var x = require('bar');
// Note: using 'new' operator on the imported variable
var y = new x('hello');
</code></pre>
<p>如果一个模块在导入后会更改其它的模块，则使用<a href="zh/declaration-files/./templates/module-plugin.d.ts.html"><code>module-plugin.d.ts</code></a>。</p>
<pre><code class="language-js">const jest = require('jest');
require('jest-matchers-files');
</code></pre>
<h3 id="全局代码库"><a class="header" href="#全局代码库">全局代码库</a></h3>
<p>全局代码库可以通过全局作用域来访问（例如，不使用任何形式的<code>import</code>语句）。
许多代码库只是简单地导出一个或多个供使用的全局变量。
比如，如果你使用<a href="https://jquery.com/">jQuery</a>，那么可以使用<code>$</code>变量来引用它。</p>
<pre><code class="language-ts">$(() =&gt; {
    console.log('hello!');
});
</code></pre>
<p>你通常能够在文档里看到如何在 HTML 的 script 标签里引用代码库：</p>
<pre><code class="language-html">&lt;script src="http://a.great.cdn.for/someLib.js"&gt;&lt;/script&gt;
</code></pre>
<p>目前，大多数流行的全局代码库都以 UMD 代码库发布。
UMD 代码库与全局代码库很难通过文档来识别。
在编写全局代码库的声明文件之前，确保代码库不是 UMD 代码库。</p>
<h4 id="从代码来识别全局代码库"><a class="header" href="#从代码来识别全局代码库">从代码来识别全局代码库</a></h4>
<p>通常，全局代码库的代码十分简单。
一个全局的“Hello, world”代码库可以如下：</p>
<pre><code class="language-js">function createGreeting(s) {
    return 'Hello, ' + s;
}
</code></pre>
<p>或者这样：</p>
<pre><code class="language-js">window.createGreeting = function (s) {
    return 'Hello, ' + s;
};
</code></pre>
<p>在阅读全局代码库的代码时，你会看到：</p>
<ul>
<li>顶层的<code>var</code>语句或<code>function</code>声明</li>
<li>一个或多个<code>window.someName</code>赋值语句</li>
<li>假设 DOM 相关的原始值<code>document</code>或<code>window</code>存在</li>
</ul>
<p>你不会看到：</p>
<ul>
<li>检查或使用了模块加载器，如<code>require</code>或<code>define</code></li>
<li>CommonJS/Node.js 风格的导入语句，如<code>var fs = require("fs");</code></li>
<li><code>define(...)</code>调用</li>
<li>描述<code>require</code>或导入代码库的文档</li>
</ul>
<h4 id="全局代码库的示例"><a class="header" href="#全局代码库的示例">全局代码库的示例</a></h4>
<p>由于将全局代码库转换为 UMD 代码库十分容易，因此很少有代码库仍然使用全局代码库风格。
然而，小型的代码库以及需要使用 DOM 的代码库仍然可以是全局的。</p>
<h4 id="全局代码库的模版"><a class="header" href="#全局代码库的模版">全局代码库的模版</a></h4>
<p>模版文件<a href="zh/declaration-files/../doc/handbook/declaration%20files/templates/global.d.ts.html"><code>global.d.ts</code></a>定义了<code>myLib</code>示例代码库。
请务必阅读<a href="zh/declaration-files/library-structures.html#es6-%E5%AF%B9%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D%E7%9A%84%E5%BD%B1%E5%93%8D">脚注："防止命名冲突"</a>。</p>
<h3 id="umd"><a class="header" href="#umd">UMD</a></h3>
<p>一个 UMD 模块既可以用作 ES 模块（使用导入语句），也可以用作全局变量（在缺少模块加载器的环境中使用）。
许多流行的代码库，如<a href="http://momentjs.com/">Moment.js</a>，都是使用这模式发布的。
例如，在 Node.js 中或使用了 RequireJS 时，你可以这样使用：</p>
<pre><code class="language-ts">import moment = require('moment');
console.log(moment.format());
</code></pre>
<p>在纯浏览器环境中，你可以这样使用：</p>
<pre><code class="language-js">console.log(moment.format());
</code></pre>
<h3 id="识别-umd-代码库"><a class="header" href="#识别-umd-代码库">识别 UMD 代码库</a></h3>
<p><a href="https://github.com/umdjs/umd">UMD 模块</a>会检查运行环境中是否存在模块加载器。
这是一种常见模式，示例如下：</p>
<pre><code class="language-js">(function (root, factory) {
    if (typeof define === "function" &amp;&amp; define.amd) {
        define(["libName"], factory);
    } else if (typeof module === "object" &amp;&amp; module.exports) {
        module.exports = factory(require("libName"));
    } else {
        root.returnExports = factory(root.libName);
    }
}(this, function (b) {
</code></pre>
<p>如果你看到代码库中存在类如<code>typeof define</code>，<code>typeof window</code>或<code>typeof module</code>的检测代码，尤其是在文件的顶端，那么它大概率是 UMD 代码库。</p>
<p>在 UMD 模块的文档中经常会提供在 Node.js 中结合<code>require</code>使用的示例，以及在浏览器中结合<code>&lt;script&gt;</code>标签使用的示例。</p>
<h3 id="umd-代码库的示例"><a class="header" href="#umd-代码库的示例">UMD 代码库的示例</a></h3>
<p>大多数流行的代码库均提供了 UMD 格式的包。
例如，<a href="https://jquery.com/">jQuery</a>，<a href="http://momentjs.com/">Moment.js</a>和<a href="https://lodash.com/">lodash</a>等。</p>
<h4 id="模版-1"><a class="header" href="#模版-1">模版</a></h4>
<p>使用<a href="zh/declaration-files/./templates/module-plugin.d.ts.html"><code>module-plugin.d.ts</code></a>模版。</p>
<h3 id="全局插件"><a class="header" href="#全局插件">全局插件</a></h3>
<p>一个<em>全局插件</em>是全局代码，它们会改变全局对象的结构。 对于<em>全局修改的模块</em>，在运行时存在冲突的可能。</p>
<p>比如，一些库往<code>Array.prototype</code>或<code>String.prototype</code>里添加新的方法。</p>
<h4 id="识别全局插件"><a class="header" href="#识别全局插件">识别全局插件</a></h4>
<p>全局通常很容易地从它们的文档识别出来。</p>
<p>你会看到像下面这样的例子：</p>
<pre><code class="language-javascript">var x = 'hello, world';
// Creates new methods on built-in types
console.log(x.startsWithHello());

var y = [1, 2, 3];
// Creates new methods on built-in types
console.log(y.reverseAndSort());
</code></pre>
<h4 id="模版-2"><a class="header" href="#模版-2">模版</a></h4>
<p>使用<a href="zh/declaration-files/../doc/handbook/declaration%20files/templates/global-plugin.d.ts.html"><code>global-plugin.d.ts</code></a>模版。</p>
<h3 id="全局修改的模块"><a class="header" href="#全局修改的模块">全局修改的模块</a></h3>
<p>当一个<em>全局修改的模块</em>被导入的时候，它们会改变全局作用域里的值。 比如，存在一些库它们添加新的成员到<code>String.prototype</code>当导入它们的时候。 这种模式很危险，因为可能造成运行时的冲突， 但是我们仍然可以为它们书写声明文件。</p>
<h4 id="识别全局修改的模块"><a class="header" href="#识别全局修改的模块">识别全局修改的模块</a></h4>
<p>全局修改的模块通常可以很容易地从它们的文档识别出来。 通常来讲，它们与全局插件相似，但是需要<code>require</code>调用来激活它们的效果。</p>
<p>你可能会看到像下面这样的文档:</p>
<pre><code class="language-javascript">// 'require' call that doesn't use its return value
var unused = require('magic-string-time');
/* or */
require('magic-string-time');

var x = 'hello, world';
// Creates new methods on built-in types
console.log(x.startsWithHello());

var y = [1, 2, 3];
// Creates new methods on built-in types
console.log(y.reverseAndSort());
</code></pre>
<h4 id="模版-3"><a class="header" href="#模版-3">模版</a></h4>
<p>使用<a href="zh/declaration-files/../doc/handbook/declaration%20files/templates/global-modifying-module.d.ts.html"><code>global-modifying-module.d.ts</code></a>模版。</p>
<h2 id="利用依赖"><a class="header" href="#利用依赖">利用依赖</a></h2>
<p>你的代码库可能会有若干种依赖。
本节会介绍如何在声明文件中导入它们。</p>
<h3 id="对全局库的依赖"><a class="header" href="#对全局库的依赖">对全局库的依赖</a></h3>
<p>如果你的代码库依赖于某个全局代码库，则使用<code>/// &lt;reference types="..." /&gt;</code>指令：</p>
<pre><code class="language-ts">/// &lt;reference types="someLib" /&gt;

function getThing(): someLib.thing;
</code></pre>
<h3 id="对模块的依赖"><a class="header" href="#对模块的依赖">对模块的依赖</a></h3>
<p>如果你的代码库依赖于某个模块，则使用<code>import</code>语句：</p>
<pre><code class="language-ts">import * as moment from 'moment';

function getThing(): moment;
</code></pre>
<h3 id="对-umd-模块的依赖"><a class="header" href="#对-umd-模块的依赖">对 UMD 模块的依赖</a></h3>
<h4 id="全局代码库-1"><a class="header" href="#全局代码库-1">全局代码库</a></h4>
<p>如果你的全局代码库依赖于某个 UMD 模块，则使用<code>/// &lt;reference types</code>指令：</p>
<pre><code class="language-ts">/// &lt;reference types="moment" /&gt;

function getThing(): moment;
</code></pre>
<h4 id="es-模块或-umd-模块代码库"><a class="header" href="#es-模块或-umd-模块代码库">ES 模块或 UMD 模块代码库</a></h4>
<p>如果你的模块或 UMD 代码库依赖于某个 UMD 代码库，则使用<code>import</code>语句：</p>
<pre><code class="language-ts">import * as someLib from 'someLib';
</code></pre>
<p>不要使用<code>/// &lt;reference</code>指令来声明对 UMD 代码库的依赖。</p>
<h2 id="脚注"><a class="header" href="#脚注">脚注</a></h2>
<h3 id="防止命名冲突"><a class="header" href="#防止命名冲突">防止命名冲突</a></h3>
<p>注意，虽说可以在全局作用域内定义许多类型。
但我们强烈建议不要这样做，因为当一个工程中存在多个声明文件时，它可能会导致难以解决的命名冲突。</p>
<p>可以遵循的一个简单规则是使用代码库提供的某个全局变量来声明拥有命名空间的类型。
例如，如果代码库提供了全局变量<code>cats</code>，那么可以这样写：</p>
<pre><code class="language-ts">declare namespace cats {
    interface KittySettings {}
}
</code></pre>
<p>而不是：</p>
<pre><code class="language-ts">// at top-level
interface CatsKittySettings {}
</code></pre>
<p>这样做会保证代码库可以被转换成 UMD 模块，且不会影响声明文件的使用者。</p>
<h3 id="es6-对模块插件的影响"><a class="header" href="#es6-对模块插件的影响">ES6 对模块插件的影响</a></h3>
<p>一些插件会对已有模块的顶层导出进行添加或修改。
这在 CommonJS 以及其它模块加载器里是合法的，但 ES6 模块是不可改变的，因此该模式是不可行的。
因为，TypeScript 是模块加载器无关的，所以在编译时不会对该行为加以限制，但是开发者若想要转换到 ES6 模块加载器则需要注意这一点。</p>
<h3 id="es6-对模块调用签名的影响"><a class="header" href="#es6-对模块调用签名的影响">ES6 对模块调用签名的影响</a></h3>
<p>许多代码库，如 Express，将自身导出为可调用的函数。
例如，Express 的典型用法如下：</p>
<pre><code class="language-ts">import exp = require('express');
var app = exp();
</code></pre>
<p>在 ES6 模块加载器中，顶层对象（此例中就<code>exp</code>）只能拥有属性；
顶层的模块对象永远不能够被调用。</p>
<p>最常见的解决方案是为可调用的/可构造的对象定义一个<code>default</code>导出；
有些模块加载器会自动检测这种情况并且将顶层对象替换为<code>default</code>导出。
如果在 tsconfig.json 里启用了<a href="zh/declaration-files//tsconfig/#esModuleInterop"><code>"esModuleInterop": true</code></a>，那么 Typescript 会自动为你处理。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模板"><a class="header" href="#模板">模板</a></h1>
<ul>
<li><a href="zh/declaration-files/templates/global-modifying-module.d.ts.html">global-modifying-module.d.ts</a></li>
<li><a href="zh/declaration-files/templates/global-plugin.d.ts.html">global-plugin.d.ts</a></li>
<li><a href="zh/declaration-files/templates/global.d.ts.html">global.d.ts</a></li>
<li><a href="zh/declaration-files/templates/module-class.d.ts.html">module-class.d.ts</a></li>
<li><a href="zh/declaration-files/templates/module-function.d.ts.html">module-function.d.ts</a></li>
<li><a href="zh/declaration-files/templates/module-plugin.d.ts.html">module-plugin.d.ts</a></li>
<li><a href="zh/declaration-files/templates/module.d.ts.html">module.d.ts</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h1>
<h2 id="常规类型"><a class="header" href="#常规类型">常规类型</a></h2>
<h3 id="numberstringbooleansymbol和object"><a class="header" href="#numberstringbooleansymbol和object"><code>Number</code>，<code>String</code>，<code>Boolean</code>，<code>Symbol</code>和<code>Object</code></a></h3>
<p><em>不要</em>使用以下类型<code>Number</code>，<code>String</code>，<code>Boolean</code>，<code>Symbol</code>或<code>Object</code>。
这些类型表示是非原始的封箱后的对象类型，它们几乎没有在 JavaScript 代码里被正确地使用过。</p>
<pre><code class="language-ts">/* 错误 */
function reverse(s: String): String;
</code></pre>
<p><em>应该</em>使用<code>number</code>，<code>string</code>，<code>boolean</code>和<code>symbol</code>类型。</p>
<pre><code class="language-ts">/* 正确 */
function reverse(s: string): string;
</code></pre>
<p>使用非原始的<code>object</code>类型来代替<code>Object</code>类型（<a href="zh/declaration-files/../release-notes/typeScript-2.2.html#object%E7%B1%BB%E5%9E%8B">在 TypeScript 2.2 中新增</a>）</p>
<h3 id="泛型-2"><a class="header" href="#泛型-2">泛型</a></h3>
<p><em>不要</em>定义没有使用过类型参数的泛型类型。
更多详情请参考：<a href="https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---">TypeScript FAQ page</a>。</p>
<h3 id="any-1"><a class="header" href="#any-1">any</a></h3>
<p>请尽量不要使用<code>any</code>类型，除非你正在将 JavaScript 代码迁移到 TypeScript 代码。
编译器实际上会将<code>any</code>视作“对其关闭类型检查”。
使用它与在每个变量前使用<code>@ts-ignore</code>注释是一样的。
它只在首次将 JavaScript 工程迁移到 TypeScript 工程时有用，因为你可以把还没有迁移完的实体标记为<code>any</code>类型，但在完整的 TypeScript 工程中，这样做就会禁用掉类型检查。</p>
<p>如果你不清楚要接收什么类型的数据，或者你希望接收任意类型并直接向下传递而不使用它，那么就可以使用<a href="zh/declaration-files/../handbook/basic-types.html#unknown"><code>unknown</code></a>类型。</p>
<h2 id="回调函数类型"><a class="header" href="#回调函数类型">回调函数类型</a></h2>
<h3 id="回调函数的返回值类型"><a class="header" href="#回调函数的返回值类型">回调函数的返回值类型</a></h3>
<p><em>不要</em>为返回值会被忽略的回调函数设置返回值类型<code>any</code>：</p>
<pre><code class="language-ts">/* 错误 */
function fn(x: () =&gt; any) {
    x();
}
</code></pre>
<p><em>应该</em>为返回值会被忽略的回调函数设置返回值类型<code>void</code>：</p>
<pre><code class="language-ts">/* 正确 */
function fn(x: () =&gt; void) {
    x();
}
</code></pre>
<p><em>原因</em>：使用<code>void</code>相对安全，因为它能防止不小心使用了未经检查的<code>x</code>的返回值：</p>
<pre><code class="language-ts">function fn(x: () =&gt; void) {
    var k = x(); // oops! meant to do something else
    k.doSomething(); // error, but would be OK if the return type had been 'any'
}
</code></pre>
<h3 id="回调函数里的可选参数"><a class="header" href="#回调函数里的可选参数">回调函数里的可选参数</a></h3>
<p><em>不要</em>在回调函数里使用可选参数，除非这是你想要的：</p>
<pre><code class="language-ts">/* 错误 */
interface Fetcher {
    getObject(done: (data: any, elapsedTime?: number) =&gt; void): void;
}
</code></pre>
<p>这里有具体的意义：<code>done</code>回调函数可以用 1 个参数或 2 个参数调用。
代码的大意是说该回调函数不关注是否有<code>elapsedTime</code>参数， 但是不需要把这个参数定义为可选参数来达到此目的 --
因为总是允许提供一个接收较少参数的回调函数。</p>
<p><em>应该</em>将回调函数定义为无可选参数：</p>
<pre><code class="language-ts">/* 正确 */
interface Fetcher {
    getObject(done: (data: any, elapsedTime: number) =&gt; void): void;
}
</code></pre>
<h3 id="重载与回调函数"><a class="header" href="#重载与回调函数">重载与回调函数</a></h3>
<p><em>不要</em>因回调函数的参数数量不同而编写不同的重载。</p>
<pre><code class="language-ts">/* WRONG */
declare function beforeAll(action: () =&gt; void, timeout?: number): void;
declare function beforeAll(
    action: (done: DoneFn) =&gt; void,
    timeout?: number
): void;
</code></pre>
<p><em>应该</em>只为最大数量参数的情况编写一个重载：</p>
<pre><code class="language-ts">/* 正确 */
declare function beforeAll(
    action: (done: DoneFn) =&gt; void,
    timeout?: number
): void;
</code></pre>
<p><em>原因</em>：回调函数总是允许忽略某个参数的，因此没必要为缺少可选参数的情况编写重载。
为缺少可选参数的情况提供重载可能会导致类型错误的回调函数被传入，因为它会匹配到第一个重载。</p>
<h2 id="函数重载-2"><a class="header" href="#函数重载-2">函数重载</a></h2>
<h3 id="顺序"><a class="header" href="#顺序">顺序</a></h3>
<p><em>不要</em>把模糊的重载放在具体的重载前面：</p>
<pre><code class="language-ts">/* 错误 */
declare function fn(x: any): any;
declare function fn(x: HTMLElement): number;
declare function fn(x: HTMLDivElement): string;

var myElem: HTMLDivElement;
var x = fn(myElem); // x: any, wat?
</code></pre>
<p><em>应该</em>将重载排序，把具体的排在模糊的之前：</p>
<pre><code class="language-ts">/* 正确 */
declare function fn(x: HTMLDivElement): string;
declare function fn(x: HTMLElement): number;
declare function fn(x: any): any;

var myElem: HTMLDivElement;
var x = fn(myElem); // x: string, :)
</code></pre>
<p><em>原因</em>：当解析函数调用的时候，TypeScript 会选择<em>匹配到的第一个重载</em>。
当位于前面的重载比后面的“更模糊”，那么后面的会被隐藏且不会被选用。</p>
<h3 id="使用可选参数"><a class="header" href="#使用可选参数">使用可选参数</a></h3>
<p><em>不要</em>因为只有末尾参数不同而编写不同的重载：</p>
<pre><code class="language-ts">/* WRONG */
interface Example {
    diff(one: string): number;
    diff(one: string, two: string): number;
    diff(one: string, two: string, three: boolean): number;
}
</code></pre>
<p><em>应该</em>尽可能使用可选参数：</p>
<pre><code class="language-ts">/* OK */
interface Example {
    diff(one: string, two?: string, three?: boolean): number;
}
</code></pre>
<p>注意，这只在返回值类型相同的情况是没问题的。</p>
<p><em>原因</em>：有以下两个重要原因。</p>
<p>TypeScript 解析签名兼容性时会查看是否某个目标签名能够使用原参数调用，
<em>且允许额外的参数</em>。
下面的代码仅在签名被正确地使用可选参数定义时才会暴露出一个 bug：</p>
<pre><code class="language-ts">function fn(x: (a: string, b: number, c: number) =&gt; void) {}
var x: Example;
// When written with overloads, OK -- used first overload
// When written with optionals, correctly an error
fn(x.diff);
</code></pre>
<p>第二个原因是当使用了 TypeScript “严格检查 null” 的特性时。
因为未指定的参数在 JavaScript 里表示为<code>undefined</code>，通常明确地为可选参数传入一个<code>undefined</code>不会有问题。
这段代码在严格 <code>null</code> 模式下可以工作：</p>
<pre><code class="language-ts">var x: Example;
// When written with overloads, incorrectly an error because of passing 'undefined' to 'string'
// When written with optionals, correctly OK
x.diff("something", true ? undefined : "hour");
</code></pre>
<h3 id="使用联合类型"><a class="header" href="#使用联合类型">使用联合类型</a></h3>
<p><em>不要</em>仅因某个特定位置上的参数类型不同而定义重载：</p>
<pre><code class="language-ts">/* 错误 */
interface Moment {
  utcOffset(): number;
  utcOffset(b: number): Moment;
  utcOffset(b: string): Moment;
}
</code></pre>
<p><em>应该</em>尽可能地使用联合类型：</p>
<pre><code class="language-ts">/* 正确 */
interface Moment {
  utcOffset(): number;
  utcOffset(b: number | string): Moment;
}
</code></pre>
<p>注意，我们没有让<code>b</code>成为可选的，因为签名的返回值类型不同。</p>
<p><em>原因</em>：这对于那些为该函数传入了值的使用者来说很重要。</p>
<pre><code class="language-ts">function fn(x: string): void;
function fn(x: number): void;
function fn(x: number | string) {
  // When written with separate overloads, incorrectly an error
  // When written with union types, correctly OK
  return moment().utcOffset(x);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="深入-1"><a class="header" href="#深入-1">深入</a></h1>
<p>组织模块以提供你想要的 API 结构是比较难的。
比如，你可能想要这样一个模块，可以用或不用<code>new</code>来创建不同的类型，在不同层级上暴露出不同的命名类型，且模块对象上还带有一些属性。</p>
<p>阅读这篇指南后，你就会了解如何编写复杂的声明文件来提供友好的 API 。
这篇指南针对于模块（或UMD）代码库，因为它们的选择具有更高的可变性。</p>
<h2 id="核心概念"><a class="header" href="#核心概念">核心概念</a></h2>
<p>如果你理解了一些关于 TypeScript 是如何工作的核心概念， 那么你就能够为任何结构书写声明文件。</p>
<h3 id="类型"><a class="header" href="#类型">类型</a></h3>
<p>如果你正在阅读这篇指南，你可能已经大概了解 TypeScript 里的类型指是什么。 明确一下，<em>类型</em>通过以下方式引入：</p>
<ul>
<li>类型别名声明（<code>type sn = number | string;</code>）</li>
<li>接口声明（<code>interface I { x: number[]; }</code>）</li>
<li>类声明（<code>class C { }</code>）</li>
<li>枚举声明（<code>enum E { A, B, C }</code>）</li>
<li>指向某个类型的<code>import</code>声明</li>
</ul>
<p>以上每种声明形式都会创建一个新的类型名称。</p>
<h3 id="值"><a class="header" href="#值">值</a></h3>
<p>与类型相比，你可能已经理解了什么是值。
值是运行时的名字，它可以在表达式里引用。
比如<code>let x = 5;</code>创建了一个名为<code>x</code>的值。</p>
<p>同样地，以下方式能够创建值：</p>
<ul>
<li><code>let</code>，<code>const</code>，和<code>var</code>声明</li>
<li>包含值的<code>namespace</code>或<code>module</code>声明</li>
<li><code>enum</code>声明</li>
<li><code>class</code>声明</li>
<li>指向值的<code>import</code>声明</li>
<li><code>function</code>声明</li>
</ul>
<h3 id="命名空间-2"><a class="header" href="#命名空间-2">命名空间</a></h3>
<p>类型可以存在于<em>命名空间</em>里。 比如，有这样的声明<code>let x: A.B.C</code>， 我们就认为<code>C</code>类型来自于<code>A.B</code>命名空间。</p>
<p>这个区别虽细微但很重要 -- 这里，<code>A.B</code>不是必需的类型或值。</p>
<h2 id="简单的组合一个名字多种意义"><a class="header" href="#简单的组合一个名字多种意义">简单的组合：一个名字，多种意义</a></h2>
<p>一个给定的名字<code>A</code>，我们可以找出三种不同的意义：一个类型，一个值或一个命名空间。 要如何去解析这个名字要看它所在的上下文是怎样的。
比如，在声明<code>let m: A.A = A;</code>中，<code>A</code>首先被当做命名空间，然后做为类型名，最后是值。
这些意义最终可能会指向完全不同的声明！</p>
<p>这看上去让人迷惑，但是只要我们不过度的重载这还是很方便的。
下面让我们来看看一些有用的组合行为。</p>
<h3 id="内置组合"><a class="header" href="#内置组合">内置组合</a></h3>
<p>眼尖的读者可能会注意到，比如，<code>class</code>同时出现在<em>类型</em>和<em>值</em>列表里。
<code>class C { }</code>声明创建了两个东西： <em>类型</em><code>C</code>指向类的实例结构， <em>值</em><code>C</code>指向类构造函数。
枚举声明拥有相似的行为。</p>
<h3 id="用户定义组合"><a class="header" href="#用户定义组合">用户定义组合</a></h3>
<p>假设我们写了模块文件<code>foo.d.ts</code>:</p>
<pre><code class="language-ts">export var SomeVar: { a: SomeType };
export interface SomeType {
  count: number;
}
</code></pre>
<p>这样使用它：</p>
<pre><code class="language-ts">import * as foo from "./foo";
let x: foo.SomeType = foo.SomeVar.a;
console.log(x.count);
</code></pre>
<p>这可以很好地工作，但是我们知道<code>SomeType</code>和<code>SomeVar</code>密切相关 因此我们想让它们有相同的名字。
我们可以使用组合通过相同的名字<code>Bar</code>表示这两种不同的对象（值和对象）：</p>
<pre><code class="language-ts">export var Bar: { a: Bar };
export interface Bar {
  count: number;
}
</code></pre>
<p>这提供了使用解构的机会：</p>
<pre><code class="language-ts">import { Bar } from "./foo";
let x: Bar = Bar.a;
console.log(x.count);
</code></pre>
<p>再次地，这里我们使用<code>Bar</code>做为类型和值。
注意我们没有声明<code>Bar</code>值为<code>Bar</code>类型 -- 它们是独立的。</p>
<h2 id="高级组合"><a class="header" href="#高级组合">高级组合</a></h2>
<p>有一些声明能够通过多个声明组合。
比如，<code>class C { }</code>和<code>interface C { }</code>可以同时存在并且都可以做为<code>C</code>类型的属性。</p>
<p>只要不产生冲突就是合法的。
一个普通的规则是值总是会和同名的其它值产生冲突，除非它们在不同命名空间里，类型冲突则发生在使用类型别名声明的情况下（<code>type s = string</code>），命名空间永远不会发生冲突。</p>
<p>让我们看看如何使用。</p>
<h3 id="通过interface添加"><a class="header" href="#通过interface添加">通过<code>interface</code>添加</a></h3>
<p>我们可以使用一个<code>interface</code>向另一个<code>interface</code>声明里添加额外成员：</p>
<pre><code class="language-ts">interface Foo {
  x: number;
}
// ... elsewhere ...
interface Foo {
  y: number;
}
let a: Foo = ...;
console.log(a.x + a.y); // OK
</code></pre>
<p>这同样作用于类：</p>
<pre><code class="language-ts">class Foo {
  x: number;
}
// ... elsewhere ...
interface Foo {
  y: number;
}
let a: Foo = ...;
console.log(a.x + a.y); // OK
</code></pre>
<p>注意我们不能使用接口往类型别名里添加成员（<code>type s = string;</code>）</p>
<h3 id="通过namespace添加"><a class="header" href="#通过namespace添加">通过<code>namespace</code>添加</a></h3>
<p><code>namespace</code>声明可以用来添加新类型，值和命名空间，只要不出现冲突即可。</p>
<p>比如，我们可以添加静态成员到一个类：</p>
<pre><code class="language-ts">class C {}
// ... elsewhere ...
namespace C {
  export let x: number;
}
let y = C.x; // OK
</code></pre>
<p>注意在这个例子里，我们添加一个值到<code>C</code>的<em>静态</em>部分（它的构造函数）。
这里因为我们添加了一个<em>值</em>，且其它值的容器是另一个值（类型包含于命名空间，命名空间包含于另外的命名空间）。</p>
<p>我们还可以给类添加一个命名空间类型：</p>
<pre><code class="language-ts">class C {}
// ... elsewhere ...
namespace C {
  export interface D {}
}
let y: C.D; // OK
</code></pre>
<p>在这个例子里，直到我们写了<code>namespace</code>声明才有了命名空间<code>C</code>。
做为命名空间的<code>C</code>不会与类创建的值<code>C</code>或类型<code>C</code>相互冲突。</p>
<p>最后，我们可以进行不同的合并通过<code>namespace</code>声明。</p>
<pre><code class="language-ts">namespace X {
  export interface Y {}
  export class Z {}
}

// ... elsewhere ...
namespace X {
  export var Y: number;
  export namespace Z {
    export class C {}
  }
}
type X = string;
</code></pre>
<p>在这个例子里，第一个代码块创建了以下名字与含义：</p>
<ul>
<li>一个值<code>X</code>（因为<code>namespace</code>声明包含一个值，<code>Z</code>）</li>
<li>一个命名空间<code>X</code>（因为<code>namespace</code>声明包含一个类型，<code>Y</code>）</li>
<li>在命名空间<code>X</code>里的类型<code>Y</code></li>
<li>在命名空间<code>X</code>里的类型<code>Z</code>（类的实例结构）</li>
<li>值<code>X</code>的一个属性值<code>Z</code>（类的构造函数）</li>
</ul>
<p>第二个代码块创建了以下名字与含义：</p>
<ul>
<li>值<code>Y</code>（<code>number</code>类型），它是值<code>X</code>的一个属性</li>
<li>一个命名空间<code>Z</code></li>
<li>值<code>Z</code>，它是值<code>X</code>的一个属性</li>
<li>在<code>X.Z</code>命名空间下的类型<code>C</code></li>
<li>值<code>X.Z</code>的一个属性值<code>C</code></li>
<li>类型<code>X</code></li>
</ul>
<h2 id="使用export-或import"><a class="header" href="#使用export-或import">使用<code>export =</code>或<code>import</code></a></h2>
<p>一个重要的原则是<code>export</code>和<code>import</code>声明会导出或导入目标的<em>所有含义</em>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="发布"><a class="header" href="#发布">发布</a></h1>
<p>现在我们已经按照指南里的步骤写好了一个声明文件，是时候把它发布到 npm 了。
有两种主要方式用来将声明文件发布到 npm：</p>
<ol>
<li>与你的 npm 包捆绑在一起，或</li>
<li>发布到 npm 上的<a href="https://www.npmjs.com/~types">@types organization</a>。</li>
</ol>
<p>如果声明文件是由你写的源码生成的，那么就将声明文件与源码一起发布。
TypeScript 工程和 JavaScript 工程都可以使用<a href="zh/declaration-files//tsconfig#declaration"><code>--declaration</code></a>选项来生成声明文件。</p>
<p>否则，我们推荐你将声明文件提交到 DefinitelyTyped，它会被发布到 npm 的<code>@types</code>里。</p>
<h2 id="包含声明文件到你的-npm-包"><a class="header" href="#包含声明文件到你的-npm-包">包含声明文件到你的 npm 包</a></h2>
<p>如果你的包有一个主<code>.js</code>文件，你还需要在<code>package.json</code>里指定主声明文件。
设置<code>types</code>属性指向捆绑在一起的声明文件。 比如：</p>
<pre><code class="language-json">{
    "name": "awesome",
    "author": "Vandelay Industries",
    "version": "1.0.0",
    "main": "./lib/main.js",
    "types": "./lib/main.d.ts"
}
</code></pre>
<p>注意<code>"typings"</code>与<code>"types"</code>具有相同的意义，也可以使用它。</p>
<p>同样要注意的是如果主声明文件名是<code>index.d.ts</code>并且位置在包的根目录里（与<code>index.js</code>并列），你就不需要使用<code>"types"</code>属性指定了。</p>
<h2 id="依赖"><a class="header" href="#依赖">依赖</a></h2>
<p>所有的依赖是由 npm 管理的。
确保所依赖的声明包都在<code>package.json</code>的<code>"dependencies"</code>里指明了。
比如，假设我们写了一个包，它依赖于 Browserify 和 TypeScript。</p>
<pre><code class="language-json">{
    "name": "browserify-typescript-extension",
    "author": "Vandelay Industries",
    "version": "1.0.0",
    "main": "./lib/main.js",
    "types": "./lib/main.d.ts",
    "dependencies": {
        "browserify": "latest",
        "@types/browserify": "latest",
        "typescript": "next"
    }
}
</code></pre>
<p>这里，我们的包依赖于<code>browserify</code>和<code>typescript</code>包。 <code>browserify</code>没有把它的声明文件捆绑在它的 npm 包里，所以我们需要依赖于<code>@types/browserify</code>得到它的声明文件。
而<code>typescript</code>则相反，它把声明文件放在了 npm 包里，因此我们不需要依赖额外的包。</p>
<p>我们的包要从这两个包里暴露出声明文件，因此<code>browserify-typescript-extension</code>的用户也需要这些依赖。 正因此，我们使用<code>"dependencies"</code>而不是<code>"devDependencies"</code>，否则用户将需要手动安装那些包。 如果我们只是在写一个命令行应用，并且我们的包不会被当做一个库使用的话，那么就可以使用<code>devDependencies</code>。</p>
<h2 id="危险信号-1"><a class="header" href="#危险信号-1">危险信号</a></h2>
<h3 id="-reference-path--1"><a class="header" href="#-reference-path--1"><code>/// &lt;reference path="..." /&gt;</code></a></h3>
<p><em>不要</em>在声明文件里使用<code>/// &lt;reference path="..." /&gt;</code>。</p>
<pre><code class="language-ts">/// &lt;reference path="../typescript/lib/typescriptServices.d.ts" /&gt;
....
</code></pre>
<p><em>应该</em>使用<code>/// &lt;reference types="..." /&gt;</code>代替</p>
<pre><code class="language-ts">/// &lt;reference types="typescript" /&gt;
....
</code></pre>
<p>务必阅读<a href="zh/declaration-files/./library-structures.html#%E5%88%A9%E7%94%A8%E4%BE%9D%E8%B5%96">利用依赖</a>一节了解详情。</p>
<h3 id="打包所依赖的声明"><a class="header" href="#打包所依赖的声明">打包所依赖的声明</a></h3>
<p>如果你的类型声明依赖于另一个包：</p>
<ul>
<li><em>不要</em>把依赖的包放进你的包里，保持它们在各自的文件里。</li>
<li><em>不要</em>将声明拷贝到你的包里。</li>
<li><em>应该</em>依赖在 npm 上的类型声明包，如果依赖包没包含它自己的声明文件的话。</li>
</ul>
<h2 id="使用typesversions选择版本"><a class="header" href="#使用typesversions选择版本">使用<code>typesVersions</code>选择版本</a></h2>
<p>当 TypeScript 打开一个<code>package.json</code>文件来决定要读取哪个文件，它首先会检查<code>typesVersions</code>字段。</p>
<p>带有<code>typesVersions</code>字段的<code>package.json</code>可能如下：</p>
<pre><code class="language-json">{
    "name": "package-name",
    "version": "1.0",
    "types": "./index.d.ts",
    "typesVersions": {
        "&gt;=3.1": { "*": ["ts3.1/*"] }
    }
}
</code></pre>
<p>该<code>package.json</code>告诉 TypeScript 去检查当前正在运行的 TypeScript 版本。
如果是 3.1 及以上版本，则会相对于<code>package.json</code>的位置来读取<code>ts3.1</code>目录的内容。
这就是<code>{ "*": ["ts3.1/*"] }</code>的含义 - 如果你熟悉路径映射的话，它们是相似的工作方式。</p>
<p>上例中，如果我们从<code>"package-name"</code>导入，当 TypeScript 版本为 3.1 时，TypeScript 会尝试解析<code>[...]/node_modules/package-name/ts3.1/index.d.ts</code>（及其它相应路径）。
如果导入的是<code>package-name/foo</code>，那么会尝试加载<code>[...]/node_modules/package-name/ts3.1/foo.d.ts</code>和<code>[...]/node_modules/package-name/ts3.1/foo/index.d.ts</code>。</p>
<p>那么如果不是在 TypeScript 3.1 环境中呢？
如果<code>typesVersions</code>中的每个字段都无法匹配，TypeScript 会回退到<code>types</code>字段，因此在 TypeScript 3.0 及之前的版本中会加载<code>[...]/node_modules/package-name/index.d.ts</code>文件。</p>
<h2 id="匹配行为"><a class="header" href="#匹配行为">匹配行为</a></h2>
<p>TypeScript 是根据 Node.js 的<a href="https://github.com/npm/node-semver#ranges">语言化版本</a>来进行编译器及语言版本匹配的。</p>
<h2 id="存在多个字段"><a class="header" href="#存在多个字段">存在多个字段</a></h2>
<p><code>typesVersions</code>支持同时指定多个字段，每个字段都指定了匹配的范围。</p>
<pre><code class="language-json tsconfig">{
    "name": "package-name",
    "version": "1.0",
    "types": "./index.d.ts",
    "typesVersions": {
        "&gt;=3.2": { "*": ["ts3.2/*"] },
        "&gt;=3.1": { "*": ["ts3.1/*"] }
    }
}
</code></pre>
<p>由于指定的范围有发生重叠的潜在风险，因此声明文件的解析与指定的顺序是相关的。
也就是说，虽然<code>&gt;=3.2</code>和<code>&gt;=3.1</code>都匹配 TypeScript 3.2 及以上版本，但调换顺序后会有不同的行为，因此上例不同于下例。</p>
<pre><code class="language-jsonc tsconfig">{
    "name": "package-name",
    "version": "1.0",
    "types": "./index.d.ts",
    "typesVersions": {
        // NOTE: this doesn't work!
        "&gt;=3.1": { "*": ["ts3.1/*"] },
        "&gt;=3.2": { "*": ["ts3.2/*"] }
    }
}
</code></pre>
<h2 id="发布到types"><a class="header" href="#发布到types">发布到<a href="https://www.npmjs.com/~types">@types</a></a></h2>
<p><a href="https://www.npmjs.com/~types">@types</a>里的包是使用<a href="https://github.com/Microsoft/types-publisher">types-publisher 工具</a>从<a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a>里自动发布的。
如果想让你的包发布为<code>@types</code>包，提交一个 pull request 到<a href="https://github.com/DefinitelyTyped/DefinitelyTyped">https://github.com/DefinitelyTyped/DefinitelyTyped</a>。
更多详情请参考<a href="http://definitelytyped.org/guides/contributing.html">contribution guidelines page</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用"><a class="header" href="#使用">使用</a></h1>
<h2 id="下载"><a class="header" href="#下载">下载</a></h2>
<p>想要获取声明文件只需要用到 npm。</p>
<p>比如，想要获取 lodash 库的声明文件，只需使用下面的命令：</p>
<pre><code class="language-text">npm install --save @types/lodash
</code></pre>
<p>如果一个 npm 包像<a href="zh/declaration-files/publishing.html">Publishing</a>里介绍的一样已经包含其声明文件，那就不必再去下载相应的<code>@types</code>包了。</p>
<h2 id="使用-1"><a class="header" href="#使用-1">使用</a></h2>
<p>下载完后，就可以直接在 TypeScript 里使用 lodash 了。 不论是在模块里还是全局代码里使用。</p>
<p>比如，你已经<code>npm install</code>安装了声明文件，你可以使用导入：</p>
<pre><code class="language-ts">import * as _ from 'lodash';
_.padStart('Hello TypeScript!', 20, ' ');
</code></pre>
<p>或者如果你没有使用模块，那么你只需使用全局的变量<code>_</code>。</p>
<pre><code class="language-ts">_.padStart('Hello TypeScript!', 20, ' ');
</code></pre>
<h2 id="查找"><a class="header" href="#查找">查找</a></h2>
<p>大多数情况下，类型声明包的名字总是与其在<code>npm</code>上的包的名字相同，但是有<code>@types/</code>前缀。
但如果你需要的话，你可以在<a href="https://aka.ms/types">https://aka.ms/types</a>上查找你喜欢的库。</p>
<blockquote>
<p>注意：如果你要找的声明文件不存在，你可以贡献一份，这样就方便了下一位开发者。
查看 DefinitelyTyped <a href="http://definitelytyped.org/guides/contributing.html">贡献指南页</a>了解详情。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript文件里的类型检查"><a class="header" href="#javascript文件里的类型检查">JavaScript文件里的类型检查</a></h1>
<p>TypeScript 2.3以后的版本支持使用<code>--checkJs</code>对<code>.js</code>文件进行类型检查和错误提示。</p>
<p>你可以通过添加<code>// @ts-nocheck</code>注释来忽略类型检查；相反，你可以通过去掉<code>--checkJs</code>设置并添加一个<code>// @ts-check</code>注释来选择检查某些<code>.js</code>文件。 你还可以使用<code>// @ts-ignore</code>来忽略本行的错误。 如果你使用了<code>tsconfig.json</code>，JS检查将遵照一些严格检查标记，如<code>noImplicitAny</code>，<code>strictNullChecks</code>等。 但因为JS检查是相对宽松的，在使用严格标记时可能会有些出乎意料的情况。</p>
<p>对比<code>.js</code>文件和<code>.ts</code>文件在类型检查上的差异，有如下几点需要注意：</p>
<h3 id="用jsdoc类型表示类型信息"><a class="header" href="#用jsdoc类型表示类型信息">用JSDoc类型表示类型信息</a></h3>
<p><code>.js</code>文件里，类型可以和在<code>.ts</code>文件里一样被推断出来。 同样地，当类型不能被推断时，它们可以通过JSDoc来指定，就好比在<code>.ts</code>文件里那样。 如同TypeScript，<code>--noImplicitAny</code>会在编译器无法推断类型的位置报错。 （除了对象字面量的情况；后面会详细介绍）</p>
<p>JSDoc注解修饰的声明会被设置为这个声明的类型。比如：</p>
<pre><code class="language-javascript">/** @type {number} */
var x;

x = 0;      // OK
x = false;  // Error: boolean is not assignable to number
</code></pre>
<p>你可以在这里找到所有JSDoc支持的模式，<a href="zh/javascript/type-checking-javascript-files.html#supported-jsdoc">JSDoc文档</a>。</p>
<h3 id="属性的推断来自于类内的赋值语句"><a class="header" href="#属性的推断来自于类内的赋值语句">属性的推断来自于类内的赋值语句</a></h3>
<p>ES2015没提供声明类属性的方法。属性是动态赋值的，就像对象字面量一样。</p>
<p>在<code>.js</code>文件里，编译器从类内部的属性赋值语句来推断属性类型。 属性的类型是在构造函数里赋的值的类型，除非它没在构造函数里定义或者在构造函数里是<code>undefined</code>或<code>null</code>。 若是这种情况，类型将会是所有赋的值的类型的联合类型。 在构造函数里定义的属性会被认为是一直存在的，然而那些在方法，存取器里定义的属性被当成可选的。</p>
<pre><code class="language-javascript">class C {
    constructor() {
        this.constructorOnly = 0
        this.constructorUnknown = undefined
    }
    method() {
        this.constructorOnly = false // error, constructorOnly is a number
        this.constructorUnknown = "plunkbat" // ok, constructorUnknown is string | undefined
        this.methodOnly = 'ok'  // ok, but methodOnly could also be undefined
    }
    method2() {
        this.methodOnly = true  // also, ok, methodOnly's type is string | boolean | undefined
    }
}
</code></pre>
<p>如果一个属性从没在类内设置过，它们会被当成未知的。</p>
<p>如果类的属性只是读取用的，那么就在构造函数里用JSDoc声明它的类型。 如果它稍后会被初始化，你甚至都不需要在构造函数里给它赋值：</p>
<pre><code class="language-javascript">class C {
    constructor() {
        /** @type {number | undefined} */
        this.prop = undefined;
        /** @type {number | undefined} */
        this.count;
    }
}

let c = new C();
c.prop = 0;          // OK
c.count = "string";  // Error: string is not assignable to number|undefined
</code></pre>
<h3 id="构造函数等同于类"><a class="header" href="#构造函数等同于类">构造函数等同于类</a></h3>
<p>ES2015以前，Javascript使用构造函数代替类。 编译器支持这种模式并能够将构造函数识别为ES2015的类。 属性类型推断机制和上面介绍的一致。</p>
<pre><code class="language-javascript">function C() {
    this.constructorOnly = 0
    this.constructorUnknown = undefined
}
C.prototype.method = function() {
    this.constructorOnly = false // error
    this.constructorUnknown = "plunkbat" // OK, the type is string | undefined
}
</code></pre>
<h3 id="支持commonjs模块"><a class="header" href="#支持commonjs模块">支持CommonJS模块</a></h3>
<p>在<code>.js</code>文件里，TypeScript能识别出CommonJS模块。 对<code>exports</code>和<code>module.exports</code>的赋值被识别为导出声明。 相似地，<code>require</code>函数调用被识别为模块导入。例如：</p>
<pre><code class="language-javascript">// same as `import module "fs"`
const fs = require("fs");

// same as `export function readFile`
module.exports.readFile = function(f) {
  return fs.readFileSync(f);
}
</code></pre>
<p>对JavaScript文件里模块语法的支持比在TypeScript里宽泛多了。 大部分的赋值和声明方式都是允许的。</p>
<h3 id="类函数和对象字面量是命名空间"><a class="header" href="#类函数和对象字面量是命名空间">类，函数和对象字面量是命名空间</a></h3>
<p><code>.js</code>文件里的类是命名空间。 它可以用于嵌套类，比如：</p>
<pre><code class="language-javascript">class C {
}
C.D = class {
}
</code></pre>
<p>ES2015之前的代码，它可以用来模拟静态方法：</p>
<pre><code class="language-javascript">function Outer() {
  this.y = 2
}
Outer.Inner = function() {
  this.yy = 2
}
</code></pre>
<p>它还可以用于创建简单的命名空间：</p>
<pre><code class="language-javascript">var ns = {}
ns.C = class {
}
ns.func = function() {
}
</code></pre>
<p>同时还支持其它的变化：</p>
<pre><code class="language-javascript">// 立即调用的函数表达式
var ns = (function (n) {
  return n || {};
})();
ns.CONST = 1

// defaulting to global
var assign = assign || function() {
  // code goes here
}
assign.extra = 1
</code></pre>
<h3 id="对象字面量是开放的"><a class="header" href="#对象字面量是开放的">对象字面量是开放的</a></h3>
<p><code>.ts</code>文件里，用对象字面量初始化一个变量的同时也给它声明了类型。 新的成员不能再被添加到对象字面量中。 这个规则在<code>.js</code>文件里被放宽了；对象字面量具有开放的类型，允许添加并访问原先没有定义的属性。例如：</p>
<pre><code class="language-javascript">var obj = { a: 1 };
obj.b = 2;  // Allowed
</code></pre>
<p>对象字面量的表现就好比具有一个默认的索引签名<code>[x:string]: any</code>，它们可以被当成开放的映射而不是封闭的对象。</p>
<p>与其它JS检查行为相似，这种行为可以通过指定JSDoc类型来改变，例如：</p>
<pre><code class="language-javascript">/** @type {{a: number}} */
var obj = { a: 1 };
obj.b = 2;  // Error, type {a: number} does not have property b
</code></pre>
<h3 id="nullundefined和空数组的类型是any或any"><a class="header" href="#nullundefined和空数组的类型是any或any">null，undefined，和空数组的类型是any或any[]</a></h3>
<p>任何用<code>null</code>，<code>undefined</code>初始化的变量，参数或属性，它们的类型是<code>any</code>，就算是在严格<code>null</code>检查模式下。 任何用<code>[]</code>初始化的变量，参数或属性，它们的类型是<code>any[]</code>，就算是在严格<code>null</code>检查模式下。 唯一的例外是像上面那样有多个初始化器的属性。</p>
<pre><code class="language-javascript">function Foo(i = null) {
    if (!i) i = 1;
    var j = undefined;
    j = 2;
    this.l = [];
}
var foo = new Foo();
foo.l.push(foo.i);
foo.l.push("end");
</code></pre>
<h3 id="函数参数是默认可选的"><a class="header" href="#函数参数是默认可选的">函数参数是默认可选的</a></h3>
<p>由于在ES2015之前无法指定可选参数，因此<code>.js</code>文件里所有函数参数都被当做是可选的。 使用比预期少的参数调用函数是允许的。</p>
<p>需要注意的一点是，使用过多的参数调用函数会得到一个错误。</p>
<p>例如：</p>
<pre><code class="language-javascript">function bar(a, b) {
  console.log(a + " " + b);
}

bar(1);       // OK, second argument considered optional
bar(1, 2);
bar(1, 2, 3); // Error, too many arguments
</code></pre>
<p>使用JSDoc注解的函数会被从这条规则里移除。 使用JSDoc可选参数语法来表示可选性。比如：</p>
<pre><code class="language-javascript">/**
 * @param {string} [somebody] - Somebody's name.
 */
function sayHello(somebody) {
    if (!somebody) {
        somebody = 'John Doe';
    }
    console.log('Hello ' + somebody);
}

sayHello();
</code></pre>
<h3 id="由arguments推断出的var-args参数声明"><a class="header" href="#由arguments推断出的var-args参数声明">由<code>arguments</code>推断出的var-args参数声明</a></h3>
<p>如果一个函数的函数体内有对<code>arguments</code>的引用，那么这个函数会隐式地被认为具有一个var-arg参数（比如:<code>(...arg: any[]) =&gt; any</code>)）。使用JSDoc的var-arg语法来指定<code>arguments</code>的类型。</p>
<pre><code class="language-javascript">/** @param {...number} args */
function sum(/* numbers */) {
    var total = 0
    for (var i = 0; i &lt; arguments.length; i++) {
      total += arguments[i]
    }
    return total
}
</code></pre>
<h3 id="未指定的类型参数默认为any"><a class="header" href="#未指定的类型参数默认为any">未指定的类型参数默认为<code>any</code></a></h3>
<p>由于JavaScript里没有一种自然的语法来指定泛型参数，因此未指定的参数类型默认为<code>any</code>。</p>
<h4 id="在extends语句中"><a class="header" href="#在extends语句中">在extends语句中：</a></h4>
<p>例如，<code>React.Component</code>被定义成具有两个类型参数，<code>Props</code>和<code>State</code>。 在一个<code>.js</code>文件里，没有一个合法的方式在extends语句里指定它们。默认地参数类型为<code>any</code>：</p>
<pre><code class="language-javascript">import { Component } from "react";

class MyComponent extends Component {
    render() {
        this.props.b; // Allowed, since this.props is of type any
    }
}
</code></pre>
<p>使用JSDoc的<code>@augments</code>来明确地指定类型。例如：</p>
<pre><code class="language-javascript">import { Component } from "react";

/**
 * @augments {Component&lt;{a: number}, State&gt;}
 */
class MyComponent extends Component {
    render() {
        this.props.b; // Error: b does not exist on {a:number}
    }
}
</code></pre>
<h4 id="在jsdoc引用中"><a class="header" href="#在jsdoc引用中">在JSDoc引用中：</a></h4>
<p>JSDoc里未指定的类型参数默认为<code>any</code>：</p>
<pre><code class="language-javascript">/** @type{Array} */
var x = [];

x.push(1);        // OK
x.push("string"); // OK, x is of type Array&lt;any&gt;

/** @type{Array.&lt;number&gt;} */
var y = [];

y.push(1);        // OK
y.push("string"); // Error, string is not assignable to number
</code></pre>
<h4 id="在函数调用中"><a class="header" href="#在函数调用中">在函数调用中</a></h4>
<p>泛型函数的调用使用<code>arguments</code>来推断泛型参数。有时候，这个流程不能够推断出类型，大多是因为缺少推断的源；在这种情况下，类型参数类型默认为<code>any</code>。例如：</p>
<pre><code class="language-javascript">var p = new Promise((resolve, reject) =&gt; { reject() });

p; // Promise&lt;any&gt;;
</code></pre>
<h2 id="支持的jsdoc"><a class="header" href="#支持的jsdoc">支持的JSDoc <a id="supported-jsdoc"></a></a></h2>
<p>下面的列表列出了当前所支持的JSDoc注解，你可以用它们在JavaScript文件里添加类型信息。</p>
<p>注意，没有在下面列出的标记（例如<code>@async</code>）都是还不支持的。</p>
<ul>
<li><code>@type</code></li>
<li><code>@param</code> (or <code>@arg</code> or <code>@argument</code>)</li>
<li><code>@returns</code> (or <code>@return</code>)</li>
<li><code>@typedef</code></li>
<li><code>@callback</code></li>
<li><code>@template</code></li>
<li><code>@class</code> (or <code>@constructor</code>)</li>
<li><code>@this</code></li>
<li><code>@extends</code> (or <code>@augments</code>)</li>
<li><code>@enum</code></li>
</ul>
<p>它们代表的意义与usejsdoc.org上面给出的通常是一致的或者是它的超集。 下面的代码描述了它们的区别并给出了一些示例。</p>
<h3 id="type"><a class="header" href="#type"><code>@type</code></a></h3>
<p>可以使用<code>@type</code>标记并引用一个类型名称（原始类型，TypeScript里声明的类型，或在JSDoc里<code>@typedef</code>标记指定的） 可以使用任何TypeScript类型和大多数JSDoc类型。</p>
<pre><code class="language-javascript">/**
 * @type {string}
 */
var s;

/** @type {Window} */
var win;

/** @type {PromiseLike&lt;string&gt;} */
var promisedString;

// You can specify an HTML Element with DOM properties
/** @type {HTMLElement} */
var myElement = document.querySelector(selector);
element.dataset.myData = '';
</code></pre>
<p><code>@type</code>可以指定联合类型—例如，<code>string</code>和<code>boolean</code>类型的联合。</p>
<pre><code class="language-javascript">/**
 * @type {(string | boolean)}
 */
var sb;
</code></pre>
<p>注意，括号是可选的。</p>
<pre><code class="language-javascript">/**
 * @type {string | boolean}
 */
var sb;
</code></pre>
<p>有多种方式来指定数组类型：</p>
<pre><code class="language-javascript">/** @type {number[]} */
var ns;
/** @type {Array.&lt;number&gt;} */
var nds;
/** @type {Array&lt;number&gt;} */
var nas;
</code></pre>
<p>还可以指定对象字面量类型。 例如，一个带有<code>a</code>（字符串）和<code>b</code>（数字）属性的对象，使用下面的语法：</p>
<pre><code class="language-javascript">/** @type {{ a: string, b: number }} */
var var9;
</code></pre>
<p>可以使用字符串和数字索引签名来指定<code>map-like</code>和<code>array-like</code>的对象，使用标准的JSDoc语法或者TypeScript语法。</p>
<pre><code class="language-javascript">/**
 * A map-like object that maps arbitrary `string` properties to `number`s.
 *
 * @type {Object.&lt;string, number&gt;}
 */
var stringToNumber;

/** @type {Object.&lt;number, object&gt;} */
var arrayLike;
</code></pre>
<p>这两个类型与TypeScript里的<code>{ [x: string]: number }</code>和<code>{ [x: number]: any }</code>是等同的。编译器能识别出这两种语法。</p>
<p>可以使用TypeScript或Closure语法指定函数类型。</p>
<pre><code class="language-javascript">/** @type {function(string, boolean): number} Closure syntax */
var sbn;
/** @type {(s: string, b: boolean) =&gt; number} Typescript syntax */
var sbn2;
</code></pre>
<p>或者直接使用未指定的<code>Function</code>类型：</p>
<pre><code class="language-javascript">/** @type {Function} */
var fn7;
/** @type {function} */
var fn6;
</code></pre>
<p>Closure的其它类型也可以使用：</p>
<pre><code class="language-javascript">/**
 * @type {*} - can be 'any' type
 */
var star;
/**
 * @type {?} - unknown type (same as 'any')
 */
var question;
</code></pre>
<h4 id="转换"><a class="header" href="#转换">转换</a></h4>
<p>TypeScript借鉴了Closure里的转换语法。 在括号表达式前面使用<code>@type</code>标记，可以将一种类型转换成另一种类型</p>
<pre><code class="language-javascript">/**
 * @type {number | string}
 */
var numberOrString = Math.random() &lt; 0.5 ? "hello" : 100;
var typeAssertedNumber = /** @type {number} */ (numberOrString)
</code></pre>
<h4 id="导入类型"><a class="header" href="#导入类型">导入类型</a></h4>
<p>可以使用导入类型从其它文件中导入声明。 这个语法是TypeScript特有的，与JSDoc标准不同：</p>
<pre><code class="language-javascript">/**
 * @param p { import("./a").Pet }
 */
function walk(p) {
    console.log(`Walking ${p.name}...`);
}
</code></pre>
<p>导入类型也可以使用在类型别名声明中：</p>
<pre><code class="language-javascript">/**
 * @typedef { import("./a").Pet } Pet
 */

/**
 * @type {Pet}
 */
var myPet;
myPet.name;
</code></pre>
<p>导入类型可以用在从模块中得到一个值的类型。</p>
<pre><code class="language-javascript">/**
 * @type {typeof import("./a").x }
 */
var x = require("./a").x;
</code></pre>
<h3 id="param和returns"><a class="header" href="#param和returns"><code>@param</code>和<code>@returns</code></a></h3>
<p><code>@param</code>语法和<code>@type</code>相同，但增加了一个参数名。 使用<code>[]</code>可以把参数声明为可选的：</p>
<pre><code class="language-javascript">// Parameters may be declared in a variety of syntactic forms
/**
 * @param {string}  p1 - A string param.
 * @param {string=} p2 - An optional param (Closure syntax)
 * @param {string} [p3] - Another optional param (JSDoc syntax).
 * @param {string} [p4="test"] - An optional param with a default value
 * @return {string} This is the result
 */
function stringsStringStrings(p1, p2, p3, p4){
  // TODO
}
</code></pre>
<p>函数的返回值类型也是类似的：</p>
<pre><code class="language-javascript">/**
 * @return {PromiseLike&lt;string&gt;}
 */
function ps(){}

/**
 * @returns {{ a: string, b: number }} - May use '@returns' as well as '@return'
 */
function ab(){}
</code></pre>
<h3 id="typedef-callback-和-param"><a class="header" href="#typedef-callback-和-param"><code>@typedef</code>, <code>@callback</code>, 和 <code>@param</code></a></h3>
<p><code>@typedef</code>可以用来声明复杂类型。 和<code>@param</code>类似的语法。</p>
<pre><code class="language-javascript">/**
 * @typedef {Object} SpecialType - creates a new type named 'SpecialType'
 * @property {string} prop1 - a string property of SpecialType
 * @property {number} prop2 - a number property of SpecialType
 * @property {number=} prop3 - an optional number property of SpecialType
 * @prop {number} [prop4] - an optional number property of SpecialType
 * @prop {number} [prop5=42] - an optional number property of SpecialType with default
 */
/** @type {SpecialType} */
var specialTypeObject;
</code></pre>
<p>可以在第一行上使用<code>object</code>或<code>Object</code>。</p>
<pre><code class="language-javascript">/**
 * @typedef {object} SpecialType1 - creates a new type named 'SpecialType1'
 * @property {string} prop1 - a string property of SpecialType1
 * @property {number} prop2 - a number property of SpecialType1
 * @property {number=} prop3 - an optional number property of SpecialType1
 */
/** @type {SpecialType1} */
var specialTypeObject1;
</code></pre>
<p><code>@param</code>允许使用相似的语法。 注意，嵌套的属性名必须使用参数名做为前缀：</p>
<pre><code class="language-javascript">/**
 * @param {Object} options - The shape is the same as SpecialType above
 * @param {string} options.prop1
 * @param {number} options.prop2
 * @param {number=} options.prop3
 * @param {number} [options.prop4]
 * @param {number} [options.prop5=42]
 */
function special(options) {
  return (options.prop4 || 1001) + options.prop5;
}
</code></pre>
<p><code>@callback</code>与<code>@typedef</code>相似，但它指定函数类型而不是对象类型：</p>
<pre><code class="language-javascript">/**
 * @callback Predicate
 * @param {string} data
 * @param {number} [index]
 * @returns {boolean}
 */
/** @type {Predicate} */
const ok = s =&gt; !(s.length % 2);
</code></pre>
<p>当然，所有这些类型都可以使用TypeScript的语法<code>@typedef</code>在一行上声明：</p>
<pre><code class="language-javascript">/** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */
/** @typedef {(data: string, index?: number) =&gt; boolean} Predicate */
</code></pre>
<h3 id="template"><a class="header" href="#template"><code>@template</code></a></h3>
<p>使用<code>@template</code>声明泛型：</p>
<pre><code class="language-javascript">/**
 * @template T
 * @param {T} x - A generic parameter that flows through to the return type
 * @return {T}
 */
function id(x){ return x }
</code></pre>
<p>用逗号或多个标记来声明多个类型参数：</p>
<pre><code class="language-javascript">/**
 * @template T,U,V
 * @template W,X
 */
</code></pre>
<p>还可以在参数名前指定类型约束。 只有列表的第一项类型参数会被约束：</p>
<pre><code class="language-javascript">/**
 * @template {string} K - K must be a string or string literal
 * @template {{ serious(): string }} Seriousalizable - must have a serious method
 * @param {K} key
 * @param {Seriousalizable} object
 */
function seriousalize(key, object) {
  // ????
}
</code></pre>
<h3 id="constructor"><a class="header" href="#constructor"><code>@constructor</code></a></h3>
<p>编译器通过<code>this</code>属性的赋值来推断构造函数，但你可以让检查更严格提示更友好，你可以添加一个<code>@constructor</code>标记：</p>
<pre><code class="language-javascript">/**
 * @constructor
 * @param {number} data
 */
function C(data) {
  this.size = 0;
  this.initialize(data); // Should error, initializer expects a string
}
/**
 * @param {string} s
 */
C.prototype.initialize = function (s) {
  this.size = s.length
}

var c = new C(0);
var result = C(1); // C should only be called with new
</code></pre>
<p>通过<code>@constructor</code>，<code>this</code>将在构造函数<code>C</code>里被检查，因此你在<code>initialize</code>方法里得到一个提示，如果你传入一个数字你还将得到一个错误提示。如果你直接调用<code>C</code>而不是构造它，也会得到一个错误。</p>
<p>不幸的是，这意味着那些既能构造也能直接调用的构造函数不能使用<code>@constructor</code>。</p>
<h3 id="this-1"><a class="header" href="#this-1"><code>@this</code></a></h3>
<p>编译器通常可以通过上下文来推断出<code>this</code>的类型。但你可以使用<code>@this</code>来明确指定它的类型：</p>
<pre><code class="language-javascript">/**
 * @this {HTMLElement}
 * @param {*} e
 */
function callbackForLater(e) {
    this.clientHeight = parseInt(e) // should be fine!
}
</code></pre>
<h3 id="extends"><a class="header" href="#extends"><code>@extends</code></a></h3>
<p>当JavaScript类继承了一个基类，无处指定类型参数的类型。而<code>@extends</code>标记提供了这样一种方式：</p>
<pre><code class="language-javascript">/**
 * @template T
 * @extends {Set&lt;T&gt;}
 */
class SortableSet extends Set {
  // ...
}
</code></pre>
<p>注意<code>@extends</code>只作用于类。当前，无法实现构造函数继承类的情况。</p>
<h3 id="enum-1"><a class="header" href="#enum-1"><code>@enum</code></a></h3>
<p><code>@enum</code>标记允许你创建一个对象字面量，它的成员都有确定的类型。不同于JavaScript里大多数的对象字面量，它不允许添加额外成员。</p>
<pre><code class="language-javascript">/** @enum {number} */
const JSDocState = {
  BeginningOfLine: 0,
  SawAsterisk: 1,
  SavingComments: 2,
}
</code></pre>
<p>注意<code>@enum</code>与TypeScript的<code>@enum</code>大不相同，它更加简单。然而，不同于TypeScript的枚举，<code>@enum</code>可以是任何类型：</p>
<pre><code class="language-javascript">/** @enum {function(number): number} */
const Math = {
  add1: n =&gt; n + 1,
  id: n =&gt; -n,
  sub1: n =&gt; n - 1,
}
</code></pre>
<h3 id="更多示例"><a class="header" href="#更多示例">更多示例</a></h3>
<pre><code class="language-javascript">var someObj = {
  /**
   * @param {string} param1 - Docs on property assignments work
   */
  x: function(param1){}
};

/**
 * As do docs on variable assignments
 * @return {Window}
 */
let someFunc = function(){};

/**
 * And class methods
 * @param {string} greeting The greeting to use
 */
Foo.prototype.sayHi = (greeting) =&gt; console.log("Hi!");

/**
 * And arrow functions expressions
 * @param {number} x - A multiplier
 */
let myArrow = x =&gt; x * x;

/**
 * Which means it works for stateless function components in JSX too
 * @param {{a: string, b: number}} test - Some param
 */
var fc = (test) =&gt; &lt;div&gt;{test.a.charAt(0)}&lt;/div&gt;;

/**
 * A parameter can be a class constructor, using Closure syntax.
 *
 * @param {{new(...args: any[]): object}} C - The class to register
 */
function registerClass(C) {}

/**
 * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')
 */
function fn10(p1){}

/**
 * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')
 */
function fn9(p1) {
  return p1.join();
}
</code></pre>
<h3 id="已知不支持的模式"><a class="header" href="#已知不支持的模式">已知不支持的模式</a></h3>
<p>在值空间中将对象视为类型是不可以的，除非对象创建了类型，如构造函数。</p>
<pre><code class="language-javascript">function aNormalFunction() {

}
/**
 * @type {aNormalFunction}
 */
var wrong;
/**
 * Use 'typeof' instead:
 * @type {typeof aNormalFunction}
 */
var right;
</code></pre>
<p>对象字面量属性上的<code>=</code>后缀不能指定这个属性是可选的：</p>
<pre><code class="language-javascript">/**
 * @type {{ a: string, b: number= }}
 */
var wrong;
/**
 * Use postfix question on the property name instead:
 * @type {{ a: string, b?: number }}
 */
var right;
</code></pre>
<p><code>Nullable</code>类型只在启用了<code>strictNullChecks</code>检查时才启作用：</p>
<pre><code class="language-javascript">/**
 * @type {?number}
 * With strictNullChecks: true -- number | null
 * With strictNullChecks: off  -- number
 */
var nullable;
</code></pre>
<p><code>Non-nullable</code>类型没有意义，以其原类型对待：</p>
<pre><code class="language-javascript">/**
 * @type {!number}
 * Just has type number
 */
var normal;
</code></pre>
<p>不同于JSDoc类型系统，TypeScript只允许将类型标记为包不包含<code>null</code>。 没有明确的<code>Non-nullable</code> -- 如果启用了<code>strictNullChecks</code>，那么<code>number</code>是非<code>null</code>的。 如果没有启用，那么<code>number</code>是可以为<code>null</code>的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工程配置"><a class="header" href="#工程配置">工程配置</a></h1>
<ul>
<li><a href="zh/project-config/project-config/tsconfig.json.html">tsconfig.json</a></li>
<li><a href="zh/project-config/project-config/project-references.html">工程引用</a></li>
<li><a href="zh/project-config/project-config/typings-for-npm-packages.html">NPM包的类型</a></li>
<li><a href="zh/project-config/project-config/compiler-options.html">编译选项</a></li>
<li><a href="zh/project-config/project-config/configuring-watch.html">配置 Watch</a></li>
<li><a href="zh/project-config/project-config/compiler-options-in-msbuild.html">在MSBuild里使用编译选项</a></li>
<li><a href="zh/project-config/project-config/integrating-with-build-tools.html">与其它构建工具整合</a></li>
<li><a href="zh/project-config/project-config/nightly-builds.html">使用TypeScript的每日构建版本</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tsconfigjson"><a class="header" href="#tsconfigjson">tsconfig.json</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>如果一个目录下存在一个<code>tsconfig.json</code>文件，那么它意味着这个目录是TypeScript项目的根目录。 <code>tsconfig.json</code>文件中指定了用来编译这个项目的根文件和编译选项。 一个项目可以通过以下方式之一来编译：</p>
<h2 id="使用tsconfigjson"><a class="header" href="#使用tsconfigjson">使用tsconfig.json</a></h2>
<ul>
<li>不带任何输入文件的情况下调用<code>tsc</code>，编译器会从当前目录开始去查找<code>tsconfig.json</code>文件，逐级向上搜索父目录。</li>
<li>不带任何输入文件的情况下调用<code>tsc</code>，且使用命令行参数<code>--project</code>（或<code>-p</code>）指定一个包含<code>tsconfig.json</code>文件的目录。</li>
</ul>
<p>当命令行上指定了输入文件时，<code>tsconfig.json</code>文件会被忽略。</p>
<h2 id="示例-1"><a class="header" href="#示例-1">示例</a></h2>
<p><code>tsconfig.json</code>示例文件:</p>
<ul>
<li>使用<code>"files"</code>属性</li>
</ul>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "module": "commonjs",
        "noImplicitAny": true,
        "removeComments": true,
        "preserveConstEnums": true,
        "sourceMap": true
    },
    "files": [
        "core.ts",
        "sys.ts",
        "types.ts",
        "scanner.ts",
        "parser.ts",
        "utilities.ts",
        "binder.ts",
        "checker.ts",
        "emitter.ts",
        "program.ts",
        "commandLineParser.ts",
        "tsc.ts",
        "diagnosticInformationMap.generated.ts"
    ]
}
</code></pre>
<ul>
<li>
<p>使用<code>"include"</code>和<code>"exclude"</code>属性</p>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "module": "system",
        "noImplicitAny": true,
        "removeComments": true,
        "preserveConstEnums": true,
        "outFile": "../../built/local/tsc.js",
        "sourceMap": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.spec.ts"
    ]
}
</code></pre>
</li>
</ul>
<h2 id="细节"><a class="header" href="#细节">细节</a></h2>
<p><code>"compilerOptions"</code>可以被忽略，这时编译器会使用默认值。在这里查看完整的<a href="zh/project-config/compiler-options.html">编译器选项</a>列表。</p>
<p><code>"files"</code>指定一个包含相对或绝对文件路径的列表。 <code>"include"</code>和<code>"exclude"</code>属性指定一个文件glob匹配模式列表。 支持的glob通配符有：</p>
<ul>
<li><code>*</code> 匹配0或多个字符（不包括目录分隔符）</li>
<li><code>?</code> 匹配一个任意字符（不包括目录分隔符）</li>
<li><code>**/</code> 递归匹配任意子目录</li>
</ul>
<p>如果一个glob模式里的某部分只包含<code>*</code>或<code>.*</code>，那么仅有支持的文件扩展名类型被包含在内（比如默认<code>.ts</code>，<code>.tsx</code>，和<code>.d.ts</code>， 如果<code>allowJs</code>设置能<code>true</code>还包含<code>.js</code>和<code>.jsx</code>）。</p>
<p>如果<code>"files"</code>和<code>"include"</code>都没有被指定，编译器默认包含当前目录和子目录下所有的TypeScript文件（<code>.ts</code>, <code>.d.ts</code> 和 <code>.tsx</code>），排除在<code>"exclude"</code>里指定的文件。JS文件（<code>.js</code>和<code>.jsx</code>）也被包含进来如果<code>allowJs</code>被设置成<code>true</code>。 如果指定了<code>"files"</code>或<code>"include"</code>，编译器会将它们结合一并包含进来。 使用<code>"outDir"</code>指定的目录下的文件永远会被编译器排除，除非你明确地使用<code>"files"</code>将其包含进来（这时就算用<code>exclude</code>指定也没用）。</p>
<p>使用<code>"include"</code>引入的文件可以使用<code>"exclude"</code>属性过滤。 然而，通过<code>"files"</code>属性明确指定的文件却总是会被包含在内，不管<code>"exclude"</code>如何设置。 如果没有特殊指定，<code>"exclude"</code>默认情况下会排除<code>node_modules</code>，<code>bower_components</code>，<code>jspm_packages</code>和<code>&lt;outDir&gt;</code>目录。</p>
<p>任何被<code>"files"</code>或<code>"include"</code>指定的文件所引用的文件也会被包含进来。 <code>A.ts</code>引用了<code>B.ts</code>，因此<code>B.ts</code>不能被排除，除非引用它的<code>A.ts</code>在<code>"exclude"</code>列表中。</p>
<p>需要注意编译器不会去引入那些可能做为输出的文件；比如，假设我们包含了<code>index.ts</code>，那么<code>index.d.ts</code>和<code>index.js</code>会被排除在外。 通常来讲，不推荐只有扩展名的不同来区分同目录下的文件。</p>
<p><code>tsconfig.json</code>文件可以是个空文件，那么所有默认的文件（如上面所述）都会以默认配置选项编译。</p>
<p>在命令行上指定的编译选项会覆盖在<code>tsconfig.json</code>文件里的相应选项。</p>
<h2 id="typestyperoots和types"><a class="header" href="#typestyperoots和types"><code>@types</code>，<code>typeRoots</code>和<code>types</code></a></h2>
<p>默认所有_可见的_"<code>@types</code>"包会在编译过程中被包含进来。 <code>node_modules/@types</code>文件夹下以及它们子文件夹下的所有包都是_可见的_； 也就是说，<code>./node_modules/@types/</code>，<code>../node_modules/@types/</code>和<code>../../node_modules/@types/</code>等等。</p>
<p>如果指定了<code>typeRoots</code>，<em>只有</em><code>typeRoots</code>下面的包才会被包含进来。 比如：</p>
<pre><code class="language-javascript">{
   "compilerOptions": {
       "typeRoots" : ["./typings"]
   }
}
</code></pre>
<p>这个配置文件会包含_所有_<code>./typings</code>下面的包，而不包含<code>./node_modules/@types</code>里面的包。</p>
<p>如果指定了<code>types</code>，只有被列出来的包才会被包含进来。 比如：</p>
<pre><code class="language-javascript">{
   "compilerOptions": {
        "types" : ["node", "lodash", "express"]
   }
}
</code></pre>
<p>这个<code>tsconfig.json</code>文件将_仅会_包含 <code>./node_modules/@types/node</code>，<code>./node_modules/@types/lodash</code>和<code>./node_modules/@types/express</code>。/@types/。 <code>node_modules/@types/*</code>里面的其它包不会被引入进来。</p>
<p>指定<code>"types": []</code>来禁用自动引入<code>@types</code>包。</p>
<p>注意，自动引入只在你使用了全局的声明（相反于模块）时是重要的。 如果你使用<code>import "foo"</code>语句，TypeScript仍然会查找<code>node_modules</code>和<code>node_modules/@types</code>文件夹来获取<code>foo</code>包。</p>
<h2 id="使用extends继承配置"><a class="header" href="#使用extends继承配置">使用<code>extends</code>继承配置</a></h2>
<p><code>tsconfig.json</code>文件可以利用<code>extends</code>属性从另一个配置文件里继承配置。</p>
<p><code>extends</code>是<code>tsconfig.json</code>文件里的顶级属性（与<code>compilerOptions</code>，<code>files</code>，<code>include</code>，和<code>exclude</code>一样）。 <code>extends</code>的值是一个字符串，包含指向另一个要继承文件的路径。</p>
<p>在原文件里的配置先被加载，然后被来自继承文件里的配置重写。 如果发现循环引用，则会报错。</p>
<p>来自所继承配置文件的<code>files</code>，<code>include</code>和<code>exclude</code>_覆盖_源配置文件的属性。</p>
<p>配置文件里的相对路径在解析时相对于它所在的文件。</p>
<p>比如：</p>
<p><code>configs/base.json</code>：</p>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
</code></pre>
<p><code>tsconfig.json</code>：</p>
<pre><code class="language-javascript">{
  "extends": "./configs/base",
  "files": [
    "main.ts",
    "supplemental.ts"
  ]
}
</code></pre>
<p><code>tsconfig.nostrictnull.json</code>：</p>
<pre><code class="language-javascript">{
  "extends": "./tsconfig",
  "compilerOptions": {
    "strictNullChecks": false
  }
}
</code></pre>
<h2 id="compileonsave"><a class="header" href="#compileonsave"><code>compileOnSave</code></a></h2>
<p>在最顶层设置<code>compileOnSave</code>标记，可以让IDE在保存文件的时候根据<code>tsconfig.json</code>重新生成文件。</p>
<pre><code class="language-javascript">{
    "compileOnSave": true,
    "compilerOptions": {
        "noImplicitAny" : true
    }
}
</code></pre>
<p>要想支持这个特性需要Visual Studio 2015， TypeScript1.8.4以上并且安装<a href="https://github.com/TypeStrong/atom-typescript#compile-on-save">atom-typescript</a>插件。</p>
<h2 id="模式"><a class="header" href="#模式">模式</a></h2>
<p>到这里查看模式: <a href="http://json.schemastore.org/tsconfig">http://json.schemastore.org/tsconfig</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工程引用"><a class="header" href="#工程引用">工程引用</a></h1>
<p>工程引用是TypeScript 3.0的新特性，它支持将TypeScript程序的结构分割成更小的组成部分。</p>
<p>这样可以改善构建时间，强制在逻辑上对组件进行分离，更好地组织你的代码。</p>
<p>TypeScript 3.0还引入了<code>tsc</code>的一种新模式，即<code>--build</code>标记，它与工程引用协同工作可以加速TypeScript的构建。</p>
<h2 id="一个工程示例"><a class="header" href="#一个工程示例">一个工程示例</a></h2>
<p>让我们来看一个非常普通的工程，并瞧瞧工程引用特性是如何帮助我们更好地组织代码的。 假设这个工程具有两个模块：<code>converter</code>和<code>unites</code>，以及相应的测试代码：</p>
<pre><code class="language-text">/src/converter.ts
/src/units.ts
/test/converter-tests.ts
/test/units-tests.ts
/tsconfig.json
</code></pre>
<p>测试文件导入相应的实现文件并进行测试：</p>
<pre><code class="language-typescript">// converter-tests.ts
import * as converter from "../converter";

assert.areEqual(converter.celsiusToFahrenheit(0), 32);
</code></pre>
<p>在之前，这种使用单一<code>tsconfig</code>文件的结构会稍显笨拙：</p>
<ul>
<li>实现文件也可以导入测试文件</li>
<li>无法同时构建<code>test</code>和<code>src</code>，除非把<code>src</code>也放在输出文件夹中，但通常并不想这样做</li>
<li>仅对实现文件的_内部_细节进行改动，必需再次对测试进行_类型检查_，尽管这是根本不必要的</li>
<li>仅对测试文件进行改动，必需再次对实现文件进行_类型检查_，尽管其实什么都没有变</li>
</ul>
<p>你可以使用多个<code>tsconfig</code>文件来解决_部分_问题，但是又会出现新问题：</p>
<ul>
<li>缺少内置的实时检查，因此你得多次运行<code>tsc</code></li>
<li>多次调用<code>tsc</code>会增加我们等待的时间</li>
<li><code>tsc -w</code>不能一次在多个配置文件上运行</li>
</ul>
<p>工程引用可以解决全部这些问题，而且还不止。</p>
<h2 id="何为工程引用"><a class="header" href="#何为工程引用">何为工程引用？</a></h2>
<p><code>tsconfig.json</code>增加了一个新的顶层属性<code>references</code>。它是一个对象的数组，指明要引用的工程：</p>
<pre><code class="language-javascript">{
    "compilerOptions": {
        // The usual
    },
    "references": [
        { "path": "../src" }
    ]
}
</code></pre>
<p>每个引用的<code>path</code>属性都可以指向到包含<code>tsconfig.json</code>文件的目录，或者直接指向到配置文件本身（名字是任意的）。</p>
<p>当你引用一个工程时，会发生下面的事：</p>
<ul>
<li>导入引用工程中的模块实际加载的是它_输出_的声明文件（<code>.d.ts</code>）。</li>
<li>如果引用的工程生成一个<code>outFile</code>，那么这个输出文件的<code>.d.ts</code>文件里的声明对于当前工程是可见的。</li>
<li>构建模式（后文）会根据需要自动地构建引用的工程。</li>
</ul>
<p>当你拆分成多个工程后，会显著地加速类型检查和编译，减少编辑器的内存占用，还会改善程序在逻辑上进行分组。</p>
<h2 id="composite"><a class="header" href="#composite"><code>composite</code></a></h2>
<p>引用的工程必须启用新的<code>composite</code>设置。 这个选项用于帮助TypeScript快速确定引用工程的输出文件位置。 若启用<code>composite</code>标记则会发生如下变动：</p>
<ul>
<li>对于<code>rootDir</code>设置，如果没有被显式指定，默认为包含<code>tsconfig</code>文件的目录</li>
<li>所有的实现文件必须匹配到某个<code>include</code>模式或在<code>files</code>数组里列出。如果违反了这个限制，<code>tsc</code>会提示你哪些文件未指定。</li>
<li>必须开启<code>declaration</code>选项。</li>
</ul>
<h2 id="declarationmaps"><a class="header" href="#declarationmaps"><code>declarationMap</code>s</a></h2>
<p>我们增加了对<a href="https://github.com/Microsoft/TypeScript/issues/14479">declaration source maps</a>的支持。 如果启用<code>--declarationMap</code>，在某些编辑器上，你可以使用诸如“Go to Definition”，重命名以及跨工程编辑文件等编辑器特性。</p>
<h2 id="带prepend的outfile"><a class="header" href="#带prepend的outfile">带<code>prepend</code>的<code>outFile</code></a></h2>
<p>你可以在引用中使用<code>prepend</code>选项来启用前置某个依赖的输出：</p>
<pre><code class="language-javascript">   "references": [
       { "path": "../utils", "prepend": true }
   ]
</code></pre>
<p>前置工程会将工程的输出添加到当前工程的输出之前。 它对<code>.js</code>文件和<code>.d.ts</code>文件都有效，<code>source map</code>文件也同样会正确地生成。</p>
<p><code>tsc</code>永远只会使用磁盘上已经存在的文件来进行这个操作，因此你可能会创建出一个无法生成正确输出文件的工程，因为有些工程的输出可能会在结果文件中重覆了多次。 例如：</p>
<pre><code class="language-text">   A
  ^ ^
 /   \
B     C
 ^   ^
  \ /
   D
</code></pre>
<p>这种情况下，不能前置引用，因为在<code>D</code>的最终输出里会有两份<code>A</code>存在 - 这可能会发生未知错误。</p>
<h2 id="关于工程引用的说明"><a class="header" href="#关于工程引用的说明">关于工程引用的说明</a></h2>
<p>工程引用在某些方面需要你进行权衡.</p>
<p>因为有依赖的工程要使用它的依赖生成的<code>.d.ts</code>，因此你必须要检查相应构建后的输出_或_在下载源码后进行构建，然后才能在编辑器里自由地导航。 我们是在操控幕后的<code>.d.ts</code>生成过程，我们应该减少这种情况，但是目前还们建议提示开发者在下载源码后进行构建。</p>
<p>此外，为了兼容已有的构建流程，<code>tsc</code>_不会_自动地构建依赖项，除非启用了<code>--build</code>选项。 下面让我们看看<code>--build</code>。</p>
<h2 id="typescript构建模式"><a class="header" href="#typescript构建模式">TypeScript构建模式</a></h2>
<p>在TypeScript工程里支持增量构建是个期待已久的功能。 在TypeScrpt 3.0里，你可以在<code>tsc</code>上使用<code>--build</code>标记。 它实际上是个新的<code>tsc</code>入口点，它更像是一个构建的协调员而不是简简单单的编译器。</p>
<p>运行<code>tsc --build</code>（简写<code>tsc -b</code>）会执行如下操作：</p>
<ul>
<li>找到所有引用的工程</li>
<li>检查它们是否为最新版本</li>
<li>按顺序构建非最新版本的工程</li>
</ul>
<p>可以给<code>tsc -b</code>指定多个配置文件地址（例如：<code>tsc -b src test</code>）。 如同<code>tsc -p</code>，如果配置文件名为<code>tsconfig.json</code>，那么文件名则可省略。</p>
<h3 id="tsc--b命令行"><a class="header" href="#tsc--b命令行"><code>tsc -b</code>命令行</a></h3>
<p>你可以指令任意数量的配置文件：</p>
<pre><code class="language-text"> &gt; tsc -b                                # Run the tsconfig.json in the current directory
 &gt; tsc -b src                            # Run src/tsconfig.json
 &gt; tsc -b foo/prd.tsconfig.json bar  # Run foo/prd.tsconfig.json and bar/tsconfig.json
</code></pre>
<p>不需要担心命令行上指定的文件顺序 - <code>tsc</code>会根据需要重新进行排序，被依赖的项会优先构建。</p>
<p><code>tsc -b</code>还支持其它一些选项：</p>
<ul>
<li><code>--verbose</code>：打印详细的日志（可以与其它标记一起使用）</li>
<li><code>--dry</code>: 显示将要执行的操作但是并不真正进行这些操作</li>
<li><code>--clean</code>: 删除指定工程的输出（可以与<code>--dry</code>一起使用）</li>
<li><code>--force</code>: 把所有工程当作非最新版本对待</li>
<li><code>--watch</code>: 观察模式（可以与<code>--verbose</code>一起使用）</li>
</ul>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<p>一般情况下，就算代码里有语法或类型错误，<code>tsc</code>也会生成输出（<code>.js</code>和<code>.d.ts</code>），除非你启用了<code>noEmitOnError</code>选项。 这在增量构建系统里就不好了 - 如果某个过期的依赖里有一个新的错误，那么你只能看到它_一次_，因为后续的构建会跳过这个最新的工程。 正是这个原因，<code>tsc -b</code>的作用就好比在所有工程上启用了<code>noEmitOnError</code>。</p>
<p>如果你想要提交所有的构建输出（<code>.js</code>, <code>.d.ts</code>, <code>.d.ts.map</code>等），你可能需要运行<code>--force</code>来构建，因为一些源码版本管理操作依赖于源码版本管理工具保存的本地拷贝和远程拷贝的时间戳。</p>
<h2 id="msbuild"><a class="header" href="#msbuild">MSBuild</a></h2>
<p>如果你的工程使用msbuild，你可以用下面的方式开启构建模式。</p>
<pre><code class="language-markup">    &lt;TypeScriptBuildMode&gt;true&lt;/TypeScriptBuildMode&gt;
</code></pre>
<p>将这段代码添加到<code>proj</code>文件。它会自动地启用增量构建模式和清理工作。</p>
<p>注意，在使用<code>tsconfig.json</code> / <code>-p</code>时，已存在的TypeScript工程属性会被忽略 - 因此所有的设置需要在<code>tsconfig</code>文件里进行。</p>
<p>一些团队已经设置好了基于msbuild的构建流程，并且<code>tsconfig</code>文件具有和它们匹配的工程一致的_隐式_图序。 若你的项目如此，那么可以继续使用<code>msbuild</code>和<code>tsc -p</code>以及工程引用；它们是完全互通的。</p>
<h2 id="指导"><a class="header" href="#指导">指导</a></h2>
<h3 id="整体结构"><a class="header" href="#整体结构">整体结构</a></h3>
<p>当<code>tsconfig.json</code>多了以后，通常会使用<a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">配置文件继承</a>来集中管理公共的编译选项。 这样你就可以在一个文件里更改配置而不必在多个文件中进行修改。</p>
<p>另一个最佳实践是有一个<code>solution</code>级别的<code>tsconfig.json</code>文件，它仅仅用于引用所有的子工程。 它用于提供一个简单的入口；比如，在TypeScript源码里，我们可以简单地运行<code>tsc -b src</code>来构建所有的节点，因为我们在<code>src/tsconfig.json</code>文件里列出了所有的子工程。 注意从3.0开始，如果<code>tsconfig.json</code>文件里有至少一个工程引用<code>reference</code>，那么<code>files</code>数组为空的话也不会报错。</p>
<p>你可以在TypeScript源码仓库里看到这些模式 - 阅读<code>src/tsconfig_base.json</code>，<code>src/tsconfig.json</code>和<code>src/tsc/tsconfig.json</code>。</p>
<h3 id="相对模块的结构"><a class="header" href="#相对模块的结构">相对模块的结构</a></h3>
<p>通常地，将代码转成使用相对模块并不需要改动太多。 只需在某个给定父目录的每个子目录里放一个<code>tsconfig.json</code>文件，并相应添加<code>reference</code>。 然后将<code>outDir</code>指定为输出目录的子目录或将<code>rootDir</code>指定为所有工程的某个公共根目录。</p>
<h3 id="outfile的结构"><a class="header" href="#outfile的结构"><code>outFile</code>的结构</a></h3>
<p>使用了<code>outFile</code>的编译输出结构十分灵活，因为相对路径是无关紧要的。 要注意的是，你通常不需要使用<code>prepend</code> - 因为这会改善构建时间并结省I/O。 TypeScript项目本身是一个好的参照 - 我们有一些“library”的工程和一些“endpoint”工程，“endpoint”工程会确保足够小并仅仅导入它们需要的“library”。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="npm-包的类型"><a class="header" href="#npm-包的类型">NPM 包的类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编译选项"><a class="header" href="#编译选项">编译选项</a></h1>
<h2 id="编译选项-1"><a class="header" href="#编译选项-1">编译选项</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">选项</th><th style="text-align: left">类型</th><th style="text-align: left">默认值</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>--allowJs</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">允许编译javascript文件。</td></tr>
<tr><td style="text-align: left"><code>--allowSyntheticDefaultImports</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>module === "system"</code>或设置了<code>--esModuleInterop</code></td><td style="text-align: left">允许从没有设置默认导出的模块中默认导入。这并不影响代码的输出，仅为了类型检查。</td></tr>
<tr><td style="text-align: left"><code>--allowUnreachableCode</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">不报告执行不到的代码错误。</td></tr>
<tr><td style="text-align: left"><code>--allowUnusedLabels</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">不报告未使用的标签错误。</td></tr>
<tr><td style="text-align: left"><code>--alwaysStrict</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">以严格模式解析并为每个源文件生成<code>"use strict"</code>语句</td></tr>
<tr><td style="text-align: left"><code>--baseUrl</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"></td><td style="text-align: left">解析非相对模块名的基准目录。查看<a href="zh/project-config/../handbook/module-resolution.html#base-url">模块解析文档</a>了解详情。</td></tr>
<tr><td style="text-align: left"><code>--build</code> <code>-b</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">使用<a href="zh/project-config/project-references.html">Project References</a>来构建此工程及其依赖工程。注意这个标记与本页内其它标记不兼容。详情参考<a href="zh/project-config/project-references.html">这里</a></td></tr>
<tr><td style="text-align: left"><code>--charset</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><code>"utf8"</code></td><td style="text-align: left">输入文件的字符集。</td></tr>
<tr><td style="text-align: left"><code>--checkJs</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">在.js文件中报告错误。与<code>--allowJs</code>配合使用。</td></tr>
<tr><td style="text-align: left"><code>--composite</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>true</code></td><td style="text-align: left">确保TypeScript能够找到编译当前工程所需要的引用工程的输出位置。</td></tr>
<tr><td style="text-align: left"><code>--declaration</code> <code>-d</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">生成相应的<code>.d.ts</code>文件。</td></tr>
<tr><td style="text-align: left"><code>--declarationDir</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"></td><td style="text-align: left">生成声明文件的输出路径。</td></tr>
<tr><td style="text-align: left"><code>--diagnostics</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">显示诊断信息。</td></tr>
<tr><td style="text-align: left"><code>--disableSizeLimit</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">禁用JavaScript工程体积大小的限制</td></tr>
<tr><td style="text-align: left"><code>--emitBOM</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">在输出文件的开头加入BOM头（UTF-8 Byte Order Mark）。</td></tr>
<tr><td style="text-align: left"><code>--emitDecoratorMetadata</code>[1]</td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">给源码里的装饰器声明加上设计类型元数据。查看<a href="https://github.com/Microsoft/TypeScript/issues/2577">issue #2577</a>了解更多信息。</td></tr>
<tr><td style="text-align: left"><code>--experimentalDecorators</code>[1]</td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">启用实验性的ES装饰器。</td></tr>
<tr><td style="text-align: left"><code>--extendedDiagnostics</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">显示详细的诊段信息。</td></tr>
<tr><td style="text-align: left"><code>--forceConsistentCasingInFileNames</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">禁止对同一个文件的不一致的引用。</td></tr>
<tr><td style="text-align: left"><code>--generateCpuProfile</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><code>profile.cpuprofile</code></td><td style="text-align: left">在指定目录生成CPU资源使用报告。若传入的是已创建的目录名，将在此目录下生成以时间戳命名的报告。</td></tr>
<tr><td style="text-align: left"><code>--help</code> <code>-h</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">打印帮助信息。</td></tr>
<tr><td style="text-align: left"><code>--importHelpers</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"></td><td style="text-align: left">从<a href="https://www.npmjs.com/package/tslib"><code>tslib</code></a>导入辅助工具函数（比如<code>__extends</code>，<code>__rest</code>等）</td></tr>
<tr><td style="text-align: left"><code>--importsNotUsedAsValues</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><code>remove</code></td><td style="text-align: left">用于设置针对于类型导入的代码生成和代码检查的行为。<code>"remove"</code>和<code>"preserve"</code>设置了是否对未使用的导入了模块副作用的导入语句生成相关代码，<code>"error"</code>则强制要求只用作类型的模块导入必须使用<code>import type</code>语句。</td></tr>
<tr><td style="text-align: left"><code>--inlineSourceMap</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">生成单个sourcemaps文件，而不是将每sourcemaps生成不同的文件。</td></tr>
<tr><td style="text-align: left"><code>--inlineSources</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">将代码与sourcemaps生成到一个文件中，要求同时设置了<code>--inlineSourceMap</code>或<code>--sourceMap</code>属性。</td></tr>
<tr><td style="text-align: left"><code>--init</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">初始化TypeScript项目并创建一个<code>tsconfig.json</code>文件。</td></tr>
<tr><td style="text-align: left"><code>--isolatedModules</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">执行额外检查以确保单独编译（如<a href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function"><code>transpileModule</code></a>或<a href="https://babeljs.io/docs/en/babel-plugin-transform-typescript">@babel/plugin-transform-typescript</a>）是安全的。</td></tr>
<tr><td style="text-align: left"><code>--jsx</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><code>"preserve"</code></td><td style="text-align: left">在<code>.tsx</code>文件里支持JSX：<code>"react"</code>或<code>"preserve"</code>或<code>"react-native"</code>。查看<a href="zh/project-config/../handbook/jsx.html">JSX</a>。</td></tr>
<tr><td style="text-align: left"><code>--jsxFactory</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><code>"React.createElement"</code></td><td style="text-align: left">指定生成目标为react JSX时，使用的JSX工厂函数，比如<code>React.createElement</code>或<code>h</code>。</td></tr>
<tr><td style="text-align: left"><code>--lib</code></td><td style="text-align: left"><code>string[]</code></td><td style="text-align: left"></td><td style="text-align: left">编译过程中需要引入的库文件的列表。 可能的值为：   ► <code>ES5</code>  ► <code>ES6</code>  ► <code>ES2015</code>  ► <code>ES7</code>  ► <code>ES2016</code>  ► <code>ES2017</code>   ► <code>ES2018</code>  ► <code>ESNext</code>  ► <code>DOM</code>  ► <code>DOM.Iterable</code>  ► <code>WebWorker</code>  ► <code>ScriptHost</code>  ► <code>ES2015.Core</code>  ► <code>ES2015.Collection</code>  ► <code>ES2015.Generator</code>  ► <code>ES2015.Iterable</code>  ► <code>ES2015.Promise</code>  ► <code>ES2015.Proxy</code>  ► <code>ES2015.Reflect</code>  ► <code>ES2015.Symbol</code>  ► <code>ES2015.Symbol.WellKnown</code>  ► <code>ES2016.Array.Include</code>  ► <code>ES2017.object</code>  ► <code>ES2017.Intl</code>  ► <code>ES2017.SharedMemory</code>  ► <code>ES2017.String</code>  ► <code>ES2017.TypedArrays</code>  ► <code>ES2018.Intl</code>  ► <code>ES2018.Promise</code>  ► <code>ES2018.RegExp</code>  ► <code>ESNext.AsyncIterable</code>  ► <code>ESNext.Array</code>  ► <code>ESNext.Intl</code>  ► <code>ESNext.Symbol</code>    注意：如果<code>--lib</code>没有指定默认注入的库的列表。默认注入的库为：  ► 针对于<code>--target ES5</code>：<code>DOM，ES5，ScriptHost</code>   ► 针对于<code>--target ES6</code>：<code>DOM，ES6，DOM.Iterable，ScriptHost</code></td></tr>
<tr><td style="text-align: left"><code>--listEmittedFiles</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">打印出编译后生成文件的名字。</td></tr>
<tr><td style="text-align: left"><code>--listFiles</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">编译过程中打印文件名。</td></tr>
<tr><td style="text-align: left"><code>--locale</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><em>(platform specific)</em></td><td style="text-align: left">显示错误信息时使用的语言，比如：en-us。</td></tr>
<tr><td style="text-align: left"><code>--mapRoot</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"></td><td style="text-align: left">为调试器指定指定sourcemap文件的路径，而不是使用生成时的路径。当<code>.map</code>文件是在运行时指定的，并不同于<code>js</code>文件的地址时使用这个标记。指定的路径会嵌入到<code>sourceMap</code>里告诉调试器到哪里去找它们。使用此标识并不会新创建指定目录并生成map文件在指定路径下。而是增加一个构建后的步骤，把相应文件移动到指定路径下。</td></tr>
<tr><td style="text-align: left"><code>--maxNodeModuleJsDepth</code></td><td style="text-align: left"><code>number</code></td><td style="text-align: left"><code>0</code></td><td style="text-align: left">node_modules依赖的最大搜索深度并加载JavaScript文件。仅适用于<code>--allowJs</code>。</td></tr>
<tr><td style="text-align: left"><code>--module</code> <code>-m</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><code>target === "ES6" ? "ES6" : "commonjs"</code></td><td style="text-align: left">指定生成哪个模块系统代码：<code>"None"</code>，<code>"CommonJS"</code>，<code>"AMD"</code>，<code>"System"</code>，<code>"UMD"</code>，<code>"ES6"</code>或<code>"ES2015"</code>。 ► 只有<code>"AMD"</code>和<code>"System"</code>能和<code>--outFile</code>一起使用。 ►<code>"ES6"</code>和<code>"ES2015"</code>可使用在目标输出为<code>"ES5"</code>或更低的情况下。</td></tr>
<tr><td style="text-align: left"><code>--moduleResolution</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><code>module === "AMD" or "System" or "ES6" ? "Classic" : "Node"</code></td><td style="text-align: left">决定如何处理模块。或者是<code>"Node"</code>对于Node.js/io.js，或者是<code>"Classic"</code>（默认）。查看<a href="zh/project-config/../handbook/module-resolution.html">模块解析</a>了解详情。</td></tr>
<tr><td style="text-align: left"><code>--newLine</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><em>(platform specific)</em></td><td style="text-align: left">当生成文件时指定行结束符：<code>"crlf"</code>（windows）或<code>"lf"</code>（unix）。</td></tr>
<tr><td style="text-align: left"><code>--noEmit</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">不生成输出文件。</td></tr>
<tr><td style="text-align: left"><code>--noEmitHelpers</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">不在输出文件中生成用户自定义的帮助函数代码，如<code>__extends</code>。</td></tr>
<tr><td style="text-align: left"><code>--noEmitOnError</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">报错时不生成输出文件。</td></tr>
<tr><td style="text-align: left"><code>--noErrorTruncation</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">不截短错误消息。</td></tr>
<tr><td style="text-align: left"><code>--noFallthroughCasesInSwitch</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">报告switch语句的fallthrough错误。（即，不允许switch的case语句贯穿）</td></tr>
<tr><td style="text-align: left"><code>--noImplicitAny</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">在表达式和声明上有隐含的<code>any</code>类型时报错。</td></tr>
<tr><td style="text-align: left"><code>--noImplicitReturns</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">不是函数的所有返回路径都有返回值时报错。</td></tr>
<tr><td style="text-align: left"><code>--noImplicitThis</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">当<code>this</code>表达式的值为<code>any</code>类型的时候，生成一个错误。</td></tr>
<tr><td style="text-align: left"><code>--noImplicitUseStrict</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">模块输出中不包含<code>"use strict"</code>指令。</td></tr>
<tr><td style="text-align: left"><code>--noLib</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">不包含默认的库文件（<code>lib.d.ts</code>）。</td></tr>
<tr><td style="text-align: left"><code>--noResolve</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">不把<code>/// &lt;reference``&gt;</code>或模块导入的文件加到编译文件列表。</td></tr>
<tr><td style="text-align: left"><code>--noStrictGenericChecks</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">禁用在函数类型里对泛型签名进行严格检查。</td></tr>
<tr><td style="text-align: left"><code>--noUnusedLocals</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">若有未使用的局部变量则抛错。</td></tr>
<tr><td style="text-align: left"><code>--noUnusedParameters</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">若有未使用的参数则抛错。</td></tr>
<tr><td style="text-align: left"><del><code>--out</code></del></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"></td><td style="text-align: left">弃用。使用 <code>--outFile</code> 代替。</td></tr>
<tr><td style="text-align: left"><code>--outDir</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"></td><td style="text-align: left">重定向输出目录。</td></tr>
<tr><td style="text-align: left"><code>--outFile</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"></td><td style="text-align: left">将输出文件合并为一个文件。合并的顺序是根据传入编译器的文件顺序和<code>///&lt;reference``&gt;</code>和<code>import</code>的文件顺序决定的。查看输出文件顺序文档<a href="https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-">了解详情</a>。</td></tr>
<tr><td style="text-align: left"><code>paths</code>[2]</td><td style="text-align: left"><code>Object</code></td><td style="text-align: left"></td><td style="text-align: left">模块名到基于<code>baseUrl</code>的路径映射的列表。查看<a href="zh/project-config/../handbook/module-resolution.html#path-mapping">模块解析文档</a>了解详情。</td></tr>
<tr><td style="text-align: left"><code>--preserveConstEnums</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">保留<code>const</code>和<code>enum</code>声明。查看<a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#94-constant-enum-declarations">const enums documentation</a>了解详情。</td></tr>
<tr><td style="text-align: left"><code>--preserveSymlinks</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">不把符号链接解析为其真实路径；将符号链接文件视为真正的文件。</td></tr>
<tr><td style="text-align: left"><code>--preserveWatchOutput</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">保留watch模式下过时的控制台输出。</td></tr>
<tr><td style="text-align: left"><code>--pretty</code>[1]</td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">给错误和消息设置样式，使用颜色和上下文。</td></tr>
<tr><td style="text-align: left"><code>--project</code> <code>-p</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"></td><td style="text-align: left">编译指定目录下的项目。这个目录应该包含一个<code>tsconfig.json</code>文件来管理编译。查看<a href="zh/project-config/tsconfig.json.html">tsconfig.json</a>文档了解更多信息。</td></tr>
<tr><td style="text-align: left"><code>--reactNamespace</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><code>"React"</code></td><td style="text-align: left">当目标为生成<code>"react"</code> JSX时，指定<code>createElement</code>和<code>__spread</code>的调用对象</td></tr>
<tr><td style="text-align: left"><code>--removeComments</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">删除所有注释，除了以<code>/!*</code>开头的版权信息。</td></tr>
<tr><td style="text-align: left"><code>--rootDir</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><em>(common root directory is computed from the list of input files)</em></td><td style="text-align: left">仅用来控制输出的目录结构<code>--outDir</code>。</td></tr>
<tr><td style="text-align: left"><code>rootDirs</code>[2]</td><td style="text-align: left"><code>string[]</code></td><td style="text-align: left"></td><td style="text-align: left">根（root）文件夹列表，表示运行时组合工程结构的内容。查看<a href="zh/project-config/../handbook/module-resolution.html#virtual-directories-with-rootdirs">模块解析文档</a>了解详情。</td></tr>
<tr><td style="text-align: left"><code>--showConfig</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">不真正执行build，而是显示build使用的配置文件信息。</td></tr>
<tr><td style="text-align: left"><code>--skipDefaultLibCheck</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">忽略<a href="zh/project-config/../handbook/triple-slash-directives.html#-reference-no-default-libtrue">库的默认声明文件</a>的类型检查。</td></tr>
<tr><td style="text-align: left"><code>--skipLibCheck</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">忽略所有的声明文件（<code>*.d.ts</code>）的类型检查。</td></tr>
<tr><td style="text-align: left"><code>--sourceMap</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">生成相应的<code>.map</code>文件。</td></tr>
<tr><td style="text-align: left"><code>--sourceRoot</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"></td><td style="text-align: left">指定TypeScript源文件的路径，以便调试器定位。当TypeScript文件的位置是在运行时指定时使用此标记。路径信息会被加到<code>sourceMap</code>里。</td></tr>
<tr><td style="text-align: left"><code>--strict</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">启用所有严格检查选项。  包含<code>--noImplicitAny</code>, <code>--noImplicitThis</code>, <code>--alwaysStrict</code>, <code>--strictBindCallApply</code>, <code>--strictNullChecks</code>, <code>--strictFunctionTypes</code>和<code>--strictPropertyInitialization</code>.</td></tr>
<tr><td style="text-align: left"><code>--strictFunctionTypes</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">禁用函数参数双向协变检查。</td></tr>
<tr><td style="text-align: left"><code>--strictPropertyInitialization</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">确保类的非<code>undefined</code>属性已经在构造函数里初始化。若要令此选项生效，需要同时启用<code>--strictNullChecks</code>。</td></tr>
<tr><td style="text-align: left"><code>--strictNullChecks</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">在严格的<code>null</code>检查模式下，<code>null</code>和<code>undefined</code>值不包含在任何类型里，只允许用它们自己和<code>any</code>来赋值（有个例外，<code>undefined</code>可以赋值到<code>void</code>）。</td></tr>
<tr><td style="text-align: left"><code>--suppressExcessPropertyErrors</code>[1]</td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">阻止对对象字面量的额外属性检查。</td></tr>
<tr><td style="text-align: left"><code>--suppressImplicitAnyIndexErrors</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">阻止<code>--noImplicitAny</code>对缺少索引签名的索引对象报错。查看<a href="https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362">issue #1232</a>了解详情。</td></tr>
<tr><td style="text-align: left"><code>--target</code> <code>-t</code></td><td style="text-align: left"><code>string</code></td><td style="text-align: left"><code>"ES3"</code></td><td style="text-align: left">指定ECMAScript目标版本<code>"ES3"</code>（默认），<code>"ES5"</code>，<code>"ES6"</code>/<code>"ES2015"</code>，<code>"ES2016"</code>，<code>"ES2017"</code>，<code>"ES2018"</code>，<code>"ES2019"</code>，<code>"ES2020"</code>或<code>"ESNext"</code>。   注意：<code>"ESNext"</code>最新的生成目标列表为<a href="https://github.com/tc39/proposals">ES proposed features</a></td></tr>
<tr><td style="text-align: left"><code>--traceResolution</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">生成模块解析日志信息</td></tr>
<tr><td style="text-align: left"><code>--types</code></td><td style="text-align: left"><code>string[]</code></td><td style="text-align: left"></td><td style="text-align: left">要包含的类型声明文件名列表。查看<a href="zh/project-config/tsconfig.json.html#types-typeroots-and-types">@types，--typeRoots和--types</a>章节了解详细信息。</td></tr>
<tr><td style="text-align: left"><code>--typeRoots</code></td><td style="text-align: left"><code>string[]</code></td><td style="text-align: left"></td><td style="text-align: left">要包含的类型声明文件路径列表。查看<a href="zh/project-config/tsconfig.json.html#types-typeroots-and-types">@types，--typeRoots和--types</a>章节了解详细信息。</td></tr>
<tr><td style="text-align: left"><code>--version</code> <code>-v</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">打印编译器版本号。</td></tr>
<tr><td style="text-align: left"><code>--watch</code> <code>-w</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。监视文件和目录的具体实现可以通过环境变量进行配置。详情请看<a href="zh/project-config/configuring-watch.html">配置 Watch</a>。</td></tr>
</tbody></table>
</div>
<ul>
<li>[1] 这些选项是试验性的。</li>
<li>[2] 这些选项只能在<code>tsconfig.json</code>里使用，不能在命令行使用。</li>
</ul>
<h2 id="相关信息"><a class="header" href="#相关信息">相关信息</a></h2>
<ul>
<li>在<a href="zh/project-config/tsconfig.json.html"><code>tsconfig.json</code></a>文件里设置编译器选项。</li>
<li>在<a href="zh/project-config/compiler-options-in-msbuild.html">MSBuild工程</a>里设置编译器选项。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置-watch"><a class="header" href="#配置-watch">配置 Watch</a></h1>
<p>编译器支持使用环境变量配置如何监视文件和目录的变化。</p>
<h2 id="使用tsc_watchfile环境变量来配置文件监视"><a class="header" href="#使用tsc_watchfile环境变量来配置文件监视">使用<code>TSC_WATCHFILE</code>环境变量来配置文件监视</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">选项</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>PriorityPollingInterval</code></td><td style="text-align: left">使用<code>fs.watchFile</code>但针对源码文件，配置文件和消失的文件使用不同的轮询间隔</td></tr>
<tr><td style="text-align: left"><code>DynamicPriorityPolling</code></td><td style="text-align: left">使用动态队列，对经常被修改的文件使用较短的轮询间隔，对未修改的文件使用较长的轮询间隔</td></tr>
<tr><td style="text-align: left"><code>UseFsEvents</code></td><td style="text-align: left">使用 <code>fs.watch</code>，它使用文件系统事件（但在不同的系统上可能不一定准确）来查询文件的修改/创建/删除。注意少数的系统如Linux，对监视者的数量有限制，如果使用<code>fs.watch</code>创建监视失败那么将通过<code>fs.watchFile</code>来创建监视</td></tr>
<tr><td style="text-align: left"><code>UseFsEventsWithFallbackDynamicPolling</code></td><td style="text-align: left">此选项与<code>UseFsEvents</code>类似，只不过当使用<code>fs.watch</code>创建监视失败后，回退到使用动态轮询队列进行监视（如<code>DynamicPriorityPolling</code>介绍的那样）</td></tr>
<tr><td style="text-align: left"><code>UseFsEventsOnParentDirectory</code></td><td style="text-align: left">此选项通过<code>fs.watch</code>（使用系统文件事件）监视文件的父目录，因此CPU占用率低但也会降低精度</td></tr>
<tr><td style="text-align: left">默认 （无指定值）</td><td style="text-align: left">如果环境变量<code>TSC_NONPOLLING_WATCHER</code>设置为<code>true</code>，监视文件的父目录（如同<code>UseFsEventsOnParentDirectory</code>）。否则，使用<code>fs.watchFile</code>监视文件，超时时间为<code>250ms</code>。</td></tr>
</tbody></table>
</div>
<h2 id="使用tsc_watchdirectory环境变量来配置目录监视"><a class="header" href="#使用tsc_watchdirectory环境变量来配置目录监视">使用<code>TSC_WATCHDIRECTORY</code>环境变量来配置目录监视</a></h2>
<p>在那些Nodejs原生就不支持递归监视目录的平台上，我们会根据<code>TSC_WATCHDIRECTORY</code>的不同选项递归地创建对子目录的监视。 注意在那些原生就支持递归监视目录的平台上（如Windows），这个环境变量会被忽略。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">选项</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>RecursiveDirectoryUsingFsWatchFile</code></td><td style="text-align: left">使用<code>fs.watchFile</code>监视目录和子目录，它是一个轮询监视（消耗CPU周期）</td></tr>
<tr><td style="text-align: left"><code>RecursiveDirectoryUsingDynamicPriorityPolling</code></td><td style="text-align: left">使用动态轮询队列来获取目录与其子目录的改变</td></tr>
<tr><td style="text-align: left">默认 （无指定值）</td><td style="text-align: left">使用<code>fs.watch</code>来监视目录及其子目录</td></tr>
</tbody></table>
</div>
<h2 id="背景"><a class="header" href="#背景">背景</a></h2>
<p>在编译器中<code>--watch</code>的实现依赖于Nodejs提供的<code>fs.watch</code>和<code>fs.watchFile</code>，两者各有优缺点。</p>
<p><code>fs.watch</code>使用文件系统事件通知文件及目录的变化。 但是它依赖于操作系统，且事件通知并不完全可靠，在很多操作系统上的行为难以预料。 还可能会有创建监视个数的限制，如Linux系统，在包含大量文件的程序中监视器个数很快被耗尽。 但也正是因为它使用文件系统事件，不需要占用过多的CPU周期。 典型地，编译器使用<code>fs.watch</code>来监视目录（比如配置文件里声明的源码目录，无法进行模块解析的目录）。 这样就可以处理改动通知不准确的问题。 但递归地监视仅在Windows和OSX系统上支持。 这就意味着在其它系统上要使用替代方案。</p>
<p><code>fs.watchFile</code>使用轮询，因此涉及到CPU周期。 但是这是最可靠的获取文件/目录状态的机制。 典型地，编译器使用<code>fs.watchFile</code>监视源文件，配置文件和消失的文件（失去文件引用），这意味着对CPU的使用依赖于程序里文件的数量。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在msbuild里使用编译选项"><a class="header" href="#在msbuild里使用编译选项">在MSBuild里使用编译选项</a></h1>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<p>编译选项可以在使用MSBuild的项目里通过MSBuild属性指定。</p>
<h2 id="例子-16"><a class="header" href="#例子-16">例子</a></h2>
<pre><code class="language-markup">  &lt;PropertyGroup Condition="'$(Configuration)' == 'Debug'"&gt;
    &lt;TypeScriptRemoveComments&gt;false&lt;/TypeScriptRemoveComments&gt;
    &lt;TypeScriptSourceMap&gt;true&lt;/TypeScriptSourceMap&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition="'$(Configuration)' == 'Release'"&gt;
    &lt;TypeScriptRemoveComments&gt;true&lt;/TypeScriptRemoveComments&gt;
    &lt;TypeScriptSourceMap&gt;false&lt;/TypeScriptSourceMap&gt;
  &lt;/PropertyGroup&gt;
  &lt;Import
      Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets"
      Condition="Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets')" /&gt;
</code></pre>
<h2 id="映射"><a class="header" href="#映射">映射</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">编译选项</th><th style="text-align: left">MSBuild属性名称</th><th style="text-align: left">可用值</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>--allowJs</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--allowSyntheticDefaultImports</code></td><td style="text-align: left">TypeScriptAllowSyntheticDefaultImports</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--allowUnreachableCode</code></td><td style="text-align: left">TypeScriptAllowUnreachableCode</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--allowUnusedLabels</code></td><td style="text-align: left">TypeScriptAllowUnusedLabels</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--alwaysStrict</code></td><td style="text-align: left">TypeScriptAlwaysStrict</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--baseUrl</code></td><td style="text-align: left">TypeScriptBaseUrl</td><td style="text-align: left">文件路径</td></tr>
<tr><td style="text-align: left"><code>--charset</code></td><td style="text-align: left">TypeScriptCharset</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--declaration</code></td><td style="text-align: left">TypeScriptGeneratesDeclarations</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--declarationDir</code></td><td style="text-align: left">TypeScriptDeclarationDir</td><td style="text-align: left">文件路径</td></tr>
<tr><td style="text-align: left"><code>--diagnostics</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--disableSizeLimit</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--emitBOM</code></td><td style="text-align: left">TypeScriptEmitBOM</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--emitDecoratorMetadata</code></td><td style="text-align: left">TypeScriptEmitDecoratorMetadata</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--experimentalAsyncFunctions</code></td><td style="text-align: left">TypeScriptExperimentalAsyncFunctions</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--experimentalDecorators</code></td><td style="text-align: left">TypeScriptExperimentalDecorators</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--forceConsistentCasingInFileNames</code></td><td style="text-align: left">TypeScriptForceConsistentCasingInFileNames</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--help</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--importHelpers</code></td><td style="text-align: left">TypeScriptImportHelpers</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--inlineSourceMap</code></td><td style="text-align: left">TypeScriptInlineSourceMap</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--inlineSources</code></td><td style="text-align: left">TypeScriptInlineSources</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--init</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--isolatedModules</code></td><td style="text-align: left">TypeScriptIsolatedModules</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--jsx</code></td><td style="text-align: left">TypeScriptJSXEmit</td><td style="text-align: left"><code>react</code>，<code>react-native</code>，<code>preserve</code></td></tr>
<tr><td style="text-align: left"><code>--jsxFactory</code></td><td style="text-align: left">TypeScriptJSXFactory</td><td style="text-align: left">有效的名字</td></tr>
<tr><td style="text-align: left"><code>--lib</code></td><td style="text-align: left">TypeScriptLib</td><td style="text-align: left">逗号分隔的字符串列表</td></tr>
<tr><td style="text-align: left"><code>--listEmittedFiles</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--listFiles</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--locale</code></td><td style="text-align: left"><em>automatic</em></td><td style="text-align: left">自动设置为PreferredUILang值</td></tr>
<tr><td style="text-align: left"><code>--mapRoot</code></td><td style="text-align: left">TypeScriptMapRoot</td><td style="text-align: left">文件路径</td></tr>
<tr><td style="text-align: left"><code>--maxNodeModuleJsDepth</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--module</code></td><td style="text-align: left">TypeScriptModuleKind</td><td style="text-align: left"><code>AMD</code>，<code>CommonJs</code>，<code>UMD</code>，<code>System</code>或<code>ES6</code></td></tr>
<tr><td style="text-align: left"><code>--moduleResolution</code></td><td style="text-align: left">TypeScriptModuleResolution</td><td style="text-align: left"><code>Classic</code>或<code>Node</code></td></tr>
<tr><td style="text-align: left"><code>--newLine</code></td><td style="text-align: left">TypeScriptNewLine</td><td style="text-align: left"><code>CRLF</code>或<code>LF</code></td></tr>
<tr><td style="text-align: left"><code>--noEmit</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--noEmitHelpers</code></td><td style="text-align: left">TypeScriptNoEmitHelpers</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--noEmitOnError</code></td><td style="text-align: left">TypeScriptNoEmitOnError</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--noFallthroughCasesInSwitch</code></td><td style="text-align: left">TypeScriptNoFallthroughCasesInSwitch</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--noImplicitAny</code></td><td style="text-align: left">TypeScriptNoImplicitAny</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--noImplicitReturns</code></td><td style="text-align: left">TypeScriptNoImplicitReturns</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--noImplicitThis</code></td><td style="text-align: left">TypeScriptNoImplicitThis</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--noImplicitUseStrict</code></td><td style="text-align: left">TypeScriptNoImplicitUseStrict</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--noStrictGenericChecks</code></td><td style="text-align: left">TypeScriptNoStrictGenericChecks</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--noUnusedLocals</code></td><td style="text-align: left">TypeScriptNoUnusedLocals</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--noUnusedParameters</code></td><td style="text-align: left">TypeScriptNoUnusedParameters</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--noLib</code></td><td style="text-align: left">TypeScriptNoLib</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--noResolve</code></td><td style="text-align: left">TypeScriptNoResolve</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--out</code></td><td style="text-align: left">TypeScriptOutFile</td><td style="text-align: left">文件路径</td></tr>
<tr><td style="text-align: left"><code>--outDir</code></td><td style="text-align: left">TypeScriptOutDir</td><td style="text-align: left">文件路径</td></tr>
<tr><td style="text-align: left"><code>--outFile</code></td><td style="text-align: left">TypeScriptOutFile</td><td style="text-align: left">文件路径</td></tr>
<tr><td style="text-align: left"><code>--paths</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--preserveConstEnums</code></td><td style="text-align: left">TypeScriptPreserveConstEnums</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--preserveSymlinks</code></td><td style="text-align: left">TypeScriptPreserveSymlinks</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--listEmittedFiles</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--pretty</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--reactNamespace</code></td><td style="text-align: left">TypeScriptReactNamespace</td><td style="text-align: left">字符串</td></tr>
<tr><td style="text-align: left"><code>--removeComments</code></td><td style="text-align: left">TypeScriptRemoveComments</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--rootDir</code></td><td style="text-align: left">TypeScriptRootDir</td><td style="text-align: left">文件路径</td></tr>
<tr><td style="text-align: left"><code>--rootDirs</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--skipLibCheck</code></td><td style="text-align: left">TypeScriptSkipLibCheck</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--skipDefaultLibCheck</code></td><td style="text-align: left">TypeScriptSkipDefaultLibCheck</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--sourceMap</code></td><td style="text-align: left">TypeScriptSourceMap</td><td style="text-align: left">文件路径</td></tr>
<tr><td style="text-align: left"><code>--sourceRoot</code></td><td style="text-align: left">TypeScriptSourceRoot</td><td style="text-align: left">文件路径</td></tr>
<tr><td style="text-align: left"><code>--strict</code></td><td style="text-align: left">TypeScriptStrict</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--strictFunctionTypes</code></td><td style="text-align: left">TypeScriptStrictFunctionTypes</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--strictNullChecks</code></td><td style="text-align: left">TypeScriptStrictNullChecks</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--stripInternal</code></td><td style="text-align: left">TypeScriptStripInternal</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--suppressExcessPropertyErrors</code></td><td style="text-align: left">TypeScriptSuppressExcessPropertyErrors</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--suppressImplicitAnyIndexErrors</code></td><td style="text-align: left">TypeScriptSuppressImplicitAnyIndexErrors</td><td style="text-align: left">布尔值</td></tr>
<tr><td style="text-align: left"><code>--target</code></td><td style="text-align: left">TypeScriptTarget</td><td style="text-align: left"><code>ES3</code>，<code>ES5</code>，或<code>ES6</code></td></tr>
<tr><td style="text-align: left"><code>--traceResolution</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--types</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--typeRoots</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>--watch</code></td><td style="text-align: left"><em>MSBuild不支持此选项</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><em>MSBuild only option</em></td><td style="text-align: left">TypeScriptAdditionalFlags</td><td style="text-align: left"><em>任何编译选项</em></td></tr>
</tbody></table>
</div>
<h2 id="我使用的visual-studio版本里支持哪些选项"><a class="header" href="#我使用的visual-studio版本里支持哪些选项">我使用的Visual Studio版本里支持哪些选项?</a></h2>
<p>查找 <code>C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets</code> 文件。 可用的MSBuild XML标签与相应的<code>tsc</code>编译选项的映射都在那里。</p>
<h2 id="toolsversion"><a class="header" href="#toolsversion">ToolsVersion</a></h2>
<p>工程文件里的<code>&lt;TypeScriptToolsVersion&gt;1.7&lt;/TypeScriptToolsVersion&gt;</code>属性值表明了构建时使用的编译器的版本号（这个例子里是1.7） 这样就允许一个工程在不同的机器上使用相同版本的编译器进行构建。</p>
<p>如果没有指定<code>TypeScriptToolsVersion</code>，则会使用机器上安装的最新版本的编译器去构建。</p>
<p>如果用户使用的是更新版本的TypeScript，则会在首次加载工程的时候看到一个提示升级工程的对话框。</p>
<h2 id="typescriptcompileblocked"><a class="header" href="#typescriptcompileblocked">TypeScriptCompileBlocked</a></h2>
<p>如果你使用其它的构建工具（比如，gulp， grunt等等）并且使用VS做为开发和调试工具，那么在工程里设置<code>&lt;TypeScriptCompileBlocked&gt;true&lt;/TypeScriptCompileBlocked&gt;</code>。 这样VS只会提供给你编辑的功能，而不会在你按F5的时候去构建。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="与其它构建工具整合"><a class="header" href="#与其它构建工具整合">与其它构建工具整合</a></h1>
<p>构建工具</p>
<ul>
<li><a href="zh/project-config/integrating-with-build-tools.html#babel">Babel</a></li>
<li><a href="zh/project-config/integrating-with-build-tools.html#browserify">Browserify</a></li>
<li><a href="zh/project-config/integrating-with-build-tools.html#duo">Duo</a></li>
<li><a href="zh/project-config/integrating-with-build-tools.html#grunt">Grunt</a></li>
<li><a href="zh/project-config/integrating-with-build-tools.html#gulp">Gulp</a></li>
<li><a href="zh/project-config/integrating-with-build-tools.html#jspm">Jspm</a></li>
<li><a href="zh/project-config/integrating-with-build-tools.html#webpack">Webpack</a></li>
<li><a href="zh/project-config/integrating-with-build-tools.html#msbuild">MSBuild</a></li>
<li><a href="zh/project-config/integrating-with-build-tools.html#nuget">NuGet</a></li>
</ul>
<h2 id="babel-1"><a class="header" href="#babel-1">Babel</a></h2>
<h3 id="安装"><a class="header" href="#安装">安装</a></h3>
<pre><code class="language-bash">npm install @babel/cli @babel/core @babel/preset-typescript --save-dev
</code></pre>
<h3 id="babelrc"><a class="header" href="#babelrc">.babelrc</a></h3>
<pre><code class="language-javascript">{
  "presets": ["@babel/preset-typescript"]
}
</code></pre>
<h3 id="使用命令行工具"><a class="header" href="#使用命令行工具">使用命令行工具</a></h3>
<pre><code class="language-bash">./node_modules/.bin/babel --out-file bundle.js src/index.ts
</code></pre>
<h3 id="packagejson"><a class="header" href="#packagejson">package.json</a></h3>
<pre><code class="language-javascript">{
  "scripts": {
    "build": "babel --out-file bundle.js main.ts"
  },
}
</code></pre>
<h3 id="在命令行上运行babel"><a class="header" href="#在命令行上运行babel">在命令行上运行Babel</a></h3>
<pre><code class="language-bash">npm run build
</code></pre>
<h2 id="browserify-1"><a class="header" href="#browserify-1">Browserify</a></h2>
<h3 id="安装-1"><a class="header" href="#安装-1">安装</a></h3>
<pre><code class="language-bash">npm install tsify
</code></pre>
<h3 id="使用命令行交互"><a class="header" href="#使用命令行交互">使用命令行交互</a></h3>
<pre><code class="language-bash">browserify main.ts -p [ tsify --noImplicitAny ] &gt; bundle.js
</code></pre>
<h3 id="使用api"><a class="header" href="#使用api">使用API</a></h3>
<pre><code class="language-javascript">var browserify = require("browserify");
var tsify = require("tsify");

browserify()
    .add('main.ts')
    .plugin('tsify', { noImplicitAny: true })
    .bundle()
    .pipe(process.stdout);
</code></pre>
<p>更多详细信息：<a href="https://github.com/smrq/tsify">smrq/tsify</a></p>
<h2 id="duo"><a class="header" href="#duo">Duo</a></h2>
<h3 id="安装-2"><a class="header" href="#安装-2">安装</a></h3>
<pre><code class="language-bash">npm install duo-typescript
</code></pre>
<h3 id="使用命令行交互-1"><a class="header" href="#使用命令行交互-1">使用命令行交互</a></h3>
<pre><code class="language-bash">duo --use duo-typescript entry.ts
</code></pre>
<h3 id="使用api-1"><a class="header" href="#使用api-1">使用API</a></h3>
<pre><code class="language-javascript">var Duo = require('duo');
var fs = require('fs')
var path = require('path')
var typescript = require('duo-typescript');

var out = path.join(__dirname, "output.js")

Duo(__dirname)
    .entry('entry.ts')
    .use(typescript())
    .run(function (err, results) {
        if (err) throw err;
        // Write compiled result to output file
        fs.writeFileSync(out, results.code);
    });
</code></pre>
<p>更多详细信息：<a href="https://github.com/frankwallis/duo-typescript">frankwallis/duo-typescript</a></p>
<h2 id="grunt"><a class="header" href="#grunt">Grunt</a></h2>
<h3 id="安装-3"><a class="header" href="#安装-3">安装</a></h3>
<pre><code class="language-bash">npm install grunt-ts
</code></pre>
<h3 id="基本gruntfilejs"><a class="header" href="#基本gruntfilejs">基本Gruntfile.js</a></h3>
<pre><code class="language-javascript">module.exports = function(grunt) {
    grunt.initConfig({
        ts: {
            default : {
                src: ["**/*.ts", "!node_modules/**/*.ts"]
            }
        }
    });
    grunt.loadNpmTasks("grunt-ts");
    grunt.registerTask("default", ["ts"]);
};
</code></pre>
<p>更多详细信息：<a href="https://github.com/TypeStrong/grunt-ts">TypeStrong/grunt-ts</a></p>
<h2 id="gulp-2"><a class="header" href="#gulp-2">Gulp</a></h2>
<h3 id="安装-4"><a class="header" href="#安装-4">安装</a></h3>
<pre><code class="language-bash">npm install gulp-typescript
</code></pre>
<h3 id="基本gulpfilejs"><a class="header" href="#基本gulpfilejs">基本gulpfile.js</a></h3>
<pre><code class="language-javascript">var gulp = require("gulp");
var ts = require("gulp-typescript");

gulp.task("default", function () {
    var tsResult = gulp.src("src/*.ts")
        .pipe(ts({
              noImplicitAny: true,
              out: "output.js"
        }));
    return tsResult.js.pipe(gulp.dest('built/local'));
});
</code></pre>
<p>更多详细信息：<a href="https://github.com/ivogabe/gulp-typescript">ivogabe/gulp-typescript</a></p>
<h2 id="jspm"><a class="header" href="#jspm">Jspm</a></h2>
<h3 id="安装-5"><a class="header" href="#安装-5">安装</a></h3>
<pre><code class="language-bash">npm install -g jspm@beta
</code></pre>
<p><em>注意：目前jspm的0.16beta版本支持TypeScript</em></p>
<p>更多详细信息：<a href="https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm">TypeScriptSamples/jspm</a></p>
<h2 id="webpack-1"><a class="header" href="#webpack-1">Webpack</a></h2>
<h3 id="安装-6"><a class="header" href="#安装-6">安装</a></h3>
<pre><code class="language-bash">npm install ts-loader --save-dev
</code></pre>
<h3 id="webpack-2-webpackconfigjs-基础配置"><a class="header" href="#webpack-2-webpackconfigjs-基础配置">Webpack 2 webpack.config.js 基础配置</a></h3>
<pre><code class="language-javascript">module.exports = {
    entry: "./src/index.tsx",
    output: {
        path: '/',
        filename: "bundle.js"
    },
    resolve: {
        extensions: [".tsx", ".ts", ".js", ".json"]
    },
    module: {
        rules: [
            // all files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'
            { test: /\.tsx?$/, use: ["ts-loader"], exclude: /node_modules/ }
        ]
    }
}
</code></pre>
<h3 id="webpack-1-webpackconfigjs-基础配置"><a class="header" href="#webpack-1-webpackconfigjs-基础配置">Webpack 1 webpack.config.js 基础配置</a></h3>
<pre><code class="language-javascript">module.exports = {
    entry: "./src/index.tsx",
    output: {
        filename: "bundle.js"
    },
    resolve: {
        // Add '.ts' and '.tsx' as a resolvable extension.
        extensions: ["", ".webpack.js", ".web.js", ".ts", ".tsx", ".js"]
    },
    module: {
        loaders: [
            // all files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'
            { test: /\.tsx?$/, loader: "ts-loader" }
        ]
    }
};
</code></pre>
<p>查看<a href="https://www.npmjs.com/package/ts-loader">更多关于ts-loader的详细信息</a></p>
<p>或者</p>
<ul>
<li><a href="https://www.npmjs.com/package/awesome-typescript-loader">awesome-typescript-loader</a></li>
</ul>
<h2 id="msbuild-1"><a class="header" href="#msbuild-1">MSBuild</a></h2>
<p>更新工程文件，包含本地安装的<code>Microsoft.TypeScript.Default.props</code>（在顶端）和<code>Microsoft.TypeScript.targets</code>（在底部）文件：</p>
<pre><code class="language-markup">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt;
  &lt;!-- Include default props at the top --&gt;
  &lt;Import
      Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.Default.props"
      Condition="Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.Default.props')" /&gt;

  &lt;!-- TypeScript configurations go here --&gt;
  &lt;PropertyGroup Condition="'$(Configuration)' == 'Debug'"&gt;
    &lt;TypeScriptRemoveComments&gt;false&lt;/TypeScriptRemoveComments&gt;
    &lt;TypeScriptSourceMap&gt;true&lt;/TypeScriptSourceMap&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup Condition="'$(Configuration)' == 'Release'"&gt;
    &lt;TypeScriptRemoveComments&gt;true&lt;/TypeScriptRemoveComments&gt;
    &lt;TypeScriptSourceMap&gt;false&lt;/TypeScriptSourceMap&gt;
  &lt;/PropertyGroup&gt;

  &lt;!-- Include default targets at the bottom --&gt;
  &lt;Import
      Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets"
      Condition="Exists('$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets')" /&gt;
&lt;/Project&gt;
</code></pre>
<p>关于配置MSBuild编译器选项的更多详细信息，请参考：<a href="zh/project-config/compiler-options-in-msbuild.html">在MSBuild里使用编译选项</a></p>
<h2 id="nuget"><a class="header" href="#nuget">NuGet</a></h2>
<ul>
<li>右键点击 -&gt; Manage NuGet Packages</li>
<li>查找<code>Microsoft.TypeScript.MSBuild</code></li>
<li>点击<code>Install</code></li>
<li>安装完成后，Rebuild。</li>
</ul>
<p>更多详细信息请参考<a href="http://docs.nuget.org/Consume/Package-Manager-Dialog">Package Manager Dialog</a>和<a href="https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild">using nightly builds with NuGet</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>在太平洋标准时间的每日午夜，TypeScript 代码仓库中<a href="https://github.com/Microsoft/TypeScript/tree/master">master 分支</a>上的代码会自动构建并发布到 npm 上。
下面将介绍如何获取并结合你的工具来使用它。</p>
<h2 id="使用-npm"><a class="header" href="#使用-npm">使用 npm</a></h2>
<pre><code class="language-shell">npm install -g typescript@next
</code></pre>
<h2 id="更新-ide-来使用每日构建"><a class="header" href="#更新-ide-来使用每日构建">更新 IDE 来使用每日构建</a></h2>
<p>你还可以配置 IDE 来使用每日构建。
首先你需要通过 npm 来安装代码包。
你可以进行全局安装或者安装到本地的<code>node_modules</code>目录下。</p>
<p>在下面的内容中，我们假设你已经安装好了<code>typescript@next</code>。</p>
<h3 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h3>
<p>参考以下示例来更新<code>.vscode/settings.json</code>：</p>
<pre><code class="language-json">"typescript.tsdk": "&lt;path to your folder&gt;/node_modules/typescript/lib"
</code></pre>
<p>更多详情请参考 <a href="https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions">VSCode 文档</a>。</p>
<h3 id="sublime-text"><a class="header" href="#sublime-text">Sublime Text</a></h3>
<p>参考以下示例来更新<code>Settings - User</code>：</p>
<pre><code class="language-json">"typescript_tsdk": "&lt;path to your folder&gt;/node_modules/typescript/lib"
</code></pre>
<p>更多详情请参考 <a href="https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation">如何在 Sublime Text 里安装 TypeScript 插件</a>。</p>
<h3 id="visual-studio-2013-和-2015"><a class="header" href="#visual-studio-2013-和-2015">Visual Studio 2013 和 2015</a></h3>
<blockquote>
<p>注意：绝大多数的变更不需要你安装新版本的 VS TypeScript 插件。</p>
</blockquote>
<p>目前，每日构建中没有包含完整的插件安装包，但是我们正在试着提供这样的安装包。</p>
<ol>
<li>
<p>下载 <a href="https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1">VSDevMode.ps1</a> 脚本。</p>
<blockquote>
<p>同时也可以参考 wiki 文档： <a href="https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file">使用自定义的语言服务文件</a>。</p>
</blockquote>
</li>
<li>
<p>打开 PowerShell 命令行窗口，并运行：</p>
</li>
</ol>
<p>针对 VS 2015：</p>
<pre><code class="language-posh">VSDevMode.ps1 14 -tsScript &lt;path to your folder&gt;/node_modules/typescript/lib
</code></pre>
<p>针对 VS 2013:</p>
<pre><code class="language-posh">VSDevMode.ps1 12 -tsScript &lt;path to your folder&gt;/node_modules/typescript/lib
</code></pre>
<h3 id="intellij-idea-mac"><a class="header" href="#intellij-idea-mac">IntelliJ IDEA （Mac）</a></h3>
<p>前往 <code>Preferences</code> &gt; <code>Languages &amp; Frameworks</code> &gt; <code>TypeScript</code>：</p>
<blockquote>
<p>TypeScript Version：若通过 npm 安装则为：<code>/usr/local/lib/node_modules/typescript/lib</code></p>
</blockquote>
<h3 id="intellij-idea-windows"><a class="header" href="#intellij-idea-windows">IntelliJ IDEA （Windows）</a></h3>
<p>前往 <code>File</code> &gt; <code>Settings</code> &gt; <code>Languages &amp; Frameworks</code> &gt; <code>TypeScript</code>：</p>
<blockquote>
<p>TypeScript Version：若通过 npm 安装则为：<code>C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="新增功能"><a class="header" href="#新增功能">新增功能</a></h1>
<ul>
<li><a href="zh/release-notes/typescript-5.4.html">TypeScript 5.4</a></li>
<li><a href="zh/release-notes/typescript-5.3.html">TypeScript 5.3</a></li>
<li><a href="zh/release-notes/typescript-5.2.html">TypeScript 5.2</a></li>
<li><a href="zh/release-notes/typescript-5.1.html">TypeScript 5.1</a></li>
<li><a href="zh/release-notes/typescript-5.0.html">TypeScript 5.0</a></li>
<li><a href="zh/release-notes/typescript-4.9.html">TypeScript 4.9</a></li>
<li><a href="zh/release-notes/typescript-4.8.html">TypeScript 4.8</a></li>
<li><a href="zh/release-notes/typescript-4.7.html">TypeScript 4.7</a></li>
<li><a href="zh/release-notes/typescript-4.6.html">TypeScript 4.6</a></li>
<li><a href="zh/release-notes/typescript-4.5.html">TypeScript 4.5</a></li>
<li><a href="zh/release-notes/typescript-4.4.html">TypeScript 4.4</a></li>
<li><a href="zh/release-notes/typescript-4.3.html">TypeScript 4.3</a></li>
<li><a href="zh/release-notes/typescript-4.2.html">TypeScript 4.2</a></li>
<li><a href="zh/release-notes/typescript-4.1.html">TypeScript 4.1</a></li>
<li><a href="zh/release-notes/typescript-4.0.html">TypeScript 4.0</a></li>
<li><a href="zh/release-notes/typescript-3.9.html">TypeScript 3.9</a></li>
<li><a href="zh/release-notes/typescript-3.8.html">TypeScript 3.8</a></li>
<li><a href="zh/release-notes/typescript-3.7.html">TypeScript 3.7</a></li>
<li><a href="zh/release-notes/typescript-3.6.html">TypeScript 3.6</a></li>
<li><a href="zh/release-notes/typescript-3.5.html">TypeScript 3.5</a></li>
<li><a href="zh/release-notes/typescript-3.4.html">TypeScript 3.4</a></li>
<li><a href="zh/release-notes/typescript-3.3.html">TypeScript 3.3</a></li>
<li><a href="zh/release-notes/typescript-3.2.html">TypeScript 3.2</a></li>
<li><a href="zh/release-notes/typescript-3.1.html">TypeScript 3.1</a></li>
<li><a href="zh/release-notes/typescript-3.0.html">TypeScript 3.0</a></li>
<li><a href="zh/release-notes/typescript-2.9.html">TypeScript 2.9</a></li>
<li><a href="zh/release-notes/typescript-2.8.html">TypeScript 2.8</a></li>
<li><a href="zh/release-notes/typescript-2.7.html">TypeScript 2.7</a></li>
<li><a href="zh/release-notes/typescript-2.6.html">TypeScript 2.6</a></li>
<li><a href="zh/release-notes/typescript-2.5.html">TypeScript 2.5</a></li>
<li><a href="zh/release-notes/typescript-2.4.html">TypeScript 2.4</a></li>
<li><a href="zh/release-notes/typescript-2.3.html">TypeScript 2.3</a></li>
<li><a href="zh/release-notes/typescript-2.2.html">TypeScript 2.2</a></li>
<li><a href="zh/release-notes/typescript-2.1.html">TypeScript 2.1</a></li>
<li><a href="zh/release-notes/typescript-2.0.html">TypeScript 2.0</a></li>
<li><a href="zh/release-notes/typescript-1.8.html">TypeScript 1.8</a></li>
<li><a href="zh/release-notes/typescript-1.7.html">TypeScript 1.7</a></li>
<li><a href="zh/release-notes/typescript-1.6.html">TypeScript 1.6</a></li>
<li><a href="zh/release-notes/typescript-1.5.html">TypeScript 1.5</a></li>
<li><a href="zh/release-notes/typescript-1.4.html">TypeScript 1.4</a></li>
<li><a href="zh/release-notes/typescript-1.3.html">TypeScript 1.3</a></li>
<li><a href="zh/release-notes/typescript-1.1.html">TypeScript 1.1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-54"><a class="header" href="#typescript-54">TypeScript 5.4</a></h1>
<h2 id="从最后一次赋值以后在闭包中保留类型细化"><a class="header" href="#从最后一次赋值以后在闭包中保留类型细化">从最后一次赋值以后，在闭包中保留类型细化</a></h2>
<p>TypeScript 通常可以根据您进行的检查来确定变量更具体的类型。
这个过程被称为类型细化。</p>
<pre><code class="language-ts">function uppercaseStrings(x: string | number) {
  if (typeof x === 'string') {
    // TypeScript 知道 'x' 是 'string' 类型
    return x.toUpperCase();
  }
}
</code></pre>
<p>一个常见的痛点是被细化的类型不总会在闭包函数中保留。</p>
<pre><code class="language-ts">function getUrls(url: string | URL, names: string[]) {
  if (typeof url === 'string') {
    url = new URL(url);
  }

  return names.map(name =&gt; {
    url.searchParams.set('name', name);
    //  ~~~~~~~~~~~~
    // error!
    // Property 'searchParams' does not exist on type 'string | URL'.

    return url.toString();
  });
}
</code></pre>
<p>在这里，TypeScript 决定在我们的回调函数中不“安全”地假设 <code>url</code> <em>实际上</em>是一个 <code>URL</code> 对象，因为它在其他地方发生了变化；
然而，在这种情况下，箭头函数总是在对 <code>url</code> 的赋值之后创建的，并且它也是对 <code>url</code> 的最后一次赋值。</p>
<p>TypeScript 5.4 利用这一点使类型细化变得更加智能。
当在非<a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting">提升</a>的函数中使用参数和 <code>let</code> 变量时，类型检查器将寻找最后一次赋值点。
如果找到了这样的点，TypeScript 可以安全地从包含函数的外部进行类型细化。
这意味着上面的例子现在可以正常工作了。</p>
<p>请注意，如果变量在嵌套函数的任何地方被赋值，类型细化分析将不会生效。
这是因为无法确定该函数是否会在后续被调用。</p>
<pre><code class="language-ts">function printValueLater(value: string | undefined) {
  if (value === undefined) {
    value = 'missing!';
  }

  setTimeout(() =&gt; {
    // Modifying 'value', even in a way that shouldn't affect
    // its type, will invalidate type refinements in closures.
    value = value;
  }, 500);

  setTimeout(() =&gt; {
    console.log(value.toUpperCase());
    //          ~~~~~
    // error! 'value' is possibly 'undefined'.
  }, 1000);
}
</code></pre>
<p>这将使许多典型的 JavaScript 代码更容易表达出来。
更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/56908">PR</a>。</p>
<h2 id="noinfer-工具类型"><a class="header" href="#noinfer-工具类型"><code>NoInfer</code> 工具类型</a></h2>
<p>当调用泛型函数时，TypeScript 能够从实际参数推断出类型参数的值。</p>
<pre><code class="language-ts">function doSomething&lt;T&gt;(arg: T) {
  // ...
}

// We can explicitly say that 'T' should be 'string'.
doSomething&lt;string&gt;('hello!');

// We can also just let the type of 'T' get inferred.
doSomething('hello!');
</code></pre>
<p>然而，一个挑战是并不总能够清楚推断出“最佳”的类型是什么。
这可能导致 TypeScript 拒绝合理的调用，接受有问题的调用，或者在捕捉到 bug 时报告较差的错误消息。</p>
<p>例如，假设 <code>createStreetLight</code> 函数接收一系列颜色名，以及一个默认颜色名。</p>
<pre><code class="language-ts">function createStreetLight&lt;C extends string&gt;(colors: C[], defaultColor?: C) {
  // ...
}

createStreetLight(['red', 'yellow', 'green'], 'red');
</code></pre>
<p>当我们传入的 <code>defaultColor</code> 不在 <code>colors</code> 数组里会发生什么？
在这个函数中，<code>colors</code> 被当成“事实来源”，并描述了可以传递给 <code>defaultColor</code>。</p>
<pre><code class="language-ts">// Oops! This undesirable, but is allowed!
createStreetLight(['red', 'yellow', 'green'], 'blue');
</code></pre>
<p>在这个调用中，类型推断决定 <code>"blue"</code> 与 <code>"red"</code>、<code>"yellow"</code> 或 <code>"green"</code> 一样有效。
因此，TypeScript 推断 <code>C</code> 的类型为 <code>"red" | "yellow" | "green" | "blue"</code>。
可以说推断结果让我们感到十分惊讶！</p>
<p>目前人们处理这个问题的一种方式是添加一个独立的类型参数，该参数受现有类型参数的限制。</p>
<pre><code class="language-ts">function createStreetLight&lt;C extends string, D extends C&gt;(
  colors: C[],
  defaultColor?: D
) {}

createStreetLight(['red', 'yellow', 'green'], 'blue');
//                                            ~~~~~~
// error!
// Argument of type '"blue"' is not assignable to parameter of type '"red" | "yellow" | "green" | undefined'.
</code></pre>
<p>这种方法可以解决问题，但有点尴尬，因为在 <code>createStreetLight</code> 的签名中可能不会在其他地方使用 <code>D</code>。
虽然这种情况不算糟糕，但在签名中只使用一次类型参数通常是一种代码坏味道。</p>
<p>这就是为什么 TypeScript 5.4 引入了一个新的 <code>NoInfer&lt;T&gt;</code> 实用类型。
将一个类型包裹在 <code>NoInfer&lt;...&gt;</code> 中向 TypeScript 发出一个信号，告诉它不要深入匹配内部类型以寻找类型推断的候选项。</p>
<p>使用 <code>NoInfer</code>，我们可以将 <code>createStreetLight</code> 重写为以下形式：</p>
<pre><code class="language-ts">function createStreetLight&lt;C extends string&gt;(
  colors: C[],
  defaultColor?: NoInfer&lt;C&gt;
) {
  // ...
}

createStreetLight(['red', 'yellow', 'green'], 'blue');
//                                            ~~~~~~
// error!
// Argument of type '"blue"' is not assignable to parameter of type '"red" | "yellow" | "green" | undefined'.
</code></pre>
<p>排除对 <code>defaultColor</code> 类型进行推断的探索意味着 <code>"blue"</code> 永远不会成为推断的候选项，类型检查器可以拒绝它。</p>
<p>具体实现请参考 <a href="https://github.com/microsoft/TypeScript/pull/56794">PR</a>，以及最初实现 <a href="https://github.com/microsoft/TypeScript/pull/52968">PR</a>，感谢<a href="https://github.com/Andarist">Mateusz Burzyński</a></p>
<h2 id="objectgroupby-和-mapgroupby"><a class="header" href="#objectgroupby-和-mapgroupby"><code>Object.groupBy</code> 和 <code>Map.groupBy</code></a></h2>
<p>TypeScript 5.4 为 JavaScript 的新静态方法 <code>Object.groupBy</code> 和 <code>Map.groupBy</code> 添加了声明。</p>
<p><code>Object.groupBy</code> 接受一个可迭代对象和一个函数，该函数确定每个元素应该被放置在哪个“组”中。
该函数需要为每个不同的分组生成一个“键”，而 <code>Object.groupBy</code> 使用该键来创建一个对象，其中每个键都映射到一个包含原始元素的数组。</p>
<p>因此：</p>
<pre><code class="language-js">const array = [0, 1, 2, 3, 4, 5];

const myObj = Object.groupBy(array, (num, index) =&gt; {
  return num % 2 === 0 ? 'even' : 'odd';
});
</code></pre>
<p>等同于：</p>
<pre><code class="language-js">const myObj = {
  even: [0, 2, 4],
  odd: [1, 3, 5],
};
</code></pre>
<p><code>Map.groupBy</code> 类似，但生成的是一个 <code>Map</code> 而不是普通对象。
如果您需要 <code>Map</code> 提供的保证、处理期望 <code>Map</code> 的 API，或者需要使用任何类型的键进行分组（而不仅仅是可以作为 JavaScript 属性名的键），那么这可能更可取。</p>
<pre><code class="language-js">const myObj = Map.groupBy(array, (num, index) =&gt; {
  return num % 2 === 0 ? 'even' : 'odd';
});
</code></pre>
<p>就像之前一样，你可以用等效的方式创建 <code>myObj</code>：</p>
<pre><code class="language-js">const myObj = new Map();

myObj.set('even', [0, 2, 4]);
myObj.set('odd', [1, 3, 5]);
</code></pre>
<p>注意在 <code>Object.groupBy</code> 的例子中，生成的对象使用了所有可选属性。</p>
<pre><code class="language-js">interface EvenOdds {
    even?: number[];
    odd?: number[];
}

const myObj: EvenOdds = Object.groupBy(...);

myObj.even;
//    ~~~~
// Error to access this under 'strictNullChecks'.
</code></pre>
<p>这是因为没法保证 <code>groupBy</code> 生成了<em>所有的</em>键。</p>
<p>注意这些方法仅在将 <code>target</code> 设置为 <code>esnext</code>，或者设置了相应的 <code>lib</code> 选项时才可用。
我们预计它们最终会在稳定的 <code>es2024</code> 目标下可用。</p>
<p>感谢<a href="https://github.com/bakkot">Kevin Gibbons</a>的<a href="https://github.com/microsoft/TypeScript/pull/56805">PR</a>。</p>
<h2 id="支持在---moduleresolution-bundler-和---module-preserve-时-使用-require"><a class="header" href="#支持在---moduleresolution-bundler-和---module-preserve-时-使用-require">支持在 <code>--moduleResolution bundler</code> 和 <code>--module preserve</code> 时 使用 <code>require()</code></a></h2>
<p>TypeScript 有一个名为 <code>bundler</code> 的 <code>moduleResolution</code> 选项，旨在模拟现代打包工具确定导入路径所指向的文件的方式。
该选项的一个限制是它必须与 <code>--module esnext</code> 配对使用，这导致无法使用 <code>import ... = require(...)</code> 语法。</p>
<pre><code class="language-ts">// previously errored
import myModule = require('module/path');
</code></pre>
<p>如果您计划只编写标准的 ECMAScript <code>import</code>，这可能看起来并不是很重要，但在使用具有<a href="https://nodejs.org/api/packages.html#conditional-exports">条件导出</a>的包时就会有所不同。</p>
<p>在 TypeScript 5.4 中，当将 <code>module</code> 设置为一个名为 <code>preserve</code> 的新选项时，可以使用 <code>require()</code>。</p>
<p>在 <code>--module preserve</code> 和 <code>--moduleResolution bundler</code> 之间，这两个选项更准确地模拟了像 Bun 等打包工具和运行时环境允许的操作以及它们如何执行模块查找。
实际上，在使用 <code>--module preserve</code> 时，<code>--moduleResolution</code> 选项将会隐式设置为 <code>bundler</code>（以及 <code>--esModuleInterop</code> 和 <code>--resolveJsonModule</code>）。</p>
<pre><code class="language-json">{
  "compilerOptions": {
    "module": "preserve"
    // ^ also implies:
    // "moduleResolution": "bundler",
    // "esModuleInterop": true,
    // "resolveJsonModule": true,

    // ...
  }
}
</code></pre>
<p>在 <code>--module preserve</code> 下，ECMAScript 的 <code>import</code> 语句将始终按原样输出，而 <code>import ... = require(...)</code> 语句将被输出为 <code>require()</code> 调用（尽管实际上你可能不会使用 TypeScript 进行输出，因为你很可能会使用打包工具来处理你的代码）。
这一点不受包含文件的文件扩展名的影响。
因此，以下代码：</p>
<pre><code class="language-ts">import * as foo from 'some-package/foo';
import bar = require('some-package/bar');
</code></pre>
<p>的输出结果会是这样：</p>
<pre><code class="language-js">import * as foo from 'some-package/foo';
var bar = require('some-package/bar');
</code></pre>
<p>这也意味着您选择的语法将指定条件导出的匹配方式。
因此，在上面的示例中，如果 <code>some-package</code> 的 <code>package.json</code> 如下所示：</p>
<pre><code class="language-json">{
  "name": "some-package",
  "version": "0.0.1",
  "exports": {
    "./foo": {
      "import": "./esm/foo-from-import.mjs",
      "require": "./cjs/foo-from-require.cjs"
    },
    "./bar": {
      "import": "./esm/bar-from-import.mjs",
      "require": "./cjs/bar-from-require.cjs"
    }
  }
}
</code></pre>
<p>TypeScript 会将路径解析为 <code>[...]/some-package/esm/foo-from-import.mjs</code> 和 <code>[...]/some-package/cjs/bar-from-require.cjs</code>。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/56785">PR</a>。</p>
<h2 id="检查导入属性和断言"><a class="header" href="#检查导入属性和断言">检查导入属性和断言</a></h2>
<p>导入属性和断言现在会与全局的 <code>ImportAttributes</code> 类型进行检查。
这意味着运行时现在可以更准确地描述导入属性。</p>
<pre><code class="language-ts">// In some global file.
interface ImportAttributes {
    type: "json";
}

// In some other module
import * as ns from "foo" with { type: "not-json" };
//                                     ~~~~~~~~~~
// error!
//
// Type '{ type: "not-json"; }' is not assignable to type 'ImportAttributes'.
//  Types of property 'type' are incompatible.
//    Type '"not-json"' is not assignable to type '"json"'.
</code></pre>
<p>感谢 <a href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a>的 <a href="https://github.com/microsoft/TypeScript/pull/56034">PR</a>。</p>
<h2 id="快速修复添加缺失参数"><a class="header" href="#快速修复添加缺失参数">快速修复：添加缺失参数</a></h2>
<p>TypeScript 现在提供了一个快速修复选项，可以为被调用时传递了过多参数的函数添加一个新的参数。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2024/01/add-missing-params-5-4-beta-before.png" alt="" /></p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2024/01/add-missing-params-5-4-beta-after.png" alt="" /></p>
<p>当在多个现有函数之间传递一个新参数时，这将非常有用，而目前这样做可能会很麻烦。</p>
<p>感谢 <a href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a>的 <a href="https://github.com/microsoft/TypeScript/pull/56411">PR</a>。</p>
<h2 id="子路径导入支持自动导入"><a class="header" href="#子路径导入支持自动导入">子路径导入支持自动导入</a></h2>
<p>在 Node.js 中，<code>package.json</code> 通过一个名为 <code>imports</code> 的字段支持一种称为“子路径导入”的功能。
这是一种将包内的路径重新映射到其他模块路径的方式。
在概念上，这与路径映射非常相似，某些模块打包工具和加载器支持该功能（TypeScript 通过一个称为 <code>paths</code> 的功能也支持该功能）。
唯一的区别是，子路径导入必须始终以 <code>#</code> 开头。</p>
<p>TypeScript 的自动导入功能以前不会考虑 <code>imports</code> 中的路径，这可能令人沮丧。
相反，用户可能需要在 <code>tsconfig.json</code> 中手动定义路径。
然而，由于 <a href="https://github.com/emmatown">Emma Hamilton</a> 的贡献，TypeScript 的自动导入现在支持<a href="https://github.com/microsoft/TypeScript/pull/55015">子路径导入</a>！</p>
<h2 id="即将到来的-typescript-50-弃用功能"><a class="header" href="#即将到来的-typescript-50-弃用功能">即将到来的 TypeScript 5.0 弃用功能</a></h2>
<p>TypeScript 5.0 弃用了以下选项和行为：</p>
<ul>
<li>charset</li>
<li>target: ES3</li>
<li>importsNotUsedAsValues</li>
<li>noImplicitUseStrict</li>
<li>noStrictGenericChecks</li>
<li>keyofStringsOnly</li>
<li>suppressExcessPropertyErrors</li>
<li>suppressImplicitAnyIndexErrors</li>
<li>out</li>
<li>preserveValueImports</li>
<li>工程引用中的 prepend</li>
<li>隐式的系统特定 newLine</li>
</ul>
<p>为了继续使用这些功能，使用 TypeScript 5.0 + 版本的开发人员必须指定一个名为 <code>ignoreDeprecations</code> 的新选项，其值为 <code>"5.0"</code>。</p>
<p>然而，TypScript 5.4 将是这些功能继续正常工作的最后一个版本。
到了 TypeScript 5.5（可能是 2024 年 6 月），它们将变成严格的错误，使用它们的代码将需要进行迁移。</p>
<p>要获取更多信息，您可以在 GitHub 上查阅<a href="https://github.com/microsoft/TypeScript/issues/51909">这个计划</a>，其中包含了如何最佳地适应您的代码库的建议。</p>
<h2 id="值得注意的行为改变"><a class="header" href="#值得注意的行为改变">值得注意的行为改变</a></h2>
<p>本节重点介绍一系列值得注意的变更，作为升级的一部分，应该予以认识和理解。
有时它会强调弃用、移除和新的限制。
它还可能包含功能性改进的错误修复，但这些修复也可能通过引入新的错误影响现有的构建。</p>
<h3 id="libdts-变化"><a class="header" href="#libdts-变化">lib.d.ts 变化</a></h3>
<p><a href="https://github.com/microsoft/TypeScript/pull/57027">DOM 类型有变化</a>。</p>
<h3 id="更准确的有条件类型约束"><a class="header" href="#更准确的有条件类型约束">更准确的有条件类型约束</a></h3>
<p>下面的 <code>foo</code> 函数不再允许第二个变量声明。</p>
<pre><code class="language-ts">type IsArray&lt;T&gt; = T extends any[] ? true : false;

function foo&lt;U extends object&gt;(x: IsArray&lt;U&gt;) {
  let first: true = x; // Error
  let second: false = x; // Error, but previously wasn't
}
</code></pre>
<p>在之前的版本中，当 TypeScript 检查第二个初始化器时，它需要确定 <code>IsArray&lt;U&gt;</code> 是否可赋值给 <code>false</code> 类型的单元类型。
虽然 <code>IsArray&lt;U&gt;</code> 在任何明显的方式下都不兼容，但 TypeScript 也会考虑该类型的约束。
在形如 <code>T extends Foo ? TrueBranch : FalseBranch</code> 的条件类型中，其中 <code>T</code> 是泛型，类型系统会查看 <code>T</code> 的约束，在 <code>T</code> 本身的位置上进行替代，并决定选择 <code>true</code> 分支还是 <code>false</code> 分支。</p>
<p>但是，这种行为是不准确的，因为它过于急切。即使 <code>T</code> 的约束不能赋值给 <code>Foo</code>，也并不意味着它不会实例化为某个可赋值给 <code>Foo</code> 的类型。
因此，更正确的行为是在无法证明 <code>T</code> 永远不会或总是 extends <code>Foo</code> 的情况下，为条件类型的约束产生一个联合类型。</p>
<p>TypeScript 5.4 采用了这种更准确的行为。
在实践中，这意味着您可能会发现某些条件类型实例与它们的分支不再兼容。</p>
<p>您可以在<a href="https://github.com/microsoft/TypeScript/pull/56004">此处</a>阅读具体的更改内容。</p>
<h3 id="更积极地减少类型变量与原始类型之间的交集"><a class="header" href="#更积极地减少类型变量与原始类型之间的交集">更积极地减少类型变量与原始类型之间的交集</a></h3>
<pre><code class="language-ts">declare function intersect&lt;T, U&gt;(x: T, y: U): T &amp; U;

function foo&lt;T extends 'abc' | 'def'&gt;(x: T, str: string, num: number) {
  // Was 'T &amp; string', now is just 'T'
  let a = intersect(x, str);

  // Was 'T &amp; number', now is just 'never'
  let b = intersect(x, num);

  // Was '(T &amp; "abc") | (T &amp; "def")', now is just 'T'
  let c = Math.random() &lt; 0.5 ? intersect(x, 'abc') : intersect(x, 'def');
}
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/56515">PR</a>。</p>
<h3 id="改进了对带有插值的模板字符串的检查"><a class="header" href="#改进了对带有插值的模板字符串的检查">改进了对带有插值的模板字符串的检查</a></h3>
<p>TypeScript 现在更准确地检查字符串是否可赋值给模板字符串类型的占位符位置。</p>
<pre><code class="language-ts">function a&lt;T extends { id: string }&gt;() {
  let x: `-${keyof T &amp; string}`;

  // Used to error, now doesn't.
  x = '-id';
}
</code></pre>
<p>这种行为更加理想，但可能会导致使用条件类型等结构的代码出现问题，因为这些规则变化很容易引发观察到的错误。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/56598">PR</a>。</p>
<h3 id="当类型导入与本地值冲突时报错"><a class="header" href="#当类型导入与本地值冲突时报错">当类型导入与本地值冲突时报错</a></h3>
<p>在之前的版本中，如果对 <code>"Something"</code> 的导入只涉及类型，TypeScript 会在 <code>"isolatedModules"</code> 下允许以下代码。</p>
<pre><code class="language-ts">import { Something } from './some/path';

let Something = 123;
</code></pre>
<p>然而，对于单文件编译器来说，假设是否能够"安全"删除 <code>import</code> 并不可靠，即使代码在运行时肯定会失败。
在 TypeScript 5.4 中，这段代码将触发以下类似的错误：</p>
<pre><code class="language-ts">Import 'Something' conflicts with local value, so must be declared with a type-only import when 'isolatedModules' is enabled.
</code></pre>
<p>修改方法或者给本地变量重命名，或者为导入语句添加 <code>type</code> 修饰符：</p>
<pre><code class="language-ts">import type { Something } from './some/path';

// or

import { type Something } from './some/path';
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/56354">PR</a>。</p>
<h3 id="新的枚举可赋值性检查"><a class="header" href="#新的枚举可赋值性检查">新的枚举可赋值性检查</a></h3>
<p>在之前的版本中，当两个枚举具有相同的声明名称和枚举成员名称时，它们通常被认为是兼容的。
然而，当这些值是已知的时候，TypeScript 会默默地允许它们具有不同的值。</p>
<p>TypeScript 5.4 通过要求已知的值必须相同来加强这一限制。
这意味着当枚举的值已知时，它们必须具有相同的值。</p>
<pre><code class="language-ts">namespace First {
  export enum SomeEnum {
    A = 0,
    B = 1,
  }
}

namespace Second {
  export enum SomeEnum {
    A = 0,
    B = 2,
  }
}

function foo(x: First.SomeEnum, y: Second.SomeEnum) {
  // Both used to be compatible - no longer the case,
  // TypeScript errors with something like:
  //
  //  Each declaration of 'SomeEnum.B' differs in its value, where '1' was expected but '2' was given.
  x = y;
  y = x;
}
</code></pre>
<p>此外，对于一个枚举成员没有静态已知值的情况，还有一些新的限制。
在这些情况下，另一个枚举成员必须至少是隐式数字类型（例如，它没有静态解析的初始化值），或者是显式数字类型（意味着 TypeScript 可以将值解析为某个数字类型）。
从实际角度来看，这意味着字符串枚举成员只能与具有相同值的其他字符串枚举兼容。</p>
<pre><code class="language-ts">namespace First {
  export declare enum SomeEnum {
    A,
    B,
  }
}

namespace Second {
  export declare enum SomeEnum {
    A,
    B = 'some known string',
  }
}

function foo(x: First.SomeEnum, y: Second.SomeEnum) {
  // Both used to be compatible - no longer the case,
  // TypeScript errors with something like:
  //
  //  One value of 'SomeEnum.B' is the string '"some known string"', and the other is assumed to be an unknown numeric value.
  x = y;
  y = x;
}
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/55924">PR</a>。</p>
<h3 id="枚举成员名的限制"><a class="header" href="#枚举成员名的限制">枚举成员名的限制</a></h3>
<p>TypeScript 不再允许枚举成员名使用 <code>Infinity</code>，<code>-Infinity</code>，或 <code>NaN</code>。</p>
<pre><code class="language-ts">// Errors on all of these:
//
//  An enum member cannot have a numeric name.
enum E {
  Infinity = 0,
  '-Infinity' = 1,
  NaN = 2,
}
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/56161">PR</a>。</p>
<h3 id="在具有-any-剩余元素的元组上更好地保留映射类型"><a class="header" href="#在具有-any-剩余元素的元组上更好地保留映射类型">在具有 <code>any</code> 剩余元素的元组上，更好地保留映射类型</a></h3>
<p>在之前的版本中，将带有 <code>"any"</code> 类型的映射类型应用于元组时，会创建一个 <code>"any"</code> 元素类型。
这是不可取的，并且现在已经修复了这个问题。</p>
<pre><code class="language-ts">Promise.all(['', ...([] as any)]).then(result =&gt; {
  const head = result[0]; // 5.3: any, 5.4: string
  const tail = result.slice(1); // 5.3 any, 5.4: any[]
});
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/57031">PR</a>，<a href="https://github.com/microsoft/TypeScript/issues/57389">Issue</a>，<a href="https://github.com/microsoft/TypeScript/issues/57389">Issue</a>。</p>
<h3 id="代码生成变化"><a class="header" href="#代码生成变化">代码生成变化</a></h3>
<p>虽然这不是一个直接的破坏性变更，但开发人员可能会隐式地依赖于 TypeScript 生成的 JavaScript 或声明文件输出。以下是一些值得注意的变化。</p>
<ul>
<li><a href="https://github.com/microsoft/TypeScript/pull/55820">当类型参数被遮蔽时更频繁地保留类型参数名称</a></li>
<li><a href="https://github.com/microsoft/TypeScript/pull/56296">将异步函数的复杂参数列表移到降级生成器主体中</a></li>
<li><a href="https://github.com/microsoft/TypeScript/pull/57020">不要移除函数声明中的绑定别名</a></li>
<li><a href="https://github.com/microsoft/TypeScript/pull/56395">当存在 ImportTypeNode 时，ImportAttributes 应该经过相同的编译阶段处理</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-53"><a class="header" href="#typescript-53">TypeScript 5.3</a></h1>
<h2 id="导入属性import-attributes"><a class="header" href="#导入属性import-attributes">导入属性（Import Attributes）</a></h2>
<p>TypeScript 5.3 支持了最新的 <a href="https://github.com/tc39/proposal-import-attributes">import attributes</a> 提案。</p>
<p>该特性的一个用例是为运行时提供期望的模块格式信息。</p>
<pre><code class="language-ts">// We only want this to be interpreted as JSON,
// not a runnable/malicious JavaScript file with a `.json` extension.
import obj from "./something.json" with { type: "json" };
</code></pre>
<p>TypeScript 不会检查属性内容，因为它们是宿主环境相关的。
TypeScript 会原样保留它们，浏览器和运行时会处理它们。</p>
<pre><code class="language-ts">// TypeScript is fine with this.
// But your browser? Probably not.
import * as foo from "./foo.js" with { type: "fluffy bunny" };
</code></pre>
<p>动态的 <code>import()</code> 调用也可以在第二个参数里使用该特性。</p>
<pre><code class="language-ts">const obj = await import('./something.json', {
  with: { type: 'json' },
});
</code></pre>
<p>第二个参数的期望类型为 <code>ImportCallOptions</code>，默认只支持一个名为 <code>with</code> 的属性。</p>
<p>请注意，导入属性是之前提案<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-5/#import-assertions">“导入断言”</a>的演进，该提案已在 TypeScript 4.5 中实现。
最明显的区别是使用<code>with</code>关键字而不是<code>assert</code>关键字。
但不太明显的区别是，现在运行时可以自由地使用属性来指导导入路径的解析和解释，而导入断言只能在加载模块后断言某些特性。</p>
<p>随着时间的推移，TypeScript 将逐渐弃用旧的导入断言语法，转而采用导入属性的提议语法。现有的使用<code>assert</code>的代码应该迁移到<code>with</code>关键字。而需要导入属性的新代码应该完全使用<code>with</code>关键字。</p>
<p>感谢 Oleksandr Tarasiuk 实现了这个功能！
也感谢 Wenlu Wang 实现了 import assertions!</p>
<h2 id="稳定支持-import-type-上的-resolution-mode"><a class="header" href="#稳定支持-import-type-上的-resolution-mode">稳定支持 <code>import type</code> 上的 <code>resolution-mode</code></a></h2>
<p>TypeScript 4.7 在 <code>/// &lt;reference types="..." /&gt;</code> 里支持了 <code>resolution-mode</code> 属性，
它用来控制一个描述符是使用 <code>import</code> 还是 <code>require</code> 语义来解析。</p>
<pre><code class="language-ts">/// &lt;reference types="pkg" resolution-mode="require" /&gt;

// or

/// &lt;reference types="pkg" resolution-mode="import" /&gt;
</code></pre>
<p>在 type-only 导入上，导入断言也引入了相应的字段；
然而，它仅在 TypeScript 的夜间版本中得到支持
其原因是在精神上，导入断言并不打算指导模块解析。
因此，这个特性以实验性的方式仅在夜间版本中发布，以获得更多的反馈。</p>
<p>但是，导入属性（Import Attributes）可以指导解析，并且我们也已经看到了有意义的用例，
TypeScript 5.3 在 <code>import type</code> 上支持了 <code>resolution-mode</code>。</p>
<pre><code class="language-ts">// Resolve `pkg` as if we were importing with a `require()`
import type { TypeFromRequire } from "pkg" with {
    "resolution-mode": "require"
};

// Resolve `pkg` as if we were importing with an `import`
import type { TypeFromImport } from "pkg" with {
    "resolution-mode": "import"
};

export interface MergedType extends TypeFromRequire, TypeFromImport {}
</code></pre>
<p>这些导入属性也可以用在 <code>import()</code> 类型上。</p>
<pre><code class="language-ts">export type TypeFromRequire =
    import("pkg", { with: { "resolution-mode": "require" } }).TypeFromRequire;

export type TypeFromImport =
    import("pkg", { with: { "resolution-mode": "import" } }).TypeFromImport;

export interface MergedType extends TypeFromRequire, TypeFromImport {}
</code></pre>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/55725">PR</a>。</p>
<h2 id="在所有模块模式中支持-resolution-mode"><a class="header" href="#在所有模块模式中支持-resolution-mode">在所有模块模式中支持 <code>resolution-mode</code></a></h2>
<p>此前，仅在 <code>moduleResolution</code> 为 <code>node16</code> 和 <code>nodenext</code> 时支持 <code>resolution-mode</code>。
为了使查找模块更容易，尤其针对类型，<code>resolution-mode</code> 现在可以在所有其它的 <code>moduleResolution</code> 选项下工作，例如 <code>bundler</code>、<code>node10</code>，甚至在 <code>classic</code> 下也不报错。</p>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/55725">PR</a>。</p>
<h2 id="switch-true-类型细化"><a class="header" href="#switch-true-类型细化"><code>switch (true)</code> 类型细化</a></h2>
<p>TypeScript 5.3 会针对 <code>switch (true)</code> 里的每一个 <code>case</code> 条件进行类型细化。</p>
<pre><code class="language-ts">function f(x: unknown) {
  switch (true) {
    case typeof x === 'string':
      // 'x' is a 'string' here
      console.log(x.toUpperCase());
    // falls through...

    case Array.isArray(x):
      // 'x' is a 'string | any[]' here.
      console.log(x.length);
    // falls through...

    default:
    // 'x' is 'unknown' here.
    // ...
  }
}
</code></pre>
<p>感谢 Mateusz Burzyński 的<a href="https://github.com/microsoft/TypeScript/pull/55991">贡献</a>。</p>
<h2 id="类型细化与布尔值的比较"><a class="header" href="#类型细化与布尔值的比较">类型细化与布尔值的比较</a></h2>
<p>有时，您可能会发现自己在条件语句中直接与 <code>true</code> 或 <code>false</code> 进行比较。
通常情况下，这些比较是不必要的，但您可能出于风格上的考虑或为了避免 JavaScript 中真值相关的某些问题而偏好这样做。
不过，之前 TypeScript 在进行类型细化时并不识别这样的形式。</p>
<p>TypeScript 5.3 在类型细化时可以理解这类表达式。</p>
<pre><code class="language-ts">interface A {
  a: string;
}

interface B {
  b: string;
}

type MyType = A | B;

function isA(x: MyType): x is A {
  return 'a' in x;
}

function someFn(x: MyType) {
  if (isA(x) === true) {
    console.log(x.a); // works!
  }
}
</code></pre>
<p>感谢 Mateusz Burzyński 的 <a href="https://github.com/microsoft/TypeScript/pull/53681">PR</a>。</p>
<h2 id="利用-symbolhasinstance-来细化-instanceof"><a class="header" href="#利用-symbolhasinstance-来细化-instanceof">利用 <code>Symbol.hasInstance</code> 来细化 <code>instanceof</code></a></h2>
<p>JavaScript 的一个稍微晦涩的特性是可以覆盖 <code>instanceof</code> 运算符的行为。
为此，<code>instanceof</code> 运算符右侧的值需要具有一个名为 <code>Symbol.hasInstance</code> 的特定方法。</p>
<pre><code class="language-ts">class Weirdo {
  static [Symbol.hasInstance](testedValue) {
    // wait, what?
    return testedValue === undefined;
  }
}

// false
console.log(new Thing() instanceof Weirdo);

// true
console.log(undefined instanceof Weirdo);
</code></pre>
<p>为了更好地支持 <code>instanceof</code> 的行为，TypeScript 现在会检查是否存在 <code>[Symbol.hasInstance]</code> 方法且被定义为类型判定函数。
如果有的话，<code>instanceof</code> 运算符左侧的值会按照类型判定进行细化。</p>
<pre><code class="language-ts">interface PointLike {
  x: number;
  y: number;
}

class Point implements PointLike {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }

  distanceFromOrigin() {
    return Math.sqrt(this.x ** 2 + this.y ** 2);
  }

  static [Symbol.hasInstance](val: unknown): val is PointLike {
    return (
      !!val &amp;&amp;
      typeof val === 'object' &amp;&amp;
      'x' in val &amp;&amp;
      'y' in val &amp;&amp;
      typeof val.x === 'number' &amp;&amp;
      typeof val.y === 'number'
    );
  }
}

function f(value: unknown) {
  if (value instanceof Point) {
    // Can access both of these - correct!
    value.x;
    value.y;

    // Can't access this - we have a 'PointLike',
    // but we don't *actually* have a 'Point'.
    value.distanceFromOrigin();
  }
}
</code></pre>
<p>能够看到例子中，<code>Point</code> 定义了自己的 <code>[Symbol.hasInstance]</code> 方法。
它实际上充当了对称为 <code>PointLike</code> 的单独类型的自定义类型保护。
在函数 <code>f</code> 中，我们能够使用 <code>instanceof</code> 将 <code>value</code> 细化为 <code>PointLike</code>，但不能细化到 <code>Point</code>。
这意味着我们可以访问属性 <code>x</code> 和 <code>y</code>，但无法访问 <code>distanceFromOrigin</code> 方法。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/55052">PR</a>。</p>
<h2 id="在实例字段上检查-super-属性访问"><a class="header" href="#在实例字段上检查-super-属性访问">在实例字段上检查 <code>super</code> 属性访问</a></h2>
<p>在 JavaScript 中，能够使用 <code>super</code> 关键字来访问基类中的声明。</p>
<pre><code class="language-ts">class Base {
  someMethod() {
    console.log('Base method called!');
  }
}

class Derived extends Base {
  someMethod() {
    console.log('Derived method called!');
    super.someMethod();
  }
}

new Derived().someMethod();
// Prints:
//   Derived method called!
//   Base method called!
</code></pre>
<p>这与 <code>this.someMethod()</code> 是不同的，因为它可能调用的是重写的方法。
这是一个微妙的区别，而且通常情况下，如果一个声明从未被覆盖，这两者可以互换，使得区别更加微妙。</p>
<pre><code class="language-ts">class Base {
  someMethod() {
    console.log('someMethod called!');
  }
}

class Derived extends Base {
  someOtherMethod() {
    // These act identically.
    this.someMethod();
    super.someMethod();
  }
}

new Derived().someOtherMethod();
// Prints:
//   someMethod called!
//   someMethod called!
</code></pre>
<p>将它们互换使用的问题在于，<code>super</code> 关键字仅适用于在原型上声明的成员，而不适用于实例属性。
这意味着，如果您编写了 <code>super.someMethod()</code>，但 <code>someMethod</code> 被定义为一个字段，那么您将会得到一个运行时错误！</p>
<pre><code class="language-ts">class Base {
  someMethod = () =&gt; {
    console.log('someMethod called!');
  };
}

class Derived extends Base {
  someOtherMethod() {
    super.someMethod();
  }
}

new Derived().someOtherMethod();
//
// Doesn't work because 'super.someMethod' is 'undefined'.
</code></pre>
<p>TypeScript 5.3 现在更仔细地检查 <code>super</code> 属性访问/方法调用，以确定它们是否对应于类字段。
如果是这样，我们现在将会得到一个类型检查错误。</p>
<p><a href="https://github.com/microsoft/TypeScript/pull/54056">这个检查</a>是由 Jack Works 开发！</p>
<h2 id="可以交互的类型内嵌提示"><a class="header" href="#可以交互的类型内嵌提示">可以交互的类型内嵌提示</a></h2>
<p>TypeScript 的内嵌提示支持跳转到类型定义！
这便利在代码间跳转变得简单。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/55141">PR</a>。</p>
<h2 id="设置偏好-type-自动导入"><a class="header" href="#设置偏好-type-自动导入">设置偏好 <code>type</code> 自动导入</a></h2>
<p>之前，当 TypeScript 为类型自动生成导入语句时，它会根据配置添加 <code>type</code> 修饰符。
例如，当为 <code>Person</code> 生成自动导入语句时：</p>
<pre><code class="language-ts">export let p: Person;
</code></pre>
<p>TypeScript 通常会这样生成 <code>Person</code> 导入：</p>
<pre><code class="language-ts">import { Person } from './types';

export let p: Person;
</code></pre>
<p>如果设置了 <code>verbatimModuleSyntax</code>，它会添加 <code>type</code> 修饰符：</p>
<pre><code class="language-ts">import { type Person } from './types';

export let p: Person;
</code></pre>
<p>然而，也许你的编辑器不支持这些选项；或者你偏好显式地使用 <code>type</code> 导入。</p>
<p><a href="https://github.com/microsoft/TypeScript/pull/56090">最近的一项改动</a>，TypeScript 把它变成了针对编辑器的配置项。
在 Visual Studio Code 中，你可以在 "TypeScript › Preferences: Prefer Type Only Auto Imports" 启用该功能，或者在 JSON 配置文件中的 <code>typescript.preferences.preferTypeOnlyAutoImports</code> 设置。</p>
<h2 id="优化略过-jsdoc-解析"><a class="header" href="#优化略过-jsdoc-解析">优化：略过 JSDoc 解析</a></h2>
<p>当通过 <code>tsc</code> 运行 TypeScript 时，编译器现在将避免解析 JSDoc。
这不仅减少了解析时间，还减少了存储注释以及垃圾回收所花费的内存使用量。
总体而言，您应该会看到编译速度稍微更快，并在 <code>--watch</code> 模式下获得更快的反馈。</p>
<p><a href="https://github.com/microsoft/TypeScript/pull/52921">具体改动在这</a>。</p>
<p>由于并非每个使用 TypeScript 的工具都需要存储 JSDoc（例如 typescript-eslint 和 Prettier），因此这种解析策略已作为 API 的一部分公开。
这使得这些工具能够获得与 TypeScript 编译器相同的内存和速度改进。
注释解析策略的新选项在 <code>JSDocParsingMode</code> 中进行了描述。
关于此拉取请求的更多信息，请参阅<a href="https://github.com/microsoft/TypeScript/pull/55739">PR</a>。</p>
<h2 id="通过比较非规范化的交叉类型进行优化"><a class="header" href="#通过比较非规范化的交叉类型进行优化">通过比较非规范化的交叉类型进行优化</a></h2>
<p>在 TypeScript 中，联合类型和交叉类型始终遵循特定的形式，其中交叉类型不能包含联合类型。
这意味着当我们在一个联合类型上创建一个交叉类型，例如 <code>A &amp; (B | C)</code>，该交叉类型将被规范化为 <code>(A &amp; B) | (A &amp; C)</code>。
然而，在某些情况下，类型系统会保留原始形式以供显示目的使用。</p>
<p>事实证明，原始形式可以用于一些巧妙的快速路径类型比较。</p>
<p>例如，假设我们有 <code>SomeType &amp; (Type1 | Type2 | ... | Type99999NINE)</code>，我们想要确定它是否可以赋值给 <code>SomeType</code>。
回想一下，我们实际上没有一个交叉类型作为源类型，而是一个联合类型，看起来像是 <code>(SomeType &amp; Type1) | (SomeType &amp; Type2) | ... | (SomeType &amp; Type99999NINE)</code>。
当检查一个联合类型是否可以赋值给目标类型时，我们必须检查联合类型的每个成员是否可以赋值给目标类型，这可能非常慢。</p>
<p>在 TypeScript 5.3 中，我们查看了我们能够隐藏的原始交叉类型形式。
当我们比较这些类型时，我们会快速检查目标类型是否存在于源交叉类型的任何组成部分中。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/55851">PR</a>。</p>
<h2 id="合并-tsserverlibraryjs-和-typescriptjs"><a class="header" href="#合并-tsserverlibraryjs-和-typescriptjs">合并 <code>tsserverlibrary.js</code> 和 <code>typescript.js</code></a></h2>
<p>TypeScript 本身包含两个库文件：<code>tsserverlibrary.js</code> 和 <code>typescript.js</code>。
在 <code>tsserverlibrary.js</code> 中有一些仅在其中可用的 API（如 <code>ProjectService API</code>），对某些导入者可能很有用。
尽管如此，这两个是不同的捆绑包，有很多重叠的部分，在包中重复了一些代码。
更重要的是，由于自动导入或肌肉记忆的原因，要始终一致地使用其中一个可能是具有挑战性的。
意外加载两个模块太容易了，而且代码可能在 API 的不同实例上无法正常工作。
即使它可以工作，加载第二个捆绑包会增加资源使用量。</p>
<p>基于此，我们决定合并这两个文件。
<code>typescript.js</code> 现在包含了以前在 <code>tsserverlibrary.js</code> 中的内容，而 <code>tsserverlibrary.js</code> 现在只是重新导出 <code>typescript.js</code>。
在这个合并前后，我们看到了以下包大小的减小：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Before</th><th>After</th><th>Diff</th><th>Diff (percent)</th></tr></thead><tbody>
<tr><td>Packed</td><td>6.90 MiB</td><td>5.48 MiB</td><td>-1.42 MiB</td><td>-20.61%</td></tr>
<tr><td>Unpacked</td><td>38.74 MiB</td><td>30.41 MiB</td><td>-8.33 MiB</td><td>-21.50%</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th></th><th>Before</th><th>After</th><th>Diff</th><th>Diff (percent)</th></tr></thead><tbody>
<tr><td>lib/tsserverlibrary.d.ts</td><td>570.95 KiB</td><td>865.00 B</td><td>-570.10 KiB</td><td>-99.85%</td></tr>
<tr><td>lib/tsserverlibrary.js</td><td>8.57 MiB</td><td>1012.00 B</td><td>-8.57 MiB</td><td>-99.99%</td></tr>
<tr><td>lib/typescript.d.ts</td><td>396.27 KiB</td><td>570.95 KiB</td><td>+174.68 KiB</td><td>+44.08%</td></tr>
<tr><td>lib/typescript.js</td><td>7.95 MiB</td><td>8.57 MiB</td><td>+637.53 KiB</td><td>+7.84%</td></tr>
</tbody></table>
</div>
<p>换句话说，这意味着包大小减小了超过 20.5%。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/55273">PR</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-52"><a class="header" href="#typescript-52">TypeScript 5.2</a></h1>
<h2 id="using-声明与显式资源管理"><a class="header" href="#using-声明与显式资源管理"><code>using</code> 声明与显式资源管理</a></h2>
<p>TypeScript 5.2 支持了 ECMAScript 即将引入的新功能 <a href="https://github.com/tc39/proposal-explicit-resource-management">显式资源管理</a>。
让我们探索一下引入该功能的一些动机，并理解这个功能给我们带来了什么。</p>
<p>在创建对象之后需要进行某种形式的“清理”是很常见的。例如，您可能需要关闭网络连接，删除临时文件，或者只是释放一些内存。
让我们来想象一个函数，它创建一个临时文件，对它进行多种操作的读写，然后关闭并删除它。</p>
<pre><code class="language-ts">import * as fs from 'fs';

export function doSomeWork() {
  const path = '.some_temp_file';
  const file = fs.openSync(path, 'w+');

  // use file...

  // Close the file and delete it.
  fs.closeSync(file);
  fs.unlinkSync(path);
}
</code></pre>
<p>这看起来不错，但如果需要提前退出会发生什么？</p>
<pre><code class="language-ts">export function doSomeWork() {
  const path = '.some_temp_file';
  const file = fs.openSync(path, 'w+');

  // use file...
  if (someCondition()) {
    // do some more work...

    // Close the file and delete it.
    fs.closeSync(file);
    fs.unlinkSync(path);
    return;
  }

  // Close the file and delete it.
  fs.closeSync(file);
  fs.unlinkSync(path);
}
</code></pre>
<p>我们可以看到存在重复的容易忘记的清理代码。
同时无法保证在代码抛出异常时，关闭和删除文件会被执行。
解决办法是用 <code>try</code>/<code>finally</code> 语句包裹整段代码。</p>
<pre><code class="language-ts">export function doSomeWork() {
  const path = '.some_temp_file';
  const file = fs.openSync(path, 'w+');

  try {
    // use file...

    if (someCondition()) {
      // do some more work...
      return;
    }
  } finally {
    // Close the file and delete it.
    fs.closeSync(file);
    fs.unlinkSync(path);
  }
}
</code></pre>
<p>虽说这样写更加健壮，但是也为我们的代码增加了一些“噪音”。
如果我们在 <code>finally</code> 块中开始添加更多的清理逻辑，还可能遇到其他的自食其果的问题。
例如，异常可能会阻止其他资源的释放。
这些就是<a href="https://github.com/tc39/proposal-explicit-resource-management">显式资源管理</a>想要解决的问题。
该提案的关键思想是将资源释放（我们试图处理的清理工作）作为 JavaScript 中的一等概念来支持。</p>
<p>首先，增加了一个新的 <code>symbol</code> 名字为 <code>Symbol.dispose</code>，然后可以定义包含 <code>Symbol.dispose</code> 方法的对象。
为了方便，TypeScript 为此定义了一个新的全局类型 <code>Disposable</code>。</p>
<pre><code class="language-ts">class TempFile implements Disposable {
  #path: string;
  #handle: number;

  constructor(path: string) {
    this.#path = path;
    this.#handle = fs.openSync(path, 'w+');
  }

  // other methods

  [Symbol.dispose]() {
    // Close the file and delete it.
    fs.closeSync(this.#handle);
    fs.unlinkSync(this.#path);
  }
}
</code></pre>
<p>之后可以调用这些方法</p>
<pre><code class="language-ts">export function doSomeWork() {
  const file = new TempFile('.some_temp_file');

  try {
    // ...
  } finally {
    file[Symbol.dispose]();
  }
}
</code></pre>
<p>将清理逻辑移动到 <code>TempFile</code> 本身没有带来多大的价值；仅仅是将清理的代码从 <code>finally</code> 提取到方法而已，你总是可以这样做。
但如果该方法有一个众所周知的名字那么 JavaScript 就可以基于此构造其它功能。</p>
<p>这将引出该功能的第一个亮点：<code>using</code> 声明！
<code>using</code> 是一个新的关键字，支持声明新的不可变绑定，像 <code>const</code> 一样。
不同点是 <code>using</code> 声明的变量在即将离开其作用域时，它的 <code>Symbol.dispose</code> 方法会被调用！</p>
<p>因此，我们可以这样编写代码：</p>
<pre><code class="language-ts">export function doSomeWork() {
    using file = new TempFile(".some_temp_file");

    // use file...

    if (someCondition()) {
        // do some more work...
        return;
    }
}
</code></pre>
<p>看一下 - 没有 <code>try</code> / <code>finally</code> 代码块！至少，我们没有见到。
从功能上讲，这些正是 <code>using</code> 声明要帮我们做的事，但我们不必自己处理它。</p>
<p>你可能熟悉 C# 中的 <code>using</code>， Python 中的 <code>with</code>，Java 中的 <code>try-with-resource</code> 声明。
这些与 JavaScript 中的 <code>using</code> 关键字是相似的，都提供了一种明确的方式来“清理”对象，在它们即将离开作用域时。</p>
<p><code>using</code> 声明在其所在的作用域的最后才执行清理工作，或在“提前返回”（如 <code>return</code> 语句或 <code>throw</code> 错误）之前执行清理工作。
释放的顺序是先入后出，像栈一样。</p>
<pre><code class="language-ts">function loggy(id: string): Disposable {
    console.log(`Creating ${id}`);

    return {
        [Symbol.dispose]() {
            console.log(`Disposing ${id}`);
        }
    }
}

function func() {
    using a = loggy("a");
    using b = loggy("b");
    {
        using c = loggy("c");
        using d = loggy("d");
    }
    using e = loggy("e");
    return;

    // Unreachable.
    // Never created, never disposed.
    using f = loggy("f");
}

func();
// Creating a
// Creating b
// Creating c
// Creating d
// Disposing d
// Disposing c
// Creating e
// Disposing e
// Disposing b
// Disposing a
</code></pre>
<p><code>using</code> 声明对异常具有适应性；如果抛出了一个错误，那么在资源释放后会重新抛出错误。
另一方面，一个函数体可能正常执行，但是 <code>Symbol.dispose</code> 可能抛出异常。
这种情况下，异常会被重新抛出。</p>
<p>但如果释放之前的逻辑以及释放时的逻辑都抛出了异常会发生什么？
为处理这类情况引入了一个新的类型 <code>SuppressedError</code>，它是 <code>Error</code> 类型的子类型。
<code>SuppressedError</code> 类型的 <code>suppressed</code> 属性保存了上一个错误，同时 <code>error</code> 属性保存了最后抛出的错误。</p>
<pre><code class="language-ts">class ErrorA extends Error {
    name = "ErrorA";
}
class ErrorB extends Error {
    name = "ErrorB";
}

function throwy(id: string) {
    return {
        [Symbol.dispose]() {
            throw new ErrorA(`Error from ${id}`);
        }
    };
}

function func() {
    using a = throwy("a");
    throw new ErrorB("oops!")
}

try {
    func();
}
catch (e: any) {
    console.log(e.name); // SuppressedError
    console.log(e.message); // An error was suppressed during disposal.

    console.log(e.error.name); // ErrorA
    console.log(e.error.message); // Error from a

    console.log(e.suppressed.name); // ErrorB
    console.log(e.suppressed.message); // oops!
}
</code></pre>
<p>你可能已经注意到了，在这些例子中使用的都是同步方法。
然而，很多资源释放的场景涉及到<em>异步</em>操作，我们需要等待它们完成才能进行后续的操作。</p>
<p>这就是为什么现在还有一个新的 <code>Symbol.asyncDispose</code>，它带来了另一个亮点 -
<code>await using</code> 声明。
它与 <code>using</code> 声明相似，但关键是它查找需要 <code>await</code> 的资源。
它使用名为 <code>Symbol.asyncDispose</code> 的方法，尽管它们也可以操作在任何具有 <code>Symbol.dispose</code> 的对象上操作。
为了方便，TypeScript 引入了全局类型 <code>AsyncDisposable</code> 用来表示拥有异步 <code>dispose</code> 方法的对象。</p>
<pre><code class="language-ts">async function doWork() {
    // Do fake work for half a second.
    await new Promise(resolve =&gt; setTimeout(resolve, 500));
}

function loggy(id: string): AsyncDisposable {
    console.log(`Constructing ${id}`);
    return {
        async [Symbol.asyncDispose]() {
            console.log(`Disposing (async) ${id}`);
            await doWork();
        },
    }
}

async function func() {
    await using a = loggy("a");
    await using b = loggy("b");
    {
        await using c = loggy("c");
        await using d = loggy("d");
    }
    await using e = loggy("e");
    return;

    // Unreachable.
    // Never created, never disposed.
    await using f = loggy("f");
}

func();
// Constructing a
// Constructing b
// Constructing c
// Constructing d
// Disposing (async) d
// Disposing (async) c
// Constructing e
// Disposing (async) e
// Disposing (async) b
// Disposing (async) a
</code></pre>
<p>如果你期望其他人能够一致地执行清理逻辑，通过使用 <code>Disposable</code> 和 <code>AsyncDisposable</code> 来定义类型可以使你的代码更易于使用。
实际上，存在许多现有的类型，它们拥有 <code>dispose()</code> 或 <code>close()</code> 方法。
例如，Visual Studio Code APIs 定义了 <a href="https://code.visualstudio.com/api/references/vscode-api#Disposable">自己的 <code>Disposable</code> 接口</a>。
在浏览器和诸如 Node.js、Deno 和 Bun 等运行时中，API 也可以选择对已经具有清理方法（如文件句柄、连接等）的对象使用 <code>Symbol.dispose</code> 和 <code>Symbol.asyncDispose</code>。</p>
<p>现在也许对于库来说这听起来很不错，但对于你的场景来说可能有些过于复杂。如果你需要进行大量的临时清理，创建一个新类型可能会引入过度抽象和关于最佳实践的问题。
例如，再次以我们的 <code>TempFile</code> 示例为例。</p>
<pre><code class="language-ts">class TempFile implements Disposable {
    #path: string;
    #handle: number;

    constructor(path: string) {
        this.#path = path;
        this.#handle = fs.openSync(path, "w+");
    }

    // other methods

    [Symbol.dispose]() {
        // Close the file and delete it.
        fs.closeSync(this.#handle);
        fs.unlinkSync(this.#path);
    }
}

export function doSomeWork() {
    using file = new TempFile(".some_temp_file");

    // use file...

    if (someCondition()) {
        // do some more work...
        return;
    }
}
</code></pre>
<p>我们只是想记住调用两个函数，但这是最好的写法吗？
我们应该在构造函数中调用 <code>openSync</code>，创建一个 <code>open()</code> 方法，还是自己传递句柄？
我们是否应该为每个需要执行的操作公开一个方法，还是只将属性公开？</p>
<p>这就引出了这个特性的最后亮点：<code>DisposableStack</code> 和 <code>AsyncDisposableStack</code>。
这些对象非常适用于一次性的清理工作，以及任意数量的清理工作。
<code>DisposableStack</code> 是一个对象，它具有多个方法用于跟踪 <code>Disposable</code> 对象，并且可以接受函数来执行任意的清理工作。
我们还可以将它们分配给 <code>using</code> 变量，因为它们也是 <code>Disposable</code>！所以下面是我们可以编写原始示例的方式。</p>
<pre><code class="language-ts">function doSomeWork() {
    const path = ".some_temp_file";
    const file = fs.openSync(path, "w+");

    using cleanup = new DisposableStack();
    cleanup.defer(() =&gt; {
        fs.closeSync(file);
        fs.unlinkSync(path);
    });

    // use file...

    if (someCondition()) {
        // do some more work...
        return;
    }

    // ...
}
</code></pre>
<p>在这里，<code>defer()</code> 方法只需要一个回调函数，该回调函数将在 <code>cleanup</code> 释放后运行。
通常，在创建资源后应立即调用 <code>defer</code>（以及其他 <code>DisposableStack</code> 方法，如 <code>use</code> 和 <code>adopt</code>）。
顾名思义，<code>DisposableStack</code> 以类似堆栈的方式处理它所跟踪的所有内容，按照先进后出的顺序进行处理，因此在创建值后立即进行 <code>defer</code> 处理有助于避免奇怪的依赖问题。
<code>AsyncDisposableStack</code> 的工作原理类似，但可以跟踪异步函数和 <code>AsyncDisposable</code>，并且本身也是 <code>AsyncDisposable</code>。</p>
<p>在许多方面，<code>defer</code> 方法与 Go、Swift、Zig、Odin 等语言中的 <code>defer</code> 关键字类似，因此其使用约定应该相似。</p>
<p>由于这个特性非常新，大多数运行时环境不会原生支持它。要使用它，您需要为以下内容提供运行时的 polyfills：</p>
<ul>
<li>Symbol.dispose</li>
<li>Symbol.asyncDispose</li>
<li>DisposableStack</li>
<li>AsyncDisposableStack</li>
<li>SuppressedError</li>
</ul>
<p>然而，如果您只对使用 <code>using</code> 和 <code>await using</code> 感兴趣，您只需要为内置的 <code>symbol</code> 提供 polyfill，通常以下简单的方法可适用于大多数情况：</p>
<pre><code class="language-ts">Symbol.dispose ??= Symbol('Symbol.dispose');
Symbol.asyncDispose ??= Symbol('Symbol.asyncDispose');
</code></pre>
<p>你还需要将编译 <code>target</code> 设置为 <code>es2022</code> 或以下，配置 <code>lib</code> 为 <code>"esnext"</code> 或 <code>"esnext.disposable"</code>。</p>
<pre><code class="language-ts">{
    "compilerOptions": {
        "target": "es2022",
        "lib": ["es2022", "esnext.disposable", "dom"]
    }
}
</code></pre>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/54505">PR</a>。</p>
<h2 id="decorator-metadata"><a class="header" href="#decorator-metadata">Decorator Metadata</a></h2>
<p>TypeScript 5.2 实现了 ECMAScript 即将引入的新功能 <a href="https://github.com/tc39/proposal-decorator-metadata">Decorator Metadata</a>。</p>
<p>这个功能的关键思想是使装饰器能够轻松地在它们所使用或嵌套的任何类上创建和使用元数据。</p>
<p>在任意的装饰器函数上，现在可以访问上下文对象的 <code>metadata</code> 属性。
<code>metadata</code> 属性是一个普通的对象。
由于 JavaScript 允许我们对其任意添加属性，它可以被用作可由每个装饰器更新的字典。
或者，由于每个 <code>metadata</code> 对象对于每个被装饰的部分来讲是等同的，它可以被用作 <code>Map</code> 的键。
当类的装饰器运行时，这个对象可以通过 <code>Symbol.metadata</code> 访问。</p>
<pre><code class="language-ts">interface Context {
  name: string;
  metadata: Record;
}

function setMetadata(_target: any, context: Context) {
  context.metadata[context.name] = true;
}

class SomeClass {
  @setMetadata
  foo = 123;

  @setMetadata
  accessor bar = 'hello!';

  @setMetadata
  baz() {}
}

const ourMetadata = SomeClass[Symbol.metadata];

console.log(JSON.stringify(ourMetadata));
// { "bar": true, "baz": true, "foo": true }
</code></pre>
<p>它可以被应用在不同的场景中。
<code>Metadata</code> 信息可以附加在调试、序列化或者依赖注入的场景中。
由于每个被装饰的类都会生成 <code>metadata</code> 对象，框架可以选择用它们做为 <code>key</code> 来访问 <code>Map</code> 或 <code>WeakMap</code>，或者跟踪它的属性。</p>
<p>例如，我们想通过装饰器来跟踪哪些属性和存取器是可以通过 <code>Json.stringify</code> 序列化的：</p>
<pre><code class="language-ts">import { serialize, jsonify } from './serializer';

class Person {
  firstName: string;
  lastName: string;

  @serialize
  age: number;

  @serialize
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  toJSON() {
    return jsonify(this);
  }

  constructor(firstName: string, lastName: string, age: number) {
    // ...
  }
}
</code></pre>
<p>此处的意图是，只有 <code>age</code> 和 <code>fullName</code> 可以被序列化，因为它们应用了 <code>@serialize</code> 装饰器。
我们定义了 <code>toJSON</code> 方法来做这件事，但它只是调用了 <code>jsonfy</code>，它会使用 <code>@serialize</code> 创建的 <code>metadata</code>。</p>
<p>下面是 <code>./serialize.ts</code> 可能的定义：</p>
<pre><code class="language-ts">const serializables = Symbol();

type Context =
  | ClassAccessorDecoratorContext
  | ClassGetterDecoratorContext
  | ClassFieldDecoratorContext;

export function serialize(_target: any, context: Context): void {
  if (context.static || context.private) {
    throw new Error('Can only serialize public instance members.');
  }
  if (typeof context.name === 'symbol') {
    throw new Error('Cannot serialize symbol-named properties.');
  }

  const propNames = ((context.metadata[serializables] as
    | string[]
    | undefined) ??= []);
  propNames.push(context.name);
}

export function jsonify(instance: object): string {
  const metadata = instance.constructor[Symbol.metadata];
  const propNames = metadata?.[serializables] as string[] | undefined;
  if (!propNames) {
    throw new Error('No members marked with @serialize.');
  }

  const pairStrings = propNames.map(key =&gt; {
    const strKey = JSON.stringify(key);
    const strValue = JSON.stringify((instance as any)[key]);
    return `${strKey}: ${strValue}`;
  });

  return `{ ${pairStrings.join(', ')} }`;
}
</code></pre>
<p>该方法有一个局部 <code>symbol</code> 名字为 <code>serializables</code> 用于保存和获取使用 <code>@serializable</code> 标记的属性。
当每次调用 <code>@serializable</code> 时，它都会在 <code>metadata</code> 上保存这些属性名。
当 <code>jsonfy</code> 被调用时，从 <code>metadata</code> 上获取属性列表，之后从实例上获取实际值，最后序列化名和值。</p>
<p>使用 <code>symbol</code> 意味着该数据可以被他人访问。
另一选择是使用 <code>WeakMap</code> 并用该 <code>metadata</code> 对象做为键。
这样可以保持数据的私密性，并且在这种情况下使用更少的类型断言，但其他方面类似。</p>
<pre><code class="language-ts">const serializables = new WeakMap();

type Context =
  | ClassAccessorDecoratorContext
  | ClassGetterDecoratorContext
  | ClassFieldDecoratorContext;

export function serialize(_target: any, context: Context): void {
  if (context.static || context.private) {
    throw new Error('Can only serialize public instance members.');
  }
  if (typeof context.name !== 'string') {
    throw new Error('Can only serialize string properties.');
  }

  let propNames = serializables.get(context.metadata);
  if (propNames === undefined) {
    serializables.set(context.metadata, (propNames = []));
  }
  propNames.push(context.name);
}

export function jsonify(instance: object): string {
  const metadata = instance.constructor[Symbol.metadata];
  const propNames = metadata &amp;&amp; serializables.get(metadata);
  if (!propNames) {
    throw new Error('No members marked with @serialize.');
  }
  const pairStrings = propNames.map(key =&gt; {
    const strKey = JSON.stringify(key);
    const strValue = JSON.stringify((instance as any)[key]);
    return `${strKey}: ${strValue}`;
  });

  return `{ ${pairStrings.join(', ')} }`;
}
</code></pre>
<p>注意，这里的实现没有考虑子类和继承。
留给读者作为练习。</p>
<p>由于该功能比较新，大多数运行时都没实现它。
如果想要使用，则需要使用 <code>Symbol.metadata</code> 的 <code>polyfill</code>。
例如像下面这样就可以适用大部分场景：</p>
<pre><code class="language-ts">Symbol.metadata ??= Symbol('Symbol.metadata');
</code></pre>
<p>你还需要将编译 <code>target</code> 设为 <code>es2022</code> 或以下，配置 <code>lib</code> 为 <code>"esnext"</code> 或者 <code>"esnext.decorators"</code>。</p>
<pre><code>{
    "compilerOptions": {
        "target": "es2022",
        "lib": ["es2022", "esnext.decorators", "dom"]
    }
}
</code></pre>
<p>感谢 <a href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a>的<a href="https://github.com/microsoft/TypeScript/pull/54657">贡献</a>。</p>
<h2 id="命名的和匿名的元组元素"><a class="header" href="#命名的和匿名的元组元素">命名的和匿名的元组元素</a></h2>
<p>元组类型已经支持了为每个元素定义可选的标签和命名。</p>
<pre><code class="language-ts">type Pair = [first: T, second: T];
</code></pre>
<p>这些标签不改变功能 - 它们只是用于增强可读性和工具支持。</p>
<p>然而，TypeScript 之前有个限制是不允许混用有标签和无标签的元素。
换句话说，要么所有元素都没有标签，要么所有元素都有标签。</p>
<pre><code class="language-ts">// ✅ fine - no labels
type Pair1 = [T, T];

// ✅ fine - all fully labeled
type Pair2 = [first: T, second: T];

// ❌ previously an error
type Pair3 = [first: T, T];
//                         ~
// Tuple members must all have names
// or all not have names.
</code></pre>
<p>如果是剩余元素就比较烦人了，我们必须要添加标签 <code>rest</code> 或者 <code>tail</code>。</p>
<pre><code class="language-ts">// ❌ previously an error
type TwoOrMore_A = [first: T, second: T, ...T[]];
//                                          ~~~~~~
// Tuple members must all have names
// or all not have names.

// ✅
type TwoOrMore_B = [first: T, second: T, rest: ...T[]];
</code></pre>
<p>这也意味着这个限制必须在类型系统内部进行强制执行，这意味着 TypeScript 将失去标签。</p>
<pre><code class="language-ts">type HasLabels = [a: string, b: string];
type HasNoLabels = [number, number];
type Merged = [...HasNoLabels, ...HasLabels];
//   ^ [number, number, string, string]
//
//     'a' and 'b' were lost in 'Merged'
</code></pre>
<p>在 TypeScript 5.2 中，对元组标签的全有或全无限制已经被取消。
而且现在可以在展开的元组中保留标签。</p>
<p>感谢 <a href="https://github.com/JoshuaKGoldberg">Josh Goldberg</a> 和 <a href="https://github.com/Andarist">Mateusz Burzyński</a> 的贡献。</p>
<h2 id="更容易地使用联合数组上的方法"><a class="header" href="#更容易地使用联合数组上的方法">更容易地使用联合数组上的方法</a></h2>
<p>在之前版本的 TypeScript 中，在联合数组上调用方法可能很痛苦。</p>
<pre><code class="language-ts">declare let array: string[] | number[];

array.filter(x =&gt; !!x);
//    ~~~~~~ error!
// This expression is not callable.
//   Each member of the union type '...' has signatures,
//   but none of those signatures are compatible
//   with each other.
</code></pre>
<p>此例中，TypeScript 会检查是否每个版本的 <code>filter</code> 都与 <code>string[]</code> 和 <code>number[]</code> 兼容。
在没有一个连贯的策略的情况下，TypeScript 会束手无策地说：“我无法使其工作”。</p>
<p>在 TypeScript 5.2 里，在放弃之前，联合数组会被特殊对待。
使用每个元素类型构造一个新数组，然后在其上调用方法。</p>
<p>对于上例来说，<code>string[] | number[]</code> 被转换为 <code>(string | number)[]</code>（或者是 <code>Array&lt;string | number&gt;</code>），然后在该类型上调用 <code>filter</code>。
有一个注意事项，<code>filter</code> 会产生 <code>Array&lt;string | number&gt;</code> 而不是 <code>string[] | number[]</code>；
但对于新产生的值，出现“出错”的风险较小。</p>
<p>这意味着在以前不能使用的情况下，许多方法如 <code>filter</code>、<code>find</code>、<code>some</code>、<code>every</code> 和 <code>reduce</code> 都可以在数组的联合类型上调用。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/53489">PR</a>。</p>
<h2 id="拷贝的数组方法"><a class="header" href="#拷贝的数组方法">拷贝的数组方法</a></h2>
<p>TypeScript 5.2 支持了 ECMAScript 提案 <a href="https://github.com/tc39/proposal-change-array-by-copy">Change Array by Copy</a>。</p>
<p>JavaScript 中的数组有很多有用的方法如 <code>sort()</code>，<code>splice()</code>，以及 <code>reverse()</code>，这些方法在数组中原地修改元素。
通常，我们想创建一个新数组，还想影响原来的数组。
为达到此目的，你可以使用 <code>slice()</code> 或者展开数组（例如 <code>[...myArray]</code>）获取一份拷贝，然后再执行操作。
例如，你可以用 <code>myArray.slice().reverse()</code> 来获取反转的数组的拷贝。</p>
<p>还有一个典型的例子 - 创建一份拷贝，但是修改其中的一个元素。
有许多方法可以实现这一点，但最明显的方法要么是由多个语句组成的...</p>
<pre><code class="language-ts">const copy = myArray.slice();
copy[someIndex] = updatedValue;
doSomething(copy);
</code></pre>
<p>要么意图不明显...</p>
<pre><code class="language-ts">doSomething(
  myArray.map((value, index) =&gt; (index === someIndex ? updatedValue : value))
);
</code></pre>
<p>所有这些对于如此常见的操作来说都很繁琐。
这就是为什么 JavaScript 现在有了 4 个新的方法，执行相同的操作，但不影响原始数据：<code>toSorted</code>、<code>toSpliced</code>、<code>toReversed</code> 和 <code>with</code>。
前三个方法执行与它们的变异版本相同的操作，但返回一个新的数组。
<code>with</code> 也返回一个新的数组，但其中一个元素被更新（如上所述）。</p>
<div class="table-wrapper"><table><thead><tr><th>修改</th><th>拷贝</th></tr></thead><tbody>
<tr><td>myArray.reverse()</td><td>myArray.toReversed()</td></tr>
<tr><td>myArray.sort((a, b) =&gt; ...)</td><td>myArray.toSorted((a, b) =&gt; ...)</td></tr>
<tr><td>myArray.splice(start, deleteCount, ...items)</td><td>myArray.toSpliced(start, deleteCount, ...items)</td></tr>
<tr><td>myArray[index] = updatedValue</td><td>myArray.with(index, updatedValue)</td></tr>
</tbody></table>
</div>
<p>请注意，复制方法始终创建一个新的数组，而修改操作则不一致。</p>
<p>这些方法不仅存在于普通数组上 - 它们还存在于 <code>TypedArray</code> 上，例如 <code>Int32Array</code>，<code>Uint8Array</code>，等。</p>
<p>感谢 <a href="https://github.com/sno2">Carter Snook</a> 的 <a href="https://github.com/microsoft/TypeScript/pull/51367">PR</a>。</p>
<h2 id="将-symbol-用于-weakmap-和-weakset-的键"><a class="header" href="#将-symbol-用于-weakmap-和-weakset-的键">将 <code>symbol</code> 用于 <code>WeakMap</code> 和 <code>WeakSet</code> 的键</a></h2>
<p>现在可以将 <code>symbol</code> 用于 <code>WeakMap</code> 和 <code>WeakSet</code> 的键，它也是 ECMAScript 的<a href="https://github.com/tc39/proposal-symbols-as-weakmap-keys">新功能</a>。</p>
<pre><code class="language-ts">const myWeakMap = new WeakMap();

const key = Symbol();
const someObject = { /*...*/ };

// Works! ✅
myWeakMap.set(key, someObject);
myWeakMap.has(key);
</code></pre>
<p><a href="https://github.com/microsoft/TypeScript/pull/54195">这个更新</a>是由 <a href="https://github.com/leoelm">Leo Elmecker-Plakolm</a> 代表 Bloomberg 提供的。我们想向他们表示感谢！</p>
<h2 id="类型导入路径里使用-typescript-实现文件扩展名"><a class="header" href="#类型导入路径里使用-typescript-实现文件扩展名">类型导入路径里使用 TypeScript 实现文件扩展名</a></h2>
<p>TypeScript 支持在类型导入路径里使用声明文件扩展名和实现文件扩展名，不论是否启用了 <code>allowImportingTsExtensions</code>。</p>
<p>也意味着你现在可以编写 <code>import type</code> 语句并使用 <code>.ts</code>, <code>.mts</code>, <code>.cts</code> 以及 <code>.tsx</code> 文件扩展。</p>
<pre><code class="language-ts">import type { JustAType } from "./justTypes.ts";

export function f(param: JustAType) {
    // ...
}
</code></pre>
<p>这也意味着，<code>import()</code> 类型（用在 TypeScript 和 JavaScript 的 JSDoc 中） 也可以使用这些扩展名。</p>
<pre><code class="language-ts">/**
 * @param {import("./justTypes.ts").JustAType} param
 */
export function f(param) {
    // ...
}
</code></pre>
<p>更多详情请查看 <a href="https://github.com/microsoft/TypeScript/pull/54746">PR</a>。</p>
<h2 id="对象成员的逗号补全"><a class="header" href="#对象成员的逗号补全">对象成员的逗号补全</a></h2>
<p>在给对象添加新属性时很容易忘记添加逗号。
在之前，如果你忘了写逗号并且请求自动补全，TypeScript 会给出差的不相关的补全结果。</p>
<p>TypeScript 5.2 现在在您缺少逗号时会优雅地提供对象成员的自动补全。
但为了避免语法错误的出现，它还会自动插入缺失的逗号。</p>
<p>更多详情请查看 <a href="https://github.com/microsoft/TypeScript/pull/52899">PR</a>。</p>
<h2 id="内联变量重构"><a class="header" href="#内联变量重构">内联变量重构</a></h2>
<p>TypeScript 5.2 现在具有一种重构方法，可以将变量的内容内联到所有使用位置。</p>
<p>使用“内联变量”重构将消除变量并将所有变量的使用替换为其初始化值。
请注意，这可能会导致初始化程序的副作用在不同的时间运行，并且运行的次数与变量的使用次数相同。</p>
<p>更多详情请查看 <a href="https://github.com/microsoft/TypeScript/pull/54281">PR</a>。</p>
<h2 id="可点击的内嵌参数提示"><a class="header" href="#可点击的内嵌参数提示">可点击的内嵌参数提示</a></h2>
<p>内嵌提示可以让我们一目了然地获取信息，即使它在我们的代码中不存在 —— 比如参数名称、推断类型等等。
在 TypeScript 5.2 中，我们开始使得与内嵌提示进行交互成为可能。
例如，在 Visual Studio Code Insiders 中，您现在可以点击内联提示以跳转到参数的定义处。</p>
<p>更多详情请查看 <a href="https://github.com/microsoft/TypeScript/pull/54734">PR</a>。</p>
<h2 id="优化进行中的类型兼容性检查"><a class="header" href="#优化进行中的类型兼容性检查">优化进行中的类型兼容性检查</a></h2>
<p>由于 TypeScript 采用的是结构化的类型系统，通常需要比较类型成员；
然而，递归类型会造成一些问题。例如：</p>
<pre><code class="language-ts">interface A {
    value: A;
    other: string;
}

interface B {
    value: B;
    other: number;
}
</code></pre>
<p>在检查 <code>A</code> 是否与 <code>B</code> 类型兼容时，TypeScript 会检查 <code>A</code> 和 <code>B</code> 中 <code>value</code> 的类型是否兼容。
此时，类型系统需要停止进一步检查并继续检查其他成员。
为此，类型系统必须跟踪两个类型是否已经相关联。</p>
<p>此前，TypeScript 已经保存了配对类型的栈，并迭代检查类型是否已经关联。
当这个堆栈很浅时，这不是一个问题；但当堆栈不是很浅时，那就是个<a href="https://accidentallyquadratic.tumblr.com/">问题</a>了。</p>
<p>在 TypeScript 5.2 中，一个简单的 <code>Set</code> 就能跟踪这些信息。
在使用了 drizzle 库的测试报告中，这项改动减少了超过 33% 的时间花费！</p>
<pre><code>Benchmark 1: old
  Time (mean ± σ):      3.115 s ±  0.067 s    [User: 4.403 s, System: 0.124 s]
  Range (min … max):    3.018 s …  3.196 s    10 runs

Benchmark 2: new
  Time (mean ± σ):      2.072 s ±  0.050 s    [User: 3.355 s, System: 0.135 s]
  Range (min … max):    1.985 s …  2.150 s    10 runs

Summary
  'new' ran
    1.50 ± 0.05 times faster than 'old'
</code></pre>
<p>更多详情请查看 <a href="https://github.com/microsoft/TypeScript/pull/55224">PR</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-51"><a class="header" href="#typescript-51">TypeScript 5.1</a></h1>
<h2 id="更易用的隐式返回-undefined-的函数"><a class="header" href="#更易用的隐式返回-undefined-的函数">更易用的隐式返回 <code>undefined</code> 的函数</a></h2>
<p>在 <code>JavaScript</code> 中，如果一个函数运行结束时没有遇到 <code>return</code> 语句，它会返回 <code>undefined</code> 值。</p>
<pre><code class="language-js">function foo() {
  // no return
}

// x = undefined
let x = foo();
</code></pre>
<p>然而，在之前版本的 TypeScript 中，<em>只有</em>返回值类型为 <code>void</code> 和 <code>any</code> 的函数可以不带 <code>return</code> 语句。
这意味着，就算明知函数返回 <code>undefined</code>，你也必须包含 <code>return</code> 语句。</p>
<pre><code class="language-ts">//  fine - we inferred that 'f1' returns 'void'
function f1() {
  // no returns
}

//  fine - 'void' doesn't need a return statement
function f2(): void {
  // no returns
}

//  fine - 'any' doesn't need a return statement
function f3(): any {
  // no returns
}

//  error!
// A function whose declared type is neither 'void' nor 'any' must return a value.
function f4(): undefined {
  // no returns
}
</code></pre>
<p>如果某些 API 期望函数返回 <code>undefined</code> 值，这可能会让人感到痛苦 —— 你需要至少有一个显式的返回 <code>undefined</code> 语句，或者一个带有显式注释的 <code>return</code> 语句。</p>
<pre><code class="language-ts">declare function takesFunction(f: () =&gt; undefined): undefined;

//  error!
// Argument of type '() =&gt; void' is not assignable to parameter of type '() =&gt; undefined'.
takesFunction(() =&gt; {
  // no returns
});

//  error!
// A function whose declared type is neither 'void' nor 'any' must return a value.
takesFunction((): undefined =&gt; {
  // no returns
});

//  error!
// Argument of type '() =&gt; void' is not assignable to parameter of type '() =&gt; undefined'.
takesFunction(() =&gt; {
  return;
});

//  works
takesFunction(() =&gt; {
  return undefined;
});

//  works
takesFunction((): undefined =&gt; {
  return;
});
</code></pre>
<p>这种行为非常令人沮丧和困惑，尤其是在调用自己无法控制的函数时。
理解推断 <code>void</code>与 <code>undefined</code> 之间的相互作用，以及一个返回 <code>undefined</code> 的函数是否需要 <code>return</code> 语句等等，似乎会分散注意力。</p>
<p>首先，TypeScript 5.1 允许返回 <code>undefined</code> 的函数不包含返回语句。</p>
<pre><code class="language-ts">//  Works in TypeScript 5.1!
function f4(): undefined {
  // no returns
}

//  Works in TypeScript 5.1!
takesFunction((): undefined =&gt; {
  // no returns
});
</code></pre>
<p>其次，如果一个函数没有返回表达式，并且被传递给期望返回 <code>undefined</code> 值的函数的地方，TypeScript 会推断该函数的返回类型为 <code>undefined</code>。</p>
<pre><code class="language-ts">//  Works in TypeScript 5.1!
takesFunction(function f() {
  //                 ^ return type is undefined
  // no returns
});

//  Works in TypeScript 5.1!
takesFunction(function f() {
  //                 ^ return type is undefined

  return;
});
</code></pre>
<p>为了解决另一个类似的痛点，在 TypeScript 的 <code>--noImplicitReturns</code> 选项下，只返回 <code>undefined</code> 的函数现在有了类似于 <code>void</code> 的例外情况，在这种情况下，并不是每个代码路径都必须以显式的返回语句结束。</p>
<pre><code class="language-ts">//  Works in TypeScript 5.1 under '--noImplicitReturns'!
function f(): undefined {
  if (Math.random()) {
    // do some stuff...
    return;
  }
}
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/issues/36288">Issue</a>，<a href="https://github.com/microsoft/TypeScript/pull/53607">PR</a></p>
<h2 id="不相关的存取器类型"><a class="header" href="#不相关的存取器类型">不相关的存取器类型</a></h2>
<p>TypeScript 4.3 支持将成对的 <code>get</code> 和 <code>set</code> 定义为不同的类型。</p>
<pre><code class="language-ts">interface Serializer {
  set value(v: string | number | boolean);
  get value(): string;
}

declare let box: Serializer;

// Allows writing a 'boolean'
box.value = true;

// Comes out as a 'string'
console.log(box.value.toUpperCase());
</code></pre>
<p>最初，我们要求 <code>get</code> 的类型是 <code>set</code> 类型的子类型。这意味着：</p>
<pre><code class="language-ts">box.value = box.value;
</code></pre>
<p>永远是合法的。</p>
<p>然而，大量现存的和提议的 API 带有毫无关联的 <code>get</code> 和 <code>set</code> 类型。
例如，考虑一个常见的情况 - DOM 中的 <code>style</code> 属性和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleRule"><code>CSSStyleRule</code></a> API。
每条样式规则都有<a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleRule/style">一个 <code>style</code> 属性</a>，它是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration"><code>CSSStyleDeclaration</code></a>；
然而，如果你尝试给该属性写值，它仅支持字符串。</p>
<p>TypeScript 5.1 现在允许为 <code>get</code> 和 <code>set</code> 访问器属性指定完全不相关的类型，前提是它们具有显式的类型注解。
虽然这个版本的 TypeScript 还没有改变这些内置接口的类型，但 <code>CSSStyleRule</code> 现在可以按以下方式定义：</p>
<pre><code class="language-ts">interface CSSStyleRule {
  // ...

  /** Always reads as a `CSSStyleDeclaration` */
  get style(): CSSStyleDeclaration;

  /** Can only write a `string` here. */
  set style(newValue: string);

  // ...
}
</code></pre>
<p>这也允许其他模式，比如要求 <code>set</code> 访问器只接受“有效”的数据，但指定 <code>get</code> 访问器可以返回 <code>undefined</code>，如果某些基础状态还没有被初始化。</p>
<pre><code class="language-ts">class SafeBox {
  #value: string | undefined;

  // Only accepts strings!
  set value(newValue: string) {}

  // Must check for 'undefined'!
  get value(): string | undefined {
    return this.#value;
  }
}
</code></pre>
<p>实际上，这与在 <code>--exactOptionalProperties</code> 选项下可选属性的检查方式类似。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/53417">PR</a>。</p>
<h2 id="解耦-jsx-元素和-jsx-标签类型之间的类型检查"><a class="header" href="#解耦-jsx-元素和-jsx-标签类型之间的类型检查">解耦 JSX 元素和 JSX 标签类型之间的类型检查</a></h2>
<p>TypeScript 在 JSX 方面的一个痛点是对每个 JSX 元素标签的类型要求。
这个 TypeScript 版本使得 JSX 库更准确地描述了 JSX 组件可以返回的内容。
对于许多人来说，这具体意味着可以在 React 中使用<a href="https://github.com/reactjs/rfcs/blob/7f8492f6a177fc33fe807d242319f2f96353bf68/text/0188-server-components.md">异步服务器组件</a>。</p>
<p>做为背景知识，JSX 元素是下列其一：</p>
<pre><code class="language-tsx">// A self-closing JSX tag
&lt;Foo /&gt;

// A regular element with an opening/closing tag
&lt;Bar&gt;&lt;/Bar&gt;
</code></pre>
<p>在类型检查 <code>&lt;Foo /&gt;</code> 或 <code>&lt;Bar&gt;&lt;/Bar&gt;</code> 时，TypeScript 总是查找名为 <code>JSX</code> 的命名空间，并且获取名为 <code>Element</code> 的类型。
换句话说，它查找 <code>JSX.Element</code>。</p>
<p>但是为了检查 <code>Foo</code>或 <code>Bar</code> 是否是有效的标签名，TypeScript 大致上只需获取由 <code>Foo</code> 或 <code>Bar</code> 返回或构造的类型，并检查其与 <code>JSX.Element</code>（或另一种叫做 <code>JSX.ElementClass</code> 的类型，如果该类型可构造）的兼容性。</p>
<p>这里的限制意味着如果组件返回或 “render” 比 <code>JSX.Element</code> 更宽泛的类型，则无法使用组件。
例如，一个 <code>JSX</code> 库可能会允许组件返回 <code>string</code>s 或 <code>Promise</code>s。</p>
<p>作为一个更具体的例子，<a href="https://github.com/reactjs/rfcs/blob/7f8492f6a177fc33fe807d242319f2f96353bf68/text/0188-server-components.md">未来版本</a>的 React 已经提出了对返回 <code>Promise</code> 的组件的有限支持，但是现有版本的 TypeScript 无法表达这一点，除非有人大幅放宽 <code>JSX.Element</code> 类型。</p>
<pre><code class="language-tsx">import * as React from 'react';

async function Foo() {
  return &lt;div&gt;&lt;/div&gt;;
}

let element = &lt;Foo /&gt;;
//             ~~~
// 'Foo' cannot be used as a JSX component.
//   Its return type 'Promise&lt;Element&gt;' is not a valid JSX element.
</code></pre>
<p>为了给 library 提供一种表达这种情况的方法，TypeScript 5.1 现在查找一个名为 <code>JSX.ElementType</code> 的类型。<code>ElementType</code> 精确地指定了在 JSX 元素中作为标签使用的内容。
因此现在可以像如下这样定义：</p>
<pre><code class="language-ts">namespace JSX {
    export type ElementType =
        // All the valid lowercase tags
        keyof IntrinsicAttributes
        // Function components
        (props: any) =&gt; Element
        // Class components
        new (props: any) =&gt; ElementClass;

    export interface IntrinsictAttributes extends /*...*/ {}
    export type Element = /*...*/;
    export type ClassElement = /*...*/;
}
</code></pre>
<p>感谢 <a href="https://github.com/eps1lon">Sebastian Silbermann</a> 的 <a href="https://github.com/microsoft/TypeScript/pull/51328">PR</a>。</p>
<h2 id="带有命名空间的-jsx-属性"><a class="header" href="#带有命名空间的-jsx-属性">带有命名空间的 JSX 属性</a></h2>
<p>TypeScript 支持在 JSX 里使用带有命名空间的属性。</p>
<pre><code class="language-tsx">import * as React from "react";

// Both of these are equivalent:
const x = &lt;Foo a:b="hello" /&gt;;
const y = &lt;Foo a : b="hello" /&gt;;

interface FooProps {
    "a:b": string;
}

function Foo(props: FooProps) {
    return &lt;div&gt;{props["a:b"]}&lt;/div&gt;;
}
</code></pre>
<p>当名字的第一段是小写名称时，在 <code>JSX.IntrinsicAttributes</code> 上查找带命名空间的标记名是类似的。</p>
<pre><code class="language-tsx">// In some library's code or in an augmentation of that library:
namespace JSX {
  interface IntrinsicElements {
    ['a:b']: { prop: string };
  }
}

// In our code:
let x = &lt;a:b prop="hello!" /&gt;;
</code></pre>
<p>感谢 <a href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a> 的 <a href="https://github.com/microsoft/TypeScript/pull/53799">PR</a>。</p>
<h2 id="模块解析时考虑-typeroots"><a class="header" href="#模块解析时考虑-typeroots">模块解析时考虑 <code>typeRoots</code></a></h2>
<p>当 TypeScript 的模块解析策略无法解析一个路径时，它现在会相对于 <code>typeRoots</code> 继续解析。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/51715">PR</a>。</p>
<h2 id="在-jsx-标签上链接光标"><a class="header" href="#在-jsx-标签上链接光标">在 JSX 标签上链接光标</a></h2>
<p>TypeScript 现在支持 <em>链接编辑</em> JSX 标签名。
链接编辑（有时称作“光标镜像”）允许编辑器同时自动编辑多个位置。</p>
<p>这个新特性在 TypeScript 和 JavaScript 里都可用，并且可以在 Visual Studio Code Insiders 版本中启用。
在 Visual Studio Code 里，你既可以用设置界面的 <code>Editor: Linked Editing</code> 配置：</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/04/linkedEditing-5.1-vscode-ui-1.png" alt="" /></p>
<p>也可以用 JSON 配置文件中的 <code>editor.linkedEditing</code>：</p>
<pre><code class="language-json">{
  // ...
  "editor.linkedEditing": true
}
</code></pre>
<p>这个功能也将在 Visual Studio 17.7 Preview 1 中得到支持。</p>
<h2 id="param-jsdoc-标记的代码片段自动补全"><a class="header" href="#param-jsdoc-标记的代码片段自动补全"><code>@param</code> JSDoc 标记的代码片段自动补全</a></h2>
<p>现在，在 TypeScript 和 JavaScript 文件中输入 <code>@param</code> 标签时，TypeScript 提供代码片段自动补全。
这可以帮助在为代码编写文档和添加 JSDoc 类型时，减少打字和文本跳转次数。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/53260">PR</a>。</p>
<h2 id="优化"><a class="header" href="#优化">优化</a></h2>
<h3 id="避免非必要的类型初始化"><a class="header" href="#避免非必要的类型初始化">避免非必要的类型初始化</a></h3>
<p>TypeScript 5.1 现在避免在已知不包含对外部类型参数的引用的对象类型中执行类型实例化。
这有可能减少许多不必要的计算，并将 <a href="https://github.com/mui/material-ui/tree/b0351248fb396001a30330daac86d0e0794a0c1d/docs"><code>material-ui</code></a> 的文档目录的类型检查时间缩短了 50% 以上。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/53246">PR</a>。</p>
<h3 id="联合字面量的反面情况检查"><a class="header" href="#联合字面量的反面情况检查">联合字面量的反面情况检查</a></h3>
<p>当检查源类型是否是联合类型的一部分时，TypeScript 首先使用该源类型的内部类型标识符进行快速查找。
如果查找失败，则 TypeScript 会检查与联合类型中的每个类型的兼容性。</p>
<p>当将字面量类型与纯字面量类型的联合类型进行关联时，TypeScript 现在可以避免针对联合中的每个其他类型进行完整遍历。
这个假设是安全的，因为 TypeScript 总是将字面量类型内部化/缓存 —— 虽然有一些与“全新”字面量类型相关的边缘情况需要处理。</p>
<p><a href="https://github.com/microsoft/TypeScript/pull/53192">这个优化</a>可以减少<a href="https://github.com/microsoft/TypeScript/issues/53191">问题代码</a>的类型检查时间从 45 秒到 0.4 秒。</p>
<h3 id="减少在解析-jsdoc-时的扫描函数调用"><a class="header" href="#减少在解析-jsdoc-时的扫描函数调用">减少在解析 JSDoc 时的扫描函数调用</a></h3>
<p>在旧版本的 TypeScript 中解析 JSDoc 注释时，它们会使用扫描器/标记化程序将注释分解为细粒度的标记，然后将内容拼回到一起。
这对于规范化注释文本可能是有帮助的，使多个空格只折叠成一个；
但这样做会极大地增加“对话”量，意味着解析器和扫描器会非常频繁地来回跳跃，从而增加了 JSDoc 解析的开销。</p>
<p>TypeScript 5.1 已经移动了更多的逻辑来分解 JSDoc 注释到扫描器/标记化程序中。
现在，扫描器直接将更大的内容块返回给解析器，以便根据需要进行处理。</p>
<p><a href="https://github.com/microsoft/TypeScript/pull/53081">这些更改</a>将几个大约 10Mb 的大部分为散文评论的 JavaScript 文件的解析时间减少了约一半。
对于一个更现实的例子，我们的性能套件对 <a href="https://github.com/statelyai/xstate">xstate</a> 的快照减少了约 300 毫秒的解析时间，使其更快地加载和分析。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-50"><a class="header" href="#typescript-50">TypeScript 5.0</a></h1>
<h2 id="装饰器-decorators"><a class="header" href="#装饰器-decorators">装饰器 Decorators</a></h2>
<p>装饰器是即将到来的 ECMAScript 特性，它允许我们定制可重用的类以及类成员。</p>
<p>考虑如下的代码：</p>
<pre><code class="language-ts">class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }

  greet() {
    console.log(`Hello, my name is ${this.name}.`);
  }
}

const p = new Person('Ron');
p.greet();
</code></pre>
<p>这里的 <code>greet</code> 很简单，但我们假设它很复杂 - 例如包含异步的逻辑，是递归的，具有副作用等。
不管你把它想像成多么混乱复杂，现在我们想插入一些 <code>console.log</code> 语句来调试 <code>greet</code>。</p>
<pre><code class="language-ts">class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }

  greet() {
    console.log('LOG: Entering method.');

    console.log(`Hello, my name is ${this.name}.`);

    console.log('LOG: Exiting method.');
  }
}
</code></pre>
<p>这个做法太常见了。
如果有种办法能给每一个类方法都添加打印功能就太好了！</p>
<p>这就是装饰器的用武之地。
让我们编写一个函数 <code>loggedMethod</code>：</p>
<pre><code class="language-ts">function loggedMethod(originalMethod: any, _context: any) {
  function replacementMethod(this: any, ...args: any[]) {
    console.log('LOG: Entering method.');
    const result = originalMethod.call(this, ...args);
    console.log('LOG: Exiting method.');
    return result;
  }

  return replacementMethod;
}
</code></pre>
<p>"这些 <code>any</code> 是怎么回事？都啥啊？"</p>
<p>先别急 - 这里我们是想简化一下问题，将注意力集中在函数的功能上。
注意一下 <code>loggedMethod</code> 接收原方法（<code>originalMethod</code>）作为参数并返回一个函数：</p>
<ol>
<li>打印 <code>"Entering…"</code> 消息</li>
<li>将 <code>this</code> 值以及所有的参数传递给原方法</li>
<li>打印 <code>"Exiting..."</code> 消息，并且</li>
<li>返回原方法的返回值。</li>
</ol>
<p>现在可以使用 <code>loggedMethod</code> 来<em>装饰</em> <code>greet</code> 方法：</p>
<pre><code class="language-ts">class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }

  @loggedMethod
  greet() {
    console.log(`Hello, my name is ${this.name}.`);
  }
}

const p = new Person('Ron');
p.greet();

// 输出:
//
//   LOG: Entering method.
//   Hello, my name is Ron.
//   LOG: Exiting method.
</code></pre>
<p>我们刚刚在 <code>greet</code> 上使用了 <code>loggedMethod</code> 装饰器 - 注意一下写法 <code>@loggedMethod</code>。
这样做之后，<code>loggedMethod</code> 被调用时会传入被装饰的目标 <code>target</code> 以及一个上下文对象 <code>context object</code> 作为参数。
因为 <code>loggedMethod</code> 返回了一个新函数，因此这个新函数会替换掉 <code>greet</code> 的原始定义。</p>
<p>在 <code>loggedMethod</code> 的定义中带有第二个参数。
它就是上下文对象 <code>context object</code>，包含了一些有关于装饰器声明细节的有用信息 -
例如是否为 <code>#private</code> 成员，或者 <code>static</code>，或者方法的名称。
让我们重写 <code>loggedMethod</code> 来使用这些信息，并且打印出被装饰的方法的名字。</p>
<pre><code class="language-ts">function loggedMethod(
  originalMethod: any,
  context: ClassMethodDecoratorContext
) {
  const methodName = String(context.name);

  function replacementMethod(this: any, ...args: any[]) {
    console.log(`LOG: Entering method '${methodName}'.`);
    const result = originalMethod.call(this, ...args);
    console.log(`LOG: Exiting method '${methodName}'.`);
    return result;
  }

  return replacementMethod;
}
</code></pre>
<p>我们使用了上下文参数。
TypeScript 提供了名为 <code>ClassMethodDecoratorContext</code> 的类型用于描述装饰器方法接收的上下文对象。</p>
<p>除了元数据外，上下文对象中还提供了一个有用的函数 <code>addInitializer</code>。
它提供了一种方式来 hook 到构造函数的起始位置。</p>
<p>例如在 JavaScript 中，下面的情形很常见：</p>
<pre><code class="language-ts">class Person {
  name: string;
  constructor(name: string) {
    this.name = name;

    this.greet = this.greet.bind(this);
  }

  greet() {
    console.log(`Hello, my name is ${this.name}.`);
  }
}
</code></pre>
<p>或者，<code>greet</code> 可以被声明为使用箭头函数初始化的属性。</p>
<pre><code class="language-ts">class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }

  greet = () =&gt; {
    console.log(`Hello, my name is ${this.name}.`);
  };
}
</code></pre>
<p>这类代码的目的是确保 <code>this</code> 值不会被重新绑定，当 <code>greet</code> 被独立地调用或者在用作回调函数时。</p>
<pre><code class="language-ts">const greet = new Person('Ron').greet;

// 我们不希望下面的调用失败
greet();
</code></pre>
<p>我们可以定义一个装饰器来利用 <code>addInitializer</code> 在构造函数里调用 <code>bind</code>。</p>
<pre><code class="language-ts">function bound(originalMethod: any, context: ClassMethodDecoratorContext) {
  const methodName = context.name;
  if (context.private) {
    throw new Error(
      `'bound' cannot decorate private properties like ${methodName as string}.`
    );
  }
  context.addInitializer(function () {
    this[methodName] = this[methodName].bind(this);
  });
}
</code></pre>
<p><code>bound</code> 没有返回值 - 因此当它装饰一个方法时，不会影响原先的方法。
但是，它会在字段被初始化前添加一些逻辑。</p>
<pre><code class="language-ts">class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }

  @bound
  @loggedMethod
  greet() {
    console.log(`Hello, my name is ${this.name}.`);
  }
}

const p = new Person('Ron');
const greet = p.greet;

// Works!
greet();
</code></pre>
<p>我们将两个装饰器叠在了一起 - <code>@bound</code> 和 <code>@loggedMethod</code>。
这些装饰器以“相反的”顺序执行。
也就是说，<code>@loggedMethod</code> 装饰原始方法 <code>greet</code>，
<code>@bound</code> 装饰的是 <code>@loggedMethod</code> 的结果。
此例中，这不太重要 - 但如果你的装饰器带有副作用或者期望特定的顺序，那就不一样了。</p>
<p>值得注意的是：如果你在乎代码样式，也可以将装饰器放在同一行上。</p>
<pre><code class="language-ts">@bound @loggedMethod greet() {
  console.log(`Hello, my name is ${this.name}.`);
}
</code></pre>
<p>可能不太明显的一点是，你甚至可以定义一个返回装饰器函数的函数。
这样我们可以在一定程序上定制最终的装饰器。
我们可以让 <code>loggedMethod</code> 返回一个装饰器并且定制如何打印消息。</p>
<pre><code class="language-ts">function loggedMethod(headMessage = 'LOG:') {
  return function actualDecorator(
    originalMethod: any,
    context: ClassMethodDecoratorContext
  ) {
    const methodName = String(context.name);

    function replacementMethod(this: any, ...args: any[]) {
      console.log(`${headMessage} Entering method '${methodName}'.`);
      const result = originalMethod.call(this, ...args);
      console.log(`${headMessage} Exiting method '${methodName}'.`);
      return result;
    }

    return replacementMethod;
  };
}
</code></pre>
<p>这样做之后，在使用 <code>loggedMethod</code> 装饰器之前需要先调用它。
接下来就可以传入任意字符串作为打印消息的前缀。</p>
<pre><code class="language-ts">class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }

  @loggedMethod('')
  greet() {
    console.log(`Hello, my name is ${this.name}.`);
  }
}

const p = new Person('Ron');
p.greet();

// Output:
//
//    Entering method 'greet'.
//   Hello, my name is Ron.
//    Exiting method 'greet'.
</code></pre>
<p>装饰器不仅可以用在方法上！
它们也可以被用在属性/字段，存取器（getter/setter）以及自动存取器。
甚至，类本身也可以被装饰，用于处理子类化和注册。</p>
<p>想深入了解装饰器，可以阅读 Axel Rauschmayer 的<a href="https://2ality.com/2022/10/javascript-decorators.html">文章</a>。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/50820">PR</a>。</p>
<h2 id="与旧的实验性的装饰器的差异"><a class="header" href="#与旧的实验性的装饰器的差异">与旧的实验性的装饰器的差异</a></h2>
<p>如果你有一定的 TypeScript 经验，你会发现 TypeScript 多年前就已经支持了“实验性的”装饰器特性。
虽然实验性的装饰器非常地好用，但是它实现的是旧版本的装饰器规范，并且总是需要启用 <code>--experimentalDecorators</code> 编译器选项。
若没有启用它并且使用了装饰器，TypeScript 会报错。</p>
<p>在未来的一段时间内，<code>--experimentalDecorators</code> 依然会存在；
然而，如果不使用该标记，在新代码中装饰器语法也是合法的。
在 <code>--experimentalDecorators</code> 之外，它们的类型检查和代码生成方式也不同。
类型检查和代码生成规则存在巨大差异，以至于虽然装饰器<em>可以</em>被定义为同时支持新、旧装饰器的行为，但任何现有的装饰器函数都不太可能这样做。</p>
<p>新的装饰器提案与 <code>--emitDecoratorMetadata</code> 的实现不兼容，并且不支持在参数上使用装饰器。
未来的 ECMAScript 提案可能会弥补这个差距。</p>
<p>最后要注意的是：除了可以在 <code>export</code> 关键字之前使用装饰器，还可以在 <code>export</code> 或者 <code>export default</code> 之后使用。
但是不允许混合使用两种风格。</p>
<pre><code class="language-ts">//  allowed
@register
export default class Foo {
  // ...
}

//  also allowed
export default
@register
class Bar {
  // ...
}

//  error - before *and* after is not allowed
@before
@after
export class Bar {
  // ...
}
</code></pre>
<h2 id="编写强类型的装饰器"><a class="header" href="#编写强类型的装饰器">编写强类型的装饰器</a></h2>
<p>上面的例子 <code>loggedMethod</code> 和 <code>bound</code> 是故意写的简单并且忽略了大量和类型有关的细节。</p>
<p>为装饰器添加类型可能会很复杂。
例如，强类型的 <code>loggedMethod</code> 可能像下面这样：</p>
<pre><code class="language-ts">function loggedMethod&lt;This, Args extends any[], Return&gt;(
  target: (this: This, ...args: Args) =&gt; Return,
  context: ClassMethodDecoratorContext&lt;
    This,
    (this: This, ...args: Args) =&gt; Return
  &gt;
) {
  const methodName = String(context.name);

  function replacementMethod(this: This, ...args: Args): Return {
    console.log(`LOG: Entering method '${methodName}'.`);
    const result = target.call(this, ...args);
    console.log(`LOG: Exiting method '${methodName}'.`);
    return result;
  }

  return replacementMethod;
}
</code></pre>
<p>我们必须分别给原方法的 <code>this</code>、形式参数和返回值添加类型，上面使用了类型参数 <code>This</code>，<code>Args</code> 以及 <code>Return</code>。
装饰器函数到底有多复杂取决于你要确保什么。
但要记住，装饰器被使用的次数远多于被编写的次数，因此强类型的版本是通常希望得到的 -
但我们需要在可读性之间做出取舍，因此要尽量保持简洁。</p>
<p>未来会有更多关于如何编写装饰器的文档 - 但是<a href="https://2ality.com/2022/10/javascript-decorators.html">这篇文章</a>详细介绍了装饰器的工作方式。</p>
<h2 id="const-类型参数"><a class="header" href="#const-类型参数"><code>const</code> 类型参数</a></h2>
<p>在推断对象类型时，TypeScript 通常会选择一个通用类型。
例如，下例中 <code>names</code> 的推断类型为 <code>string[]</code>：</p>
<pre><code class="language-ts">type HasNames = { readonly names: string[] };
function getNamesExactly&lt;T extends HasNames&gt;(arg: T): T['names'] {
  return arg.names;
}

// Inferred type: string[]
const names = getNamesExactly({ names: ['Alice', 'Bob', 'Eve'] });
</code></pre>
<p>这样做的目的通常是为了允许后面可以进行修改。</p>
<p>然而，根据 <code>getNamesExactly</code> 的具体功能和预期使用方式，通常情况下需要更加具体的类型。</p>
<p>直到现在，API 作者们通常不得不在一些位置上添加 <code>as const</code> 来达到预期的类型推断目的：</p>
<pre><code class="language-ts">// The type we wanted:
//    readonly ["Alice", "Bob", "Eve"]
// The type we got:
//    string[]
const names1 = getNamesExactly({ names: ['Alice', 'Bob', 'Eve'] });

// Correctly gets what we wanted:
//    readonly ["Alice", "Bob", "Eve"]
const names2 = getNamesExactly({ names: ['Alice', 'Bob', 'Eve'] } as const);
</code></pre>
<p>这样做既繁琐又容易忘。
在 TypeScript 5.0 里，你可以为类型参数声明添加 <code>const</code> 修饰符，
这使得 <code>const</code> 形式的类型推断成为默认行为：</p>
<pre><code class="language-ts">type HasNames = { names: readonly string[] };
function getNamesExactly&lt;const T extends HasNames&gt;(arg: T): T['names'] {
  //                       ^^^^^
  return arg.names;
}

// Inferred type: readonly ["Alice", "Bob", "Eve"]
// Note: Didn't need to write 'as const' here
const names = getNamesExactly({ names: ['Alice', 'Bob', 'Eve'] });
</code></pre>
<p>注意，<code>const</code> 修饰符不会<em>拒绝</em>可修改的值，并且不需要不可变约束。
使用可变类型约束可能会产生令人惊讶的结果。</p>
<pre><code class="language-ts">declare function fnBad&lt;const T extends string[]&gt;(args: T): void;

// 'T' is still 'string[]' since 'readonly ["a", "b", "c"]' is not assignable to 'string[]'
fnBad(['a', 'b', 'c']);
</code></pre>
<p>这里，<code>T</code> 的候选推断类型为 <code>readonly ["a", "b", "c"]</code>，但是 <code>readonly</code> 只读数组不能用在需要可变数组的地方。
这种情况下，类型推断会回退到类型约束，将数组视为 <code>string[]</code> 类型，因此函数调用仍然会成功。</p>
<p>这个函数更好的定义是使用 <code>readonly string[]</code>：</p>
<pre><code class="language-ts">declare function fnGood&lt;const T extends readonly string[]&gt;(args: T): void;

// T is readonly ["a", "b", "c"]
fnGood(['a', 'b', 'c']);
</code></pre>
<p>要注意 <code>const</code> 修饰符只影响在函数调用中直接写出的对象、数组和基本表达式的类型推断，
因此，那些无法（或不会）使用 <code>as const</code> 进行修饰的参数在行为上不会有任何变化：</p>
<pre><code class="language-ts">declare function fnGood&lt;const T extends readonly string[]&gt;(args: T): void;
const arr = ['a', 'b', 'c'];

// 'T' is still 'string[]'-- the 'const' modifier has no effect here
fnGood(arr);
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/51865">PR</a>，<a href="https://github.com/microsoft/TypeScript/issues/30680">PR</a> 和 <a href="https://github.com/microsoft/TypeScript/issues/41114">PR</a>。</p>
<h2 id="extends-支持多个配置文件"><a class="header" href="#extends-支持多个配置文件"><code>extends</code> 支持多个配置文件</a></h2>
<p>在管理多个项目时，拥有一个“基础”配置文件，其他 tsconfig.json 文件可以继承它，这会非常有帮助。
这就是为什么 TypeScript 支持使用 <code>extends</code> 字段来从 <code>compilerOptions</code> 中复制字段的原因。</p>
<pre><code class="language-json">// packages/front-end/src/tsconfig.json
{
  "extends": "../../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "../lib"
    // ...
  }
}
</code></pre>
<p>然而，有时您可能想要从多个配置文件中进行继承。
例如，假设您正在使用一个<a href="https://github.com/tsconfig/bases">在 npm 上发布的 TypeScript 基础配置文件</a>。
如果您希望自己所有的项目也使用 npm 上的 <code>@tsconfig/strictest</code> 包中的选项，那么有一个简单的解决方案：让 <code>tsconfig.base.json</code> 从 <code>@tsconfig/strictest</code> 进行扩展：</p>
<pre><code class="language-json">// tsconfig.base.json
{
  "extends": "@tsconfig/strictest/tsconfig.json",
  "compilerOptions": {
    // ...
  }
}
</code></pre>
<p>这在某种程度上是有效的。
如果您的某些工程不想使用 <code>@tsconfig/strictest</code>，那么必须手动禁用这些选项，或者创建一个不继承于 <code>@tsconfig/strictest</code> 的 <code>tsconfig.base.json</code>。</p>
<p>为了提高灵活性，TypeScript 5.0 允许 <code>extends</code> 字段指定多个值。
例如，有如下的配置文件：</p>
<pre><code class="language-json">{
  "extends": ["a", "b", "c"],
  "compilerOptions": {
    // ...
  }
}
</code></pre>
<p>这样写就如同是直接继承 <code>c</code>，而 <code>c</code> 继承于 <code>b</code>，<code>b</code> 继承于 <code>a</code>。
如果出现冲突，后来者会被采纳。</p>
<p>在下面的例子中，在最终的 <code>tsconfig.json</code> 中 <code>strictNullChecks</code> 和 <code>noImplicitAny</code> 会被启用。</p>
<pre><code class="language-json">// tsconfig1.json
{
    "compilerOptions": {
        "strictNullChecks": true
    }
}

// tsconfig2.json
{
    "compilerOptions": {
        "noImplicitAny": true
    }
}

// tsconfig.json
{
    "extends": ["./tsconfig1.json", "./tsconfig2.json"],
    "files": ["./index.ts"]
}
</code></pre>
<p>另一个例子，我们可以这样改写最初的示例：</p>
<pre><code class="language-json">// packages/front-end/src/tsconfig.json
{
  "extends": [
    "@tsconfig/strictest/tsconfig.json",
    "../../../tsconfig.base.json"
  ],
  "compilerOptions": {
    "outDir": "../lib"
    // ...
  }
}
</code></pre>
<p>更多详情请参考：<a href="https://github.com/microsoft/TypeScript/pull/50403">PR</a>。</p>
<h2 id="所有的-enum-均为联合-enum"><a class="header" href="#所有的-enum-均为联合-enum">所有的 <code>enum</code> 均为联合 <code>enum</code></a></h2>
<p>在最初 TypeScript 引入枚举类型时，它们只不过是一组同类型的数值常量。</p>
<pre><code class="language-ts">enum E {
  Foo = 10,
  Bar = 20,
}
</code></pre>
<p><code>E.Foo</code> 和 <code>E.Bar</code> 唯一特殊的地方在于它们可以赋值给任何期望类型为 <code>E</code> 的地方。
除此之外，它们基本上等同于 <code>number</code> 类型。</p>
<pre><code class="language-ts">function takeValue(e: E) {}

takeValue(E.Foo); // works
takeValue(123); // error!
</code></pre>
<p>直到 TypeScript 2.0 引入了枚举字面量类型，枚举才变得更为特殊。
枚举字面量类型为每个枚举成员提供了其自己的类型，并将枚举本身转换为每个成员类型的联合类型。
它们还允许我们仅引用枚举中的一部分类型，并细化掉那些类型。</p>
<pre><code class="language-ts">// Color is like a union of Red | Orange | Yellow | Green | Blue | Violet
enum Color {
    Red, Orange, Yellow, Green, Blue, /* Indigo */, Violet
}

// Each enum member has its own type that we can refer to!
type PrimaryColor = Color.Red | Color.Green | Color.Blue;

function isPrimaryColor(c: Color): c is PrimaryColor {
    // Narrowing literal types can catch bugs.
    // TypeScript will error here because
    // we'll end up comparing 'Color.Red' to 'Color.Green'.
    // We meant to use ||, but accidentally wrote &amp;&amp;.
    return c === Color.Red &amp;&amp; c === Color.Green &amp;&amp; c === Color.Blue;
}
</code></pre>
<p>为每个枚举成员提供其自己的类型的一个问题是，这些类型在某种程度上与成员的实际值相关联。
在某些情况下，无法计算该值 - 例如，枚举成员可能由函数调用初始化。</p>
<pre><code class="language-ts">enum E {
  Blah = Math.random(),
}
</code></pre>
<p>每当 TypeScript 遇到这些问题时，它会悄悄地退而使用旧的枚举策略。
这意味着放弃所有联合类型和字面量类型的优势。</p>
<p>TypeScript 5.0 通过为每个计算成员创建唯一类型，成功将所有枚举转换为联合枚举。
这意味着现在所有枚举都可以被细化，并且每个枚举成员都有其自己的类型。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/50528">PR</a></p>
<h2 id="--moduleresolution-bundler"><a class="header" href="#--moduleresolution-bundler"><code>--moduleResolution bundler</code></a></h2>
<p>TypeScript 4.7 支持将 <code>--module</code> 和 <code>--moduleResolution</code> 选项设置为 <code>node16</code> 和 <code>nodenext</code>。
这些选项的目的是更好地模拟 <code>Node.js</code> 中 ECMAScript 模块的精确查找规则；
然而，这种模式存在许多其他工具实际上并不强制执行的限制。</p>
<p>例如，在 Node.js 的 ECMAScript 模块中，任何相对导入都需要包含文件扩展名。</p>
<pre><code class="language-ts">// entry.mjs
import * as utils from './utils'; //  wrong - we need to include the file extension.

import * as utils from './utils.mjs'; //  works
</code></pre>
<p>对于 Node.js 和浏览器来说，这样做有一些原因 - 它可以加快文件查找速度，并且对于简单的文件服务器效果更好。
但是对于许多使用打包工具的开发人员来说，<code>node16</code> / <code>nodenext</code> 设置很麻烦，
因为打包工具中没有这么多限制。
在某些方面，<code>node</code> 解析模式对于任何使用打包工具的人来说是更好的。</p>
<p>但在某些方面，原始的 <code>node</code> 解析模式已经过时了。
大多数现代打包工具在 Node.js 中使用 ECMAScript 模块和 CommonJS 查找规则的融合。
例如，像在 CommonJS 中一样，无扩展名的导入也可以正常工作，但是在查找<a href="https://nodejs.org/api/packages.html#nested-conditions">包的导出条件</a>时，它们将首选像在 ECMAScript 文件中一样的 <code>import</code> 条件。</p>
<p>为了模拟打包工具的工作方式，TypeScript 现在引入了一种新策略：<code>--moduleResolution bundler</code>。</p>
<pre><code class="language-json">{
  "compilerOptions": {
    "target": "esnext",
    "moduleResolution": "bundler"
  }
}
</code></pre>
<p>如果你使用如 Vite， esbuild, swc, Webpack, parcel 等现代打包工具，它们实现了混合的查找策略，新的 <code>bundler</code> 选项是更好的选择。</p>
<p>另一方面，如果您正在编写一个要发布到 npm 的代码库，那么使用 <code>bundler</code> 选项可能会隐藏影响未使用打包工具用户的兼容性问题。
因此，在这些情况下，使用 <code>node16</code> 或 <code>nodenext</code> 解析选项可能是更好的选择。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/51669">PR</a></p>
<h2 id="定制化解析的标记"><a class="header" href="#定制化解析的标记">定制化解析的标记</a></h2>
<p>JavaScript 工具现在可以模拟“混合”解析规则，就像我们上面描述的 <code>bundler</code> 模式一样。
由于工具的支持可能有所不同，因此 TypeScript 5.0 提供了启用或禁用一些功能的方法，这些功能可能无法与您的配置一起使用。</p>
<h3 id="allowimportingtsextensions"><a class="header" href="#allowimportingtsextensions"><code>allowImportingTsExtensions</code></a></h3>
<p><code>--allowImportingTsExtensions</code> 允许 TypeScript 文件导入使用了 TypeScript 特定扩展名的文件，例如 <code>.ts</code>, <code>.mts</code>, <code>.tsx</code>。</p>
<p>此标记仅在启用了 <code>--noEmit</code> 或 <code>--emitDeclarationOnly</code> 时允许使用，
因为这些导入路径无法在运行时的 JavaScript 输出文件中被解析。
这里的期望是，您的解析器（例如打包工具、运行时或其他工具）将保证这些在 <code>.ts</code> 文件之间的导入可以工作。</p>
<h3 id="resolvepackagejsonexports"><a class="header" href="#resolvepackagejsonexports">resolvePackageJsonExports</a></h3>
<p><code>--resolvePackageJsonExports</code> 强制 TypeScript 使用 <a href="https://nodejs.org/api/packages.html#exports">package.json 里的 exports 字段</a>，如果它尝试读取 <code>node_modules</code> 里的某个包。</p>
<p>当 <code>--moduleResolution</code> 为 <code>node16</code>, <code>nodenext</code> 和 <code>bundler</code> 时，该选项的默认值为 <code>true</code>。</p>
<h3 id="resolvepackagejsonimports"><a class="header" href="#resolvepackagejsonimports"><code>resolvePackageJsonImports</code></a></h3>
<p><code>--resolvePackageJsonImports</code> 强制 TypeScript 使用 <a href="https://nodejs.org/api/packages.html#imports">package.json 里的 imports 字段</a>，当它查找以 <code>#</code> 开头的文件时，且该文件的父目录中包含 <code>package.json</code> 文件。</p>
<p>当 <code>--moduleResolution</code> 为 <code>node16</code>, <code>nodenext</code> 和 <code>bundler</code> 时，该选项的默认值为 <code>true</code>。</p>
<h3 id="allowarbitraryextensions"><a class="header" href="#allowarbitraryextensions"><code>allowArbitraryExtensions</code></a></h3>
<p>在 TypeScript 5.0 中，当导入路径不是以已知的 JavaScript 或 TypeScript 文件扩展名结尾时，编译器将查找该路径的声明文件，形式为 <code>{文件基础名称}.d.{扩展名}.ts</code>。
例如，如果您在打包项目中使用 CSS 加载器，您可能需要编写（或生成）如下的声明文件：</p>
<pre><code class="language-css">/* app.css */
.cookie-banner {
  display: none;
}
</code></pre>
<pre><code class="language-ts">// app.d.css.ts
declare const css: {
  cookieBanner: string;
};
export default css;
</code></pre>
<pre><code class="language-tsx">// App.tsx
import styles from './app.css';

styles.cookieBanner; // string
</code></pre>
<p>默认情况下，该导入将引发错误，告诉您 TypeScript 不支持此文件类型，您的运行时可能不支持导入它。
但是，如果您已经配置了运行时或打包工具来处理它，您可以使用新的 <code>--allowArbitraryExtensions</code> 编译器选项来抑制错误。</p>
<p>需要注意的是，历史上通常可以通过添加名为 <code>app.css.d.ts</code> 而不是 <code>app.d.css.ts</code> 的声明文件来实现类似的效果 - 但是，这只在 Node.js 中 CommonJS 的 <code>require</code> 解析规则下可以工作。
严格来说，前者被解析为名为 <code>app.css.js</code> 的 JavaScript 文件的声明文件。
由于 Node 中的 ESM 需要使用包含扩展名的相对文件导入，因此在 <code>--moduleResolution</code> 为 <code>node16</code> 或 <code>nodenext</code> 时，TypeScript 会在示例的 ESM 文件中报错。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/issues/50133">PR</a> <a href="https://github.com/microsoft/TypeScript/pull/51435">PR</a>。</p>
<h3 id="customconditions"><a class="header" href="#customconditions"><code>customConditions</code></a></h3>
<p><code>--customConditions</code> 接受额外的<a href="https://nodejs.org/api/packages.html#nested-conditions">条件</a>列表，当 TypeScript 从 package.json 的<a href="https://nodejs.org/api/packages.html#exports">exports</a>或 <a href="https://nodejs.org/api/packages.html#imports">imports</a> 字段解析时，这些条件应该成功。
这些条件会被添加到解析器默认使用的任何现有条件中。</p>
<p>例如，有如下的配置：</p>
<pre><code class="language-json">{
  "compilerOptions": {
    "target": "es2022",
    "moduleResolution": "bundler",
    "customConditions": ["my-condition"]
  }
}
</code></pre>
<p>每当 <code>package.json</code> 里引用了 <code>exports</code> 或 <code>imports</code> 字段时，TypeScript 都会考虑名为 <code>my-condition</code> 的条件。</p>
<p>所以当从具有如下 <code>package.json</code> 的包中导入时：</p>
<pre><code class="language-json">{
  // ...
  "exports": {
    ".": {
      "my-condition": "./foo.mjs",
      "node": "./bar.mjs",
      "import": "./baz.mjs",
      "require": "./biz.mjs"
    }
  }
}
</code></pre>
<p>TypeScript 会尝试查找 <code>foo.mjs</code> 文件。</p>
<p>该字段仅在 <code>--moduleResolution</code> 为 <code>node16</code>, <code>nodenext</code> 和 <code>bundler</code> 时有效。</p>
<h2 id="--verbatimmodulesyntax"><a class="header" href="#--verbatimmodulesyntax">--verbatimModuleSyntax</a></h2>
<p>在默认情况下，TypeScript 会执行<em>导入省略</em>。
大体上来讲，如果有如下代码：</p>
<pre><code class="language-ts">import { Car } from './car';

export function drive(car: Car) {
  // ...
}
</code></pre>
<p>TypeScript 能够检测到导入语句仅用于导入类型，因此会删除导入语句。
最终生成的 JavaScript 代码如下：</p>
<pre><code class="language-js">export function drive(car) {
  // ...
}
</code></pre>
<p>大多数情况下这是没问题的，因为如果 <code>Car</code> 不是从 <code>./car</code> 导出的值，我们将会得到一个运行时错误。</p>
<p>但在一些特殊情况下，它增加了一层复杂性。
例如，不存在像 <code>import "./car";</code> 这样的语句 - 这个导入语句会被完全删除。
这对于有副作用的模块来讲是有区别的。</p>
<p>TypeScript 的 JavaScript 代码生成策略还有其它一些复杂性 - 导入省略不仅只是由导入语句的使用方式决定 - 它还取决于值的声明方式。
因此，如下的代码的处理方式不总是那么明显：</p>
<pre><code class="language-ts">export { Car } from './car';
</code></pre>
<p>这段代码是应该保留还是删除？
如果 <code>Car</code> 是使用 <code>class</code> 声明的，那么在生成的 JavaScript 代码中会被保留。
但是如果 <code>Car</code> 是使用类型别名或 <code>interface</code> 声明的，那么在生成的 JavaScript 代码中会被省略。</p>
<p>尽管 TypeScript 可以根据多个文件来综合判断如何生成代码，但不是所有的编译器都能够做到。</p>
<p>导入和导出语句中的 <code>type</code> 修饰符能够起到一点作用。
我们可以使用 <code>type</code> 修饰符明确声明导入和导出是否仅用于类型分析，并且可以在生成的 JavaScript 文件中完全删除。</p>
<pre><code class="language-ts">// This statement can be dropped entirely in JS output
import type * as car from './car';

// The named import/export 'Car' can be dropped in JS output
import { type Car } from './car';
export { type Car } from './car';
</code></pre>
<p><code>type</code> 修饰符本身并不是特别管用 - 默认情况下，导入省略仍会删除导入语句，
并且不强制要求您区分类型导入和普通导入以及导出。
因此，TypeScript 提供了 <code>--importsNotUsedAsValues</code> 来确保您使用类型修饰符，
<code>--preserveValueImports</code> 来防止<em>某些</em>模块消除行为，
以及 <code>--isolatedModules</code> 来确保您的 TypeScript 代码在不同编译器中都能正常运行。
不幸的是，理解这三个标志的细节很困难，并且仍然存在一些意外行为的边缘情况。</p>
<p>TypeScript 5.0 提供了一个新的 <code>--verbatimModuleSyntax</code> 来简化这个情况。
规则很简单 - 所有不带 <code>type</code> 修饰符的导入导出语句会被保留。
任何带有 <code>type</code> 修饰符的导入导出语句会被删除。</p>
<pre><code class="language-ts">// Erased away entirely.
import type { A } from 'a';

// Rewritten to 'import { b } from "bcd";'
import { b, type c, type d } from 'bcd';

// Rewritten to 'import {} from "xyz";'
import { type xyz } from 'xyz';
</code></pre>
<p>使用这个新的选项，实现了所见即所得。</p>
<p>但是，这在涉及模块互操作性时会有一些影响。
在这个标志下，当您的设置或文件扩展名暗示了不同的模块系统时，ECMAScript 的导入和导出不会被重写为 <code>require</code> 调用。
相反，您会收到一个错误。
如果您需要生成使用 <code>require</code> 和 <code>module.exports</code> 的代码，您需要使用早于 ES2015 的 TypeScript 的模块语法：</p>
<pre><code class="language-ts">import foo = require('foo');

// ==&gt;

const foo = require('foo');
</code></pre>
<pre><code class="language-ts">function foo() {}
function bar() {}
function baz() {}

export = {
  foo,
  bar,
  baz,
};

// ==&gt;

function foo() {}
function bar() {}
function baz() {}

module.exports = {
  foo,
  bar,
  baz,
};
</code></pre>
<p>虽然这是一种限制，但它确实有助于使一些问题更加明显。
例如，在 <code>--module node16</code> 下很容易忘记<a href="https://nodejs.org/api/packages.html#type">在 package.json 中设置 <code>type</code> 字段</a>。
结果是开发人员会开始编写 CommonJS 模块而不是 ES 模块，但却没有意识到这一点，从而导致查找规则和 JavaScript 输出出现意外的结果。
这个新的标志确保您有意识地使用文件类型，因为语法是刻意不同的。</p>
<p>因为 <code>--verbatimModuleSyntax</code> 相比于 <code>--importsNotUsedAsValues</code> 和 <code>--preserveValueImports</code> 提供了更加一致的行为，推荐使用前者，后两个标记将被弃用。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/52203">PR</a> 和 <a href="https://github.com/microsoft/TypeScript/issues/51479">issue</a>.</p>
<h2 id="支持-export-type-"><a class="header" href="#支持-export-type-">支持 <code>export type *</code></a></h2>
<p>在 TypeScript 3.8 引入类型导入时，该语法不支持在 <code>export * from "module"</code> 或 <code>export * as ns from "module"</code> 重新导出上使用。
TypeScript 5.0 添加了对两者的支持：</p>
<pre><code class="language-ts">// models/vehicles.ts
export class Spaceship {
  // ...
}

// models/index.ts
export type * as vehicles from './vehicles';

// main.ts
import { vehicles } from './models';

function takeASpaceship(s: vehicles.Spaceship) {
  //  ok - `vehicles` only used in a type position
}

function makeASpaceship() {
  return new vehicles.Spaceship();
  //         ^^^^^^^^
  // 'vehicles' cannot be used as a value because it was exported using 'export type'.
}
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/52217">PR</a>。</p>
<h2 id="支持-jsdoc-中的-satisfies"><a class="header" href="#支持-jsdoc-中的-satisfies">支持 JSDoc 中的 <code>@satisfies</code></a></h2>
<p>TypeScript 4.9 支持 <code>satisfies</code> 运算符。
它确保了表达式的类型是兼容的，且不影响类型自身。
例如，有如下代码：</p>
<pre><code class="language-ts">interface CompilerOptions {
  strict?: boolean;
  outDir?: string;
  // ...
}

interface ConfigSettings {
  compilerOptions?: CompilerOptions;
  extends?: string | string[];
  // ...
}

let myConfigSettings = {
  compilerOptions: {
    strict: true,
    outDir: '../lib',
    // ...
  },

  extends: ['@tsconfig/strictest/tsconfig.json', '../../../tsconfig.base.json'],
} satisfies ConfigSettings;
</code></pre>
<p>这里，TypeScript 知道 <code>myConfigSettings.extends</code> 声明为数组 - 因为 <code>satisfies</code> 会验证对象的类型。
因此，如果我们想在 <code>extends</code> 上进行映射操作，那是可以的。</p>
<pre><code class="language-ts">declare function resolveConfig(configPath: string): CompilerOptions;

let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);
</code></pre>
<p>这对 TypeScript 用户来讲是有用处的，但是许多人使用 TypeScript 来对带有 JSDoc 的 JavaScript 代码进行类型检查。
因此，TypeScript 5.0 支持了新的 JSDoc 标签 <code>@satisfies</code> 来做相同的事。</p>
<p><code>/** @satisfies */</code> 能够检查出类型不匹配：</p>
<pre><code class="language-ts">// @ts-check

/**
 * @typedef CompilerOptions
 * @prop {boolean} [strict]
 * @prop {string} [outDir]
 */

/**
 * @satisfies {CompilerOptions}
 */
let myCompilerOptions = {
  outdir: '../lib',
  //  ~~~~~~ oops! we meant outDir
};
</code></pre>
<p>但它会保留表达式的原始类型，允许我们稍后使用值的更详细的类型。</p>
<pre><code class="language-ts">// @ts-check

/**
 * @typedef CompilerOptions
 * @prop {boolean} [strict]
 * @prop {string} [outDir]
 */

/**
 * @typedef ConfigSettings
 * @prop {CompilerOptions} [compilerOptions]
 * @prop {string | string[]} [extends]
 */

/**
 * @satisfies {ConfigSettings}
 */
let myConfigSettings = {
  compilerOptions: {
    strict: true,
    outDir: '../lib',
  },
  extends: ['@tsconfig/strictest/tsconfig.json', '../../../tsconfig.base.json'],
};

let inheritedConfigs = myConfigSettings.extends.map(resolveConfig);
</code></pre>
<p><code>/** @satisfies */</code> 也可以在行内的括号表达式上使用。
可以像下面这样定义 <code>myConfigSettings</code>：</p>
<pre><code class="language-ts">let myConfigSettings = /** @satisfies {ConfigSettings} */ {
  compilerOptions: {
    strict: true,
    outDir: '../lib',
  },
  extends: ['@tsconfig/strictest/tsconfig.json', '../../../tsconfig.base.json'],
};
</code></pre>
<p>为什么？当你更深入地研究其他代码时，比如函数调用，它通常更有意义。</p>
<pre><code class="language-ts">compileCode(
  /** @satisfies {ConfigSettings} */ {
    // ...
  }
);
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/51753">PR</a>。
感谢作者 <a href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a>。</p>
<h2 id="支持-jsdoc-中的-overload"><a class="header" href="#支持-jsdoc-中的-overload">支持 JSDoc 中的 <code>@overload</code></a></h2>
<p>在 TypeScript 中，你可以为一个函数指定多个重载。
使用重载能够描述一个函数可以使用不同的参数进行调用，也可能会返回不同的结果。
它们可以限制调用方如何调用函数，并细化他们将得到的结果。</p>
<pre><code class="language-ts">// Our overloads:
function printValue(str: string): void;
function printValue(num: number, maxFractionDigits?: number): void;

// Our implementation:
function printValue(value: string | number, maximumFractionDigits?: number) {
  if (typeof value === 'number') {
    const formatter = Intl.NumberFormat('en-US', {
      maximumFractionDigits,
    });
    value = formatter.format(value);
  }

  console.log(value);
}
</code></pre>
<p>这里表示 <code>printValue</code> 的第一个参数可以为 <code>string</code> 或 <code>number</code> 类型。
如果接收的是 <code>number</code> 类型，那么它还接收第二个参数决定打印的小数位数。</p>
<p>TypeScript 5.0 支持在 JSDoc 里使用 <code>@overload</code> 来声明重载。
每一个 JSDoc <code>@overload</code> 标记都表示一个不同的函数重载。</p>
<pre><code class="language-js">// @ts-check

/**
 * @overload
 * @param {string} value
 * @return {void}
 */

/**
 * @overload
 * @param {number} value
 * @param {number} [maximumFractionDigits]
 * @return {void}
 */

/**
 * @param {string | number} value
 * @param {number} [maximumFractionDigits]
 */
function printValue(value, maximumFractionDigits) {
  if (typeof value === 'number') {
    const formatter = Intl.NumberFormat('en-US', {
      maximumFractionDigits,
    });
    value = formatter.format(value);
  }

  console.log(value);
}
</code></pre>
<p>现在不论是编写 TypeScript 文件还是 JavaScript 文件，TypeScript 都能够提示函数调用是否正确。</p>
<pre><code class="language-js">// all allowed
printValue('hello!');
printValue(123.45);
printValue(123.45, 2);

printValue('hello!', 123); // error!
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/51234">PR</a>，感谢 <a href="https://github.com/apendua">Tomasz Lenarcik</a>。</p>
<h2 id="在---build-模式下使用有关文件生成的选项"><a class="header" href="#在---build-模式下使用有关文件生成的选项">在 <code>--build</code> 模式下使用有关文件生成的选项</a></h2>
<p>TypeScript 现在允许在 <code>--build</code> 模式下使用如下选项：</p>
<ul>
<li><code>--declaration</code></li>
<li><code>--emitDeclarationOnly</code></li>
<li><code>--declarationMap</code></li>
<li><code>--sourceMap</code></li>
<li><code>--inlineSourceMap</code></li>
</ul>
<p>这使得在构建过程中定制某些部分变得更加容易，特别是在你可能会有不同的开发和生产构建时。</p>
<p>例如，一个库的开发构建可能不需要生成声明文件，但是生产构建则需要。
一个项目可以将生成声明文件配置为默认关闭，并使用如下方式构建：</p>
<pre><code class="language-sh">tsc --build -p ./my-project-dir
</code></pre>
<p>开发完毕后，在“生产环境”构建时使用 <code>--declaration</code> 选项：</p>
<pre><code class="language-sh">tsc --build -p ./my-project-dir --declaration
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/51241">PR</a>。</p>
<h2 id="编辑器导入语句排序时不区分大小写"><a class="header" href="#编辑器导入语句排序时不区分大小写">编辑器导入语句排序时不区分大小写</a></h2>
<p>在 Visual Studio 和 VS Code 等编辑器中，TypeScript 可以帮助组织和排序导入和导出语句。
不过，通常情况下，对于何时将列表“排序”，可能会有不同的解释。</p>
<p>例如，下面的导入列表是否已排序？</p>
<pre><code class="language-ts">import { Toggle, freeze, toBoolean } from './utils';
</code></pre>
<p>令人惊讶的是，答案可能是“这要看情况”。
如果我们不考虑大小写敏感性，那么这个列表显然是没有排序的。
字母<code>f</code>排在<code>t</code>和<code>T</code>之前。</p>
<p>但在大多数编程语言中，排序默认是比较字符串的字节值。
JavaScript 比较字符串的方式意味着 “Toggle” 总是排在 “freeze” 之前，因为根据 <a href="https://en.wikipedia.org/wiki/ASCII">ASCII 字符编码</a>，大写字母排在小写字母之前。
所以从这个角度来看，导入列表是已排序的。</p>
<p>以前，TypeScript 认为导入列表已排序，因为它进行了基本的大小写敏感排序。
这可能让开发人员感到沮丧，因为他们更喜欢不区分大小写的排序方式，或者使用像 ESLint 这样的工具默认需要不区分大小写的排序方式。</p>
<p>现在，TypeScript 默认会检测大小写敏感性。
这意味着 TypeScript 和类似 ESLint 的工具通常不会因为如何最好地排序导入而“互相冲突”。</p>
<p>我们的团队还在尝试更多的排序策略，你可以在<a href="https://github.com/microsoft/TypeScript/pull/52115">这里了解更多</a>。
这些选项可能最终可以由编辑器进行配置。
目前，它们仍然不稳定和实验性的，你可以通过在 JSON 选项中使用 typescript.unstable 条目来选择它们。
下面是你可以尝试的所有选项（设置为它们的默认值）：</p>
<pre><code class="language-json">{
  "typescript.unstable": {
    // Should sorting be case-sensitive? Can be:
    // - true
    // - false
    // - "auto" (auto-detect)
    "organizeImportsIgnoreCase": "auto",

    // Should sorting be "ordinal" and use code points or consider Unicode rules? Can be:
    // - "ordinal"
    // - "unicode"
    "organizeImportsCollation": "ordinal",

    // Under `"organizeImportsCollation": "unicode"`,
    // what is the current locale? Can be:
    // - [any other locale code]
    // - "auto" (use the editor's locale)
    "organizeImportsLocale": "en",

    // Under `"organizeImportsCollation": "unicode"`,
    // should upper-case letters or lower-case letters come first? Can be:
    // - false (locale-specific)
    // - "upper"
    // - "lower"
    "organizeImportsCaseFirst": false,

    // Under `"organizeImportsCollation": "unicode"`,
    // do runs of numbers get compared numerically (i.e. "a1" &lt; "a2" &lt; "a100")? Can be:
    // - true
    // - false
    "organizeImportsNumericCollation": true,

    // Under `"organizeImportsCollation": "unicode"`,
    // do letters with accent marks/diacritics get sorted distinctly
    // from their "base" letter (i.e. is é different from e)? Can be
    // - true
    // - false
    "organizeImportsAccentCollation": true
  },
  "javascript.unstable": {
    // same options valid here...
  }
}
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/51733">PR</a> 和 <a href="https://github.com/microsoft/TypeScript/pull/52115">PR</a>。</p>
<h2 id="穷举式-switchcase-自动补全"><a class="header" href="#穷举式-switchcase-自动补全">穷举式 <code>switch/case</code> 自动补全</a></h2>
<p>在编写 <code>switch</code> 语句时，TypeScript 现在会检测被检查的值是否具有字面量类型。
如果是，它将提供一个补全选项，可以为每个未覆盖的情况构建骨架代码。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/50996">PR</a>。</p>
<h2 id="速度内存以及代码包尺寸优化"><a class="header" href="#速度内存以及代码包尺寸优化">速度，内存以及代码包尺寸优化</a></h2>
<p>TypeScript 5.0 在我们的代码结构、数据结构和算法实现方面进行了许多强大的变化。
这些变化的意义在于，整个体验都应该更快 —— 不仅仅是运行 TypeScript，甚至包括安装 TypeScript。</p>
<p>以下是我们相对于 TypeScript 4.9 能够获得的一些有趣的速度和大小优势。</p>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Time or Size Relative to TS 4.9</th></tr></thead><tbody>
<tr><td>material-ui build time</td><td>90%</td></tr>
<tr><td>TypeScript Compiler startup time</td><td>89%</td></tr>
<tr><td>Playwright build time</td><td>88%</td></tr>
<tr><td>TypeScript Compiler self-build time</td><td>87%</td></tr>
<tr><td>Outlook Web build time</td><td>82%</td></tr>
<tr><td>VS Code build time</td><td>80%</td></tr>
<tr><td>typescript npm Package Size</td><td>59%</td></tr>
</tbody></table>
</div>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/03/speed-5.0-stable-2.png" alt="img" /></p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/03/size-5.0-stable-1.png" alt="img" /></p>
<p>怎么做到的呢？我们将在未来的博客文章中详细介绍一些值得注意的改进。
但我们不会让你等到那篇博客文章。</p>
<p>首先，我们最近将 TypeScript 从命名空间迁移到了模块，这使我们能够利用现代构建工具来执行像作用域提升这样的优化。
使用这些工具，重新审视我们的打包策略，并删除一些已过时的代码，使 TypeScript 4.9 的 63.8 MB 包大小减少了约 26.4 MB。
这也通过直接函数调用为我们带来了显著的加速。
我们在这里撰写了关于我们迁移到模块的<a href="https://devblogs.microsoft.com/typescript/typescripts-migration-to-modules/">详细介绍</a>。</p>
<p>TypeScript 还在编译器内部对象类型上增加了更多的一致性，并且也减少了一些这些对象类型上存储的数据。
这减少了多态操作，同时平衡了由于使我们的对象结构更加一致而带来的内存使用增加。</p>
<p>我们还在将信息序列化为字符串时执行了一些缓存。
类型显示，它可能在错误报告、声明生成、代码补全等情况下使用，是非常昂贵的操作。
TypeScript 现在对一些常用的机制进行缓存，以便在这些操作之间重复使用。</p>
<p>我们进行了一个值得注意的改变，改善了我们的解析器，即在某些情况下，利用 var 来避免在闭包中使用 let 和 const 的成本。
这提高了一些解析性能。</p>
<p>总的来说，我们预计大多数代码库应该会从 TypeScript 5.0 中看到速度的提升，并且一直能够保持 10% 到 20% 之间的优势。
当然，这将取决于硬件和代码库的特性，但我们鼓励你今天就在你的代码库上尝试它！</p>
<p>更多详情：</p>
<ul>
<li><a href="https://github.com/microsoft/TypeScript/pull/51387">Migrate to Modules</a></li>
<li><a href="https://github.com/microsoft/TypeScript/pull/51682">Node Monomorphization</a></li>
<li><a href="https://github.com/microsoft/TypeScript/pull/51880">Symbol Monomorphization</a></li>
<li><a href="https://github.com/microsoft/TypeScript/pull/52170">Identifier Size Reduction</a></li>
<li><a href="https://github.com/microsoft/TypeScript/pull/52382">Printer Caching</a></li>
<li><a href="https://github.com/microsoft/TypeScript/issues/52924">Limited Usage of var</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-49"><a class="header" href="#typescript-49">TypeScript 4.9</a></h1>
<h2 id="satisfies-运算符"><a class="header" href="#satisfies-运算符"><code>satisfies</code> 运算符</a></h2>
<p>TypeScript 开发者有时会感到进退两难：既想要确保表达式能够<em>匹配</em>某种类型，也想要表达式获得最确切的类型用作类型推断。</p>
<p>例如：</p>
<pre><code class="language-ts">// 每个属性可能是 string 或 RGB 元组。
const palette = {
    red: [255, 0, 0],
    green: "#00ff00",
    bleu: [0, 0, 255]
//  ^^^^ 拼写错误
};

// 我们想要在 'red' 上调用数组的方法
const redComponent = palette.red.at(0);

// 或者在 'green' 上调用字符串的方法
const greenNormalized = palette.green.toUpperCase();
</code></pre>
<p>注意，这里写成了 <code>bleu</code>，但我们想写的是 <code>blue</code>。
通过给 <code>palette</code> 添加类型注释就能够捕获 <code>bleu</code> 拼写错误，
但同时我们也失去了属性各自的信息。</p>
<pre><code class="language-ts">type Colors = "red" | "green" | "blue";

type RGB = [red: number, green: number, blue: number];

const palette: Record&lt;Colors, string | RGB&gt; = {
    red: [255, 0, 0],
    green: "#00ff00",
    bleu: [0, 0, 255]
//  ~~~~ 能够检测到拼写错误
};

// 意想不到的错误 - 'palette.red' 可能为 string
const redComponent = palette.red.at(0);
</code></pre>
<p>新的 <code>satisfies</code> 运算符让我们可以验证表达式是否匹配某种类型，同时不改变表达式自身的类型。
例如，可以使用 <code>satisfies</code> 来检验 <code>palette</code> 的所有属性与 <code>string | number[]</code> 是否兼容：</p>
<pre><code class="language-ts">type Colors = "red" | "green" | "blue";

type RGB = [red: number, green: number, blue: number];

const palette = {
    red: [255, 0, 0],
    green: "#00ff00",
    bleu: [0, 0, 255]
//  ~~~~ 捕获拼写错误
} satisfies Record&lt;Colors, string | RGB&gt;;

// 依然可以访问这些方法
const redComponent = palette.red.at(0);
const greenNormalized = palette.green.toUpperCase();
</code></pre>
<p><code>satisfies</code> 可以用来捕获许多错误。
例如，检查一个对象是否包含了某个类型要求的所有的键，并且没有多余的：</p>
<pre><code class="language-ts">type Colors = "red" | "green" | "blue";

// 确保仅包含 'Colors' 中定义的键
const favoriteColors = {
    "red": "yes",
    "green": false,
    "blue": "kinda",
    "platypus": false
//  ~~~~~~~~~~ 错误 - "platypus" 不在 'Colors' 中
} satisfies Record&lt;Colors, unknown&gt;;

// 'red', 'green', and 'blue' 的类型信息保留下来
const g: boolean = favoriteColors.green;
</code></pre>
<p>有可能我们不太在乎属性名，在乎的是属性值的类型。
在这种情况下，我们也能够确保对象属性值的类型是匹配的。</p>
<pre><code class="language-ts">type RGB = [red: number, green: number, blue: number];

const palette = {
    red: [255, 0, 0],
    green: "#00ff00",
    blue: [0, 0]
    //    ~~~~~~ 错误！
} satisfies Record&lt;string, string | RGB&gt;;

// 类型信息保留下来
const redComponent = palette.red.at(0);
const greenNormalized = palette.green.toUpperCase();
</code></pre>
<p>更多示例请查看<a href="https://github.com/microsoft/TypeScript/issues/47920">这里</a>和<a href="https://github.com/microsoft/TypeScript/pull/46827">这里</a>。
感谢<a href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a>对该属性的贡献。</p>
<h2 id="使用-in-运算符来细化并未列出其属性的对象类型"><a class="header" href="#使用-in-运算符来细化并未列出其属性的对象类型">使用 <code>in</code> 运算符来细化并未列出其属性的对象类型</a></h2>
<p>开发者经常需要处理在运行时不完全已知的值。
事实上，我们常常不能确定对象的某个属性是否存在，是否从服务端得到了响应或者读取到了某个配置文件。
JavaScript 的 <code>in</code> 运算符能够检查对象上是否存在某个属性。</p>
<p>从前，TypeScript 能够根据没有明确列出的属性来细化类型。</p>
<pre><code class="language-ts">interface RGB {
    red: number;
    green: number;
    blue: number;
}

interface HSV {
    hue: number;
    saturation: number;
    value: number;
}

function setColor(color: RGB | HSV) {
    if ("hue" in color) {
        // 'color' 类型为 HSV
    }
    // ...
}
</code></pre>
<p>此处，<code>RGB</code> 类型上没有列出 <code>hue</code> 属性，因此被细化掉了，剩下了 <code>HSV</code> 类型。</p>
<p>那如果每个类型上都没有列出这个属性呢？
在这种情况下，语言无法提供太多的帮助。
看下面的 JavaScript 示例：</p>
<pre><code class="language-ts">function tryGetPackageName(context) {
    const packageJSON = context.packageJSON;
    // Check to see if we have an object.
    if (packageJSON &amp;&amp; typeof packageJSON === "object") {
        // Check to see if it has a string name property.
        if ("name" in packageJSON &amp;&amp; typeof packageJSON.name === "string") {
            return packageJSON.name;
        }
    }

    return undefined;
}
</code></pre>
<p>将上面的代码改写为合适的 TypeScript，我们会给 <code>context</code> 定义一个类型；
然而，在旧版本的 TypeScript 中如果声明 <code>packageJSON</code> 属性的类型为安全的 <code>unknown</code> 类型会有问题。</p>
<pre><code class="language-ts">interface Context {
    packageJSON: unknown;
}

function tryGetPackageName(context: Context) {
    const packageJSON = context.packageJSON;
    // Check to see if we have an object.
    if (packageJSON &amp;&amp; typeof packageJSON === "object") {
        // Check to see if it has a string name property.
        if ("name" in packageJSON &amp;&amp; typeof packageJSON.name === "string") {
        //                                              ~~~~
        // error! Property 'name' does not exist on type 'object.
            return packageJSON.name;
        //                     ~~~~
        // error! Property 'name' does not exist on type 'object.
        }
    }

    return undefined;
}
</code></pre>
<p>这是因为当 <code>packageJSON</code> 的类型从 <code>unknown</code> 细化为 <code>object</code> 类型后，
<code>in</code> 运算符会严格地将类型细化为包含了所检查属性的某个类型。
因此，<code>packageJSON</code> 的类型仍为 <code>object</code>。</p>
<p>TypeScript 4.9 增强了 <code>in</code> 运算符的类型细化功能，它能够更好地处理没有列出属性的类型。
现在 TypeScript 不是什么也不做，而是将其类型与 <code>Record&lt;"property-key-being-checked", unknown&gt;</code> 进行类型交叉运算。</p>
<p>因此在上例中，<code>packageJSON</code> 的类型将从 <code>unknown</code> 细化为 <code>object</code> 再细化为 <code>object &amp; Record&lt;"name", unknown&gt;</code>。
这样就允许我们访问并细化类型 <code>packageJSON.name</code>。</p>
<pre><code class="language-ts">interface Context {
    packageJSON: unknown;
}

function tryGetPackageName(context: Context): string | undefined {
    const packageJSON = context.packageJSON;
    // Check to see if we have an object.
    if (packageJSON &amp;&amp; typeof packageJSON === "object") {
        // Check to see if it has a string name property.
        if ("name" in packageJSON &amp;&amp; typeof packageJSON.name === "string") {
            // Just works!
            return packageJSON.name;
        }
    }

    return undefined;
}
</code></pre>
<p>TypeScript 4.9 还会严格限制 <code>in</code> 运算符的使用，以确保左侧的操作数能够赋值给 <code>string | number | symbol</code>，右侧的操作数能够赋值给 <code>object</code>。
它有助于检查是否使用了合法的属性名，以及避免在原始类型上进行检查。</p>
<p>更多详情请查看 <a href="https://github.com/microsoft/TypeScript/pull/50666">PR</a>.</p>
<h2 id="类中的自动存取器"><a class="header" href="#类中的自动存取器">类中的自动存取器</a></h2>
<p>TypeScript 4.9 支持了 ECMAScript 即将引入的“自动存取器”功能。
自动存取器的声明如同定义一个类的属性，只不过是需要使用 <code>accessor</code> 关键字。</p>
<pre><code class="language-ts">class Person {
    accessor name: string;

    constructor(name: string) {
        this.name = name;
    }
}
</code></pre>
<p>在底层实现中，自动存取器会被展开为 <code>get</code> 和 <code>set</code> 存取器，以及一个无法访问的私有成员。</p>
<pre><code class="language-ts">class Person {
    #__name: string;

    get name() {
        return this.#__name;
    }
    set name(value: string) {
        this.#__name = name;
    }

    constructor(name: string) {
        this.name = name;
    }
}
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/49705">PR</a>。</p>
<h2 id="在-nan-上的相等性检查"><a class="header" href="#在-nan-上的相等性检查">在 <code>NaN</code> 上的相等性检查</a></h2>
<p>在 JavaScript 中，你无法使用内置的相等运算符去检查某个值是否等于 <code>NaN</code>。</p>
<p>由于一些原因，<code>NaN</code> 是个特殊的数值，它代表 <code>不是一个数字</code>。
没有值等于 <code>NaN</code>，包括 <code>NaN</code> 自己！</p>
<pre><code class="language-ts">console.log(NaN == 0)  // false
console.log(NaN === 0) // false

console.log(NaN == NaN)  // false
console.log(NaN === NaN) // false
</code></pre>
<p>换句话说，任何值都不等于 <code>NaN</code>。</p>
<pre><code class="language-ts">console.log(NaN != 0)  // true
console.log(NaN !== 0) // true

console.log(NaN != NaN)  // true
console.log(NaN !== NaN) // true
</code></pre>
<p>从技术上讲，这不是 JavaScript 独有的问题，任何使用 IEEE-754 浮点数的语言都有一样的问题；
但是 JavaScript 中主要的数值类型为浮点数，并且解析数值时经常会得到 <code>NaN</code>。
因此，检查 <code>NaN</code> 是很常见的操作，正确的方法是使用 <code>Number.isNaN</code> 函数 -
但像上文提到的，很多人可能不小心地使用了 <code>someValue === NaN</code> 来进行检查。</p>
<p>现在，如果 TypeScript 发现直接比较 <code>NaN</code> 会报错，并提示使用 <code>Number.isNaN</code>。</p>
<pre><code class="language-ts">function validate(someValue: number) {
    return someValue !== NaN;
    //     ~~~~~~~~~~~~~~~~~
    // error: This condition will always return 'true'.
    //        Did you mean '!Number.isNaN(someValue)'?
}
</code></pre>
<p>我们确信这个改动会帮助捕获初级的错误，就如同 TypeScript 也会检查比较对象字面量和数组字面量一样。</p>
<p>感谢 <a href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a> 提交的 <a href="https://github.com/microsoft/TypeScript/pull/50626">PR</a>。</p>
<h2 id="监视文件功能使用文件系统事件"><a class="header" href="#监视文件功能使用文件系统事件">监视文件功能使用文件系统事件</a></h2>
<p>在先前的版本中，TypeScript 主要依靠<em>轮询</em>来监视每个文件。
使用轮询的策略意味着定期检查文件是否有更新。
在 Node.js 中，<code>fs.watchFile</code> 是内置的使用轮询来检查文件变动的方法。
虽说轮询在跨操作系统和文件系统的情况下更稳妥，但是它也意味着 CPU 会定期地被中断，转而去检查是否有文件更新即便在没有任何改动的情况下。
这在只有少数文件的时候问题不大，但如果工程包含了大量文件 - 或 <code>node_modules</code> 里有大量的文件 - 就会变得非常吃资源。</p>
<p>通常来讲，更好的做法是使用文件系统事件。
做为轮询的替换，我们声明对某些文件的变动感兴趣并提供回调函数用于处理有改动的文件。
大多数现代的平台提供了如 <code>CreateIoCompletionPort</code>、<code>kqueue</code>、<code>epoll</code> 和 <code>inotify</code> API。
Node.js 对这些 API 进行了抽象，提供了 <code>fs.watch</code> API。
文件系统事件通常可以很好地工作，但是也存在一些注意事项。
一个 watcher 需要考虑 <a href="https://nodejs.org/docs/latest-v18.x/api/fs.html#inodes">inode watching</a>的问题、
<a href="https://nodejs.org/docs/latest-v18.x/api/fs.html#availability">在一些文件系统上不可用</a>的问题（比如：网络文件系统）、
嵌套的文件监控是否可用、重命名目录是否触发事件以及可用 file watcher 耗尽的问题！
换句话说，这件事不是那么容易做的，特别是我们还需要跨平台。</p>
<p>因此，过去我们的默认选择是普遍好用的方式：轮询。
虽不总是，但大部分时候是这样的。</p>
<p>后来，我们提供了<a href="https://www.typescriptlang.org/docs/handbook/configuring-watch.html">选择文件监视策略的方法</a>。
这让我们收到了很多使用反馈并改善跨平台的问题。
由于 TypeScript 必须要能够处理大规模的代码并且也已经有了改进，因此我们觉得切换到使用文件系统事件是件值得做的事情。</p>
<p>在 TypeScript 4.9 中，文件监视已经默认使用文件系统事件的方式，仅当无法初始化事件监视时才回退到轮询。
对大部分开发者来讲，在使用 <code>--watch</code> 模式或在 Visual Studio、VS Code 里使用 TypeScript 时会极大降低资源的占用。</p>
<p><a href="https://www.typescriptlang.org/docs/handbook/configuring-watch.html">文件监视方式仍然是可以配置的</a>，可以使用环境变量和 <code>watchOptions</code> - 像 <a href="https://code.visualstudio.com/docs/getstarted/settings#:~:text=typescript%2etsserver%2ewatchOptions">VS Code 这样的编辑器还支持单独配置</a>。
如果你的代码使用的是网络文件系统（如 NFS 和 SMB）就需要回退到旧的行为；
但如果服务器有强大的处理能力，最好是启用 SSH 并且通过远程运行 TypeScript，这样就可以使用本地文件访问。
VS Code 支持了很多<a href="https://marketplace.visualstudio.com/search?term=remote&amp;target=VSCode&amp;category=All%20categories&amp;sortBy=Relevance">远程开发</a>的工具。</p>
<h2 id="编辑器中的删除未使用导入和排序导入命令"><a class="header" href="#编辑器中的删除未使用导入和排序导入命令">编辑器中的“删除未使用导入”和“排序导入”命令</a></h2>
<p>以前，TypeScript 仅支持两个管理导入语句的编辑器命令。
拿下面的代码举例：</p>
<pre><code class="language-ts">import { Zebra, Moose, HoneyBadger } from "./zoo";
import { foo, bar } from "./helper";

let x: Moose | HoneyBadger = foo();
</code></pre>
<p>第一个命令是 “组织导入语句”，它会删除未使用的导入并对剩下的条目排序。
因此会将上面的代码重写为：</p>
<pre><code class="language-ts">import { foo } from "./helper";
import { HoneyBadger, Moose } from "./zoo";

let x: Moose | HoneyBadger = foo();
</code></pre>
<p>在 TypeScript 4.3 中，引入了“排序导入语句”命令，它仅排序导入语句但不进行删除，因此会将上例代码重写为：</p>
<pre><code class="language-ts">import { bar, foo } from "./helper";
import { HoneyBadger, Moose, Zebra } from "./zoo";

let x: Moose | HoneyBadger = foo();
</code></pre>
<p>使用“排序导入语句”的注意事项是，在 VS Code 中该命令只能在保存文件时触发，而非能够手动执行的命令。</p>
<p>TypeScript 4.9 添加了另一半功能，提供了“移除未使用的导入”功能。
TypeScript 会移除未使用的导入命名和语句，但是不能改变当前的排序。</p>
<pre><code class="language-ts">import { Moose, HoneyBadger } from "./zoo";
import { foo } from "./helper";

let x: Moose | HoneyBadger = foo();
</code></pre>
<p>该功能对任何编译器都是可用的；
但要注意的是，VS Code (1.73+) 会内置这个功能并且可以使用 <code>Command Pallette</code> 来执行。
如果用户想要使用更细的“移除未使用的导入”或“排序导入”命令，那么可以将“组织导入”的快捷键绑定到这些命令上。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/50931">这里</a>。</p>
<h2 id="在-return-关键字上使用跳转到定义"><a class="header" href="#在-return-关键字上使用跳转到定义">在 <code>return</code> 关键字上使用跳转到定义</a></h2>
<p>在编辑器中，当在 <code>return</code> 关键字上使用跳转到定义功能时，TypeScript 会跳转到函数的顶端。
这会帮助理解 <code>return</code> 语句是属于哪个函数的。</p>
<p>我们期待这个功能扩展到更多的关键字上，例如 <code>await</code> 和 <code>yield</code> 或者 <code>switch</code>、<code>case</code> 和 <code>default</code>。
感谢<a href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a>的<a href="https://github.com/microsoft/TypeScript/pull/51227">实现</a>。</p>
<h2 id="性能优化"><a class="header" href="#性能优化">性能优化</a></h2>
<p>TypeScript 进行了一些较小的但是能觉察到的性能优化。</p>
<p>首先，重写了 TypeScript 的 <code>forEachChild</code> 函数使用函数查找表代替 <code>switch</code> 语句。
<code>forEachChild</code> 是编译器在遍历语法节点时会反复调用的函数，和部分语言服务一起大量地被使用在编译绑定阶段。
对 <code>forEachChild</code> 函数的重构减少了绑定阶段和语言服务操作的 20% 时间消耗。</p>
<p>当我们看到了 <code>forEachChild</code> 的效果后也在 <code>visitEachChild</code>（在编译器和语言服务中用来变换节点的函数）上进行了类似的优化。
同样的重构减少了 3% 生成工程输出的时间消耗。</p>
<p>对于 <code>forEachChild</code> 的优化最初是受到了 <a href="https://artemis.sh/">Artemis Everfree</a> <a href="https://artemis.sh/2022/08/07/emulating-calculators-fast-in-js.html">文章</a>的启发。
虽说我们认为速度提升的根本原因是由于函数体积和复杂度的降低而非这篇文章里提到的问题，但我们非常感谢能够从中获得经验并快速地进行重构让 TypeScript 运行得更快。</p>
<p>最后，TypeScript 还优化了在条件类型的 <code>true</code> 分支中保留类型信息。
例如：</p>
<pre><code class="language-ts">interface Zoo&lt;T extends Animal&gt; {
    // ...
}

type MakeZoo&lt;A&gt; = A extends Animal ? Zoo&lt;A&gt; : never;
</code></pre>
<p>TypeScript 在检查 <code>Zoo&lt;A&gt;</code>时需要记住 <code>A</code> 是 <code>Animal</code>。
TypeScript 通过新建 <code>A</code> 和 <code>Animal</code> 的交叉类型来保留该信息；
然而，TypeScript 之前采用的是即时求值的方式，即便有时是不需要的。
而且类型检查器中的一些问题代码使得这些类型无法被简化。
TypeScript 现在会推迟类型交叉操作直到真的有需要的时候。
对于大量地使用了有条件类型的代码来说，你会觉察到大幅的提速，但从我们的性能测试结果来看却只看到了 3% 的类型检查性能提升。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-48"><a class="header" href="#typescript-48">TypeScript 4.8</a></h1>
<h2 id="改进的交叉类型化简联合类型兼容性以及类型细化"><a class="header" href="#改进的交叉类型化简联合类型兼容性以及类型细化">改进的交叉类型化简、联合类型兼容性以及类型细化</a></h2>
<p>TypeScript 4.8 为 <code>--strictNullChecks</code> 带来了一系列修正和改进。
这些变化会影响交叉类型和联合类型的工作方式，也作用于 TypeScript 的类型细化。</p>
<p>例如，<code>unknown</code> 与 <code>{} | null | undefined</code> 类型神似，
因为它接受 <code>null</code>，<code>undefined</code> 以及任何其它类型。
TypeScript 现在能够识别出这种情况，允许将 <code>unknown</code> 赋值给 <code>{} | null | undefined</code>。</p>
<blockquote>
<p>译者注：除 <code>null</code> 和 <code>undefined</code> 类型外，其它任何类型都可以赋值给 <code>{}</code> 类型。</p>
</blockquote>
<pre><code class="language-ts">function f(x: unknown, y: {} | null | undefined) {
    x = y; // 可以工作
    y = x; // 以前会报错，现在可以工作
}
</code></pre>
<p>另一个变化是 <code>{}</code> 与任何其它对象类型交叉会得到那个对象类型。
因此，我们可以重写 <code>NonNullable</code> 类型为与 <code>{}</code> 的交叉类型，
因为 <code>{} &amp; null</code> 和 <code>{} &amp; undefined</code> 会被消掉。</p>
<pre><code class="language-diff">- type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;
+ type NonNullable&lt;T&gt; = T &amp; {};
</code></pre>
<p>之所以称其为一项改进，是因为交叉类型可以被化简和赋值了，
而有条件类型目前是不支持的。
因此，<code>NonNullable&lt;NonNullable&lt;T&gt;&gt;</code> 至少可以简化为 <code>NonNullable&lt;T&gt;</code>，在以前这是不行的。</p>
<pre><code class="language-ts">function foo&lt;T&gt;(x: NonNullable&lt;T&gt;, y: NonNullable&lt;NonNullable&lt;T&gt;&gt;) {
    x = y; // 一直没问题
    y = x; // 以前会报错，现在没问题
}
</code></pre>
<p>这些变化还为我们带来了更合理的控制流分析和类型细化。
比如，<code>unknown</code> 在条件为“真”的分支中被细化为 <code>{} | null | undefined</code>。</p>
<pre><code class="language-ts">function narrowUnknownishUnion(x: {} | null | undefined) {
    if (x) {
        x;  // {}
    }
    else {
        x;  // {} | null | undefined
    }
}

function narrowUnknown(x: unknown) {
    if (x) {
        x;  // 以前是 'unknown'，现在是 '{}'
    }
    else {
        x;  // unknown
    }
}
</code></pre>
<p>泛型也会进行类似的细化。
当检查一个值不为 <code>null</code> 或 <code>undefined</code> 时，
TypeScript 会将其与 <code>{}</code> 进行交叉 - 等同于使用 <code>NonNullable</code>。
把所有变化放在一起，我们就可以在不使用类型断言的情况下定义下列函数。</p>
<pre><code class="language-ts">function throwIfNullable&lt;T&gt;(value: T): NonNullable&lt;T&gt; {
    if (value === undefined || value === null) {
        throw Error("Nullable value!");
    }

    // 以前会报错，因为 'T' 不能赋值给 'NonNullable&lt;T&gt;'。
    // 现在会细化为 'T &amp; {}' 并且不报错，因为它等同于 'NonNullable&lt;T&gt;'。
    return value;
}
</code></pre>
<p><code>value</code> 细化为了 <code>T &amp; {}</code>，此时它与 <code>NonNullable&lt;T&gt;</code> 等同 -
因此在函数体中不再需要使用 TypeScript 的特定语法。</p>
<p>就该改进本身而言可能是一个很小的变化 - 但它却实实在在地修复了在过去几年中报告的大量问题。</p>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/49119">这里</a>。</p>
<h2 id="改进模版字符串类型中-infer-类型的类型推断"><a class="header" href="#改进模版字符串类型中-infer-类型的类型推断">改进模版字符串类型中 <code>infer</code> 类型的类型推断</a></h2>
<p>近期，TypeScript 支持了在有条件类型中的 <code>infer</code> 类型变量上添加 <code>extends</code> 约束。</p>
<pre><code class="language-ts">// 提取元组类型中的第一个元素，若其能够赋值给 'number'，
// 返回 'never' 若无这样的元素。
type TryGetNumberIfFirst&lt;T&gt; =
    T extends [infer U extends number, ...unknown[]] ? U : never;
</code></pre>
<p>若 <code>infer</code> 类型出现在模版字符串类型中且被原始类型所约束，则 TypeScript 会尝试将其解析为字面量类型。</p>
<pre><code class="language-ts">// SomeNum 以前是 'number'；现在是 '100'。
type SomeNum = "100" extends `${infer U extends number}` ? U : never;

// SomeBigInt 以前是 'bigint'；现在是 '100n'。
type SomeBigInt = "100" extends `${infer U extends bigint}` ? U : never;

// SomeBool 以前是 'boolean'；现在是 'true'。
type SomeBool = "true" extends `${infer U extends boolean}` ? U : never;
</code></pre>
<p>现在它能更好地表达代码库在运行时的行为，提供更准确的类型。</p>
<p>要注意的一点是当 TypeScript 解析这些字面量类型时会使用贪心策略，尽可能多地提取原始类型；
然后再回头检查解析出的原始类型是否匹配字符串的内容。
也就是说，TypeScript 检查从字符串到原始类型再到字符串是否匹配。
如果发现字符串前后对不上了，那么回退到基本的原始类型。</p>
<pre><code class="language-ts">// JustNumber 为 `number` 因为 TypeScript 解析 出 `"1.0"`，但 `String(Number("1.0"))` 为 `"1"` 不匹配。
type JustNumber = "1.0" extends `${infer T extends number}` ? T : never; 
</code></pre>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/48094">这里</a>。</p>
<h2 id="--build---watch-和---incremental-的性能优化"><a class="header" href="#--build---watch-和---incremental-的性能优化"><code>--build</code>, <code>--watch</code>, 和 <code>--incremental</code> 的性能优化</a></h2>
<p>TypeScript 4.8 优化了使用 <code>--watch</code> 和 <code>--incremental</code> 时的速度，以及使用 <code>--build</code> 构建工程引用时的速度。
例如，现在在 <code>--watch</code> 模式下 TypeScript 不会去更新未改动文件的时间戳，
这使得重新构建更快，避免与其它监视 TypeScript 输出文件的构建工具之间产生干扰。
此外，TypeScript 也能够重用 <code>--build</code>, <code>--watch</code> 和 <code>--incremental</code> 之间的信息。</p>
<p>这些优化有多大效果？在一个相当大的代码库上，对于简单常用的操作有 10%-25% 的改进，对于无改动操作的场景节省了 40% 的时间。
在 TypeScript 代码库中我们也看到了相似的结果。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/48784">这里</a>。</p>
<h2 id="比较对象和数组字面量时报错"><a class="header" href="#比较对象和数组字面量时报错">比较对象和数组字面量时报错</a></h2>
<p>在许多语言中，<code>==</code> 操作符在对象上比较的是“值”。
例如，在 Python 语言中想检查列表是否为空时可以使用 <code>==</code> 检查该值是否与空列表相等。</p>
<pre><code class="language-py">if people_at_home == []:
    print("that's where she lies, broken inside. &lt;/3")
</code></pre>
<p>在 JavaScript 里却不是这样，使用 <code>==</code> 和 <code>===</code> 比较对象和数组时比较的是引用。
我们确信这会让 JavaScript 程序员搬起石头砸自己脚，且最坏的情况是在生产环境中存在 bug。
因此，TypeScript 现在不允许如下的代码：</p>
<pre><code class="language-ts">let peopleAtHome = [];

if (peopleAtHome === []) {
//  ~~~~~~~~~~~~~~~~~~~
// This condition will always return 'false' since JavaScript compares objects by reference, not value.
    console.log("that's where she lies, broken inside. &lt;/3")
}
</code></pre>
<p>非常感谢<a href="https://github.com/Jack-Works">Jack Works</a>的贡献。
更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/45978">这里</a>。</p>
<h2 id="改进从绑定模式中进行类型推断"><a class="header" href="#改进从绑定模式中进行类型推断">改进从绑定模式中进行类型推断</a></h2>
<p>在某些情况下，TypeScript 会从绑定模式中获取类型来帮助类型推断。</p>
<pre><code class="language-ts">declare function chooseRandomly&lt;T&gt;(x: T, y: T): T;

let [a, b, c] = chooseRandomly([42, true, "hi!"], [0, false, "bye!"]);
//   ^  ^  ^
//   |  |  |
//   |  |  string
//   |  |
//   |  boolean
//   |
//   number
</code></pre>
<p>当 <code>chooseRandomly</code> 需要确定 <code>T</code> 的类型时，它主要检查 <code>[42, true, "hi!"]</code> 和 <code>[0, false, "bye!"]</code>;
但 TypeScript 还需要确定这两个类型是 <code>Array&lt;number | boolean | string&gt;</code>
还是 <code>[number, boolean, string]</code>。
为此，它会检查当前类型推断候选列表中是否存在元组类型。
当 TypeScript 看到了绑定模式 <code>[a, b, c]</code>，它创建了类型 <code>[any, any, any]</code>，
该类型会被加入到 <code>T</code> 的候选列表（作为推断 <code>[42, true, "hi!"]</code> 和 <code>[0, false, "bye!"]</code> 的参考）但优先级较低。</p>
<p>这对 <code>chooseRandomly</code> 函数来讲不错，但在有些情况下不合适。例如：</p>
<pre><code class="language-ts">declare function f&lt;T&gt;(x?: T): T;

let [x, y, z] = f();
</code></pre>
<p>绑定模式 <code>[x, y, z]</code> 提示 <code>f</code> 应该输出 <code>[any, any, any]</code> 元组；
但是 <code>f</code> 不应该根据绑定模式来改变类型参数的类型。
它不应该像变戏法一样根据被赋的值突然变成一个类数组的值，
因此绑定模式过多地影响到了生成的类型。
由于绑定模式中均为 <code>any</code> 类型，因此我们也就让 <code>x</code>，<code>y</code> 和 <code>z</code> 为 <code>any</code> 类型。</p>
<p>在 TypeScript 4.8 里，绑定模式不会成为类型参数的候选类型。
它们仅在参数需要更确切的类型时提供参考，例如 <code>chooseRandomly</code> 的情况。
如果你想回到之前的行为，可以提供明确的类型参数。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/49086">这里</a>。</p>
<h2 id="修复文件监视尤其是在-git-checkout-之间"><a class="header" href="#修复文件监视尤其是在-git-checkout-之间">修复文件监视（尤其是在 <code>git checkout</code> 之间）</a></h2>
<p>长久以来 TypeScript 中存在一个 bug，它对在编辑器中使用 <code>--watch</code> 模式监视文件改动处理的不好。
它有时表现为错误提示不准确，需要重启 <code>tsc</code> 或 VS Code 才行。
这在 Unix 系统上常发生，例如用 vim 保存了一个文件或切换了 git 的分支。</p>
<p>这是因为错误地假设了 Node.js 在不同文件系统下处理文件重命名的方式。
Linux 和 macOS 使用 <a href="https://en.wikipedia.org/wiki/Inode">inodes</a>，
<a href="https://nodejs.org/api/fs.html#inodes">Node.js 监视的是 inodes 的变化而非文件路径</a>。
因此，当 Node.js 返回了 <a href="https://nodejs.org/api/fs.html#class-fsfswatcher">watcher 对象</a>，
根据平台和文件系统的不同，它即可能监视文件路径也可能是 inode。</p>
<p>为了高效，TypeScript 尝试重用 watcher 对象，如果它检测到文件路径仍存在于磁盘上。
这里就产生了问题，因为即使给定路径上的文件仍然存在，但它可能是全新创建的文件，inode 已经发生了变化。
TypeScript 重用了 watcher 对象而非重新创建一个 watcher 对象，因此可能监视了一个完全不相关的文件。
TypeScript 4.8 能够在 inode 系统上处理这些情况，新建 watcher 对象。</p>
<p>非常感谢 <a href="https://github.com/MarcCelani-at">Marc Celani</a> 和他的团队的贡献。
更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/48997">这里</a>。</p>
<h2 id="查找所有引用性能优化"><a class="header" href="#查找所有引用性能优化">查找所有引用性能优化</a></h2>
<p>在编辑器中执行“查找所有引用”时，TypeScript 现在能够更智能地聚合引用。
在 TypeScript 自己的代码库中去搜索一个广泛使用的标识符时能够减少 20% 时间。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/49581">这里</a>。</p>
<h2 id="从自动导入中排除指定文件"><a class="header" href="#从自动导入中排除指定文件">从自动导入中排除指定文件</a></h2>
<p>TypeScript 4.8 增加了一个编辑器首选项从自动导入中排除指定文件。
在 Visual Studio Code 里，可以将文件名和 globs 添加到 Settings UI 的 “Auto Import File Exclude Patterns” 下，或者 <code>.vscode/settings.json</code> 文件中：</p>
<pre><code class="language-json">{
    // Note that `javascript.preferences.autoImportFileExcludePatterns` can be specified for JavaScript too.
    "typescript.preferences.autoImportFileExcludePatterns": [
      "**/node_modules/@types/node"
    ]
}
</code></pre>
<p>如果你想避免导入某些模块或代码库，它个功能就派上用场了。
有些模块可能有过多的导出以致于影响到了自动导入功能，让我们难以选择一条自动导入。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/49578">这里</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-47"><a class="header" href="#typescript-47">TypeScript 4.7</a></h1>
<h2 id="nodejs-对-ecmascript-module-的支持"><a class="header" href="#nodejs-对-ecmascript-module-的支持">Node.js 对 ECMAScript Module 的支持</a></h2>
<p>在过去的几年中，Node.js 为支持 ECMAScript 模块（ESM）而做了一些工作。
这是一项有难度的工作，因为 Node.js 生态圈是基于 CommonJS（CJS）模块系统构建的，而非 ESM。
支持两者之间的互操作带来了巨大挑战，有大量的特性需要考虑；
然而，在 Node.js 12 及以上版本中，已经提供了对 ESM 的大部分支持。
在 TypeScript 4.5 期间的一个 nightly 版本中支持了在 Node.js 里使用 ESM 以获得用户反馈，
同时让代码库作者们有时间为此提前作准备。</p>
<p>TypeScript 4.7 正式地支持了该功能，它添加了两个新的 <code>module</code> 选项：<code>node16</code> 和<code>nodenext</code>。</p>
<pre><code class="language-json">{
    "compilerOptions": {
        "module": "node16",
    }
}
</code></pre>
<p>这些新模式带来了一些高级特征，下面将一一介绍。</p>
<h3 id="packagejson-里的-type-字段和新的文件扩展名"><a class="header" href="#packagejson-里的-type-字段和新的文件扩展名"><code>package.json</code> 里的 <code>type</code> 字段和新的文件扩展名</a></h3>
<p>Node.js 在 <a href="https://nodejs.org/api/packages.html#packages_package_json_and_file_extensions">package.json 中支持了一个新的设置</a>，叫做 <code>type</code>。
<code>"type"</code> 可以被设置为 <code>"module"</code> 或者 <code>"commonjs"</code>。</p>
<pre><code class="language-json">{
    "name": "my-package",
    "type": "module",

    "//": "...",
    "dependencies": {
    }
}
</code></pre>
<p>这些设置会控制 <code>.js</code> 文件是作为 ESM 进行解析还是作为 CommonJS 模块进行解析，
若没有设置，则默认值为 CommonJS。
当一个文件被当做 ESM 模块进行解析时，会使用如下与 CommonJS 模块不同的规则：</p>
<ul>
<li>允许使用 <code>import</code> / <code>export</code> 语句</li>
<li>允许使用顶层的 <code>await</code></li>
<li>相对路径导入必须提供完整的扩展名（需要使用 <code>import "./foo.js"</code> 而非 <code>import "./foo"</code>）</li>
<li>解析 <code>node_modules</code> 里的依赖可能不同</li>
<li>不允许直接使用像 <code>require</code> 和 <code>module</code> 这样的全局值</li>
<li>需要使用特殊的规则来导入 CommonJS 模块</li>
</ul>
<p>我们回头会介绍其中一部分。</p>
<p>为了让 TypeScript 融入该系统，<code>.ts</code> 和 <code>.tsx</code> 文件现在也以同样的方式工作。
当 TypeScript 遇到 <code>.ts</code>，<code>.tsx</code>，<code>.js</code> 或 <code>.jsx</code> 文件时，
它会向上查找 <code>package.json</code> 来确定该文件是否使用了 ESM，然后再以此决定：</p>
<ul>
<li>如何查找该文件所导入的其它模块</li>
<li>当需要产生输出的时，如何转换该文件</li>
</ul>
<p>当一个 <code>.ts</code> 文件被编译为 ESM 时，ECMAScript <code>import</code> / <code>export</code> 语句在生成的 <code>.js</code> 文件中原样输出；
当一个 <code>.ts</code> 文件被编译为 CommonJS 模块时，则会产生与使用了 <code>--module commonjs</code> 选项一致的输出结果。</p>
<p>这也意味着 ESM 和 CJS 模块中的 <code>.ts</code> 文件路径解析是不同的。
例如，现在有如下的代码：</p>
<pre><code class="language-ts">// ./foo.ts
export function helper() {
    // ...
}

// ./bar.ts
import { helper } from "./foo"; // only works in CJS

helper();
</code></pre>
<p>这段代码在 CommonJS 模块里没问题，但在 ESM 里会出错，因为相对导入需要使用完整的扩展名。
因此，我们不得不重写代码并使用 <code>foo.ts</code> 输出文件的扩展名，<code>bar.ts</code> 必须从 <code>./foo.js</code> 导入。</p>
<pre><code class="language-ts">// ./bar.ts
import { helper } from "./foo.js"; // works in ESM &amp; CJS

helper();
</code></pre>
<p>初看可能感觉很繁琐，但 TypeScript 的自动导入工具以及路径补全工具会有所帮助。</p>
<p>此外还需要注意的是该行为同样适用于 <code>.d.ts</code> 文件。
当 TypeScript 在一个 package 里找到了 <code>.d.ts</code> 文件，它会基于这个 package 来解析 <code>.d.ts</code> 文件。</p>
<h3 id="新的文件扩展名"><a class="header" href="#新的文件扩展名">新的文件扩展名</a></h3>
<p><code>package.json</code> 文件里的 <code>type</code> 字段让我们可以继续使用 <code>.ts</code> 和 <code>.js</code> 文件扩展名；
但你可能偶尔需要编写与 <code>type</code> 设置不符的文件，或者更喜欢明确地表达意图。</p>
<p>为此，Node.js 支持了两个文件扩展名：<code>.mjs</code> 和 <code>.cjs</code>。
<code>.mjs</code> 文件总是使用 ESM，而 <code>.cjs</code> 则总是使用 CommonJS 模块，
它们分别会生成 <code>.mjs</code> 和<code>.cjs</code> 文件。</p>
<p>正因此，TypeScript 也支持了两个新的文件扩展名：<code>.mts</code> 和 <code>.cts</code>。
当 TypeScript 生成 JavaScript 文件时，将生成 <code>.mjs</code> 和<code>.cjs</code>。</p>
<p>TypeScript 还支持了两个新的声明文件扩展名：<code>.d.mts</code> 和 <code>.d.cts</code>。
当 TypeScript 为 <code>.mts</code> 和 <code>.cts</code> 生成声明文件时，对应的扩展名为 <code>.d.mts</code> 和 <code>.d.cts</code>。</p>
<p>这些扩展名的使用完全是可选的，但通常是有帮助的，不论它们是不是你工作流中的一部分。</p>
<h3 id="commonjs-互操作性"><a class="header" href="#commonjs-互操作性">CommonJS 互操作性</a></h3>
<p>Node.js 允许 ESM 导入 CommonJS 模块，就如同它们是带有默认导出的 ESM。</p>
<pre><code class="language-ts">// ./foo.cts
export function helper() {
    console.log("hello world!");
}

// ./bar.mts
import foo from "./foo.cjs";

// prints "hello world!"
foo.helper();
</code></pre>
<p>在某些情况下，Node.js 会综合和合成 CommonJS 模块里的命名导出，这提供了便利。
此时，ESM 既可以使用“命名空间风格”的导入（例如，<code>import * as foo from "..."</code>），
也可以使用命名导入（例如，<code>import { helper } from "..."</code>）。</p>
<pre><code class="language-ts">// ./foo.cts
export function helper() {
    console.log("hello world!");
}

// ./bar.mts
import { helper } from "./foo.cjs";

// prints "hello world!"
helper();
</code></pre>
<p>有时候 TypeScript 不知道命名导入是否会被综合合并，但如果 TypeScript 能够通过确定地 CommonJS 模块导入了解到该信息，那么就会提示错误。</p>
<p>关于互操作性，TypeScript 特有的注意点是如下的语法：</p>
<pre><code class="language-ts">import foo = require("foo");
</code></pre>
<p>在 CommonJS 模块中，它可以归结为 <code>require()</code> 调用，
在 ESM 里，它会导入 <a href="https://nodejs.org/api/module.html#module_module_createrequire_filename">createRequire</a> 来完成同样的事情。
对于像浏览器这样的平台（不支持 <code>require()</code>）这段代码的可移植性较差，但对互操作性是有帮助的。
你可以这样改写：</p>
<pre><code class="language-ts">// ./foo.cts
export function helper() {
    console.log("hello world!");
}

// ./bar.mts
import foo = require("./foo.cjs");

foo.helper()
</code></pre>
<p>最后值得注意的是在 CommonJS 模块里导入 ESM 的唯一方法是使用动态 <code>import()</code> 调用。
这也许是一个挑战，但也是目前 Node.js 的行为。</p>
<p>更多详情，请阅读<a href="https://nodejs.org/api/esm.html#esm_interoperability_with_commonjs">这里</a>。</p>
<h3 id="packagejson-中的-exports-imports-以及自引用"><a class="header" href="#packagejson-中的-exports-imports-以及自引用">package.json 中的 <code>exports</code>, <code>imports</code> 以及自引用</a></h3>
<p>Node.js 在 <code>package.json</code> 支持了一个新的字段 <a href="https://nodejs.org/api/packages.html#packages_exports"><code>exports</code></a> 来定义入口位置。
它比在 <code>package.json</code> 里定义 <code>"main"</code> 更强大，它能控制将包里的哪些部分公开给使用者。</p>
<p>下例的 <code>package.json</code> 支持对 CommonJS 和 ESM 使用不同的入口位置：</p>
<pre><code class="language-json">// package.json
{
    "name": "my-package",
    "type": "module",
    "exports": {
        ".": {
            // Entry-point for `import "my-package"` in ESM
            "import": "./esm/index.js",

            // Entry-point for `require("my-package") in CJS
            "require": "./commonjs/index.cjs",
        },
    },

    // CJS fall-back for older versions of Node.js
    "main": "./commonjs/index.cjs",
}
</code></pre>
<p>关于该特性的更多详情请阅读<a href="https://nodejs.org/api/packages.html">这里</a>。
下面我们主要关注 TypeScript 是如何支持它的。</p>
<p>在以前 TypeScript 会先查找 <code>"main"</code> 字段，然后再查找其对应的声明文件。
例如，如果 <code>"main"</code> 指向了 <code>./lib/index.js</code>，
TypeScript 会查找名为 <code>./lib/index.d.ts</code> 的文件。
代码包作者可以使用 <code>"types"</code> 字段来控制该行为（例如，<code>"types": "./types/index.d.ts"</code>）。</p>
<p>新实现的工作方式与<a href="https://nodejs.org/api/packages.html">导入条件</a>相似。
默认地，TypeScript 使用与<strong>导入条件</strong>相同的规则 -
对于 ESM 里的 <code>import</code> 语句，它会查找 <code>import</code> 字段；
对于 CommonJS 模块里的 <code>import</code> 语句，它会查找 <code>require</code> 字段。
如果找到了文件，则去查找相应的声明文件。
如果你想将声明文件指向其它位置，则可以添加一个 <code>"types"</code> 导入条件。</p>
<pre><code class="language-json">// package.json
{
    "name": "my-package",
    "type": "module",
    "exports": {
        ".": {
            // Entry-point for `import "my-package"` in ESM
            "import": {
                // Where TypeScript will look.
                "types": "./types/esm/index.d.ts",

                // Where Node.js will look.
                "default": "./esm/index.js"
            },
            // Entry-point for `require("my-package") in CJS
            "require": {
                // Where TypeScript will look.
                "types": "./types/commonjs/index.d.cts",

                // Where Node.js will look.
                "default": "./commonjs/index.cjs"
            },
        }
    },

    // Fall-back for older versions of TypeScript
    "types": "./types/index.d.ts",

    // CJS fall-back for older versions of Node.js
    "main": "./commonjs/index.cjs"
}
</code></pre>
<p><strong>注意</strong>，<code>"types"</code> 条件在 <code>"exports"</code> 中需要被放在开始的位置。</p>
<p>TypeScript 也支持 <code>package.json</code> 里的 <a href="https://nodejs.org/api/packages.html#packages_imports"><code>"imports"</code></a> 字段，它与查找声明文件的工作方式类似。
此外，还支持<a href="https://nodejs.org/api/packages.html#packages_self_referencing_a_package_using_its_name">一个包引用它自己</a>。
这些特性通常不特殊设置，但是是支持的。</p>
<h2 id="设置模块检测策略"><a class="header" href="#设置模块检测策略">设置模块检测策略</a></h2>
<p>在 JavaScript 中引入模块带来的一个问题是让“Script”代码和新的模块代码之间的界限变得模糊。
（译者注：对于任意一段 JavaScript 代码，它的类型只能为 “Script” 或 “Module” 两者之一，它们是 ECMAScript 语言规范中定义的术语。）
模块中的 JavaScript 存在些许不同的执行方式和作用域规则，因此工具们需要确定每个文件的执行方式。
例如，Node.js 要求模块入口脚本是一个 <code>.mjs</code> 文件，或者它有一个邻近的 <code>package.json</code> 文件且带有 <code>"type": "module"</code>。
TypeScript 的规则则是如果一个文件里存在 <code>import</code> 或 <code>export</code> 语句，那么它是模块文件；
反之会把 <code>.ts</code> 和 <code>.js</code> 文件当作是 “Script” 文件，它们存在于<strong>全局作用域</strong>。</p>
<p>这与 Node.js 中对 <code>package.json</code> 的处理行为不同，因为 <code>package.json</code> 可以改变文件的类型；又或者是在 <code>--jsx react-jsx</code> 模式下一个 JSX 文件显式地导入了 JSX 工厂函数。
它也与当下的期望不符，因为大多数的 TypeScript 代码是基于模块来编写的。</p>
<p>以上就是 TypeScript 4.7 引入了 <code>moduleDetection. moduleDetection</code> 选项的原因。
它接受三个值：</p>
<ol>
<li><code>"auto"</code>，默认值</li>
<li><code>"legacy"</code>，行为与 TypeScript 4.6 和以前的版本相同</li>
<li><code>"force"</code></li>
</ol>
<p>在 <code>"auto"</code> 模式下，TypeScript 不但会检测 <code>import</code> 和 <code>export</code> 语句，它还会检测：</p>
<ul>
<li>若启用了 <code>--module nodenext</code> / <code>--module node16</code>，那么 <code>package.json</code> 里的 <code>"type"</code> 字段是否为 <code>"module"</code>，以及</li>
<li>若启用了 <code>--jsx react-jsx</code>，那么当前文件是否为 JSX 文件。</li>
</ul>
<p>在这些情况下，我们想将每个文件都当作模块文件。</p>
<p><code>"force"</code> 选项能够保证每个非声明文件都被当成模块文件，不论 <code>module</code>，<code>moduleResoluton</code> 和 <code>jsx</code> 是如何设置的。</p>
<p>与此同时，使用 <code>"legacy"</code> 选项会回退到以前的行为，仅通过检测 <code>import</code> 和 <code>export</code> 语句来决定是否为模块文件。</p>
<p>更多详情请阅读<a href="https://github.com/microsoft/TypeScript/pull/47495">PR</a>。</p>
<h2 id="-语法元素访问的控制流分析"><a class="header" href="#-语法元素访问的控制流分析"><code>[]</code> 语法元素访问的控制流分析</a></h2>
<p>在 TypeScript 4.7 里，当索引键值是字面量类型和 <code>unique symbol</code> 类型时会细化访问元素的类型。
例如，有如下代码：</p>
<pre><code class="language-ts">const key = Symbol();

const numberOrString = Math.random() &lt; 0.5 ? 42 : "hello";

const obj = {
    [key]: numberOrString,
};

if (typeof obj[key] === "string") {
    let str = obj[key].toUpperCase();
}
</code></pre>
<p>在之前，TypeScript 不会处理涉及 <code>obj[key]</code> 的类型守卫，也就不知道 <code>obj[key]</code> 的类型是 <code>string</code>。
它会将 <code>obj[key]</code> 当作 <code>string | number</code> 类型，因此调用 <code>toUpperCase()</code> 会产生错误。</p>
<p>TypeScript 4.7 能够知道 <code>obj[key]</code> 的类型为 <code>string</code>。</p>
<p>这意味着在 <code>--strictPropertyInitialization</code> 模式下，TypeScript 能够正确地检查<em>计算属性</em>是否被初始化。</p>
<pre><code class="language-ts">// 'key' has type 'unique symbol'
const key = Symbol();

class C {
    [key]: string;

    constructor(str: string) {
        // oops, forgot to set 'this[key]'
    }

    screamString() {
        return this[key].toUpperCase();
    }
}
</code></pre>
<p>在 TypeScript 4.7 里，<code>--strictPropertyInitialization</code> 会提示错误说 <code>[key]</code> 属性在构造函数里没有被赋值。</p>
<p>感谢 <a href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a> 提交的<a href="https://github.com/microsoft/TypeScript/pull/45974">代码</a>。</p>
<h2 id="改进对象和方法里的函数类型推断"><a class="header" href="#改进对象和方法里的函数类型推断">改进对象和方法里的函数类型推断</a></h2>
<p>TypeScript 4.7 可以对数组和对象里的函数进行更精细的类型推断。
它们可以像普通参数那样将类型从左向右进行传递。</p>
<pre><code class="language-ts">declare function f&lt;T&gt;(arg: {
    produce: (n: string) =&gt; T,
    consume: (x: T) =&gt; void }
): void;

// Works
f({
    produce: () =&gt; "hello",
    consume: x =&gt; x.toLowerCase()
});

// Works
f({
    produce: (n: string) =&gt; n,
    consume: x =&gt; x.toLowerCase(),
});

// Was an error, now works.
f({
    produce: n =&gt; n,
    consume: x =&gt; x.toLowerCase(),
});

// Was an error, now works.
f({
    produce: function () { return "hello"; },
    consume: x =&gt; x.toLowerCase(),
});

// Was an error, now works.
f({
    produce() { return "hello" },
    consume: x =&gt; x.toLowerCase(),
});
</code></pre>
<p>之所以有些类型推断之前会失败是因为，若要知道 <code>produce</code> 函数的类型则需要在找到合适的类型 <code>T</code> 之前间接地获得 <code>arg</code> 的类型。
（译者注：这些之前失败的情况均是需要进行按上下文件归类的场景，即需要先知道 <code>arg</code> 的类型，才能确定 <code>produce</code> 的类型；如果不需要执行按上下文归类就能确定 <code>produce</code> 的类型则没有问题。）
TypeScript 现在会收集与泛型参数 <code>T</code> 的类型推断相关的函数，然后进行惰性地类型推断。</p>
<p>更多详情请阅读<a href="https://github.com/microsoft/TypeScript/pull/48538">这里</a>。</p>
<h2 id="实例化表达式"><a class="header" href="#实例化表达式">实例化表达式</a></h2>
<p>我们偶尔可能会觉得某个函数过于通用了。
例如有一个 <code>makeBox</code> 函数。</p>
<pre><code class="language-ts">interface Box&lt;T&gt; {
    value: T;
}

function makeBox&lt;T&gt;(value: T) {
    return { value };
}
</code></pre>
<p>假如我们想要定义一组更具体的可以收纳<em>扳手</em>和<em>锤子</em>的 <code>Box</code> 函数。
为此，我们将 <code>makeBox</code> 函数包装进另一个函数，或者明确地定义一个 <code>makeBox</code> 的类型别名。</p>
<pre><code class="language-ts">function makeHammerBox(hammer: Hammer) {
    return makeBox(hammer);
}

// 或者

const makeWrenchBox: (wrench: Wrench) =&gt; Box&lt;Wrench&gt; = makeBox;
</code></pre>
<p>这样可以工作，但有些浪费且笨重。
理想情况下，我们可以在替换泛型参数的时候直接声明 <code>makeBox</code> 的别名。</p>
<p>TypeScript 4.7 支持了该特性！
我们现在可以直接为函数和构造函数传入类型参数。</p>
<pre><code class="language-ts">const makeHammerBox = makeBox&lt;Hammer&gt;;
const makeWrenchBox = makeBox&lt;Wrench&gt;;
</code></pre>
<p>这样我们可以让 <code>makeBox</code> 只接受更具体的类型并拒绝其它类型。</p>
<pre><code class="language-ts">const makeStringBox = makeBox&lt;string&gt;;

// TypeScript 会提示错误
makeStringBox(42);
</code></pre>
<p>这对构造函数也生效，例如 <code>Array</code>，<code>Map</code> 和 <code>Set</code>。</p>
<pre><code class="language-ts">// 类型为 `new () =&gt; Map&lt;string, Error&gt;`
const ErrorMap = Map&lt;string, Error&gt;;

// 类型为 `Map&lt;string, Error&gt;`
const errorMap = new ErrorMap();
</code></pre>
<p>当函数或构造函数接收了一个类型参数，它会生成一个新的类型并保持所有签名使用了兼容的类型参数列表，
将形式类型参数替换成给定的实际类型参数。
其它种类的签名会被丢弃，因为 TypeScript 认为它们不会被使用到。</p>
<p>更多详情请阅读<a href="https://github.com/microsoft/TypeScript/pull/47607">这里</a>。</p>
<h2 id="infer-类型参数上的-extends-约束"><a class="header" href="#infer-类型参数上的-extends-约束"><code>infer</code> 类型参数上的 <code>extends</code> 约束</a></h2>
<p>有条件类型有点儿像一个进阶功能。
它允许我们匹配并依据类型结构进行推断，然后作出某种决定。
例如，编写一个有条件类型，它返回元组类型的第一个元素如果它类似 <code>string</code> 类型的话。</p>
<pre><code class="language-ts">type FirstIfString&lt;T&gt; =
    T extends [infer S, ...unknown[]]
        ? S extends string ? S : never
        : never;

 // string
type A = FirstIfString&lt;[string, number, number]&gt;;

// "hello"
type B = FirstIfString&lt;["hello", number, number]&gt;;

// "hello" | "world"
type C = FirstIfString&lt;["hello" | "world", boolean]&gt;;

// never
type D = FirstIfString&lt;[boolean, number, string]&gt;;
</code></pre>
<p><code>FirstIfString</code> 匹配至少有一个元素的元组类型，将元组第一个元素的类型提取到 <code>S</code>。
然后检查 <code>S</code> 与 <code>string</code> 是否兼容，如果是就返回它。</p>
<p>可以注意到我们必须使用两个有条件类型来实现它。
我们也可以这样定义 <code>FirstIfString</code>：</p>
<pre><code class="language-ts">type FirstIfString&lt;T&gt; =
    T extends [string, ...unknown[]]
        // Grab the first type out of `T`
        ? T[0]
        : never;
</code></pre>
<p>它可以工作但要更多的“手动”操作且不够形象。
我们不是进行类型模式匹配并给首个元素命名，而是使用 <code>T[0]</code> 来提取 <code>T</code> 的第 <code>0</code> 个元素。
如果我们处理的是比元组类型复杂得多的类型就会变得棘手，因此 <code>infer</code> 可以让事情变得简单。</p>
<p>使用嵌套的条件来推断类型再去匹配推断出的类型是很常见的。
为了省去那一层嵌套，TypeScript 4.7 允许在 <code>infer</code> 上应用约束。</p>
<pre><code class="language-ts">type FirstIfString&lt;T&gt; =
    T extends [infer S extends string, ...unknown[]]
        ? S
        : never;
</code></pre>
<p>通过这种方式，在 TypeScript 去匹配 <code>S</code> 时，它也会保证 <code>S</code> 是 <code>string</code> 类型。
如果 <code>S</code> 不是 <code>string</code> 就是进入到 <code>false</code> 分支，此例中为 <code>never</code>。</p>
<p>更多详情请阅读<a href="https://github.com/microsoft/TypeScript/pull/48112">这里</a>。</p>
<h2 id="可选的类型参数变型注释"><a class="header" href="#可选的类型参数变型注释">可选的类型参数变型注释</a></h2>
<p>先看一下如下的类型。</p>
<pre><code class="language-ts">interface Animal {
    animalStuff: any;
}

interface Dog extends Animal {
    dogStuff: any;
}

// ...

type Getter&lt;T&gt; = () =&gt; T;

type Setter&lt;T&gt; = (value: T) =&gt; void;
</code></pre>
<p>假设有两个不同的 <code>Getter</code> 实例。
要想知道这两个 <code>Getter</code> 实例是否可以相互替换完全依赖于类型 <code>T</code>。
例如要知道 <code>Getter&lt;Dog&gt; → Getter&lt;Animal&gt;</code> 是否允许，则需要检查 <code>Dog → Animal</code> 是否允许。
因为对 <code>T</code> 与 <code>Getter&lt;T&gt;</code> 的判断是相同“方向”的，我们称 <code>Getter</code> 是<em>协变</em>的。
相反的，判断 <code>Setter&lt;Dog&gt; → Setter&lt;Animal&gt;</code> 是否允许，需要检查 <code>Animal → Dog</code> 是否允许。
这种在方向上的“翻转”有点像数学里判断 $−x &lt; −y$ 等同于判断 $y &lt; x$。
当我们需要像这样翻转方向来比较 <code>T</code> 时，我们称 <code>Setter</code> 对于 <code>T</code> 是<em>逆变</em>的。</p>
<p>在 TypeScript 4.7 里，我们可以明确地声明类型参数上的变型关系。</p>
<p>因此，现在如果想在 <code>Getter</code> 上明确地声明对于 <code>T</code> 的协变关系则可以使用 <code>out</code> 修饰符。</p>
<pre><code class="language-ts">type Getter&lt;out T&gt; = () =&gt; T;
</code></pre>
<p>相似的，如果想要明确地声明 <code>Setter</code> 对于 <code>T</code> 是逆变关系则可以指定 <code>in</code> 修饰符。</p>
<pre><code class="language-ts">type Setter&lt;in T&gt; = (value: T) =&gt; void;
</code></pre>
<p>使用 <code>out</code> 和 <code>in</code> 的原因是类型参数的变型关系依赖于它们被用在<em>输出</em>的位置还是<em>输入</em>的位置。
若不思考变型关系，你也可以只关注 <code>T</code> 是被用在输出还是输入位置上。</p>
<p>当然也有同时使用 <code>out</code> 和 <code>in</code> 的时候。</p>
<pre><code class="language-ts">interface State&lt;in out T&gt; {
    get: () =&gt; T;
    set: (value: T) =&gt; void;
}
</code></pre>
<p>当 <code>T</code> 被同时用在输入和输出的位置上时就成为了<em>不变</em>关系。
两个不同的 <code>State&lt;T&gt;</code> 不允许互换使用，除非两者的 <code>T</code> 是相同的。
换句话说，<code>State&lt;Dog&gt;</code> 和 <code>State&lt;Animal&gt;</code> 不能互换使用。</p>
<p>从技术上讲，在纯粹的结构化类型系统里，类型参数和它们的变型关系不太重要 -
我们只需要将类型参数替换为实际类型，然后再比较相匹配的类型成员之间是否兼容。
那么如果 TypeScript 使用结构化类型系统为什么我们要在意类型参数的变型呢？
还有为什么我们会想要为它们添加类型注释呢？</p>
<p>其中一个原因是可以让读者能够明确地知道类型参数是如何被使用的。
对于十分复杂的类型来讲，可能很难确定一个类型参数是用于输入或者输出再或者两者兼有。
如果我们忘了说明类型参数是如何被使用的，TypeScript 也会提示我们。
举个例子，如果忘了在 <code>State</code> 上添加 <code>in</code> 和 <code>out</code> 就会产生错误。</p>
<pre><code class="language-ts">interface State&lt;out T&gt; {
    //          ~~~~~
    // error!
    // Type 'State&lt;sub-T&gt;' is not assignable to type 'State&lt;super-T&gt;' as implied by variance annotation.
    //   Types of property 'set' are incompatible.
    //     Type '(value: sub-T) =&gt; void' is not assignable to type '(value: super-T) =&gt; void'.
    //       Types of parameters 'value' and 'value' are incompatible.
    //         Type 'super-T' is not assignable to type 'sub-T'.
    get: () =&gt; T;
    set: (value: T) =&gt; void;
}
</code></pre>
<p>另一个原因则有关精度和速度。
TypeScript 已经在尝试推断类型参数的变型并做为一项优化。
这样做可以快速对大型的结构化类型进行类型检查。
提前计算变型省去了深入结构内部进行兼容性检查的步骤，
仅比较类型参数相比于一次又一次地比较完整的类型结构会快得多。
但经常也会出现这个计算十分耗时，并且在计算时产生了环，从而无法得到准确的变型关系。</p>
<pre><code class="language-ts">type Foo&lt;T&gt; = {
    x: T;
    f: Bar&lt;T&gt;;
}

type Bar&lt;U&gt; = (x: Baz&lt;U[]&gt;) =&gt; void;

type Baz&lt;V&gt; = {
    value: Foo&lt;V[]&gt;;
}

declare let foo1: Foo&lt;unknown&gt;;
declare let foo2: Foo&lt;string&gt;;

foo1 = foo2;  // Should be an error but isn't ❌
foo2 = foo1;  // Error - correct ✅
</code></pre>
<p>提供明确的类型注解能够加快对环状类型的解析速度，有利于提高准确度。
例如，将上例的 <code>T</code> 设置为逆变可以帮助阻止有问题的赋值运算。</p>
<pre><code class="language-ts">- type Foo&lt;T&gt; = {
+ type Foo&lt;in out T&gt; = {
      x: T;
      f: Bar&lt;T&gt;;
  }
</code></pre>
<p>我们并不推荐为所有的类型参数都添加变型注解；
例如，我们是能够（但不推荐）将变型设置为更严格的关系（即便实际上不需要），
因此 TypeScript 不会阻止你将类型参数设置为不变，就算它们实际上是协变的、逆变的或者是分离的。
因此，如果你选择添加明确的变型标记，我们推荐要经过深思熟虑后准确地使用它们。</p>
<p>但如果你操作的是深层次的递归类型，尤其是作为代码库作者，那么你可能会对使用这些注解来让用户获利感兴趣。
这些注解能够帮助提高准确性和类型检查速度，甚至可以增强代码编辑的体验。
可以通过实验来确定变型计算是否为类型检查时间的瓶颈，例如使用像 <a href="https://github.com/microsoft/typescript-analyze-trace">analyze-trace</a> 这样的工具。</p>
<p>更多详情请阅读<a href="https://github.com/microsoft/TypeScript/pull/48240">这里</a>。</p>
<h2 id="使用-modulesuffixes-自定义解析策略"><a class="header" href="#使用-modulesuffixes-自定义解析策略">使用 <code>moduleSuffixes</code> 自定义解析策略</a></h2>
<p>TypeScript 4.7 支持了 <code>moduleSuffixes</code> 选项来自定义模块说明符的查找方式。</p>
<pre><code class="language-ts">{
    "compilerOptions": {
        "moduleSuffixes": [".ios", ".native", ""]
    }
}
</code></pre>
<p>对于上述配置，如果有如下的导入语句：</p>
<pre><code class="language-ts">import * as foo from "./foo";
</code></pre>
<p>它会尝试查找文件 <code>./foo.ios.ts</code>，<code>./foo.native.ts</code> 最后是 <code>./foo.ts</code>。</p>
<p>注意 <code>moduleSuffixes</code> 末尾的空字符串 <code>""</code> 是必须的，只有这样 TypeScript 才会去查找 <code>./foo.ts</code>。
也就是说，<code>moduleSuffixes</code> 的默认值是 <code>[""]</code>。</p>
<p>这个功能对于 React Native 工程是很有用的，因为对于不同的目标平台会有不同的 <code>tsconfig.json</code> 和 <code>moduleSuffixes</code>。</p>
<p>这个<a href="https://github.com/microsoft/TypeScript/pull/48189">功能</a>是由 <a href="https://github.com/afoxman">Adam Foxman</a> 贡献的！</p>
<h2 id="resolution-mode"><a class="header" href="#resolution-mode">resolution-mode</a></h2>
<p>Node.js 的 ECMAScript 解析规则是根据当前文件所属的模式以及使用的语法来决定如何解析导入；
然而，在 ECMAScript 模块里引用 CommonJS 模块也是很常用的，或者反过来。</p>
<p>TypeScript 允许使用 <code>/// &lt;reference types="..." /&gt;</code> 指令。</p>
<pre><code class="language-ts">/// &lt;reference types="pkg" resolution-mode="require" /&gt;

// or

/// &lt;reference types="pkg" resolution-mode="import" /&gt;
</code></pre>
<p>此外，在 Nightly 版本的 TypeScript 里，<code>import type</code> 可以指定导入断言来达到同样的目的。</p>
<pre><code class="language-ts">// Resolve `pkg` as if we were importing with a `require()`
import type { TypeFromRequire } from "pkg" assert {
    "resolution-mode": "require"
};

// Resolve `pkg` as if we were importing with an `import`
import type { TypeFromImport } from "pkg" assert {
    "resolution-mode": "import"
};

export interface MergedType extends TypeFromRequire, TypeFromImport {}
</code></pre>
<p>这些断言也可以用在 <code>import()</code> 类型上。</p>
<pre><code class="language-ts">export type TypeFromRequire =
    import("pkg", { assert: { "resolution-mode": "require" } }).TypeFromRequire;

export type TypeFromImport =
    import("pkg", { assert: { "resolution-mode": "import" } }).TypeFromImport;

export interface MergedType extends TypeFromRequire, TypeFromImport {}
</code></pre>
<p><code>import type</code> 和 <code>import()</code> 语法仅在 <a href="https://www.typescriptlang.org/docs/handbook/nightly-builds.html">Nightly 版本</a>里支持 <code>resolution-mode</code>。
你可能会看到如下的错误：</p>
<pre><code class="language-txt">Resolution mode assertions are unstable.
Use nightly TypeScript to silence this error.
Try updating with 'npm install -D typescript@next'.
</code></pre>
<p>如果你在 TypeScript 的 Nightly 版本中使用了该功能，别忘了可以<a href="https://github.com/microsoft/TypeScript/issues/49055">提供反馈</a>。</p>
<p>更多详情请查看 <a href="https://github.com/microsoft/TypeScript/pull/47732">PR: 引用指令</a>和<a href="https://github.com/microsoft/TypeScript/pull/47807">PR: 类型导入断言</a>。</p>
<h2 id="跳转到在源码中的定义"><a class="header" href="#跳转到在源码中的定义">跳转到在源码中的定义</a></h2>
<p>TypeScript 4.7 支持了一个实验性的编辑器功能叫作 <em>Go To Source Definition</em> （跳转到在源码中的定义）。
它和 <em>Go To Definition</em> （跳转到定义）相似，但不是跳转到声明文件中。
而是查找相应的<em>实现</em>文件（比如 <code>.js</code> 或 <code>.ts</code> 文件），并且在那里查找定义 -
即便这些文件总是会被声明文件 <code>.d.ts</code> 所遮蔽。</p>
<p>当你想查看导入的三方库的函数实现而不是 <code>.d.ts</code> 声明文件时是很便利的。</p>
<p>你可以在最新版本的 Visual Studio Code 里试用该功能。
但该功能还是预览版，存在一些已知的限制。
在某些情况下 TypeScript 使用启发式的方法来猜测函数定义的代码在哪个 <code>.js</code> 文件中，
因此结果可能不太精确。
Visual Studio Code 也不会提示哪些结果是通过猜测得到的，但我们正在实现它。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/issues/49003">PR</a>。</p>
<h2 id="分组整理导入语句"><a class="header" href="#分组整理导入语句">分组整理导入语句</a></h2>
<p>TypeScript 为 JavaScript 和 TypeScript 提供了叫做 “Organize Imports” （整理导入语句）编辑器功能。
可是，它的行为有点简单粗暴，它直接排序所有的导入语句。</p>
<p>例如，在如下的代码上使用 “Organize Imports”：</p>
<pre><code class="language-ts">// local code
import * as bbb from "./bbb";
import * as ccc from "./ccc";
import * as aaa from "./aaa";

// built-ins
import * as path from "path";
import * as child_process from "child_process"
import * as fs from "fs";

// some code...
</code></pre>
<p>你会得到：</p>
<pre><code class="language-ts">// local code
import * as child_process from "child_process";
import * as fs from "fs";
// built-ins
import * as path from "path";
import * as aaa from "./aaa";
import * as bbb from "./bbb";
import * as ccc from "./ccc";


// some code...
</code></pre>
<p>这不是我们想要的。
尽管导入语句已经按它们的路径排序了，并且注释和折行被保留了，
但仍不是我们期望的。</p>
<p>TypeScript 4.7 在 “Organize Imports” 时会考虑分组。
再次在上例代码上执行 “Organize Imports” 会得到期望的结果：</p>
<pre><code class="language-ts">// local code
import * as aaa from "./aaa";
import * as bbb from "./bbb";
import * as ccc from "./ccc";

// built-ins
import * as child_process from "child_process";
import * as fs from "fs";
import * as path from "path";

// some code...
</code></pre>
<p>感谢 <a href="https://github.com/MQuy">Minh Quy</a> 的 <a href="https://github.com/microsoft/TypeScript/pull/48330">PR</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-46"><a class="header" href="#typescript-46">TypeScript 4.6</a></h1>
<h3 id="允许在构造函数中的-super-调用之前插入代码"><a class="header" href="#允许在构造函数中的-super-调用之前插入代码">允许在构造函数中的 <code>super()</code> 调用之前插入代码</a></h3>
<p>在 JavaScript 的类中，在引用 <code>this</code> 之前必须先调用 <code>super()</code>。
在 TypeScript 中同样有这个限制，只不过在检查时过于严格。
在之前版本的 TypeScript 中，如果类中存在<strong>属性初始化器</strong>，
那么在构造函数里，在 <code>super()</code> 调用之前不允许出现任何其它代码。</p>
<pre><code class="language-ts">class Base {
    // ...
}

class Derived extends Base {
    someProperty = true;

    constructor() {
        // 错误！
        // 必须先调用 'super()' 因为需要初始化 'someProperty'。
        doSomeStuff();
        super();
    }
}
</code></pre>
<p>这样做是因为程序实现起来容易，但这样做也会拒绝很多合法的代码。
TypeScript 4.6 放宽了限制，它允许在 <code>super()</code> 之前出现其它代码，
与此同时仍然会检查在引用 <code>this</code> 之前顶层的<code>super()</code> 已经被调用。</p>
<p>感谢 <a href="https://github.com/JoshuaKGoldberg">Joshua Goldberg</a> 的 <a href="https://github.com/microsoft/TypeScript/pull/29374">PR</a>。</p>
<h3 id="基于控制流来分析解构的可辨识联合类型"><a class="header" href="#基于控制流来分析解构的可辨识联合类型">基于控制流来分析解构的可辨识联合类型</a></h3>
<p>TypeScript 可以根据判别式属性来细化类型。
例如，在下面的代码中，TypeScript 能够在检查 <code>kind</code> 的类型后细化 <code>action</code> 的类型。</p>
<pre><code class="language-ts">type Action =
    | { kind: "NumberContents", payload: number }
    | { kind: "StringContents", payload: string };

function processAction(action: Action) {
    if (action.kind === "NumberContents") {
        // `action.payload` is a number here.
        let num = action.payload * 2
        // ...
    }
    else if (action.kind === "StringContents") {
        // `action.payload` is a string here.
        const str = action.payload.trim();
        // ...
    }
}
</code></pre>
<p>这样就可以使用持有不同数据的对象，但通过共同的字段来区分它们。</p>
<p>这在 TypeScript 是很常见的；然而，根据个人的喜好，你可能想对上例中的 <code>kind</code> 和 <code>payload</code> 进行解构。
就像下面这样：</p>
<pre><code class="language-ts">type Action =
    | { kind: "NumberContents", payload: number }
    | { kind: "StringContents", payload: string };

function processAction(action: Action) {
    const { kind, payload } = action;
    if (kind === "NumberContents") {
        let num = payload * 2
        // ...
    }
    else if (kind === "StringContents") {
        const str = payload.trim();
        // ...
    }
}
</code></pre>
<p>此前，TypeScript 会报错 - 当 <code>kind</code> 和 <code>payload</code> 是由同一个对象解构为变量时，它们会被独立对待。</p>
<p>在 TypeScript 4.6 中可以正常工作！</p>
<p>当解构独立的属性为 const 声明，或当解构参数到变量且没有重新赋值时，TypeScript 会检查被解构的类型是否为可辨识联合。
如果是的话，TypeScript 就能够根据类型检查来细化变量的类型。
因此上例中，通过检查 <code>kind</code> 的类型可以细化 <code>payload</code> 的类型。</p>
<p>更多详情请查看 <a href="https://github.com/microsoft/TypeScript/pull/46266">PR</a>。</p>
<h3 id="改进的递归深度检查"><a class="header" href="#改进的递归深度检查">改进的递归深度检查</a></h3>
<p>TypeScript 要面对一些有趣的挑战，因为它是构建在结构化类型系统之上，同时又支持了泛型。</p>
<p>在结构化类型系统中，对象类型的兼容性是由对象包含的成员决定的。</p>
<pre><code class="language-ts">interface Source {
    prop: string;
}

interface Target {
    prop: number;
}

function check(source: Source, target: Target) {
    target = source;
    // error!
    // Type 'Source' is not assignable to type 'Target'.
    //   Types of property 'prop' are incompatible.
    //     Type 'string' is not assignable to type 'number'.
}
</code></pre>
<p><code>Source</code> 与 <code>Target</code> 的兼容性取决于它们的<em>属性</em>是否可以执行赋值操作。
此例中是指 <code>prop</code> 属性。</p>
<p>当引入了泛型后，有一些难题需要解决。
例如，下例中的 <code>Source&lt;string&gt;</code> 是否可以赋值给 <code>Target&lt;number&gt;</code>？</p>
<pre><code class="language-ts">interface Source&lt;T&gt; {
    prop: Source&lt;Source&lt;T&gt;&gt;;
}

interface Target&lt;T&gt; {
    prop: Target&lt;Target&lt;T&gt;&gt;;
}

function check(source: Source&lt;string&gt;, target: Target&lt;number&gt;) {
    target = source;
}
</code></pre>
<p>要想回答这个问题，TypeScript 需要检查 <code>prop</code> 的类型是否兼容。
这又要回答另一个问题：<code>Source&lt;Source&lt;string&gt;&gt;</code> 是否能够赋值给 <code>Target&lt;Target&lt;number&gt;&gt;</code>？
要想回答这个问题，TypeScript 需要检查 <code>prop</code> 的类型是否与那些类型兼容，
结果就是还要检查 <code>Source&lt;Source&lt;Source&lt;string&gt;&gt;&gt;</code> 是否能够赋值给 <code>Target&lt;Target&lt;Target&lt;number&gt;&gt;&gt;</code>？
继续发展下去，就会注意到类型会进行无限展开。</p>
<p>TypeScript 使用了启发式的算法 - 当一个类型达到特定的检查深度时，它表现出了将会进行无限展开，
那么就认为它<em>可能</em>是兼容的。
通常情况下这是没问题的，但是也可能出现漏报的情况。</p>
<pre><code class="language-ts">interface Foo&lt;T&gt; {
    prop: T;
}

declare let x: Foo&lt;Foo&lt;Foo&lt;Foo&lt;Foo&lt;Foo&lt;string&gt;&gt;&gt;&gt;&gt;&gt;;
declare let y: Foo&lt;Foo&lt;Foo&lt;Foo&lt;Foo&lt;string&gt;&gt;&gt;&gt;&gt;;

x = y;
</code></pre>
<p>通过人眼观察我们知道上例中的 <code>x</code> 和 <code>y</code> 是不兼容的。
虽然类型的嵌套层次很深，但人家就是这样声明的。
启发式算法要处理的是在探测类型过程中生成的深层次嵌套类型，而非程序员明确手写出的类型。</p>
<p>TypeScript 4.6 现在能够区分出这类情况，并且对上例进行正确的错误提示。
此外，由于不再担心会对明确书写的类型进行误报，
TypeScript 能够更容易地判断类型的无限展开，
并且降低了类型兼容性检查的成本。
因此，像 DefinitelyTyped 上的 <code>redux-immutable</code> 、 <code>react-lazylog</code> 和 <code>yup</code>
代码库，对它们的类型检查时间降低了 50%。</p>
<p>你可能已经体验过这个改动了，因为它被挑选合并到了 TypeScript 4.5.3 中，
但它仍然是 TypeScript 4.6 中值得关注的一个特性。
更多详情请阅读 <a href="https://github.com/microsoft/TypeScript/pull/46599">PR</a>。</p>
<h3 id="索引访问类型推断改进"><a class="header" href="#索引访问类型推断改进">索引访问类型推断改进</a></h3>
<p>TypeScript 现在能够正确地推断通过索引访问到另一个映射对象类型的类型。</p>
<pre><code class="language-ts">interface TypeMap {
    "number": number;
    "string": string;
    "boolean": boolean;
}

type UnionRecord&lt;P extends keyof TypeMap&gt; = { [K in P]:
    {
        kind: K;
        v: TypeMap[K];
        f: (p: TypeMap[K]) =&gt; void;
    }
}[P];

function processRecord&lt;K extends keyof TypeMap&gt;(record: UnionRecord&lt;K&gt;) {
    record.f(record.v);
}

// 这个调用之前是有问题的，但现在没有问题
processRecord({
    kind: "string",
    v: "hello!",

    // 'val' 之前会隐式地获得类型 'string | number | boolean'，
    // 但现在会正确地推断为类型 'string'。
    f: val =&gt; {
        console.log(val.toUpperCase());
    }
})
</code></pre>
<p>该模式已经被支持了并允许 TypeScript 判断 <code>record.f(record.v)</code> 调用是合理的，
但是在以前，<code>processRecord</code> 调用中对 <code>val</code> 的类型推断并不好。</p>
<p>TypeScript 4.6 改进了这个情况，因此在启用 <code>processRecord</code> 时不再需要使用类型断言。</p>
<p>更多详情请阅读 <a href="https://github.com/microsoft/TypeScript/pull/47109">PR</a>。</p>
<h3 id="对因变参数的控制流分析"><a class="header" href="#对因变参数的控制流分析">对因变参数的控制流分析</a></h3>
<p>函数签名可以声明为剩余参数且其类型可以为可辨识联合元组类型。</p>
<pre><code class="language-ts">function func(...args: ["str", string] | ["num", number]) {
    // ...
}
</code></pre>
<p>这意味着 <code>func</code> 的实际参数完全依赖于第一个实际参数。
若第一个参数为字符串 <code>"str"</code> 时，则第二个参数为 <code>string</code> 类型。
若第一个参数为字符串 <code>"num"</code> 时，则第二个参数为 <code>number</code> 类型。</p>
<p>像这样 TypeScript 是由签名来推断函数类型时，TypeScript 能够根据依赖的参数来细化类型。</p>
<pre><code class="language-ts">type Func = (...args: ["a", number] | ["b", string]) =&gt; void;

const f1: Func = (kind, payload) =&gt; {
    if (kind === "a") {
        payload.toFixed();  // 'payload' narrowed to 'number'
    }
    if (kind === "b") {
        payload.toUpperCase();  // 'payload' narrowed to 'string'
    }
};

f1("a", 42);
f1("b", "hello");
</code></pre>
<p>更多详情请阅读 <a href="https://github.com/microsoft/TypeScript/pull/47190">PR</a>。</p>
<h3 id="--target-es2022"><a class="header" href="#--target-es2022">--target es2022</a></h3>
<p>TypeScript 的 <code>--target</code> 编译选项现在支持使用 <code>es2022</code>。
这意味着像类字段这样的特性能够稳定地在输出结果中保留。
这也意味着像 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn">Arrays 的上 at() 和 Object.hasOwn 方法</a>
或者 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Error#rethrowing_an_error_with_a_cause">new Error 时的 <code>cause</code> 选项</a>
可以通过设置新的 <code>--target</code> 或者 <code>--lib es2022</code> 来使用。</p>
<p>感谢 <a href="https://github.com/saschanaz">Kagami Sascha Rosylight (saschanaz)</a> 的<a href="https://github.com/microsoft/TypeScript/pull/46291">实现</a>。</p>
<h3 id="删除-react-jsx-中不必要的参数"><a class="header" href="#删除-react-jsx-中不必要的参数">删除 react-jsx 中不必要的参数</a></h3>
<p>在以前，当使用 <code>--jsx react-jsx</code> 来编译如下的代码时</p>
<pre><code class="language-ts">export const el = &lt;div&gt;foo&lt;/div&gt;;
</code></pre>
<p>TypeScript 会生成如下的 JavaScript 代码：</p>
<pre><code class="language-ts">import { jsx as _jsx } from "react/jsx-runtime";
export const el = _jsx("div", { children: "foo" }, void 0);
</code></pre>
<p>末尾的 <code>void 0</code> 参数是没用的，删掉它会减小打包的体积。</p>
<p>感谢 <a href="https://github.com/a-tarasyuk">https://github.com/a-tarasyuk</a> 的 <a href="https://github.com/microsoft/TypeScript/pull/47467">PR</a>，TypeScript 4.6 会删除 <code>void 0</code> 参数。</p>
<h3 id="jsdoc-命名建议"><a class="header" href="#jsdoc-命名建议">JSDoc 命名建议</a></h3>
<p>在 JSDoc 里，你可以用 <code>@param</code> 标签来文档化参数。</p>
<pre><code class="language-js">/**
 * @param x The first operand
 * @param y The second operand
 */
function add(x, y) {
    return x + y;
}
</code></pre>
<p>但是，如果这些注释已经过时了会发生什么？就比如，我们将 <code>x</code> 和 <code>y</code> 重命名为 <code>a</code> 和 <code>b</code>？</p>
<pre><code class="language-js">/**
 * @param x {number} The first operand
 * @param y {number} The second operand
 */
function add(a, b) {
    return a + b;
}
</code></pre>
<p>在之前 TypeScript 仅会在对 JavaScript 文件执行类型检查时报告这个问题 - 通过
使用 <code>checkJs</code> 选项，或者在文件顶端添加 <code>// @ts-check</code> 注释。</p>
<p>现在，你能够在编译器中的 TypeScript 文件上看到类似的提示！
TypeScript 现在会给出建议，如果函数签名中的参数名与 JSDoc 中的参数名不一致。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2022/02/jsdoc-comment-suggestions-4-6.png" alt="example" /></p>
<p>该<a href="https://github.com/microsoft/TypeScript/pull/47257">改动</a>是由 <a href="https://github.com/a-tarasyuk">Alexander Tarasyuk</a> 提供的！</p>
<h3 id="javascript-中更多的语法和绑定错误提示"><a class="header" href="#javascript-中更多的语法和绑定错误提示">JavaScript 中更多的语法和绑定错误提示</a></h3>
<p>TypeScript 将更多的语法和绑定错误检查应用到了 JavaScript 文件上。
如果你在 Visual Studio 或 Visual Studio Code 这样的编辑器中打开 JavaScript 文件时就会看到这些新的错误提示，
或者当你使用 TypeScript 编译器来处理 JavaScript 文件时 - 即便你没有打开 <code>checkJs</code> 或者添加 <code>// @ts-check</code> 注释。</p>
<p>做为例子，如果在 JavaScript 文件中的同一个作用域中有两个同名的 <code>const</code> 声明，
那么 TypeScript 会报告一个错误。</p>
<pre><code class="language-js">const foo = 1234;
//    ~~~
// error: Cannot redeclare block-scoped variable 'foo'.

// ...

const foo = 5678;
//    ~~~
// error: Cannot redeclare block-scoped variable 'foo'.
</code></pre>
<p>另外一个例子，TypeScript 会报告修饰符是否被正确地使用了。</p>
<pre><code class="language-js">function container() {
    export function foo() {
//  ~~~~~~
// error: Modifiers cannot appear here.

    }
}
</code></pre>
<p>这些检查可以通过在文件顶端添加 <code>// @ts-nocheck</code> 注释来禁用，
但是我们很想听听在大家的 JavaScript 工作流中使用该特性的反馈。
你可以在 Visual Studio Code 安装 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next">TypeScript 和 JavaScript Nightly 扩展</a> 来提前体验，
并阅读 <a href="https://github.com/microsoft/TypeScript/pull/47067">PR1</a> 和 <a href="https://github.com/microsoft/TypeScript/pull/47075">PR1</a>。</p>
<h3 id="typescript-trace-分析器"><a class="header" href="#typescript-trace-分析器">TypeScript Trace 分析器</a></h3>
<p>有人偶尔会遇到创建和比较类型时很耗时的情况。
TypeScript 提供了一个 <a href="https://github.com/microsoft/TypeScript/wiki/Performance#performance-tracing"><code>--generateTrace</code></a> 选项来帮助识别耗时的类型，
或者帮助诊断 TypeScript 编译器中的问题。
虽说由 <code>--generateTrace</code> 生成的信息是非常有帮助的（尤其是在 TypeScript 4.6 的改进后），
但是阅读这些 trace 信息是比较难的。</p>
<p>近期，我们发布了 <a href="https://www.npmjs.com/package/@typescript/analyze-trace">@typescript/analyze-trace</a> 工具来帮助阅读这些信息。
虽说我们不认为每个人都需要使用 <code>analyze-trace</code>，但是我们认为它会为遇到了 <a href="https://github.com/microsoft/TypeScript/wiki/Performance">TypeScript 构建性能</a>问题的团队提供帮助。</p>
<p>更多详情请查看 <a href="https://github.com/microsoft/typescript-analyze-trace">repo</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-45"><a class="header" href="#typescript-45">TypeScript 4.5</a></h1>
<h3 id="支持从-node_modules-里读取-lib"><a class="header" href="#支持从-node_modules-里读取-lib">支持从 <code>node_modules</code> 里读取 <code>lib</code></a></h3>
<p>为确保对 TypeScript 和 JavaScript 的支持可以开箱即用，TypeScript 内置了一些声明文件（<code>.d.ts</code>）。
这些声明文件描述了 JavaScript 语言中可用的 API，以及标准的浏览器 DOM API。
虽说 TypeScript 会根据工程中 <a href="zh/release-notes//tsconfig#target"><code>target</code></a> 的设置来提供默认值，但你仍然可以通过在 <code>tsconfig.json</code> 文件中设置 <a href="https://www.typescriptlang.org/tsconfig#lib"><code>lib</code></a> 来指定包含哪些声明文件。</p>
<p>TypeScript 包含的声明文件偶尔也会成为缺点：</p>
<ul>
<li>在升级 TypeScript 时，你必须要处理 TypeScript 内置声明文件的升级带来的改变，这可能成为一项挑战，因为 DOM API 的变动十分频繁。</li>
<li>难以根据你的需求以及工程依赖的需求去定制声明文件（例如，工程依赖声明了需要使用 DOM API，那么你可能也必须要使用 DOM API）。</li>
</ul>
<p>TypeScript 4.5 引入了覆盖特定内置 <code>lib</code> 的方式，它与 <code>@types/</code> 的工作方式类似。
在决定应包含哪些 <code>lib</code> 文件时，TypeScript 会先去检查 <code>node_modules</code> 下面的 <code>@typescript/lib-*</code> 包。
例如，若将 <code>dom</code> 作为 <code>lib</code> 中的一项，那么 TypeScript 会尝试使用 <code>node_modules/@typescript/lib-dom</code>。</p>
<p>然后，你就可以使用包管理器去安装特定的包作为 <code>lib</code> 中的某一项。
例如，现在 TypeScript 会将 DOM API 发布到 <code>@types/web</code>。
如果你想要给工程指定一个固定版本的 DOM API，你可以在 <code>package.json</code> 文件中添加如下代码：</p>
<pre><code class="language-json">{
  "dependencies": {
    "@typescript/lib-dom": "npm:@types/web"
  }
}
</code></pre>
<p>从 4.5 版本开始，你可以更新 TypeScript 和依赖管理工具生成的锁文件来确保使用固定版本的 DOM API。
你可以根据自己的情况来逐步更新类型声明。</p>
<p>十分感谢 <a href="https://github.com/saschanaz">saschanaz</a> 提供的帮助。</p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/45771">PR</a>。</p>
<h3 id="改进-awaited-类型和-promise"><a class="header" href="#改进-awaited-类型和-promise">改进 <code>Awaited</code> 类型和 <code>Promise</code></a></h3>
<p>TypeScript 4.5 引入了一个新的 <code>Awaited</code> 类型。
该类型用于描述 <code>async</code> 函数中的 <code>await</code> 操作，或者 <code>Promise</code> 上的 <code>.then()</code> 方法 - 尤其是递归地解开 <code>Promise</code> 的行为。</p>
<pre><code class="language-ts">// A = string
type A = Awaited&lt;Promise&lt;string&gt;&gt;;

// B = number
type B = Awaited&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt;;

// C = boolean | number
type C = Awaited&lt;boolean | Promise&lt;number&gt;&gt;;
</code></pre>
<p><code>Awaited</code> 有助于描述现有 API，比如 JavaScript 内置的 <code>Promise.all</code>，<code>Promise.race</code> 等等。
实际上，正是涉及 <code>Promise.all</code> 的类型推断问题促进了 <code>Awaited</code> 类型的产生。
例如，下例中的代码在 TypeScript 4.4 及之前的版本中会失败。</p>
<pre><code class="language-ts">declare function MaybePromise&lt;T&gt;(value: T): T | Promise&lt;T&gt; | PromiseLike&lt;T&gt;;

async function doSomething(): Promise&lt;[number, number]&gt; {
  const result = await Promise.all([MaybePromise(100), MaybePromise(200)]);

  // 错误！
  //
  //    [number | Promise&lt;100&gt;, number | Promise&lt;200&gt;]
  //
  // 不能赋值给类型
  //
  //    [number, number]
  return result;
}
</code></pre>
<p>现在，<code>Promise.all</code> 结合并利用 <code>Awaited</code> 来提供更好的类型推断结果，同时上例中的代码也不再有错误。</p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/45350">PR</a>。</p>
<h3 id="模版字符串类型作为判别式属性"><a class="header" href="#模版字符串类型作为判别式属性">模版字符串类型作为判别式属性</a></h3>
<p>TypeScript 4.5 可以对模版字符串类型的值进行细化，同时可以识别模版字符串类型的判别式属性。</p>
<p>例如，下面的代码在以前会出错，但在 TypeScript 4.5 里没有错误。</p>
<pre><code class="language-ts">export interface Success {
  type: `${string}Success`;
  body: string;
}

export interface Error {
  type: `${string}Error`;
  message: string;
}

export function handler(r: Success | Error) {
  if (r.type === "HttpSuccess") {
    // 'r' 的类型为 'Success'
    let token = r.body;
  }
}
</code></pre>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/46137">PR</a>。</p>
<h3 id="module-es2022"><a class="header" href="#module-es2022"><code>module es2022</code></a></h3>
<p>感谢 <a href="https://github.com/saschanaz">Kagami S. Rosylight</a>，TypeScript 现在支持了一个新的 <code>module</code> 设置：<code>es2022</code>。
<a href="zh/release-notes//tsconfig#module"><code>module es2022</code></a> 的主要功能是支持顶层的 <code>await</code>，即可以在 <code>async</code> 函数外部使用 <code>await</code>。
该功能在 <code>--module esnext</code> 里已经被支持了（现在又增加了 <a href="zh/release-notes//tsconfig#target"><code>--module nodenext</code></a>），但 <code>es2022</code> 是支持该功能的首个稳定版本。</p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/44656">PR</a>。</p>
<h3 id="在条件类型上消除尾递归"><a class="header" href="#在条件类型上消除尾递归">在条件类型上消除尾递归</a></h3>
<p>当 TypeScript 检测到了以下情况时通常需要优雅地失败，比如无限递归、极其耗时以至影响编辑器使用体验的类型展开操作。
因此，TypeScript 会使用试探式的方法来确保它在试图拆分一个无限层级的类型时或操作将生成大量中间结果的类型时不会偏离轨道。</p>
<pre><code class="language-ts">type InfiniteBox&lt;T&gt; = { item: InfiniteBox&lt;T&gt; };

type Unpack&lt;T&gt; = T extends { item: infer U } ? Unpack&lt;U&gt; : T;

// error: Type instantiation is excessively deep and possibly infinite.
type Test = Unpack&lt;InfiniteBox&lt;number&gt;&gt;;
</code></pre>
<p>上例是有意写成简单且没用的类型，但是存在大量有用的类型恰巧会触发试探。
作为示例，下面的 <code>TrimLeft</code> 类型会从字符串类型的开头删除空白。
若给定一个在开头位置有一个空格的字符串类型，它会直接将空格后面的字符串再传入 <code>TrimLeft</code>。</p>
<pre><code class="language-ts">type TrimLeft&lt;T extends string&gt; = T extends ` ${infer Rest}`
  ? TrimLeft&lt;Rest&gt;
  : T;

// Test = "hello" | "world"
type Test = TrimLeft&lt;"   hello" | " world"&gt;;
</code></pre>
<p>这个类型也许有用，但如果字符串起始位置有 50 个空格，就会产生错误。</p>
<pre><code class="language-ts">type TrimLeft&lt;T extends string&gt; = T extends ` ${infer Rest}`
  ? TrimLeft&lt;Rest&gt;
  : T;

// error: Type instantiation is excessively deep and possibly infinite.
type Test = TrimLeft&lt;"                                                oops"&gt;;
</code></pre>
<p>这很讨厌，因为这种类型在表示字符串操作时很有用 - 例如，URL 路由解析器。
更差的是，越有用的类型越会创建更多的实例化类型，结果就是对输入参数会有限制。</p>
<p>但也有一个可取之处：<code>TrimLeft</code> 在一个分支中使用了<em>尾递归</em>的方式编写。
当它再次调用自己时，是直接返回了结果并且不存在后续操作。
由于这些类型不需要创建中间结果，因此可以被更快地实现并且可以避免触发 TypeScript 内置的类型递归试探。</p>
<p>这就是 TypeScript 4.5 在条件类型上删除尾递归的原因。
只要是条件类型的某个分支为另一个条件类型，TypeScript 就不会去生成中间类型。
虽说仍然会进行一些试探来确保类型没有偏离方向，但已无伤大雅。</p>
<p>注意，下面的类型<em>不会</em>被优化，因为它使用了包含条件类型的联合类型。</p>
<pre><code class="language-ts">type GetChars&lt;S&gt; = S extends `${infer Char}${infer Rest}`
  ? Char | GetChars&lt;Rest&gt;
  : never;
</code></pre>
<p>如果你想将它改成尾递归，可以引入帮助类型来接收一个累加类型的参数，就如同尾递归函数一样。</p>
<pre><code class="language-ts">type GetChars&lt;S&gt; = GetCharsHelper&lt;S, never&gt;;
type GetCharsHelper&lt;S, Acc&gt; = S extends `${infer Char}${infer Rest}`
  ? GetCharsHelper&lt;Rest, Char | Acc&gt;
  : Acc;
</code></pre>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/45711">PR</a>。</p>
<h3 id="禁用导入省略"><a class="header" href="#禁用导入省略">禁用导入省略</a></h3>
<p>在某些情况下，TypeScript 无法检测导入是否被使用。
例如，考虑下面的代码：</p>
<pre><code class="language-ts">import { Animal } from "./animal.js";

eval("console.log(new Animal().isDangerous())");
</code></pre>
<p>默认情况下，TypeScript 会删除上面的导入语句，因为它看上去没有被使用。
在 TypeScript 4.5 里，你可以启用新的标记 <a href="zh/release-notes//tsconfig#preserveValueImports"><code>preserveValueImports</code></a> 来阻止 TypeScript 从生成的 JavaScript 代码里删除导入的值。
虽说应该使用 <code>eval</code> 的理由不多，但在 Svelte 框架里有相似的情况：</p>
<pre><code class="language-html">&lt;!-- A .svelte File --&gt;
&lt;script&gt;
  import { someFunc } from "./some-module.js";
&lt;/script&gt;

&lt;button on:click="{someFunc}"&gt;Click me!&lt;/button&gt;
</code></pre>
<p>同样在 Vue.js 中，使用 <code>&lt;script setup&gt;</code> 功能：</p>
<pre><code class="language-html">&lt;!-- A .vue File --&gt;
&lt;script setup&gt;
  import { someFunc } from "./some-module.js";
&lt;/script&gt;

&lt;button @click="someFunc"&gt;Click me!&lt;/button&gt;
</code></pre>
<p>这些框架会根据 <code>&lt;script&gt;</code> 标签外的标记来生成代码，但 TypeScript <em>仅仅</em>会考虑 <code>&lt;script&gt;</code> 标签内的代码。
也就是说 TypeScript 会自动删除对 <code>someFunc</code> 的导入，因此上面的代码无法运行！
使用 TypeScript 4.5，你可以通过 <a href="zh/release-notes//tsconfig#preserveValueImports"><code>preserveValueImports</code></a> 来避免发生这种情况。</p>
<p>当该标记和 <a href="zh/release-notes//tsconfig#isolatedModules">--isolatedModules`</a> 一起使用时有个额外要求：导入的类型<em>必须</em>被标记为 type-only，因为编译器一次处理一个文件，无法知道是否导入了未被使用的值，或是导入了必须要被删除的类型以防运行时崩溃。</p>
<pre><code class="language-ts">// Which of these is a value that should be preserved? tsc knows, but `ts.transpileModule`,
// ts-loader, esbuild, etc. don't, so `isolatedModules` gives an error.
import { someFunc, BaseType } from "./some-module.js";
//                 ^^^^^^^^
// Error: 'BaseType' is a type and must be imported using a type-only import
// when 'preserveValueImports' and 'isolatedModules' are both enabled.
</code></pre>
<p>这催生了另一个 TypeScript 4.5 的功能，<a href="zh/release-notes/typescript-4.5.html#type-on-import-names">导入语句中的 <code>type</code> 修饰符</a>，它尤其重要。</p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/44619">PR</a>。</p>
<h3 id="在导入名称前使用-type-修饰符"><a class="header" href="#在导入名称前使用-type-修饰符">在导入名称前使用 <code>type</code> 修饰符</a></h3>
<p>上面提到，<a href="zh/release-notes//tsconfig#preserveValueImports"><code>preserveValueImports</code></a> 和 <a href="zh/release-notes//tsconfig#isolatedModules"><code>isolatedModules</code></a> 结合使用时有额外的要求，这是为了让构建工具能够明确知道是否可以省略导入语句。</p>
<pre><code class="language-ts">// Which of these is a value that should be preserved? tsc knows, but `ts.transpileModule`,
// ts-loader, esbuild, etc. don't, so `isolatedModules` issues an error.
import { someFunc, BaseType } from "./some-module.js";
//                 ^^^^^^^^
// Error: 'BaseType' is a type and must be imported using a type-only import
// when 'preserveValueImports' and 'isolatedModules' are both enabled.
</code></pre>
<p>当同时使用了这些选项时，需要有一种方式来表示导入语句是否可以被合法地丢弃。
TypeScript 已经有类似的功能，即 <code>import type</code>：</p>
<pre><code class="language-ts">import type { BaseType } from "./some-module.js";
import { someFunc } from "./some-module.js";

export class Thing implements BaseType {
  // ...
}
</code></pre>
<p>这是有效的，但还可以提供更好的方式来避免使用两条导入语句从相同的模块中导入。
因此，TypeScript 4.5 允许在每个命名导入前使用 <code>type</code> 修饰符，你可以按需混合使用它们。</p>
<pre><code class="language-ts">import { someFunc, type BaseType } from "./some-module.js";

export class Thing implements BaseType {
    someMethod() {
        someFunc();
    }
}
</code></pre>
<p>上例中，在 <a href="zh/release-notes//tsconfig#preserveValueImports"><code>preserveValueImports</code></a> 模式下，能够确定 <code>BaseType</code> 可以被删除，同时 <code>someFunc</code> 应该被保留，于是就会生成如下代码：</p>
<pre><code class="language-js">import { someFunc } from "./some-module.js";

export class Thing {
  someMethod() {
    someFunc();
  }
}
</code></pre>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/45998">PR</a>。</p>
<h3 id="私有字段存在性检查"><a class="header" href="#私有字段存在性检查">私有字段存在性检查</a></h3>
<p>TypeScript 4.5 支持了检查对象上是否存在某私有字段的 ECMAScript Proposal。
现在，你可以编写带有 <code>#private</code> 字段成员的类，然后使用 <code>in</code> 运算符检查另一个对象是否包含相同的字段。</p>
<pre><code class="language-ts">class Person {
    #name: string;
    constructor(name: string) {
        this.#name = name;
    }

    equals(other: unknown) {
        return other &amp;&amp;
            typeof other === "object" &amp;&amp;
            #name in other &amp;&amp; // &lt;- this is new!
            this.#name === other.#name;
    }
}
</code></pre>
<p>该功能一个有趣的地方是，<code>#name in other</code> 隐含了 <code>other</code> 必须是使用 <code>Person</code> 构造的，因为只有在这种情况下才可能存在该字段。
这是该提议中关键的功能之一，同时也是为什么这项提议叫作 “ergonomic brand checks” 的原因 - 因为私有字段通常作为一种“商标”来区分不同类的实例。
因此，TypeScript 能够在每次检查中细化 <code>other</code>类型，直到细化为 <code>Person</code> 类型。</p>
<p>感谢来自 Bloomberg 的朋友提交的 <a href="https://github.com/microsoft/TypeScript/pull/44648">PR</a>：<a href="https://github.com/acutmore">Ashley Claymore</a>，<a href="https://github.com/dragomirtitian">Titian Cernicova-Dragomir</a>，<a href="https://github.com/mkubilayk">Kubilay Kahveci</a>，和 <a href="https://github.com/robpalme">Rob Palmer</a>！</p>
<h3 id="导入断言"><a class="header" href="#导入断言">导入断言</a></h3>
<p>TypeScript 4.5 支持了 ECMAScript Proposal 中的 <em>导入断言</em>。
该语法会被运行时所使用来检查导入是否为期望的格式。</p>
<pre><code class="language-ts">import obj from "./something.json" assert { type: "json" };
</code></pre>
<p>TypeScript 不会检查这些断言，因为它们依赖于宿主环境。
TypeScript 会保留原样，稍后让浏览器或者运行时来处理它们（也可能会出错）。</p>
<pre><code class="language-ts">// TypeScript 允许
// 但浏览器可能不允许
import obj from "./something.json" assert {
    type: "fluffy bunny"
};
</code></pre>
<p>动态的 <code>import()</code> 调用可以通过第二个参数来使用导入断言。</p>
<pre><code class="language-ts">const obj = await import("./something.json", {
  assert: { type: "json" },
});
</code></pre>
<p>第二个参数的类型为 <code>ImportCallOptions</code>，并且目前它只接受一个 <code>assert</code> 属性。</p>
<p>感谢 <a href="https://github.com/Kingwl/">Wenlu Wang</a> 实现了 <a href="https://github.com/microsoft/TypeScript/pull/40698">这个功能</a>！</p>
<h3 id="使用-realpathsyncnative-获得更快的加载速度"><a class="header" href="#使用-realpathsyncnative-获得更快的加载速度">使用 <code>realPathSync.native</code> 获得更快的加载速度</a></h3>
<p>TypeScript 在所有操作系统上使用了 Node.js <code>realPathSync</code> 函数的系统原生实现。</p>
<p>以前，这个函数只在 Linux 上使用了，但在 TypeScript 4.5 中，在大小写不敏感的操作系统上，如 Windows 和 MacOS，也被采用了。
对于一些代码库来讲这个改动会提升 5 ~ 13% 的加载速度（和操作系统有关）。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/44966">PR</a>。</p>
<h3 id="jsx-attributes-的代码片段自动补全"><a class="header" href="#jsx-attributes-的代码片段自动补全">JSX Attributes 的代码片段自动补全</a></h3>
<p>TypeScript 4.5 为 JSX 属性提供了<em>代码片段自动补全</em>功能。
当在 JSX 标签上输入属性时，TypeScript 已经能够提供提供建议；
但对于代码片段自动补全来讲，它们会删除部分已经输入的字符来添加一个初始化器并将光标放到正确的位置。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/jsx-attributes-snippets-4-5.gif" alt="Snippet completions for JSX attributes. For a string property, quotes are automatically added. For a numeric properties, braces are added." /></p>
<p>TypeScript 通常会使用属性的类型来判断插入哪种初始化器，但你可以在 Visual Studio Code 中自定义该行为。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/jsx-snippet-settings-4-5.png" alt="Settings in VS Code for JSX attribute completions" /></p>
<p>注意，该功能只在新版本的 Visual Studio Code 中支持，因此你可能需要使用 Insiders 版本。
更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/45903">PR</a>。</p>
<h3 id="为未解决类型提供更好的编辑器支持"><a class="header" href="#为未解决类型提供更好的编辑器支持">为未解决类型提供更好的编辑器支持</a></h3>
<p>在某些情况下，编辑器会使用一个轻量级的“部分”语义模式 - 比如编辑器正在等待加载完整的工程，又或者是 <a href="https://docs.github.com/en/codespaces/developing-in-codespaces/web-based-editor">GitHub 的基于 web 的编辑器</a>。</p>
<p>在旧版本 TypeScript 中，如果语言服务无法找到一个类型，它会输出 <code>any</code>。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/quick-info-unresolved-4-4.png" alt="Hovering over a signature where Buffer isn&#39;t found, TypeScript replaces it with any." /></p>
<p>上例中，没有找到 <code>Buffer</code>，因此 TypeScript 在 <em>quick info</em> 里显示了 <code>any</code>。
在 TypeScript 4.5 中，TypeScript 会尽可能保留你编写的代码。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/quick-info-unresolved-4-5.png" alt="Hovering over a signature where Buffer isn&#39;t found, it continues to use the name Buffer." /></p>
<p>然而，当你将鼠标停在 <code>Buffer</code> 上时，你会看到 TypeScript 无法找到 <code>Buffer</code> 的提示。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/10/quick-info-unresolved-on-type-4-5.png" alt="TypeScript displays type Buffer = /* unresolved */ any;" /></p>
<p>总之，在 TypeScript 还没有读取整个工程的时候，它提供了更加平滑的体验。
注意，在其它正常情况下，当无法找到某个类型时总会产生错误。</p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/45976">PR</a>。</p>
<!--
### Breaking Changes

#### `lib.d.ts` Changes

TypeScript 4.5 contains changes to its built-in declaration files which may affect your compilation;
however, [these changes were fairly minimal](https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1143), and we expect most code will be unaffected.

#### Inference Changes from `Awaited`

Because `Awaited` is now used in `lib.d.ts` and as a result of `await`, you may see certain generic types change that might cause incompatibilities;
however, given many intentional design decisions around `Awaited` to avoid breakage, we expect most code will be unaffected.

#### Compiler Options Checking at the Root of `tsconfig.json`

It's an easy mistake to accidentally forget about the `compilerOptions` section in a `tsconfig.json`.
To help catch this mistake, in TypeScript 4.5, it is an error to add a top-level field which matches any of the available options in `compilerOptions` _without_ having also defined `compilerOptions` in that `tsconfig.json`.
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-44"><a class="header" href="#typescript-44">TypeScript 4.4</a></h1>
<h2 id="针对条件表达式和判别式的别名引用进行控制流分析"><a class="header" href="#针对条件表达式和判别式的别名引用进行控制流分析">针对条件表达式和判别式的别名引用进行控制流分析</a></h2>
<p>在 JavaScript 中，总会用多种方式对某个值进行检查，然后根据不同类型的值执行不同的操作。
TypeScript 能够理解这些检查，并将它们称作为<em>类型守卫</em>。
我们不需要在变量的每一个使用位置上都指明类型，TypeScript 的类型检查器能够利用<em>基于控制流的分析</em>技术来检查是否在前面使用了类型守卫。</p>
<p>例如，可以这样写</p>
<pre><code class="language-ts twoslash">function foo(arg: unknown) {
    if (typeof arg === 'string') {
        console.log(arg.toUpperCase());
        //           ^?
    }
}
</code></pre>
<p>这个例子中，我们检查 <code>arg</code> 是否为 <code>string</code> 类型。
TypeScript 识别出了 <code>typeof arg === "string"</code> 检查，它被当作是一个类型守卫，并且知道在 <code>if</code> 分支内 <code>arg</code> 的类型为 <code>string</code>。
这样就可以正常地访问 <code>string</code> 类型上的方法，例如 <code>toUpperCase()</code>。</p>
<p>但如果我们将条件表达式提取到一个名为 <code>argIsString</code> 的常量会发生什么？</p>
<pre><code class="language-ts">// 在 TS 4.3 及以下版本

function foo(arg: unknown) {
    const argIsString = typeof arg === 'string';
    if (argIsString) {
        console.log(arg.toUpperCase());
        //              ~~~~~~~~~~~
        // 错误！'unknown' 类型上不存在 'toUpperCase' 属性。
    }
}
</code></pre>
<p>在之前版本的 TypeScript 中，这样做会产生错误 - 就算 <code>argIsString</code> 的值为类型守卫，TypeScript 也会丢掉这个信息。
这不是想要的结果，因为我们可能想要在不同的地方重用这个检查。
为了绕过这个问题，通常需要重复多次代码或使用类型断言。</p>
<p>在 TypeScript 4.4 中，情况有所改变。
上面的例子不再产生错误！
当 TypeScript 看到我们在检查一个常量时，会额外检查它是否包含类型守卫。
如果那个类型守卫操作的是 <code>const</code> 常量，某个 <code>readonly</code> 属性或某个未修改的参数，那么 TypeScript 能够对该值进行类型细化。</p>
<p>不同种类的类型守卫都支持，不只是 <code>typeof</code> 类型守卫。
例如，对于可辨识联合类型同样适用。</p>
<pre><code class="language-ts twoslash">type Shape =
    | { kind: 'circle'; radius: number }
    | { kind: 'square'; sideLength: number };

function area(shape: Shape): number {
    const isCircle = shape.kind === 'circle';
    if (isCircle) {
        // 知道此处为 circle
        return Math.PI * shape.radius ** 2;
    } else {
        // 知道此处为 square
        return shape.sideLength ** 2;
    }
}
</code></pre>
<p>在 TypeScript 4.4 版本中对判别式的分析又进了一层 - 现在可以提取出判别式然后细化原来的对象类型。</p>
<pre><code class="language-ts twoslash">type Shape =
    | { kind: 'circle'; radius: number }
    | { kind: 'square'; sideLength: number };

function area(shape: Shape): number {
    // Extract out the 'kind' field first.
    const { kind } = shape;

    if (kind === 'circle') {
        // We know we have a circle here!
        return Math.PI * shape.radius ** 2;
    } else {
        // We know we're left with a square here!
        return shape.sideLength ** 2;
    }
}
</code></pre>
<p>另一个例子，该函数会检查它的两个参数是否有内容。</p>
<pre><code class="language-ts twoslash">function doSomeChecks(
    inputA: string | undefined,
    inputB: string | undefined,
    shouldDoExtraWork: boolean
) {
    const mustDoWork = inputA &amp;&amp; inputB &amp;&amp; shouldDoExtraWork;
    if (mustDoWork) {
        // We can access 'string' properties on both 'inputA' and 'inputB'!
        const upperA = inputA.toUpperCase();
        const upperB = inputB.toUpperCase();
        // ...
    }
}
</code></pre>
<p>TypeScript 知道如果 <code>mustDoWork</code> 为 <code>true</code> 那么 <code>inputA</code> 和 <code>inputB</code> 都存在。
也就是说不需要编写像 <code>inputA!</code> 这样的非空断言的代码来告诉 TypeScript <code>inputA</code> 不为 <code>undefined</code>。</p>
<p>一个好的性质是该分析同时具有可传递性。
TypeScript 可以通过这些常量来理解在它们背后执行的检查。</p>
<pre><code class="language-ts twoslash">function f(x: string | number | boolean) {
    const isString = typeof x === 'string';
    const isNumber = typeof x === 'number';
    const isStringOrNumber = isString || isNumber;
    if (isStringOrNumber) {
        x;
        //  ^?
    } else {
        x;
        //  ^?
    }
}
</code></pre>
<p>注意这里会有一个截点 - TypeScript 并不是毫无限制地去追溯检查这些条件表达式，但对于大多数使用场景而言已经足够了。</p>
<p>这个功能能让很多直观的 JavaScript 代码在 TypeScript 里也好用，而不会妨碍我们。
更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/44730">PR</a>！</p>
<h2 id="symbol-以及模版字符串索引签名"><a class="header" href="#symbol-以及模版字符串索引签名">Symbol 以及模版字符串索引签名</a></h2>
<p>TypeScript 支持使用<em>索引签名</em>来为对象的每个属性定义类型。
这样我们就可以将对象当作字典类型来使用，把字符串放在方括号里来进行索引。</p>
<p>例如，可以编写由 <code>string</code> 类型的键映射到 <code>boolean</code> 值的类型。
如果我们给它赋予 <code>boolean</code> 类型以外的值会报错。</p>
<pre><code class="language-ts twoslash">interface BooleanDictionary {
    [key: string]: boolean;
}

declare let myDict: BooleanDictionary;

// 允许赋予 boolean 类型的值
myDict['foo'] = true;
myDict['bar'] = false;

// 错误
myDict['baz'] = 'oops';
</code></pre>
<p>虽说在这里 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code> 可能是更适合的数据结构</a>（具体的说是 <code>Map&lt;string, boolean&gt;</code>），但 JavaScript 对象通常更方便或者正是我们要操作的目标。</p>
<p>相似地，<code>Array&lt;T&gt;</code> 已经定义了 <code>number</code> 索引签名，我们可以插入和获取 <code>T</code> 类型的值。</p>
<pre><code class="language-ts">// 这是 TypeScript 内置的部分 Array 类型
interface Array&lt;T&gt; {
    [index: number]: T;

    // ...
}

let arr = new Array&lt;string&gt;();

// 没问题
arr[0] = 'hello!';

// 错误，期待一个 'string' 值
arr[1] = 123;
</code></pre>
<p>索引签名是一种非常有用的表达方式。
然而，直到现在它们只能使用 <code>string</code> 和 <code>number</code> 类型的键（<code>string</code> 索引签名存在一个有意为之的怪异行为，它们可以接受 <code>number</code> 类型的键，因为 <code>number</code> 会被转换为字符串）。
这意味着 TypeScript 不允许使用 <code>symbol</code> 类型的键来索引对象。
TypeScript 也无法表示由一部分 <code>string</code> 类型的键组成的索引签名 - 例如，对象属性名是以 <code>data-</code> 字符串开头的索引签名。</p>
<p>TypeScript 4.4 解决了这个问题，允许 <code>symbol</code> 索引签名以及模版字符串。</p>
<p>例如，TypeScript 允许声明一个接受任意 <code>symbol</code> 值作为键的对象类型。</p>
<pre><code class="language-ts twoslash">interface Colors {
    [sym: symbol]: number;
}

const red = Symbol('red');
const green = Symbol('green');
const blue = Symbol('blue');

let colors: Colors = {};

// 没问题
colors[red] = 255;
let redVal = colors[red];
//  ^ number

colors[blue] = 'da ba dee';
// 错误：'string' 不能赋值给 'number'
</code></pre>
<p>相似地，可以定义带有模版字符串的索引签名。
一个场景是用来免除对以 <code>data-</code> 开头的属性名执行的 TypeScript 额外属性检查。
当传递一个对象字面量给目标类型时，TypeScript 会检查是否存在相比于目标类型的额外属性。</p>
<pre><code class="language-ts">interface Options {
    width?: number;
    height?: number;
}

let a: Options = {
    width: 100,
    height: 100,

    'data-blah': true,
};

interface OptionsWithDataProps extends Options {
    // 允许以 'data-' 开头的属性
    [optName: `data-${string}`]: unknown;
}

let b: OptionsWithDataProps = {
    width: 100,
    height: 100,
    'data-blah': true,

    // 使用未知属性会报错，不包括以 'data-' 开始的属性
    'unknown-property': true,
};
</code></pre>
<p>最后，索引签名现在支持联合类型，只要它们是无限域原始类型的联合 - 尤其是：</p>
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>symbol</code></li>
<li>模版字符串（例如 <code>`hello-${string}`</code>）</li>
</ul>
<p>带有以上类型的联合的索引签名会展开为不同的索引签名。</p>
<pre><code class="language-ts">interface Data {
    [optName: string | symbol]: any;
}

// 等同于

interface Data {
    [optName: string]: any;
    [optName: symbol]: any;
}
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/44512">PR</a>。</p>
<h2 id="defaulting-to-the-unknown-type-in-catch-variables---useunknownincatchvariables"><a class="header" href="#defaulting-to-the-unknown-type-in-catch-variables---useunknownincatchvariables">Defaulting to the <code>unknown</code> Type in Catch Variables (<code>--useUnknownInCatchVariables</code>)</a></h2>
<h2 id="异常捕获变量的类型默认为-unknown---useunknownincatchvariables"><a class="header" href="#异常捕获变量的类型默认为-unknown---useunknownincatchvariables">异常捕获变量的类型默认为 <code>unknown</code> （<code>--useUnknownInCatchVariables</code>）</a></h2>
<p>在 JavaScript 中，允许使用 <code>throw</code> 语句抛出任意类型的值，并在 <code>catch</code> 语句中捕获它。
因此，TypeScript 从前会将异常捕获变量的类型设置为 <code>any</code> 类型，并且不允许指定其它的类型注解:</p>
<pre><code class="language-ts">try {
    // 谁知道它会抛出什么东西
    executeSomeThirdPartyCode();
} catch (err) {
    // err: any
    console.error(err.message); // 可以，因为类型为 'any'
    err.thisWillProbablyFail(); // 可以，因为类型为 'any' :(
}
</code></pre>
<p>当 TypeScript 引入了 <code>unknown</code> 类型后，对于追求高度准确性和类型安全的用户来讲在 <code>catch</code> 语句的捕获变量处使用 <code>unknown</code> 成为了比 <code>any</code> 类型更好的选择，因为它强制我们去检测要使用的值。
后来，TypeScript 4.0 允许用户在 <code>catch</code> 语句中明确地指定 <code>unknown</code>（或 <code>any</code>）类型，这样就可以根据情况有选择一使用更严格的类型检查；
然而，在每一处 <code>catch</code> 语句里手动指定 <code>: unknown</code> 是一件繁琐的事情。</p>
<p>因此，TypeScript 4.4 引入了一个新的标记 <code>--useUnknownInCatchVariables</code>。
它将 <code>catch</code> 语句捕获变量的默认类型由 <code>any</code> 改为 <code>unknown</code>。</p>
<pre><code class="language-ts">declare function executeSomeThirdPartyCode(): void;

try {
    executeSomeThirdPartyCode();
} catch (err) {
    // err: unknown

    // Error! Property 'message' does not exist on type 'unknown'.
    console.error(err.message);

    // Works! We can narrow 'err' from 'unknown' to 'Error'.
    if (err instanceof Error) {
        console.error(err.message);
    }
}
</code></pre>
<p>这个标记属性于 <code>--strict</code> 标记家族的一员。
也就是说如果你启用了 <code>--strict</code>，那么该标记也自动启用了。
在 TypeScript 4.4 中，你可能会看到如下的错误：</p>
<pre><code>Property 'message' does not exist on type 'unknown'.
Property 'name' does not exist on type 'unknown'.
Property 'stack' does not exist on type 'unknown'.
</code></pre>
<p>如果我们不想处理 <code>catch</code> 语句中 <code>unknown</code> 类型的捕获变量，那么可以明确使用 <code>: any</code> 类型注解，这样就会关闭严格类型检查。</p>
<pre><code class="language-ts twoslash">declare function executeSomeThirdPartyCode(): void;

try {
    executeSomeThirdPartyCode();
} catch (err: any) {
    console.error(err.message); // Works again!
}
</code></pre>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/41013">PR</a>。</p>
<h2 id="确切的可选属性类型---exactoptionalpropertytypes"><a class="header" href="#确切的可选属性类型---exactoptionalpropertytypes">确切的可选属性类型 (<code>--exactOptionalPropertyTypes</code>)</a></h2>
<p>在 JavaScript 中，读取对象上某个不存在的属性会得到 <code>undefined</code> 值。
与此同时，某个已有属性的值也允许为 <code>undefined</code> 值。
有许多 JavaScript 代码都会对这些情况一视同仁，因此最初 TypeScript 将可选属性视为添加了 <code>undefined</code> 类型。
例如，</p>
<pre><code class="language-ts">interface Person {
    name: string;
    age?: number;
}
</code></pre>
<p>等同于：</p>
<pre><code class="language-ts">interface Person {
    name: string;
    age?: number | undefined;
}
</code></pre>
<p>这意味着用户可以给 <code>age</code> 明确地指定 <code>undefined</code> 值。</p>
<pre><code class="language-ts">const p: Person = {
    name: 'Daniel',
    age: undefined, // This is okay by default.
};
</code></pre>
<p>因此默认情况下，TypeScript 不区分带有 <code>undefined</code> 类型的属性和不存在的属性。
虽说这在大部分情况下是没问题的，但并非所有的 JavaScript 代码都如此。
像是 <code>Object.assign</code>，<code>Object.keys</code>，对象展开（<code>{ ...obj }</code>）和 <code>for</code>-<code>in</code> 循环这样的函数和运算符会区别对待属性是否存在于对象之上。
在 <code>Person</code> 例子中，如果 <code>age</code> 属性的存在与否是至关重要的，那么就可能会导致运行时错误。</p>
<p>在 TypeScript 4.4 中，新的 <code>--exactOptionalPropertyTypes</code> 标记指明了可选属性的确切表示方式，即不自动添加 <code>| undefined</code> 类型：</p>
<pre><code class="language-ts twoslash">interface Person {
    name: string;
    age?: number;
}

// 启用 'exactOptionalPropertyTypes'
const p: Person = {
    name: 'Daniel',
    age: undefined, // 错误！undefined 不是一个成员
};
</code></pre>
<p>该标记<strong>不是</strong> <code>--strict</code> 标记家族的一员，需要显式地开启。
该标记要求同时启用 <code>--strictNullChecks</code> 标记。
我们已经更新了 DefinitelyTyped 以及其它的声明定义来帮助进行平稳地过渡，但你仍可能遇到一些问题，这取决于代码的结构。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/43947">PR</a>。</p>
<h2 id="类中的-static-语句块"><a class="header" href="#类中的-static-语句块">类中的 <code>static</code> 语句块</a></h2>
<p>TypeScript 4.4 支持了 <a href="https://github.com/tc39/proposal-class-static-block#ecmascript-class-static-initialization-blocks">类中的 <code>static</code> 语句块</a>，一个即将到来的 ECMAScript 特性，它能够帮助编写复杂的静态成员初始化代码。</p>
<pre><code class="language-ts">declare function someCondition(): boolean

class Foo {
    static count = 0;

    // 静态语句块：
    static {
        if (someCondition()) {
            Foo.count++;
        }
    }
}
</code></pre>
<p>在静态语句块中允许编写一系列语句，它们可以访问类中的私有字段。
也就是说在初始化代码中能够编写语句，不会暴露变量，并且可以完全访问类的内部信息。</p>
<pre><code class="language-ts">declare function loadLastInstances(): any[]

class Foo {
    static #count = 0;

    get count() {
        return Foo.#count;
    }

    static {
        try {
            const lastInstances = loadLastInstances();
            Foo.#count += lastInstances.length;
        }
        catch {}
    }
}
</code></pre>
<p>若不使用 <code>static</code> 语句块也能够编写上述代码，只不过需要使用一些折中的 hack 手段。</p>
<p>一个类可以有多个 <code>static</code> 语句块，它们的运行顺序与编写顺序一致。</p>
<pre><code class="language-ts">// Prints:
//    1
//    2
//    3
class Foo {
    static prop = 1
    static {
        console.log(Foo.prop++);
    }
    static {
        console.log(Foo.prop++);
    }
    static {
        console.log(Foo.prop++);
    }
}
</code></pre>
<p>感谢 <a href="https://github.com/Kingwl">Wenlu Wang</a> 为 TypeScript 添加了该支持。
更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/43370">PR</a>。</p>
<h2 id="tsc---help-更新与优化"><a class="header" href="#tsc---help-更新与优化"><code>tsc --help</code> 更新与优化</a></h2>
<p>TypeScript 的 <code>--help</code> 选项完全更新了！
感谢 <a href="https://github.com/ShuiRuTian">Song Gao</a>，我们<a href="https://github.com/microsoft/TypeScript/pull/44409">更新了编译选项的描述</a>和 <a href="https://github.com/microsoft/TypeScript/pull/44157"><code>--help</code> 菜单的配色样式</a>。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/tsc-help-ps-wt-4-4.png" alt="The new TypeScript --help menu where the output is bucketed into several different areas" /></p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/issues/44074">Issue</a>。</p>
<h2 id="性能优化-1"><a class="header" href="#性能优化-1">性能优化</a></h2>
<h3 id="更快地生成声明文件"><a class="header" href="#更快地生成声明文件">更快地生成声明文件</a></h3>
<p>TypeScript 现在会缓存下内部符号是否可以在不同上下文中被访问，以及如何显示指定的类型。
这些改变能够改进 TypeScript 处理复杂类型时的性能，尤其是在使用了 <code>--declaration</code> 标记来生成 <code>.d.ts</code> 文件的时候。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/43973">PR</a>。</p>
<h3 id="更快地标准化路径"><a class="header" href="#更快地标准化路径">更快地标准化路径</a></h3>
<p>TypeScript 经常需要对文件路径进行“标准化”操作来得到统一的格式，以便编译器能够随处使用它。
它包括将反斜线替换成正斜线，或者删除路径中间的 <code>/./</code> 和 <code>/../</code> 片段。
当 TypeScript 需要处理成千上万的路径时，这个操作就会很慢。
在 TypeScript 4.4 里会先对路径进行快速检查，判断它们是否需要进行标准化。
这些改进能够减少 5-10% 的工程加载时间，对于大型工程来讲效果会更加明显。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/44173">PR</a> 以及 <a href="https://github.com/microsoft/TypeScript/pull/44100">PR</a>。</p>
<h3 id="更快地路径映射"><a class="header" href="#更快地路径映射">更快地路径映射</a></h3>
<p>TypeScript 现在会缓存构造的路径映射（通过 <code>tsconfig.json</code> 里的 <code>paths</code>）。
对于拥有数百个路径映射的工程来讲效果十分明显。
更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/44078">PR</a>。</p>
<h3 id="更快地增量构建与---strict"><a class="header" href="#更快地增量构建与---strict">更快地增量构建与 <code>--strict</code></a></h3>
<p>这曾是一个缺陷，在 <code>--incremental</code> 模式下，如果启用了 <code>--strict</code> 则 TypeScript 会重新进行类型检查。
这导致了不管是否开启了 <code>--incremental</code> 构建速度都挺慢。
TypeScript 4.4 修复了这个问题，该修复也应用到了 TypeScript 4.3 里。</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/44394">PR</a>。</p>
<h3 id="针对大型输出更快地生成-source-map"><a class="header" href="#针对大型输出更快地生成-source-map">针对大型输出更快地生成 Source Map</a></h3>
<p>TypeScript 4.4 优化了为超大输出文件生成 source map 的速度。
在构建旧版本的 TypeScript 编译器时，结果显示节省了 8% 的生成时间。</p>
<p>感谢 <a href="https://github.com/dmichon-msft">David Michon</a> 提供了这项<a href="https://github.com/microsoft/TypeScript/pull/44031">简洁的优化</a>。</p>
<h3 id="更快的---force-构建"><a class="header" href="#更快的---force-构建">更快的 <code>--force</code> 构建</a></h3>
<p>当在工程引用上使用了 <code>--build</code> 模式时，TypeScript 必须执行“是否更新检查”来确定是否需要重新构建。
在进行 <code>--force</code> 构建时，该检查是无关的，因为每个工程依赖都要被重新构建。
在 TypeScript 4.4 里，<code>--force</code> 会避免执行无用的步骤并进行完整的构建。
更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/43666">PR</a>。</p>
<h2 id="javascript-中的拼写建议"><a class="header" href="#javascript-中的拼写建议">JavaScript 中的拼写建议</a></h2>
<p>TypeScript 为在 Visual Studio 和 Visual Studio Code 等编辑器中的 JavaScript 编写体验赋能。
大多数情况下，在处理 JavaScript 文件时，TypeScript 会置身事外；
然而，TypeScript 经常能够提供有理有据的建议且不过分地侵入其中。</p>
<p>这就是为什么 TypeScript 会为 JavaScript 文件提供拼写建议 - 不带有 <code>// @ts-check</code> 的 文件或者关闭了 <code>checkJs</code> 选项的工程。
即，TypeScript 文件中已有的 <em>"Did you mean...?"</em> 建议，现在它们也作用于 JavaScript 文件。</p>
<p>这些拼写建议也暗示了代码中可能存在错误。
我们在测试该特性时已经发现了已有代码中的一些错误！</p>
<p>更多详情请参考 <a href="https://github.com/microsoft/TypeScript/pull/44271">PR</a>！</p>
<h2 id="内嵌提示inlay-hints"><a class="header" href="#内嵌提示inlay-hints">内嵌提示（Inlay Hints）</a></h2>
<p>TypeScript 4.4 支持了<em>内嵌提示</em>特性，它能帮助显示参数名和返回值类型等信息。
可将其视为一种友好的“ghost text”。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/inlayHints-4.4-rc-ghd.png" alt="A preview of inlay hints in Visual Studio Code" /></p>
<p>该特性由 <a href="https://github.com/Kingwl">Wenlu Wang</a> 的 <a href="https://github.com/microsoft/TypeScript/pull/42089">PR</a> 所实现。</p>
<p>他也在 <a href="https://github.com/microsoft/vscode/pull/113412">Visual Studio Code 里进行了集成</a> 并在 <a href="https://code.visualstudio.com/updates/v1_59#_typescript-44">July 2021 (1.59) 发布</a>。
若你想尝试该特性，需确保安装了<a href="https://code.visualstudio.com/updates/v1_59">稳定版</a>或 <a href="https://code.visualstudio.com/insiders/">insiders</a> 版本的编辑器。
你也可以在 Visual Studio Code 的设置里修改何时何地显示内嵌提示。</p>
<h2 id="自动导入的补全列表里显示真正的路径"><a class="header" href="#自动导入的补全列表里显示真正的路径">自动导入的补全列表里显示真正的路径</a></h2>
<p>当 Visual Studio Code 显示补全列表时，包含自动导入在内的补全列表里会显示指向模块的路径；
然而，该路径通常不是 TypeScript 最终替换进来的模块描述符。
该路径通常是相对于 <em>workspace</em> 的，如果你导入了 <code>moment</code> 包，你大概会看到 <code>node_modules/moment</code> 这样的路径 。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/completion-import-labels-pre-4-4.png" alt="A completion list containing unwieldy paths containing &#39;node_modules&#39;. For example, the label for &#39;calendarFormat&#39; is &#39;node_modules/moment/moment&#39; instead of &#39;moment&#39;." /></p>
<p>这些路径很难处理且容易产生误导，尤其是插入的路径同时需要考虑 Node.js 的 <code>node_modules</code> 解析，路径映射，符号链接以及重新导出等。</p>
<p>这就是为什么 TypeScript 4.4 中的补全列表会显示真正的导入模块路径。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/08/completion-import-labels-4-4.png" alt="A completion list containing clean paths with no intermediate &#39;node_modules&#39;. For example, the label for &#39;calendarFormat&#39; is &#39;moment&#39; instead of &#39;node_modules/moment/moment&#39;." /></p>
<p>由于该计算可能很昂贵，当补全列表包含许多条目时最终的模块描述符会在你输入更多的字符时显示出来。
你仍可能看到基于 workspace 的相对路径；然而，当编辑器“预热”后，再多输入几个字符它们会被替换为真正的路径。</p>
<!--
## Breaking Changes

### `lib.d.ts` Changes for TypeScript 4.4

As with every TypeScript version, declarations for `lib.d.ts` (especially the declarations generated for web contexts), have changed.
You can consult [our list of known `lib.dom.d.ts` changes](https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1029#issuecomment-869224737) to understand what is impacted.

### More-Compliant Indirect Calls for Imported Functions

In earlier versions of TypeScript, calling an import from CommonJS, AMD, and other non-ES module systems would set the `this` value of the called function.
Specifically, in the following example, when calling `fooModule.foo()`, the `foo()` method will have `fooModule` set as the value of `this`.

```ts
// Imagine this is our imported module, and it has an export named 'foo'.
let fooModule = {
    foo() {
        console.log(this);
    },
};

fooModule.foo();
```

This is not the way exported functions in ECMAScript are supposed to work when we call them.
That's why TypeScript 4.4 intentionally discards the `this` value when calling imported functions, by using the following emit.

```ts
// Imagine this is our imported module, and it has an export named 'foo'.
let fooModule = {
    foo() {
        console.log(this);
    },
};

// Notice we're actually calling '(0, fooModule.foo)' now, which is subtly different.
(0, fooModule.foo)();
```

You can [read up more about the changes here](https://github.com/microsoft/TypeScript/pull/44624).

### Using `unknown` in Catch Variables

Users running with the `--strict` flag may see new errors around `catch` variables being `unknown`, especially if the existing code assumes only `Error` values have been caught.
This often results in error messages such as:

```
Property 'message' does not exist on type 'unknown'.
Property 'name' does not exist on type 'unknown'.
Property 'stack' does not exist on type 'unknown'.
```

To get around this, you can specifically add runtime checks to ensure that the thrown type matches your expected type.
Otherwise, you can just use a type assertion, add an explicit `: any` to your catch variable, or turn off `--useUnknownInCatchVariables`.

### Broader Always-Truthy Promise Checks

In prior versions, TypeScript introduced "Always Truthy Promise checks" to catch code where an `await` may have been forgotten;
however, the checks only applied to named declarations.
That meant that while this code would correctly receive an error...

```ts
async function foo(): Promise<boolean> {
    return false;
}

async function bar(): Promise<string> {
    const fooResult = foo();
    if (fooResult) {
        // <- error! :D
        return 'true';
    }
    return 'false';
}
```

...the following code would not.

```ts
async function foo(): Promise<boolean> {
    return false;
}

async function bar(): Promise<string> {
    if (foo()) {
        // <- no error :(
        return 'true';
    }
    return 'false';
}
```

TypeScript 4.4 now flags both.
For more information, [read up on the original change](https://github.com/microsoft/TypeScript/pull/44491).

### Abstract Properties Do Not Allow Initializers

The following code is now an error because abstract properties may not have initializers:

```ts
abstract class C {
    abstract prop = 1;
    //       ~~~~
    // Property 'prop' cannot have an initializer because it is marked abstract.
}
```

Instead, you may only specify a type for the property:

```ts
abstract class C {
    abstract prop: number;
}
```
--><div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-43"><a class="header" href="#typescript-43">TypeScript 4.3</a></h1>
<h2 id="拆分属性的写入类型"><a class="header" href="#拆分属性的写入类型">拆分属性的写入类型</a></h2>
<p>在 JavaScript 中，API 经常需要对传入的值进行转换，然后再保存。
这种情况在 getter 和 setter 中也常出现。
例如，在某个类中的一个 setter 总是需要将传入的值转换成 <code>number</code>，然后再保存到私有字段中。</p>
<pre><code class="language-js">class Thing {
    #size = 0;

    get size() {
        return this.#size;
    }
    set size(value) {
        let num = Number(value);

        // Don't allow NaN and stuff.
        if (!Number.isFinite(num)) {
            this.#size = 0;
            return;
        }

        this.#size = num;
    }
}
</code></pre>
<p>我们该如何将这段 JavaScript 代码改写为 TypeScript 呢？
从技术上讲，我们不必进行任何特殊处理 - TypeScript 能够识别出 <code>size</code> 是一个数字。</p>
<p>但问题在于 <code>size</code> 不仅仅是允许将 <code>number</code> 赋值给它。
我们可以通过将 <code>size</code> 声明为 <code>unknown</code> 或 <code>any</code> 来解决这个问题：</p>
<pre><code class="language-ts">class Thing {
    // ...
    get size(): unknown {
        return this.#size;
    }
}
</code></pre>
<p>但这不太友好 - <code>unknown</code> 类型会强制在读取 <code>size</code> 值时进行类型断言，同时 <code>any</code> 类型也不会去捕获错误。
如果我们真想要为转换值的 API 进行建模，那么之前版本的 TypeScript 会强制我们在准确性（读取容易，写入难）和自由度（写入方便，读取难）两者之间进行选择。</p>
<p>这就是 TypeScript 4.3 允许分别为读取和写入属性值添加类型的原因。</p>
<pre><code class="language-ts">class Thing {
    #size = 0;

    get size(): number {
        return this.#size;
    }

    set size(value: string | number | boolean) {
        let num = Number(value);

        // Don't allow NaN and stuff.
        if (!Number.isFinite(num)) {
            this.#size = 0;
            return;
        }

        this.#size = num;
    }
}
</code></pre>
<p>上例中，<code>set</code> 存取器使用了更广泛的类型种类（<code>string</code>、<code>boolean</code>和<code>number</code>），但 <code>get</code> 存取器保证它的值为<code>number</code>。
现在，我们再给这类属性赋予其它类型的值就不会报错了！</p>
<pre><code class="language-ts">class Thing {
    #size = 0;

    get size(): number {
        return this.#size;
    }

    set size(value: string | number | boolean) {
        let num = Number(value);

        // Don't allow NaN and stuff.
        if (!Number.isFinite(num)) {
            this.#size = 0;
            return;
        }

        this.#size = num;
    }
}
// ---cut---
let thing = new Thing();

// 可以给 `thing.size` 赋予其它类型的值！
thing.size = 'hello';
thing.size = true;
thing.size = 42;

// 读取 `thing.size` 总是返回数字！
let mySize: number = thing.size;
</code></pre>
<p>当需要判定两个同名属性间的关系时，TypeScript 将只考虑“读取的”类型（比如，<code>get</code> 存取器上的类型）。
而“写入”类型只在直接写入属性值时才会考虑。</p>
<p>注意，这个模式不仅作用于类。
你也可以在对象字面量中为 getter 和 setter 指定不同的类型。</p>
<pre><code class="language-ts">function makeThing(): Thing {
    let size = 0;
    return {
        get size(): number {
            return size;
        },
        set size(value: string | number | boolean) {
            let num = Number(value);

            // Don't allow NaN and stuff.
            if (!Number.isFinite(num)) {
                size = 0;
                return;
            }

            size = num;
        },
    };
}
</code></pre>
<p>事实上，我们在接口/对象类型上支持了为属性的读和写指定不同的类型。</p>
<pre><code class="language-ts">// Now valid!
interface Thing {
    get size(): number;
    set size(value: number | string | boolean);
}
</code></pre>
<p>此处的一个限制是属性的读取类型必须能够赋值给属性的写入类型。
换句话说，getter 的类型必须能够赋值给 setter。
这在一定程度上确保了一致性，一个属性应该总是能够赋值给它自身。</p>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/42425">PR</a>。</p>
<h2 id="override-和---noimplicitoverride-标记"><a class="header" href="#override-和---noimplicitoverride-标记"><code>override</code> 和 <code>--noImplicitOverride</code> 标记</a></h2>
<p>当在 JavaScript 中去继承一个类时，覆写方法十分容易 - 但不幸的是可能会犯一些错误。</p>
<p>其中一个就是会导致丢失重命名。
例如：</p>
<pre><code class="language-ts">class SomeComponent {
    show() {
        // ...
    }
    hide() {
        // ...
    }
}

class SpecializedComponent extends SomeComponent {
    show() {
        // ...
    }
    hide() {
        // ...
    }
}
</code></pre>
<p><code>SpecializedComponent</code> 是 <code>SomeComponent</code> 的子类，并且覆写了 <code>show</code> 和 <code>hide</code> 方法。
猜一猜，如果有人想要将 <code>show</code> 和 <code>hide</code> 方法删除并用单个方法代替会发生什么？</p>
<pre><code class="language-diff"> class SomeComponent {
-    show() {
-        // ...
-    }
-    hide() {
-        // ...
-    }
+    setVisible(value: boolean) {
+        // ...
+    }
 }
 class SpecializedComponent extends SomeComponent {
     show() {
         // ...
     }
     hide() {
         // ...
     }
 }
</code></pre>
<p><em>哦，不！</em>
<code>SpecializedComponent</code> 中的方法没有被更新。
而是变为添加了两个没用的 <code>show</code> 和 <code>hide</code> 方法，它们可能都没有被调用。</p>
<p>此处的部分问题在于我们不清楚这里是想添加新的方法，还是想覆写已有的方法。
因此，TypeScript 4.3 增加了 <code>override</code> 关键字。</p>
<pre><code class="language-ts">class SpecializedComponent extends SomeComponent {
    override show() {
        // ...
    }
    override hide() {
        // ...
    }
}
</code></pre>
<p>当一个方法被标记为 <code>override</code>，TypeScript 会确保在基类中存在同名的方法。</p>
<pre><code class="language-ts">class SomeComponent {
    setVisible(value: boolean) {
        // ...
    }
}
class SpecializedComponent extends SomeComponent {
    override show() {
        //   ~~~~
        //   错误
    }
}
</code></pre>
<p>这是一项重大改进，但如果<em>忘记</em>在方法前添加 <code>override</code> 则不会起作用 - 这也是人们常犯的错误。</p>
<p>例如，可能会不小心覆写了基类中的方法，并且还没有意识到。</p>
<pre><code class="language-ts">class Base {
    someHelperMethod() {
        // ...
    }
}

class Derived extends Base {
    // 不是真正想覆写基类中的方法，
    // 只是想编写一个本地的帮助方法
    someHelperMethod() {
        // ...
    }
}
</code></pre>
<p>因此，TypeScript 4.3 中还增加了一个 <code>--noImplicitOverride</code> 选项。
当启用了该选项，如果覆写了父类中的方法但没有添加 <code>override</code> 关键字，则会产生错误。
在上例中，如果启用了 <code>--noImplicitOverride</code>，则 TypeScript 会报错，并提示我们需要重命名 <code>Derived</code> 中的方法。</p>
<p>感谢开发者社区的贡献。
该功能是在<a href="https://github.com/microsoft/TypeScript/pull/39669">这个 PR</a>中由<a href="https://github.com/Kingwl">Wenlu Wang</a>实现，一个更早的 <code>override</code> 实现是由<a href="https://github.com/pcj">Paul Cody Johnston</a>完成。</p>
<h2 id="模版字符串类型改进"><a class="header" href="#模版字符串类型改进">模版字符串类型改进</a></h2>
<p>在近期的版本中，TypeScript 引入了一种新类型，即：模版字符串类型。
它可以通过连接操作来构造类字符串类型：</p>
<pre><code class="language-ts">type Color = 'red' | 'blue';
type Quantity = 'one' | 'two';

type SeussFish = `${Quantity | Color} fish`;
// 等同于
//   type SeussFish = "one fish" | "two fish"
//                  | "red fish" | "blue fish";
</code></pre>
<p>或者与其它类字符串类型进行模式匹配。</p>
<pre><code class="language-ts">declare let s1: `${number}-${number}-${number}`;
declare let s2: `1-2-3`;

// 正确
s1 = s2;
</code></pre>
<p>我们做的首个改动是 TypeScript 应该在何时去推断模版字符串类型。
当一个模版字符串的类型是由类字符串字面量类型进行的按上下文归类（比如，TypeScript 识别出将模版字符串传递给字面量类型时），它会得到模版字符串类型。</p>
<pre><code class="language-ts">function bar(s: string): `hello ${string}` {
    // 之前会产生错误，但现在没有问题
    return `hello ${s}`;
}
</code></pre>
<p>在类型推断和 <code>extends string</code> 的类型参数上也会起作用。</p>
<pre><code class="language-ts">declare let s: string;
declare function f&lt;T extends string&gt;(x: T): T;

// 以前：string
// 现在：`hello-${string}`
let x2 = f(`hello ${s}`);
</code></pre>
<p>另一个主要的改动是 TypeScript 会更好地进行类型关联，并在不同的模版字符串之间进行推断。</p>
<p>示例如下：</p>
<pre><code class="language-ts">declare let s1: `${number}-${number}-${number}`;
declare let s2: `1-2-3`;
declare let s3: `${number}-2-3`;

s1 = s2;
s1 = s3;
</code></pre>
<p>在检查字符串字面量类型时，例如 <code>s2</code>，TypeScript 可以匹配字符串的内容并计算出在第一个赋值语句中 <code>s2</code> 与 <code>s1</code> 兼容。
然而，当再次遇到模版字符串类型时，则会直接放弃进行匹配。
结果就是，像 <code>s3</code> 到 <code>s1</code> 的赋值语句会出错。</p>
<p>现在，TypeScript 会去判断是否模版字符串的每一部分都能够成功匹配。
你现在可以混合并使用不同的替换字符串来匹配模版字符串，TypeScript 能够更好地计算出它们是否兼容。</p>
<pre><code class="language-ts">declare let s1: `${number}-${number}-${number}`;
declare let s2: `1-2-3`;
declare let s3: `${number}-2-3`;
declare let s4: `1-${number}-3`;
declare let s5: `1-2-${number}`;
declare let s6: `${number}-2-${number}`;

// 下列均无问题
s1 = s2;
s1 = s3;
s1 = s4;
s1 = s5;
s1 = s6;
</code></pre>
<p>在这项改进之后，TypeScript 提供了更好的推断能力。
示例如下：</p>
<pre><code class="language-ts">declare function foo&lt;V extends string&gt;(arg: `*${V}*`): V;

function test&lt;T extends string&gt;(s: string, n: number, b: boolean, t: T) {
    let x1 = foo('*hello*'); // "hello"
    let x2 = foo('**hello**'); // "*hello*"
    let x3 = foo(`*${s}*` as const); // string
    let x4 = foo(`*${n}*` as const); // `${number}`
    let x5 = foo(`*${b}*` as const); // "true" | "false"
    let x6 = foo(`*${t}*` as const); // `${T}`
    let x7 = foo(`**${s}**` as const); // `*${string}*`
}
</code></pre>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/43376">PR：利用按上下文归类</a>，以及<a href="https://github.com/microsoft/TypeScript/pull/43361">PR：改进模版字符串类型的类型推断和检查</a>。</p>
<h2 id="ecmascript-private-的类成员"><a class="header" href="#ecmascript-private-的类成员">ECMAScript <code>#private</code> 的类成员</a></h2>
<p>TypeScript 4.3 扩大了在类中可被声明为 <code>#private</code> <code>#names</code> 的成员的范围，使得它们在运行时成为真正的私有的。
除属性外，方法和存取器也可进行私有命名。</p>
<pre><code class="language-ts">class Foo {
    #someMethod() {
        //...
    }

    get #someValue() {
        return 100;
    }

    publicMethod() {
        // 可以使用
        // 可以在类内部访问私有命名成员。
        this.#someMethod();
        return this.#someValue;
    }
}

new Foo().#someMethod();
//        ~~~~~~~~~~~
// 错误!
// 属性 '#someMethod' 无法在类 'Foo' 外访问，因为它是私有的。

new Foo().#someValue;
//        ~~~~~~~~~~
// 错误!
// 属性 '#someValue' 无法在类 'Foo' 外访问，因为它是私有的。
</code></pre>
<p>更为广泛地，静态成员也可以有私有命名。</p>
<pre><code class="language-ts">class Foo {
    static #someMethod() {
        // ...
    }
}

Foo.#someMethod();
//  ~~~~~~~~~~~
// 错误!
// 属性 '#someMethod' 无法在类 'Foo' 外访问，因为它是私有的。
</code></pre>
<p>该功能是由 Bloomberg 的朋友开发的：<a href="https://github.com/microsoft/TypeScript/pull/42458">PR</a> - 由 <a href="https://github.com/dragomirtitian">Titian Cernicova-Dragomir</a> 和 <a href="https://github.com/mkubilayk">Kubilay Kahveci</a> 开发，并得到了 <a href="https://github.com/joeywatts">Joey Watts</a>，<a href="https://github.com/robpalme">Rob Palmer</a> 和 <a href="https://github.com/tim-mc">Tim McClure</a> 的帮助支持。
感谢他们！</p>
<h2 id="constructorparameters-可用于抽象类"><a class="header" href="#constructorparameters-可用于抽象类"><code>ConstructorParameters</code> 可用于抽象类</a></h2>
<p>在 TypeScript 4.3 中，<code>ConstructorParameters</code>工具类型可以用在 <code>abstract</code> 类上。</p>
<pre><code class="language-ts">abstract class C {
    constructor(a: string, b: number) {
        // ...
    }
}

// 类型为 '[a: string, b: number]'
type CParams = ConstructorParameters&lt;typeof C&gt;;
</code></pre>
<p>这多亏了 TypeScript 4.2 支持了声明抽象的构造签名：</p>
<pre><code class="language-ts">type MyConstructorOf&lt;T&gt; = {
    new (...args: any[]): T;
};

// 或使用简写形式：

type MyConstructorOf&lt;T&gt; = abstract new (...args: any[]) =&gt; T;
</code></pre>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/43380">PR</a>。</p>
<h2 id="按上下文细化泛型类型"><a class="header" href="#按上下文细化泛型类型">按上下文细化泛型类型</a></h2>
<p>TypeScript 4.3 能够更智能地对泛型进行类型细化。
这让 TypeScript 能够支持更多模式，甚至有时还能够发现错误。</p>
<p>设想有这样的场景，我们想要编写一个 <code>makeUnique</code> 函数。
它接受一个 <code>Set</code> 或 <code>Array</code>，如果接收的是 <code>Array</code>，则对数组进行排序并去除重复的元素。
最后返回初始的集合。</p>
<pre><code class="language-ts">function makeUnique&lt;T&gt;(
  collection: Set&lt;T&gt; | T[],
  comparer: (x: T, y: T) =&gt; number
): Set&lt;T&gt; | T[] {
  // 假设元素已经是唯一的
  if (collection instanceof Set) {
    return collection;
  }

  // 排序，然后去重
  collection.sort(comparer);
  for (let i = 0; i &lt; collection.length; i++) {
    let j = i;
    while (
      j &lt; collection.length &amp;&amp;
      comparer(collection[i], collection[j + 1]) === 0
    ) {
      j++;
    }
    collection.splice(i + 1, j - i);
  }
  return collection;
}
</code></pre>
<p>暂且不谈该函数的具体实现，假设它就是某应用中的一个需求。
我们可能会注意到，函数签名没能捕获到 <code>collection</code> 的初始类型。
我们可以定义一个类型参数 <code>C</code>，并用它代替 <code>Set&lt;T&gt; | T[]</code>。</p>
<pre><code class="language-diff">- function makeUnique&lt;T&gt;(collection: Set&lt;T&gt; | T[], comparer: (x: T, y: T) =&gt; number): Set&lt;T&gt; | T[]
+ function makeUnique&lt;T, C extends Set&lt;T&gt; | T[]&gt;(collection: C, comparer: (x: T, y: T) =&gt; number): C
</code></pre>
<p>在 TypeScript 4.2 以及之前的版本中，如果这样做的话会产生很多错误。</p>
<pre><code class="language-ts">function makeUnique&lt;T, C extends Set&lt;T&gt; | T[]&gt;(
  collection: C,
  comparer: (x: T, y: T) =&gt; number
): C {
  // 假设元素已经是唯一的
  if (collection instanceof Set) {
    return collection;
  }

  // 排序，然后去重
  collection.sort(comparer);
  //         ~~~~
  // 错误：属性 'sort' 不存在于类型 'C' 上。
  for (let i = 0; i &lt; collection.length; i++) {
    //                           ~~~~~~
    // 错误: 属性 'length' 不存在于类型 'C' 上。
    let j = i;
    while (
      j &lt; collection.length &amp;&amp;
      comparer(collection[i], collection[j + 1]) === 0
    ) {
      //             ~~~~~~
      // 错误: 属性 'length' 不存在于类型 'C' 上。
      //       ~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~
      // 错误: 元素具有隐式的 'any' 类型，因为 'number' 类型的表达式不能用来索引 'Set&lt;T&gt; | T[]' 类型。
      j++;
    }
    collection.splice(i + 1, j - i);
    //         ~~~~~~
    // 错误: 属性 'splice' 不存在于类型 'C' 上。
  }
  return collection;
}
</code></pre>
<p>全是错误！
为何 TypeScript 要对我们如此刻薄？</p>
<p>问题在于进行 <code>collection instanceof Set</code> 检查时，我们期望它能够成为类型守卫，并根据条件将 <code>Set&lt;T&gt; | T[]</code> 类型细化为 <code>Set&lt;T&gt;</code> 和 <code>T[]</code> 类型；
然而，实际上 TypeScript 没有对 <code>Set&lt;T&gt; | T[]</code> 进行处理，而是去细化泛型值 <code>collection</code>，其类型为 <code>C</code>。</p>
<p>虽是细微的差别，但结果却不同。
TypeScript 不会去读取 <code>C</code> 的泛型约束（即 <code>Set&lt;T&gt; | T[]</code>）并细化它。
如果要让 TypeScript 由 <code>Set&lt;T&gt; | T[]</code> 进行类型细化，它就会忘记在每个分支中 <code>collection</code> 的类型为 <code>C</code>，因为没有比较好的办法去保留这些信息。
假设 TypeScript 真这样做了，那么上例也会有其它的错误。
在函数返回的位置期望得到一个 <code>C</code> 类型的值，但从每个分支中得到的却是<code>Set&lt;T&gt;</code> 和 <code>T[]</code>，因此 TypeScript 会拒绝编译。</p>
<pre><code class="language-ts">function makeUnique&lt;T&gt;(
  collection: Set&lt;T&gt; | T[],
  comparer: (x: T, y: T) =&gt; number
): Set&lt;T&gt; | T[] {
  // 假设元素已经是唯一的
  if (collection instanceof Set) {
    return collection;
    //     ~~~~~~~~~~
    // 错误：类型 'Set&lt;T&gt;' 不能赋值给类型 'C'。
    //          'Set&lt;T&gt;' 可以赋值给 'C' 的类型约束，但是
    //          'C' 可能使用 'Set&lt;T&gt; | T[]' 的不同子类型进行实例化。
  }

  // ...

  return collection;
  //     ~~~~~~~~~~
  // 错误：类型 'T[]' 不能赋值给类型 'C'。
  //          'T[]' 可以赋值给 'C' 的类型约束，但是
  //          'C' 可能使用 'Set&lt;T&gt; | T[]' 的不同子类型进行实例化。
}
</code></pre>
<p>TypeScript 4.3 是怎么做的？
在一些关键的位置，类型系统会去查看类型的约束。
例如，在遇到 <code>collection.length</code> 时，TypeScript 不去关心 <code>collection</code> 的类型为 <code>C</code>，而是会去查看可访问的属性，而这些是由 <code>T[] | Set&lt;T&gt;</code> 泛型约束决定的。</p>
<p>在类似的地方，TypeScript 会获取由泛型约束细化出的类型，因为它包含了用户关心的信息；
而在其它的一些地方，TypeScript 会去细化初始的泛型类型（但结果通常也是该泛型类型）。</p>
<p>换句话说，根据泛型值的使用方式，TypeScript 的处理方式会稍有不同。
最终结果就是，上例中的代码不会产生编译错误。</p>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/43183">PR</a>。</p>
<h2 id="检查总是为真的-promise"><a class="header" href="#检查总是为真的-promise">检查总是为真的 Promise</a></h2>
<p>在 <code>strictNullChecks</code> 模式下，在条件语句中检查 <code>Promise</code> 是否真时会产生错误。</p>
<pre><code class="language-ts">async function foo(): Promise&lt;boolean&gt; {
  return false;
}

async function bar(): Promise&lt;string&gt; {
  if (foo()) {
    //  ~~~~~
    // Error!
    // This condition will always return true since
    // this 'Promise&lt;boolean&gt;' appears to always be defined.
    // Did you forget to use 'await'?
    return 'true';
  }
  return 'false';
}
</code></pre>
<p><a href="https://github.com/microsoft/TypeScript/pull/39175">这项改动</a>是由<a href="https://github.com/Jack-Works">Jack Works</a>实现。</p>
<h2 id="static-索引签名"><a class="header" href="#static-索引签名"><code>static</code> 索引签名</a></h2>
<p>与明确的类型声明相比，索引签名允许我们在一个值上设置更多的属性。</p>
<pre><code class="language-ts">class Foo {
  hello = 'hello';
  world = 1234;

  // 索引签名：
  [propName: string]: string | number | undefined;
}

let instance = new Foo();

// 没问题
instance['whatever'] = 42;

// 类型为 'string | number | undefined'
let x = instance['something'];
</code></pre>
<p>目前为止，索引签名只允许在类的实例类型上进行设置。
感谢 <a href="https://github.com/microsoft/TypeScript/pull/37797">Wenlu Wang</a> 的 <a href="https://github.com/microsoft/TypeScript/pull/37797">PR</a>，现在索引签名也可以声明为 <code>static</code>。</p>
<pre><code class="language-ts">class Foo {
  static hello = 'hello';
  static world = 1234;

  static [propName: string]: string | number | undefined;
}

// 没问题
Foo['whatever'] = 42;

// 类型为 'string | number | undefined'
let x = Foo['something'];
</code></pre>
<p>类静态类型上的索引签名检查规则与类实例类型上的索引签名的检查规则是相同的，即每个静态属性必须与静态索引签名类型兼容。</p>
<pre><code class="language-ts">class Foo {
  static prop = true;
  //     ~~~~
  // 错误！'boolean' 类型的属性 'prop' 不能赋值给字符串索引类型
  // 'string | number | undefined'.

  static [propName: string]: string | number | undefined;
}
</code></pre>
<h2 id="tsbuildinfo-文件大小改善"><a class="header" href="#tsbuildinfo-文件大小改善"><code>.tsbuildinfo</code> 文件大小改善</a></h2>
<p>TypeScript 4.3 中，作为 <code>--incremental</code> 构建组分部分的 <code>.tsbuildinfo</code> 文件会变得非常小。
这得益于一些内部格式的优化，使用以数值标识的查找表来替代重复多次的完整路径以及类似的信息。
这项工作的灵感源自于 <a href="https://github.com/sokra">Tobias Koppers</a> 的 <a href="https://github.com/microsoft/TypeScript/pull/43079">PR</a>，而后在 <a href="https://github.com/microsoft/TypeScript/pull/43155">PR</a> 中实现，并在 <a href="https://github.com/microsoft/TypeScript/pull/43695">PR</a> 中进行优化。</p>
<p>我们观察到了 <code>.tsbuildinfo</code> 文件有如下的变化：</p>
<ul>
<li>1MB 到 411 KB</li>
<li>14.9MB 到 1MB</li>
<li>1345MB 到 467MB</li>
</ul>
<p>不用说，缩小文件的尺寸会稍微加快构建速度。</p>
<h2 id="在---incremental-和---watch-中进行惰性计算"><a class="header" href="#在---incremental-和---watch-中进行惰性计算">在 <code>--incremental</code> 和 <code>--watch</code> 中进行惰性计算</a></h2>
<p><code>--incremental</code> 和 <code>--watch</code> 模式的一个问题是虽然它会加快后续的编译速度，但是首次编译很慢 - 有时会非常地慢。
这是因为在该模式下需要保存和计算当前工程的一些信息，有时还需要将这些信息写入 <code>.tsbuildinfo</code> 文件，以备后续之用。</p>
<p>因此， TypeScript 4.3 也对 <code>--incremental</code> 和 <code>--watch</code> 进行了首次构建时的优化，让它可以和普通构建一样快。
为了达到目的，大部分信息会进行按需计算，而不是和往常一样全部一次性计算。
虽然这会加重后续构建的负担，但是 TypeScript 的 <code>--incremental</code> 和 <code>--watch</code> 功能会智能地处理一小部分文件，并保存住会对后续构建有用的信息。
这就好比，<code>--incremental</code> 和 <code>--watch</code> 构建会进行“预热”，并能够在多次修改文件后加速构建。</p>
<p>在一个包含了 3000 个文件的仓库中， <strong>这能节约大概三分之一的构建时间</strong>！</p>
<p><a href="https://github.com/microsoft/TypeScript/pull/42960">这项改进</a> 是由 <a href="https://github.com/sokra">Tobias Koppers</a> 开启，并在 <a href="https://github.com/microsoft/TypeScript/pull/43314">PR</a> 里完成。
感谢他们！</p>
<h2 id="导入语句的补全"><a class="header" href="#导入语句的补全">导入语句的补全</a></h2>
<p>在 JavaScript 中，关于导入导出语句的一大痛点是其排序问题 - 尤其是导入语句的写法如下：</p>
<pre><code class="language-ts">import { func } from './module.js';
</code></pre>
<p>而非</p>
<pre><code class="language-ts">from "./module.js" import { func };
</code></pre>
<p>这导致了在书写完整的导入语句时很难受，因为自动补全无法工作。
例如，你输入了 <code>import {</code> ，TypeScript 不知道你要从哪个模块里导入，因此它不能提供补全信息。</p>
<p>为缓解该问题，我们可以利用自动导入功能！
自动导入能够提供每个可能导出并在文件顶端插入一条导入语句。</p>
<p>因此当你输入 <code>import</code> 语句并没提供一个路径时，TypeScript 会提供一个可能的导入列表。
当你确认了一个补全，TypeScript 会补全完整的导入语句，它包含了你要输入的路径。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/05/auto-import-statement-4-3.gif" alt="Import statement completions" /></p>
<p>该功能需要编辑器的支持。
你可以在 <a href="https://code.visualstudio.com/insiders/">Insiders 版本的 Visual Studio Code</a> 中进行尝试。</p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/43149">PR</a>！</p>
<h2 id="编辑器对-link-标签的支持"><a class="header" href="#编辑器对-link-标签的支持">编辑器对 <code>@link</code> 标签的支持</a></h2>
<p>TypeScript 现在能够理解 <code>@link</code> 标签，并会解析它指向的声明。
也就是说，你将鼠标悬停在 <code>@link</code> 标签上会得到一个快速提示，或者使用“跳转到定义”或“查找全部引用”命令。</p>
<p>例如，在支持 TypeScript 的编辑器中你可以在 <code>@link bar</code>中的 <code>bar</code> 上使用跳转到定义，它会跳转到 <code>bar</code> 的函数声明。</p>
<pre><code class="language-ts">/**
 * To be called 70 to 80 days after {@link plantCarrot}.
 */
function harvestCarrot(carrot: Carrot) {}

/**
 * Call early in spring for best results. Added in v2.1.0.
 * @param seed Make sure it's a carrot seed!
 */
function plantCarrot(seed: Seed) {
  // TODO: some gardening
}
</code></pre>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/05/link-tag-4-3.gif" alt="Jumping to definition and requesting quick info on a @link tag for " /></p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/41877">PR</a>！</p>
<h2 id="在非-javascript-文件上的跳转到定义"><a class="header" href="#在非-javascript-文件上的跳转到定义">在非 JavaScript 文件上的跳转到定义</a></h2>
<p>许多加载器允许用户在 JavaScript 的导入语句中导入资源文件。
例如典型的 <code>import "./styles.css"</code> 语句。</p>
<p>目前为止，TypeScript 的编辑器功能不会去尝试读取这些文件，因此“跳转到定义”会失败。
在最好的情况下，“跳转到定义”会跳转到类似 <code>declare module "*.css"</code> 这样的声明语句上，如果它能够找到的话。</p>
<p>现在，在执行“跳转到定义”命令时，TypeScript 的语言服务会尝试跳转到正确的文件，即使它们不是 JavaScript 或 TypeScript 文件！
在 CSS，SVGs，PNGs，字体文件，Vue 文件等的导入语句上尝试一下吧。</p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/42539">PR</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-42"><a class="header" href="#typescript-42">TypeScript 4.2</a></h1>
<h2 id="更智能地保留类型别名"><a class="header" href="#更智能地保留类型别名">更智能地保留类型别名</a></h2>
<p>在 TypeScript 中，使用类型别名能够给某个类型起个新名字。
倘若你定义了一些函数，并且它们全都使用了 <code>string | number | boolean</code> 类型，那么你就可以定义一个类型别名来避免重复。</p>
<pre><code class="language-ts">type BasicPrimitive = number | string | boolean;
</code></pre>
<p>TypeScript 使用了一系列规则来推测是否该在显示类型时使用类型别名。
例如，有如下的代码。</p>
<pre><code class="language-ts">export type BasicPrimitive = number | string | boolean;

export function doStuff(value: BasicPrimitive) {
    let x = value;
    return x;
}
</code></pre>
<p>如果在 Visual Studio，Visual Studio Code 或者 <a href="https://www.typescriptlang.org/play?ts=4.1.3#code/KYDwDg9gTgLgBDAnmYcBCBDAzgSwMYAKUOAtjjDgG6oC8cAdgK4kBGwUcAPnFjMfQHMucFhAgAbYBnoBuAFBzQkWHABmjengoR6cACYQAyjEarVACkoZxjYAC502fEVLkqwAJRwA3nLj+4SXgQODorG2B5ALgoYBMoXRB5AF8gA">TypeScript 演练场</a>编辑器中把鼠标光标放在 <code>x</code> 上，我们就会看到信息面板中显示出了 <code>BasicPrimitive</code> 类型。
同样地，如果我们查看由该文件生成的声明文件（<code>.d.ts</code>），那么 TypeScript 会显示出 <code>doStuff</code> 的返回值类型为 <code>BasicPrimitive</code> 类型。</p>
<p>那么你猜一猜，如果返回值类型为 <code>BasicPrimitive</code> 或 <code>undefined</code> 时会发生什么？</p>
<pre><code class="language-ts">export type BasicPrimitive = number | string | boolean;

export function doStuff(value: BasicPrimitive) {
    if (Math.random() &lt; 0.5) {
        return undefined;
    }

    return value;
}
</code></pre>
<p>可以在<a href="https://www.typescriptlang.org/play?ts=4.1.3#code/KYDwDg9gTgLgBDAnmYcBCBDAzgSwMYAKUOAtjjDgG6oC8cAdgK4kBGwUcAPnFjMfQHMucFhAgAbYBnoBuALAAoRQHplcABIRqHCPTgByACYQAyjEYAzC-pHBxEAO4IIPYKgcALDPAAqyYCZ4xGDwhjhYYOIYiFhwFtAIHqhQwOZQekgoAHQqagDqqGQCHvBe1HCgKHgwwIZw5M5wYPzw2Lm5cJ2YuITEZBTl3Iz0hsAWOPS1HR0sjPBs9k5+KIHB8AAsWQBMADT18BO8UnVhEVExcG0Kqh2dTKzswrz8QtyiElJ6QyNjE1PXykUlWg8Asw2qOF0cGMZksFgAFJQMOJGMAAFzobD4IikchUYAASjgAG9FJ1yTgLHB4QBZbweLJQaTGEjwokAHjgAAYsgBWImkhTk4WdFJpPTDUbjSaGeRC4UAX0UZOFYsY6TgSJRwDlcAVQA">TypeScript 4.1 演练场</a>中查看结果。
虽然我们希望 TypeScript 将 <code>doStuff</code> 的返回值类型显示为 <code>BasicPrimitive | undefined</code>，但是它却显示成了 <code>string | number | boolean | undefined</code> 类型！
这是怎么回事？</p>
<p>这与 TypeScript 内部的类型表示方式有关。
当基于一个联合类型来创建另一个联合类型时，TypeScript 会将类型<em>标准化</em>，也就是把类型展开为一个新的联合类型 - 但这么做也可能会丢失信息。
类型检查器不得不根据 <code>string | number | boolean | undefined</code> 类型来尝试每一种可能的组合并查看使用了哪些类型别名，即便这样也可能会有多个类型别名指向 <code>string | number | boolean</code> 类型。</p>
<p>TypeScript 4.2 的内部实现更加智能了。
我们会记录类型是如何被构造的，会记录它们原本的编写方式和之后的构造方式。
我们同样会记录和区分不同的类型别名！</p>
<p>有能力根据类型使用的方式来回显这个类型就意味着，对于 TypeScript 用户来讲能够避免显示很长的类型；同时也意味着会生成更友好的 <code>.d.ts</code> 声明文件、错误消息和编辑器内显示的类型及签名帮助信息。
这会让 TypeScript 对于初学者来讲更友好一些。</p>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/42149">PR：改进保留类型别名的联合</a>，以及<a href="https://github.com/microsoft/TypeScript/pull/42284">PR：保留间接的类型别名</a>。</p>
<h2 id="元组类型中前导的中间的剩余元素"><a class="header" href="#元组类型中前导的中间的剩余元素">元组类型中前导的/中间的剩余元素</a></h2>
<p>在 TypeScript 中，元组类型用于表示固定长度和元素类型的数组。</p>
<pre><code class="language-ts">// 存储了一对数字的元组
let a: [number, number] = [1, 2];

// 存储了一个string，一个number和一个boolean的元组
let b: [string, number, boolean] = ['hello', 42, true];
</code></pre>
<p>随着时间的推移，TypeScript 中的元组类型变得越来越复杂，因为它们也被用来表示像 JavaScript 中的参数列表类型。
结果就是，它可能包含可选元素和剩余元素，以及用于工具和提高可读性的标签。</p>
<pre><code class="language-ts">// 包含一个或两个元素的元组。
let c: [string, string?] = ['hello'];
c = ['hello', 'world'];

// 包含一个或两个元素的标签元组。
let d: [first: string, second?: string] = ['hello'];
d = ['hello', 'world'];

// 包含剩余元素的元组 - 至少前两个元素是字符串，
// 以及后面的任意数量的布尔元素。
let e: [string, string, ...boolean[]];

e = ['hello', 'world'];
e = ['hello', 'world', false];
e = ['hello', 'world', true, false, true];
</code></pre>
<p>在 TypeScript 4.2 中，剩余元素会按它们的使用方式进行展开。
在之前的版本中，TypeScript 只允许 <code>...rest</code> 元素位于元组的末尾。</p>
<p>但现在，剩余元素可以出现在元组中的任意位置 - 但有一点限制。</p>
<pre><code class="language-ts">let foo: [...string[], number];

foo = [123];
foo = ['hello', 123];
foo = ['hello!', 'hello!', 'hello!', 123];

let bar: [boolean, ...string[], boolean];

bar = [true, false];
bar = [true, 'some text', false];
bar = [true, 'some', 'separated', 'text', false];
</code></pre>
<p>唯一的限制是，剩余元素之后不能出现可选元素或其它剩余元素。
换句话说，一个元组中只允许有一个剩余元素，并且剩余元素之后不能有可选元素。</p>
<pre><code class="language-ts twoslash">interface Clown {
    /*...*/
}
interface Joker {
    /*...*/
}

let StealersWheel: [...Clown[], 'me', ...Joker[]];
//                                    ~~~~~~~~~~ 错误

let StringsAndMaybeBoolean: [...string[], boolean?];
//                                        ~~~~~~~~ 错误
</code></pre>
<p>这些不在结尾的剩余元素能够用来描述，可接收任意数量的前导参数加上固定数量的结尾参数的函数。</p>
<pre><code class="language-ts">declare function doStuff(
    ...args: [...names: string[], shouldCapitalize: boolean]
): void;

doStuff(/*shouldCapitalize:*/ false);
doStuff('fee', 'fi', 'fo', 'fum', /*shouldCapitalize:*/ true);
</code></pre>
<p>尽管 JavaScript 中没有声明前导剩余参数的语法，但我们仍可以将 <code>doStuff</code> 函数的参数声明为带有前导剩余元素 <code>...args</code> 的元组类型。
使用这种方式可以帮助我们描述许多的 JavaScript 代码！</p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/41544">PR</a>。</p>
<h2 id="更严格的-in-运算符检查"><a class="header" href="#更严格的-in-运算符检查">更严格的 <code>in</code> 运算符检查</a></h2>
<p>在 JavaScript 中，如果 <code>in</code> 运算符的右操作数是非对象类型，那么会产生运行时错误。
TypeScript 4.2 确保了该错误能够在编译时被捕获。</p>
<pre><code class="language-ts twoslash">'foo' in 42;
// The right-hand side of an 'in' expression must not be a primitive.
</code></pre>
<p>这个检查在大多数情况下是相当保守的，如果你看到提示了这个错误，那么代码中很可能真的有问题。</p>
<p>非常感谢外部贡献者 <a href="https://github.com/jonhue">Jonas Hübotter</a> 的 <a href="https://github.com/microsoft/TypeScript/pull/41928">PR</a>！</p>
<h2 id="--nopropertyaccessfromindexsignature"><a class="header" href="#--nopropertyaccessfromindexsignature"><code>--noPropertyAccessFromIndexSignature</code></a></h2>
<p>在 TypeScript 刚开始支持索引签名时，它只允许使用方括号语法来访问索引签名中定义的元素，例如 <code>person["name"]</code>。</p>
<pre><code class="language-ts">interface SomeType {
    /** 这是索引签名 */
    [propName: string]: any;
}

function doStuff(value: SomeType) {
    let x = value['someProperty'];
}
</code></pre>
<p>这就导致了在处理带有任意属性的对象时变得烦锁。
例如，假设有一个容易出现拼写错误的 API，容易出现在属性名的末尾位置多写一个字母 <code>s</code> 的错误。</p>
<pre><code class="language-ts">interface Options {
    /** 要排除的文件模式。 */
    exclude?: string[];

    /**
     * 这会将其余所有未声明的属性定义为 'any' 类型。
     */
    [x: string]: any;
}

function processOptions(opts: Options) {
    // 注意，我们想要访问 `excludes` 而不是 `exclude`
    if (opts.excludes) {
        console.error(
            'The option `excludes` is not valid. Did you mean `exclude`?'
        );
    }
}
</code></pre>
<p>为了便于处理以上情况，在从前的时候，TypeScript 允许使用点语法来访问通过字符串索引签名定义的属性。
这会让从 JavaScript 代码到 TypeScript 代码的迁移工作变得容易。</p>
<p>然而，放宽限制同样意味着更容易出现属性名拼写错误。</p>
<pre><code class="language-ts">interface Options {
    /** 要排除的文件模式。 */
    exclude?: string[];

    /**
     * 这会将其余所有未声明的属性定义为 'any' 类型。
     */
    [x: string]: any;
}
// ---cut---
function processOptions(opts: Options) {
    // ...

    // 注意，我们不小心访问了错误的 `excludes`。
    // 但是！这是合法的！
    for (const excludePattern of opts.excludes) {
        // ...
    }
}
</code></pre>
<p>在某些情况下，用户会想要选择使用索引签名 - 在使用点号语法进行属性访问时，如果访问了没有明确定义的属性，就得到一个错误。</p>
<p>这就是为什么 TypeScript 引入了一个新的 <code>--noPropertyAccessFromIndexSignature</code> 编译选项。
在该模式下，你可以有选择的启用 TypeScript 之前的行为，即在上述使用场景中产生错误。
该编译选项不属于 <code>strict</code> 编译选项集合的一员，因为我们知道该功能只适用于部分用户。</p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/40171/">PR</a>。
我们同时要感谢 <a href="https://github.com/Kingwl">Wenlu Wang</a> 为该功能的付出！</p>
<h2 id="abstract-构造签名"><a class="header" href="#abstract-构造签名"><code>abstract</code> 构造签名</a></h2>
<p>TypeScript 允许将一个类标记为 <em>abstract</em>。
这相当于告诉 TypeScript 这个类只是用于继承，并且有些成员需要在子类中实现，以便能够真正地创建出实例。</p>
<pre><code class="language-ts twoslash">abstract class Shape {
    abstract getArea(): number;
}

// 不能创建抽象类的实例
new Shape();

class Square extends Shape {
    #sideLength: number;

    constructor(sideLength: number) {
        super();
        this.#sideLength = sideLength;
    }

    getArea() {
        return this.#sideLength ** 2;
    }
}

// 没问题
new Square(42);
</code></pre>
<p>为了能够确保一贯的对 <code>new</code> 一个 <code>abstract</code> 类进行限制，不允许将 <code>abstract</code> 类赋值给接收构造签名的值。</p>
<pre><code class="language-ts twoslash">abstract class Shape {
    abstract getArea(): number;
}

interface HasArea {
    getArea(): number;
}

// 不能将抽象构造函数类型赋值给非抽象构造函数类型。
let Ctor: new () =&gt; HasArea = Shape;
</code></pre>
<p>如果有代码调用了 <code>new Ctor</code>，那么上述的行为是正确的，但若想要编写 <code>Ctor</code> 的子类，就会出现过度限制的情况。</p>
<pre><code class="language-ts">abstract class Shape {
    abstract getArea(): number;
}

interface HasArea {
    getArea(): number;
}

function makeSubclassWithArea(Ctor: new () =&gt; HasArea) {
    return class extends Ctor {
        getArea() {
            return 42;
        }
    };
}

// 不能将抽象构造函数类型赋值给非抽象构造函数类型。
let MyShape = makeSubclassWithArea(Shape);
</code></pre>
<p>对于内置的工具类型<code>InstanceType</code>来讲，它也不是工作得很好。</p>
<pre><code class="language-ts">// 错误！
// 不能将抽象构造函数类型赋值给非抽象构造函数类型。
type MyInstance = InstanceType&lt;typeof Shape&gt;;
</code></pre>
<p>这就是为什么 TypeScript 4.2 允许在构造签名上指定 <code>abstract</code> 修饰符。</p>
<pre><code class="language-ts">abstract class Shape {
  abstract getArea(): number;
}
// ---cut---
interface HasArea {
    getArea(): number;
}

// Works!
let Ctor: abstract new () =&gt; HasArea = Shape;
</code></pre>
<p>在构造签名上添加 <code>abstract</code> 修饰符表示可以传入一个 <code>abstract</code> 构造函数。
它不会阻止你传入其它具体的类/构造函数 - 它只是想表达不会直接调用这个构造函数，因此可以安全地传入任意一种类类型。</p>
<p>这个特性允许我们编写支持抽象类的<em>混入工厂函数</em>。
例如，在下例中，我们可以同时使用混入函数 <code>withStyles</code> 和 <code>abstract</code> 类 <code>SuperClass</code>。</p>
<pre><code class="language-ts">abstract class SuperClass {
    abstract someMethod(): void;
    badda() {}
}

type AbstractConstructor&lt;T&gt; = abstract new (...args: any[]) =&gt; T

function withStyles&lt;T extends AbstractConstructor&lt;object&gt;&gt;(Ctor: T) {
    abstract class StyledClass extends Ctor {
        getStyles() {
            // ...
        }
    }
    return StyledClass;
}

class SubClass extends withStyles(SuperClass) {
    someMethod() {
        this.someMethod()
    }
}
</code></pre>
<p>注意，<code>withStyles</code> 展示了一个特殊的规则，若一个类（<code>StyledClass</code>）继承了被抽象构造函数所约束的泛型值，那么这个类也需要被声明为 <code>abstract</code>。
由于无法知道传入的类是否拥有更多的抽象成员，因此也无法知道子类是否实现了所有的抽象成员。</p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/36392">PR</a>。</p>
<h2 id="使用---explainfiles-来理解工程的结构"><a class="header" href="#使用---explainfiles-来理解工程的结构">使用 <code>--explainFiles</code> 来理解工程的结构</a></h2>
<p>TypeScript 用户时常会问“为什么 TypeScript 包含了这个文件？”。
推断程序中所包含的文件是个很复杂的过程，比如有很多原因会导致使用了 <code>lib.d.ts</code> 文件的组合，会导致 <code>node_modules</code> 中的文件被包含进来，会导致有些已经 <code>exclude</code> 的文件被包含进来。</p>
<p>这就是 TypeScript 提供 <code>--explainFiles</code> 的原因。</p>
<pre><code class="language-sh">tsc --explainFiles
</code></pre>
<p>在使用了该选项时，TypeScript 编译器会输出非常详细的信息来说明某个文件被包含进工程的原因。
为了更易理解，我们可以把输出结果存到文件里，或者通过管道使用其它命令来查看它。</p>
<pre><code class="language-sh"># 将输出保存到文件
tsc --explainFiles &gt; expanation.txt

# 将输出传递给工具程序 `less`，或编辑器 VS Code
tsc --explainFiles | less

tsc --explainFiles | code -
</code></pre>
<p>通常，输出结果首先会给列出包含 <code>lib.d.ts</code> 文件的原因，然后是本地文件，再然后是 <code>node_modules</code> 文件。</p>
<pre><code>TS_Compiler_Directory/4.2.2/lib/lib.es5.d.ts
  Library referenced via 'es5' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2015.d.ts'
TS_Compiler_Directory/4.2.2/lib/lib.es2015.d.ts
  Library referenced via 'es2015' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2016.d.ts'
TS_Compiler_Directory/4.2.2/lib/lib.es2016.d.ts
  Library referenced via 'es2016' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2017.d.ts'
TS_Compiler_Directory/4.2.2/lib/lib.es2017.d.ts
  Library referenced via 'es2017' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2018.d.ts'
TS_Compiler_Directory/4.2.2/lib/lib.es2018.d.ts
  Library referenced via 'es2018' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2019.d.ts'
TS_Compiler_Directory/4.2.2/lib/lib.es2019.d.ts
  Library referenced via 'es2019' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2020.d.ts'
TS_Compiler_Directory/4.2.2/lib/lib.es2020.d.ts
  Library referenced via 'es2020' from file 'TS_Compiler_Directory/4.2.2/lib/lib.esnext.d.ts'
TS_Compiler_Directory/4.2.2/lib/lib.esnext.d.ts
  Library 'lib.esnext.d.ts' specified in compilerOptions

... More Library References...

foo.ts
  Matched by include pattern '**/*' in 'tsconfig.json'
</code></pre>
<p>目前，TypeScript 不保证输出文件的格式 - 它在将来可能会改变。
关于这一点，我们也打算改进输出文件格式，请给出你的建议！</p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/40011">PR</a>！</p>
<h2 id="改进逻辑表达式中的未被调用函数检查"><a class="header" href="#改进逻辑表达式中的未被调用函数检查">改进逻辑表达式中的未被调用函数检查</a></h2>
<p>感谢 <a href="https://github.com/a-tarasyuk">Alex Tarasyuk</a> 提供的持续改进，TypeScript 中的未调用函数检查现在也作用于 <code>&amp;&amp;</code> 和 <code>||</code> 表达式。</p>
<p>在 <code>--strictNullChecks</code> 模式下，下面的代码会产生错误。</p>
<pre><code class="language-ts">function shouldDisplayElement(element: Element) {
    // ...
    return true;
}

function getVisibleItems(elements: Element[]) {
    return elements.filter((e) =&gt; shouldDisplayElement &amp;&amp; e.children.length);
    //                          ~~~~~~~~~~~~~~~~~~~~
    // 该条件表达式永远返回 true，因为函数永远是定义了的。
    // 你是否想要调用它？
}
</code></pre>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/issues/40197">PR</a>。</p>
<h2 id="解构出来的变量可以被明确地标记为未使用的"><a class="header" href="#解构出来的变量可以被明确地标记为未使用的">解构出来的变量可以被明确地标记为未使用的</a></h2>
<p>感谢 <a href="https://github.com/a-tarasyuk">Alex Tarasyuk</a> 提供的另一个 PR，你可以使用下划线（<code>_</code> 字符）将解构变量标记为未使用的。</p>
<pre><code class="language-ts">let [_first, second] = getValues();
</code></pre>
<p>在之前，如果 <code>_first</code> 未被使用，那么在启用了 <code>noUnusedLocals</code> 时 TypeScript 会产生一个错误。
现在，TypeScript 会识别出使用了下划线的 <code>_first</code> 变量是有意的未使用的变量。</p>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/41378">PR</a>。</p>
<h2 id="放宽了在可选属性和字符串索引签名间的限制"><a class="header" href="#放宽了在可选属性和字符串索引签名间的限制">放宽了在可选属性和字符串索引签名间的限制</a></h2>
<p>字符串索引签名可用于为类似于字典的对象添加类型，它表示允许使用任意的键来访问对象：</p>
<pre><code class="language-ts">const movieWatchCount: { [key: string]: number } = {};

function watchMovie(title: string) {
    movieWatchCount[title] = (movieWatchCount[title] ?? 0) + 1;
}
</code></pre>
<p>当然了，对于不在字典中的电影名而言 <code>movieWatchCount[title]</code> 的值为 <code>undefined</code>。（TypeScript 4.1 增加了 <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#checked-indexed-accesses---nouncheckedindexedaccess"><code>--noUncheckedIndexedAccess</code></a> 选项，在访问索引签名时会增加 <code>undefined</code> 值。）
即便一定会有 <code>movieWatchCount</code> 中不存在的属性，但在之前的版本中，由于 <code>undefined</code> 值的存在，TypeScript 会将可选对象属性视为不可以赋值给兼容的索引签名。</p>
<pre><code class="language-ts">type WesAndersonWatchCount = {
    'Fantastic Mr. Fox'?: number;
    'The Royal Tenenbaums'?: number;
    'Moonrise Kingdom'?: number;
    'The Grand Budapest Hotel'?: number;
};

declare const wesAndersonWatchCount: WesAndersonWatchCount;
const movieWatchCount: { [key: string]: number } = wesAndersonWatchCount;
//    ~~~~~~~~~~~~~~~ 错误！
// 类型 'WesAndersonWatchCount' 不允许赋值给类型 '{ [key: string]: number; }'。
//    属性 '"Fantastic Mr. Fox"' 与索引签名不兼容。
//      类型 'number | undefined' 不允许赋值给类型 'number'。
//        类型 'undefined' 不允许赋值给类型 'number'。 (2322)
</code></pre>
<p>TypeScript 4.2 允许这样赋值。
但是不允许使用带有 <code>undefined</code> 类型的非可选属性进行赋值，也不允许将 <code>undefined</code> 值直接赋值给某个属性：</p>
<pre><code class="language-ts">type BatmanWatchCount = {
    'Batman Begins': number | undefined;
    'The Dark Knight': number | undefined;
    'The Dark Knight Rises': number | undefined;
};

declare const batmanWatchCount: BatmanWatchCount;

// 在 TypeScript 4.2 中仍是错误。
const movieWatchCount: { [key: string]: number } = batmanWatchCount;

// 在 TypeScript 4.2 中仍是错误。
// 索引签名不允许显式地赋值 `undefined`。
movieWatchCount["It's the Great Pumpkin, Charlie Brown"] = undefined;
</code></pre>
<p>这条新规则不适用于数字索引签名，因为它们被当成是类数组的并且是稠密的：</p>
<pre><code class="language-ts">declare let sortOfArrayish: { [key: number]: string };
declare let numberKeys: { 42?: string };

sortOfArrayish = numberKeys;
</code></pre>
<p>更多详情，请参考 <a href="https://github.com/microsoft/TypeScript/pull/41921">PR</a>。</p>
<h2 id="声明缺失的函数"><a class="header" href="#声明缺失的函数">声明缺失的函数</a></h2>
<p>感谢 <a href="https://github.com/a-tarasyuk">Alexander Tarasyuk</a> 提交的 <a href="https://github.com/microsoft/TypeScript/pull/41215">PR</a>，TypeScript 支持了一个新的快速修复功能，那就是根据调用方来生成新的函数和方法声明！</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2021/01/addMissingFunction-4.2.gif" alt="一个未被声明的 foo 函数被调用了，使用快速修复" /></p>
<!--
## Breaking Changes

We always strive to minimize breaking changes in a release.
TypeScript 4.2 contains some breaking changes, but we believe they should be manageable in an upgrade.

### `lib.d.ts` Updates

As with every TypeScript version, declarations for `lib.d.ts` (especially the declarations generated for web contexts), have changed.
There are various changes, though `Intl` and `ResizeObserver`'s may end up being the most disruptive.

### `noImplicitAny` Errors Apply to Loose `yield` Expressions

When the value of a `yield` expression is captured, but TypeScript can't immediately figure out what type you intend for it to receive (i.e. the `yield` expression isn't contextually typed), TypeScript will now issue an implicit `any` error.

```ts twoslash
// @errors: 7057
function* g1() {
    const value = yield 1;
}

function* g2() {
    // No error.
    // The result of `yield 1` is unused.
    yield 1;
}

function* g3() {
    // No error.
    // `yield 1` is contextually typed by 'string'.
    const value: string = yield 1;
}

function* g4(): Generator<number, void, string> {
    // No error.
    // TypeScript can figure out the type of `yield 1`
    // from the explicit return type of `g3`.
    const value = yield 1;
}
```

See more details in [the corresponding changes](https://github.com/microsoft/TypeScript/pull/41348).

### Expanded Uncalled Function Checks

As described above, uncalled function checks will now operate consistently within `&&` and `||` expressions when using `--strictNullChecks`.
This can be a source of new breaks, but is typically an indication of a logic error in existing code.

### Type Arguments in JavaScript Are Not Parsed as Type Arguments

Type arguments were already not allowed in JavaScript, but in TypeScript 4.2, the parser will parse them in a more spec-compliant way.
So when writing the following code in a JavaScript file:

```ts
f<T>(100);
```

TypeScript will parse it as the following JavaScript:

```js
f < T > 100;
```

This may impact you if you were leveraging TypeScript's API to parse type constructs in JavaScript files, which may have occurred when trying to parse Flow files.

See [the pull request](https://github.com/microsoft/TypeScript/pull/41928) for more details on what's checked.

### Tuple size limits for spreads

Tuple types can be made by using any sort of spread syntax (`...`) in TypeScript.

```ts
// Tuple types with spread elements
type NumStr = [number, string];
type NumStrNumStr = [...NumStr, ...NumStr];

// Array spread expressions
const numStr = [123, 'hello'] as const;
const numStrNumStr = [...numStr, ...numStr] as const;
```

Sometimes these tuple types can accidentally grow to be huge, and that can make type-checking take a long time.
Instead of letting the type-checking process hang (which is especially bad in editor scenarios), TypeScript has a limiter in place to avoid doing all that work.

You can [see this pull request](https://github.com/microsoft/TypeScript/pull/42448) for more details.

### `.d.ts` Extensions Cannot Be Used In Import Paths

In TypeScript 4.2, it is now an error for your import paths to contain `.d.ts` in the extension.

```ts
// must be changed something like
//   - "./foo"
//   - "./foo.js"
import { Foo } from './foo.d.ts';
```

Instead, your import paths should reflect whatever your loader will do at runtime.
Any of the following imports might be usable instead.

```ts
import { Foo } from './foo';
import { Foo } from './foo.js';
import { Foo } from './foo/index.js';
```

### Reverting Template Literal Inference

This change removed a feature from TypeScript 4.2 beta.
If you haven't yet upgraded past our last stable release, you won't be affected, but you may still be interested in the change.

The beta version of TypeScript 4.2 included a change in inference to template strings.
In this change, template string literals would either be given template string types or simplify to multiple string literal types.
These types would then _widen_ to `string` when assigning to mutable variables.

```ts
declare const yourName: string;

// 'bar' is constant.
// It has type '`hello ${string}`'.
const bar = `hello ${yourName}`;

// 'baz' is mutable.
// It has type 'string'.
let baz = `hello ${yourName}`;
```

This is similar to how string literal inference works.

```ts
// 'bar' has type '"hello"'.
const bar = 'hello';

// 'baz' has type 'string'.
let baz = 'hello';
```

For that reason, we believed that making template string expressions have template string types would be "consistent";
however, from what we've seen and heard, that isn't always desirable.

In response, we've reverted this feature (and potential breaking change).
If you _do_ want a template string expression to be given a literal-like type, you can always add `as const` to the end of it.

```ts
declare const yourName: string;

// 'bar' has type '`hello ${string}`'.
const bar = `hello ${yourName}` as const;
//                              ^^^^^^^^

// 'baz' has type 'string'.
const baz = `hello ${yourName}`;
```

### TypeScript's `lift` Callback in `visitNode` Uses a Different Type

TypeScript has a `visitNode` function that takes a `lift` function.
`lift` now expects a `readonly Node[]` instead of a `NodeArray<Node>`.
This is technically an API breaking change which you can read more on [here](https://github.com/microsoft/TypeScript/pull/42000).
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-41"><a class="header" href="#typescript-41">TypeScript 4.1</a></h1>
<h2 id="模版字面量类型-1"><a class="header" href="#模版字面量类型-1">模版字面量类型</a></h2>
<p>使用字符串字面量类型能够表示仅接受特定字符串参数的函数和 API。</p>
<pre><code class="language-ts twoslash">function setVerticalAlignment(location: 'top' | 'middle' | 'bottom') {
    // ...
}

setVerticalAlignment('middel');
//                   ^^^^^^^^
// Argument of type '"middel"' is not assignable to parameter of type '"top" | "middle" | "bottom"'.
</code></pre>
<p>使用字符串字面量类型的好处是它能够对字符串进行拼写检查。</p>
<p>此外，字符串字面量还能用于映射类型中的属性名。
从这个意义上来讲，它们可被当作构件使用。</p>
<pre><code class="language-ts">type Options = {
    [K in
        | 'noImplicitAny'
        | 'strictNullChecks'
        | 'strictFunctionTypes']?: boolean;
};
// same as
//   type Options = {
//       noImplicitAny?: boolean,
//       strictNullChecks?: boolean,
//       strictFunctionTypes?: boolean
//   };
</code></pre>
<p>还有一处字符串字面量类型可被当作构件使用，那就是在构造其它字符串字面量类型时。</p>
<p>这也是 TypeScript 4.1 支持模版字面量类型的原因。
它的语法与<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">JavaScript 中的模版字面量</a>的语法是一致的，但是是用在表示类型的位置上。
当将其与具体类型结合使用时，它会将字符串拼接并产生一个新的字符串字面量类型。</p>
<pre><code class="language-ts twoslash">type World = 'world';

type Greeting = `hello ${World}`;
//   ^^^^^^^^^
//   "hello world"
</code></pre>
<p>如果在替换的位置上使用了联合类型会怎么样呢？
它将生成由各个联合类型成员所表示的字符串字面量类型的联合。</p>
<pre><code class="language-ts twoslash">type Color = 'red' | 'blue';
type Quantity = 'one' | 'two';

type SeussFish = `${Quantity | Color} fish`;
//   ^^^^^^^^^
//   "one fish" | "two fish" | "red fish" | "blue fish"
</code></pre>
<p>除此之外，我们也可以在其它场景中应用它。
例如，有些 UI 组件库提供了指定垂直和水平对齐的 API，通常会使用类似于<code>"bottom-right"</code>的字符串来同时指定。
在垂直对齐的选项<code>"top"</code>，<code>"middle"</code>和<code>"bottom"</code>，以及水平对齐的选项<code>"left"</code>，<code>"center"</code>和<code>"right"</code>之间，共有 9 种可能的字符串，前者选项之一与后者选项之一之间使用短横线连接。</p>
<pre><code class="language-ts twoslash">type VerticalAlignment = 'top' | 'middle' | 'bottom';
type HorizontalAlignment = 'left' | 'center' | 'right';

// Takes
//   | "top-left"    | "top-center"    | "top-right"
//   | "middle-left" | "middle-center" | "middle-right"
//   | "bottom-left" | "bottom-center" | "bottom-right"

declare function setAlignment(
    value: `${VerticalAlignment}-${HorizontalAlignment}`
): void;

setAlignment('top-left'); // works!
setAlignment('top-middel'); // error!
setAlignment('top-pot'); // error! but good doughnuts if you're ever in Seattle
</code></pre>
<p>这样的例子还有很多，但它仍只是小例子而已，因为我们可以直接写出所有可能的值。
实际上，对于 9 个字符串来讲还算可以；但是如果需要大量的字符串，你就得考虑如何去自动生成（或者简单地使用<code>string</code>）。</p>
<p>有些值实际上是来自于动态创建的字符串字面量。
例如，假设 <code>makeWatchedObject</code> API 接收一个对象，并生成一个几乎等同的对象，但是带有一个新的<code>on</code>方法来检测属性的变化。</p>
<pre><code class="language-ts">let person = makeWatchedObject({
    firstName: 'Homer',
    age: 42,
    location: 'Springfield',
});

person.on('firstNameChanged', () =&gt; {
    console.log(`firstName was changed!`);
});
</code></pre>
<p>注意，<code>on</code>监听的是<code>"firstNameChanged"</code>事件，而非仅仅是<code>"firstName"</code>。
那么我们如何定义类型？</p>
<pre><code class="language-ts twslash">type PropEventSource&lt;T&gt; = {
    on(eventName: `${string &amp; keyof T}Changed`, callback: () =&gt; void): void;
};

/// Create a "watched object" with an 'on' method
/// so that you can watch for changes to properties.
declare function makeWatchedObject&lt;T&gt;(obj: T): T &amp; PropEventSource&lt;T&gt;;
</code></pre>
<p>这样做的话，如果传入了错误的属性会产生一个错误！</p>
<pre><code class="language-ts twoslash">type PropEventSource&lt;T&gt; = {
    on(eventName: `${string &amp; keyof T}Changed`, callback: () =&gt; void): void;
};
declare function makeWatchedObject&lt;T&gt;(obj: T): T &amp; PropEventSource&lt;T&gt;;
let person = makeWatchedObject({
    firstName: 'Homer',
    age: 42,
    location: 'Springfield',
});

// error!
person.on('firstName', () =&gt; {});

// error!
person.on('frstNameChanged', () =&gt; {});
</code></pre>
<p>我们还可以在模版字面量上做一些其它的事情：可以从替换的位置来<em>推断</em>类型。
我们将上面的例子改写成泛型，由<code>eventName</code>字符串来推断关联的属性名。</p>
<pre><code class="language-ts twoslash">type PropEventSource&lt;T&gt; = {
    on&lt;K extends string &amp; keyof T&gt;(
        eventName: `${K}Changed`,
        callback: (newValue: T[K]) =&gt; void
    ): void;
};

declare function makeWatchedObject&lt;T&gt;(obj: T): T &amp; PropEventSource&lt;T&gt;;

let person = makeWatchedObject({
    firstName: 'Homer',
    age: 42,
    location: 'Springfield',
});

// works! 'newName' is typed as 'string'
person.on('firstNameChanged', (newName) =&gt; {
    // 'newName' has the type of 'firstName'
    console.log(`new name is ${newName.toUpperCase()}`);
});

// works! 'newAge' is typed as 'number'
person.on('ageChanged', (newAge) =&gt; {
    if (newAge &lt; 0) {
        console.log('warning! negative age');
    }
});
</code></pre>
<p>这里我们将<code>on</code>定义为泛型方法。
当用户使用<code>"firstNameChanged'</code>来调用该方法，TypeScript 会尝试去推断出<code>K</code>所表示的类型。
为此，它尝试将<code>K</code>与<code>"Changed"</code>之前的内容进行匹配并推断出<code>"firstName"</code>。
一旦 TypeScript 得到了结果，<code>on</code>方法就能够从原对象上获取<code>firstName</code>的类型，此例中是<code>string</code>。
类似地，当使用<code>"ageChanged"</code>调用时，它会找到属性<code>age</code>的类型为<code>number</code>。</p>
<p>类型推断可以用不同的方式组合，常见的是解构字符串，再使用其它方式重新构造它们。
实际上，为了便于修改字符串字面量类型，我们引入了一些新的工具类型来修改字符大小写。</p>
<pre><code class="language-ts twoslash">type EnthusiasticGreeting&lt;T extends string&gt; = `${Uppercase&lt;T&gt;}`;

type HELLO = EnthusiasticGreeting&lt;'hello'&gt;;
//   ^^^^^
//   "HELLO"
</code></pre>
<p>新的类型别名为<code>Uppercase</code>，<code>Lowercase</code>，<code>Capitalize</code>和<code>Uncapitalize</code>。
前两个会转换字符串中的所有字符，而后面两个只转换字符串的首字母。</p>
<p>更多详情，<a href="https://github.com/microsoft/TypeScript/pull/40336">查看原 PR</a>以及<a href="https://github.com/microsoft/TypeScript/pull/40580">正在进行中的切换类型别名助手的 PR</a>.</p>
<h2 id="在映射类型中更改映射的键"><a class="header" href="#在映射类型中更改映射的键">在映射类型中更改映射的键</a></h2>
<p>让我们先回顾一下，映射类型可以使用任意的键来创建新的对象类型。</p>
<pre><code class="language-ts">type Options = {
    [K in
        | 'noImplicitAny'
        | 'strictNullChecks'
        | 'strictFunctionTypes']?: boolean;
};
// same as
//   type Options = {
//       noImplicitAny?: boolean,
//       strictNullChecks?: boolean,
//       strictFunctionTypes?: boolean
//   };
</code></pre>
<p>或者，基于任意的对象类型来创建新的对象类型。</p>
<pre><code class="language-ts">/// 'Partial&lt;T&gt;' 等同于 'T'，只是把每个属性标记为可选的。
type Partial&lt;T&gt; = {
    [K in keyof T]?: T[K];
};
</code></pre>
<p>到目前为止，映射类型只能使用提供给它的键来创建新的对象类型；然而，很多时候我们想要创建新的键，或者过滤掉某些键。</p>
<p>这就是 TypeScript 4.1 允许更改映射类型中的键的原因。它使用了新的<code>as</code>语句。</p>
<pre><code class="language-ts">type MappedTypeWithNewKeys&lt;T&gt; = {
    [K in keyof T as NewKeyType]: T[K];
    //            ^^^^^^^^^^^^^
    //            这里是新的语法！
};
</code></pre>
<p>通过<code>as</code>语句，你可以利用例如模版字面量类型，并基于原属性名来轻松地创建新属性名。</p>
<pre><code class="language-ts twoslash">type Getters&lt;T&gt; = {
    [K in keyof T as `get${Capitalize&lt;string &amp; K&gt;}`]: () =&gt; T[K];
};

interface Person {
    name: string;
    age: number;
    location: string;
}

type LazyPerson = Getters&lt;Person&gt;;
// type LazyPerson = {
//     getName: () =&gt; string;
//     getAge: () =&gt; number;
//     getLocation: () =&gt; string;
// }
</code></pre>
<p>此外，你可以巧用<code>never</code>类型来过滤掉某些键。
也就是说，在某些情况下你不必使用<code>Omit</code>工具类型。</p>
<pre><code class="language-ts twoslash">// 删除 'kind' 属性
type RemoveKindField&lt;T&gt; = {
    [K in keyof T as Exclude&lt;K, 'kind'&gt;]: T[K];
};

interface Circle {
    kind: 'circle';
    radius: number;
}

type KindlessCircle = RemoveKindField&lt;Circle&gt;;

type RemoveKindField&lt;T&gt; = {
    [K in keyof T as Exclude&lt;K, 'kind'&gt;]: T[K];
};

interface Circle {
    kind: 'circle';
    radius: number;
}

type KindlessCircle = RemoveKindField&lt;Circle&gt;;
// type KindlessCircle = {
//     radius: number;
// }
</code></pre>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/40336">PR</a>。</p>
<h2 id="递归的有条件类型"><a class="header" href="#递归的有条件类型">递归的有条件类型</a></h2>
<p>在 JavaScript 中较为常见的是，一个函数能够以任意的层级来展平（flatten）并构建容器类型。
例如，可以拿<code>Promise</code>实例对象上的<code>.then()</code>方法来举例。
<code>.then(...)</code>方法能够拆解每一个<code>Promise</code>，直到它找到一个非<code>Promise</code>的值，然后将该值传递给回调函数。
<code>Array</code>上也存在一个相对较新的<code>flat</code>方法，它接收一个表示深度的参数，并以此来决定展平操作的层数。</p>
<p>在过去，我们无法使用 TypeScript 类型系统来表达上述例子。
虽然也存在一些 hack，但基本上都不切合实际。</p>
<p>TypeScript 4.1 取消了对有条件类型的一些限制 - 因此它现在可以表达上述类型。
在 TypeScript 4.1 中，允许在有条件类型的分支中立即引用该有条件类型自身，这就使得编写递归的类型别名变得更加容易。
例如，我们想定义一个类型来获取嵌套数组中的元素类型，可以定义如下的<code>deepFlatten</code>类型。</p>
<pre><code class="language-ts">type ElementType&lt;T&gt; = T extends ReadonlyArray&lt;infer U&gt; ? ElementType&lt;U&gt; : T;

function deepFlatten&lt;T extends readonly unknown[]&gt;(x: T): ElementType&lt;T&gt;[] {
    throw 'not implemented';
}

// All of these return the type 'number[]':
deepFlatten([1, 2, 3]);
deepFlatten([[1], [2, 3]]);
deepFlatten([[1], [[2]], [[[3]]]]);
</code></pre>
<p>类似地，在 TypeScript 4.1 中我们可以定义<code>Awaited</code>类型来拆解<code>Promise</code>。</p>
<pre><code class="language-ts">type Awaited&lt;T&gt; = T extends PromiseLike&lt;infer U&gt; ? Awaited&lt;U&gt; : T;

/// 类似于 `promise.then(...)`，但是类型更准确
declare function customThen&lt;T, U&gt;(
    p: Promise&lt;T&gt;,
    onFulfilled: (value: Awaited&lt;T&gt;) =&gt; U
): Promise&lt;Awaited&lt;U&gt;&gt;;
</code></pre>
<p>一定要注意，虽然这些递归类型很强大，但要有节制地使用它。</p>
<p>首先，这些类型能做的更多，但也会增加类型检查的耗时。
尝试为考拉兹猜想或斐波那契数列建模是一件有趣的事儿，但请不要在 npm 上发布带有它们的<code>.d.ts</code>文件。</p>
<p>除了计算量大之外，这些类型还可能会达到内置的递归深度限制。
如果到达了递归深度限制，则会产生编译错误。
通常来讲，最好不要去定义这样的类型。</p>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/40002">PR</a>.</p>
<h2 id="索引访问类型检查--nouncheckedindexedaccess"><a class="header" href="#索引访问类型检查--nouncheckedindexedaccess">索引访问类型检查（<code>--noUncheckedIndexedAccess</code>）</a></h2>
<p>TypeScript 支持一个叫做<em>索引签名</em>的功能。
索引签名用于告诉类型系统，用户可以访问任意名称的属性。</p>
<pre><code class="language-ts twoslash">interface Options {
    path: string;
    permissions: number;

    // 额外的属性可以被这个签名捕获
    [propName: string]: string | number;
}

function checkOptions(opts: Options) {
    opts.path; // string
    opts.permissions; // number

    // 以下都是允许的
    // 它们的类型为 'string | number'
    opts.yadda.toString();
    opts['foo bar baz'].toString();
    opts[Math.random()].toString();
}
</code></pre>
<p>上例中，<code>Options</code>包含了索引签名，它表示在访问未直接列出的属性时得到的类型为<code>string | number</code>。
这是一种乐观的做法，它假想我们非常清楚代码在做什么，但实际上 JavaScript 中的大部分值并不支持任意的属性名。
例如，大多数类型并不包含属性名为<code>Math.random()</code>的值。
对许多用户来讲，这不是期望的行为，就好像没有利用到<code>--strictNullChecks</code>提供的严格类型检查。</p>
<p>这就是 TypeScript 4.1 提供了<code>--noUncheckedIndexedAccess</code>编译选项的原因。
在该新模式下，任何属性访问（例如<code>foo.bar</code>）或者索引访问（例如<code>foo["bar"]</code>）都会被认为可能为<code>undefined</code>。
例如在上例中，<code>opts.yadda</code>的类型为<code>string | number | undefined</code>，而不是<code>string | number</code>。
如果需要访问那个属性，你可以先检查属性是否存在或者使用非空断言运算符（<code>!</code>后缀字符）。</p>
<pre><code class="language-ts twoslash">// @noUncheckedIndexedAccess
interface Options {
    path: string;
    permissions: number;

    // 额外的属性可以被这个签名捕获
    [propName: string]: string | number;
}
// ---cut---
function checkOptions(opts: Options) {
    opts.path; // string
    opts.permissions; // number

    // 在 noUncheckedIndexedAccess 下，以下操作不允许
    opts.yadda.toString();
    opts['foo bar baz'].toString();
    opts[Math.random()].toString();

    // 首先检查是否存在
    if (opts.yadda) {
        console.log(opts.yadda.toString());
    }

    // 使用 ! 非空断言，“我知道在做什么”
    opts.yadda!.toString();
}
</code></pre>
<p>使用<code>--noUncheckedIndexedAccess</code>的一个结果是，通过索引访问数组元素时也会进行严格类型检查，就算是在遍历检查过边界的数组时。</p>
<pre><code class="language-ts twoslash">// @noUncheckedIndexedAccess
function screamLines(strs: string[]) {
    // 下面会有问题
    for (let i = 0; i &lt; strs.length; i++) {
        console.log(strs[i].toUpperCase());
    }
}
</code></pre>
<p>如果你不需要使用索引，那么可以使用<code>for</code>-<code>of</code>循环或<code>forEach</code>来遍历。</p>
<pre><code class="language-ts twoslash">// @noUncheckedIndexedAccess
function screamLines(strs: string[]) {
    // 可以正常工作
    for (const str of strs) {
        console.log(str.toUpperCase());
    }

    // 可以正常工作
    strs.forEach((str) =&gt; {
        console.log(str.toUpperCase());
    });
}
</code></pre>
<p>这个选项虽可以用来捕获访问越界的错误，但对大多数代码来讲有些烦，因此它不会被<code>--strict</code>选项自动启用；然而，如果你对此选项感兴趣，可以尝试一下，看它是否适用于你的代码。</p>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/39560">PR</a>.</p>
<h2 id="不带-baseurl-的-paths"><a class="header" href="#不带-baseurl-的-paths">不带 <code>baseUrl</code> 的 <code>paths</code></a></h2>
<p>路径映射的使用很常见 - 通常它用于优化导入语句，以及模拟在单一代码仓库中进行链接的行为。</p>
<p>不幸的是，在使用<code>paths</code>时必须指定<code>baseUrl</code>，它允许裸路径描述符基于<code>baseUrl</code>进行解析。
它会导致在自动导入时会使用较差的路径。</p>
<p>在 TypeScript 4.1 中，<code>paths</code>不必与<code>baseUrl</code>一起使用。
它会一定程序上帮助解决上述的问题。</p>
<h2 id="checkjs-默认启用-allowjs"><a class="header" href="#checkjs-默认启用-allowjs"><code>checkJs</code> 默认启用 <code>allowJs</code></a></h2>
<p>从前，如果你想要对 JavaScript 工程执行类型检查，你需要同时启用<code>allowJs</code>和<code>checkJs</code>。
这样的体验让人讨厌，因此现在<code>checkJs</code>会默认启用<code>allowJs</code>。</p>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/40275">PR</a>。</p>
<h2 id="react-17-jsx-工厂"><a class="header" href="#react-17-jsx-工厂">React 17 JSX 工厂</a></h2>
<p>TypeScript 4.1 通过以下两个编译选项来支持 React 17 中的<code>jsx</code>和<code>jsxs</code>工厂函数：</p>
<ul>
<li><code>react-jsx</code></li>
<li><code>react-jsxdev</code></li>
</ul>
<p>这两个编译选项分别用于生产环境和开发环境中。
通常，编译选项之间可以继承。
例如，用于生产环境的<code>tsconfig.json</code>如下：</p>
<pre><code class="language-json tsconfig">// ./src/tsconfig.json
{
    "compilerOptions": {
        "module": "esnext",
        "target": "es2015",
        "jsx": "react-jsx",
        "strict": true
    },
    "include": ["./**/*"]
}
</code></pre>
<p>另外一个用于开发环境的<code>tsconfig.json</code>如下：</p>
<pre><code class="language-json tsconfig">// ./src/tsconfig.dev.json
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "jsx": "react-jsxdev"
    }
}
</code></pre>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/39199">PR</a>。</p>
<h2 id="在编辑器中支持-jsdoc-see-标签"><a class="header" href="#在编辑器中支持-jsdoc-see-标签">在编辑器中支持 JSDoc <code>@see</code> 标签</a></h2>
<p>编辑器对 TypeScript 和 JavaScript 代码中的 JSDoc 标签<code>@see</code>有了更好的支持。
它允许你使用像“跳转到定义”这样的功能。
例如，在下例中的 JSDoc 里可以使用跳转到定义到<code>first</code>或<code>C</code>。</p>
<pre><code class="language-ts">// @filename: first.ts
export class C {}

// @filename: main.ts
import * as first from './first';

/**
 * @see first.C
 */
function related() {}
</code></pre>
<p>感谢贡献者<a href="https://github.com/Kingwl">Wenlu Wang</a><a href="https://github.com/microsoft/TypeScript/pull/39760">实现了这个功能</a>！</p>
<h2 id="破坏性改动"><a class="header" href="#破坏性改动">破坏性改动</a></h2>
<h3 id="libdts-更新"><a class="header" href="#libdts-更新"><code>lib.d.ts</code> 更新</a></h3>
<p><code>lib.d.ts</code>包含一些 API 变动，在某种程度上是因为 DOM 类型是自动生成的。
一个具体的变动是<code>Reflect.enumerate</code>被删除了，因为它在 ES2016 中被删除了。</p>
<h3 id="abstract-成员不能被标记为-async"><a class="header" href="#abstract-成员不能被标记为-async"><code>abstract</code> 成员不能被标记为 <code>async</code></a></h3>
<p><code>abstract</code>成员不再可以被标记为<code>async</code>。
这可以通过删除<code>async</code>关键字来修复，因为调用者只关注返回值类型。</p>
<h3 id="anyunknown-are-propagated-in-falsy-positions"><a class="header" href="#anyunknown-are-propagated-in-falsy-positions"><code>any</code>/<code>unknown</code> Are Propagated in Falsy Positions</a></h3>
<p>从前，对于表达式<code>foo &amp;&amp; somethingElse</code>，若<code>foo</code>的类型为<code>any</code>或<code>unknown</code>，那么整个表达式的类型为<code>somethingElse</code>。</p>
<p>例如，在以前此处的<code>x</code>的类型为<code>{ someProp: string }</code>。</p>
<pre><code class="language-ts">declare let foo: unknown;
declare let somethingElse: { someProp: string };

let x = foo &amp;&amp; somethingElse;
</code></pre>
<p>然而，在 TypeScript 4.1 中，会更谨慎地确定该类型。
由于不清楚<code>&amp;&amp;</code>左侧的类型，我们会传递<code>any</code>和<code>unknown</code>类型，而不是<code>&amp;&amp;</code>右侧的类型。</p>
<p>常见的模式是检查与<code>boolean</code>的兼容性，尤其是在谓词函数中。</p>
<pre><code class="language-ts">function isThing(x: any): boolean {
    return x &amp;&amp; typeof x === 'object' &amp;&amp; x.blah === 'foo';
}
</code></pre>
<p>一种合适的修改是使用<code>!!foo &amp;&amp; someExpression</code>来代替<code>foo &amp;&amp; someExpression</code>。</p>
<h3 id="promise的resolve的参数不再是可选的"><a class="header" href="#promise的resolve的参数不再是可选的"><code>Promise</code>的<code>resolve</code>的参数不再是可选的</a></h3>
<p>在编写如下的代码时</p>
<pre><code class="language-ts">new Promise((resolve) =&gt; {
    doSomethingAsync(() =&gt; {
        doSomething();
        resolve();
    });
});
</code></pre>
<p>你可能会得到如下的错误：</p>
<pre><code>  resolve()
  ~~~~~~~~~
error TS2554: Expected 1 arguments, but got 0.
  An argument for 'value' was not provided.
</code></pre>
<p>这是因为<code>resolve</code>不再有可选参数，因此默认情况下，必须给它传值。
它通常能够捕获<code>Promise</code>的 bug。
典型的修复方法是传入正确的参数，以及添加明确的类型参数。</p>
<pre><code class="language-ts">new Promise&lt;number&gt;((resolve) =&gt; {
    //     ^^^^^^^^
    doSomethingAsync((value) =&gt; {
        doSomething();
        resolve(value);
        //      ^^^^^
    });
});
</code></pre>
<p>然而，有时<code>resolve()</code>确实需要不带参数来调用
在这种情况下，我们可以给<code>Promise</code>传入明确的<code>void</code>泛型类型参数（例如，<code>Promise&lt;void&gt;</code>）。
它利用了 TypeScript 4.1 中的一个新功能，一个潜在的<code>void</code>类型的末尾参数会变成可选参数。</p>
<pre><code class="language-ts">new Promise&lt;void&gt;((resolve) =&gt; {
    //     ^^^^^^
    doSomethingAsync(() =&gt; {
        doSomething();
        resolve();
    });
});
</code></pre>
<p>TypeScript 4.1 提供了快速修复选项来解决该问题。</p>
<h3 id="有条件展开会创建可选属性"><a class="header" href="#有条件展开会创建可选属性">有条件展开会创建可选属性</a></h3>
<p>在 JavaScript 中，对象展开（例如，<code>{ ...foo }</code>）不会操作假值。
因此，在<code>{ ...foo }</code>代码中，如果<code>foo</code>的值为<code>null</code>或<code>undefined</code>，则它会被略过。</p>
<p>很多人利用该性质来可选地展开属性。</p>
<pre><code class="language-ts">interface Person {
    name: string;
    age: number;
    location: string;
}

interface Animal {
    name: string;
    owner: Person;
}

function copyOwner(pet?: Animal) {
    return {
        ...(pet &amp;&amp; pet.owner),
        otherStuff: 123,
    };
}

// We could also use optional chaining here:

function copyOwner(pet?: Animal) {
    return {
        ...pet?.owner,
        otherStuff: 123,
    };
}
</code></pre>
<p>此处，如果<code>pet</code>定义了，那么<code>pet.owner</code>的属性会被展开 - 否则，不会有属性被展开到目标对象中。</p>
<p>在之前，<code>copyOwner</code>的返回值类型为基于每个展开运算结果的联合类型：
The return type of <code>copyOwner</code> was previously a union type based on each spread:</p>
<pre><code>{ x: number } | { x: number, name: string, age: number, location: string }
</code></pre>
<p>它精确地展示了操作是如何进行的：如果<code>pet</code>定义了，那么<code>Person</code>中的所有属性都存在；否则，在结果中不存在<code>Person</code>中的任何属性。
它是一种要么全有要么全无的的操作。</p>
<p>然而，我们发现这个模式被过度地使用了，在单一对象中存在数以百计的展开运算，每一个展开操作可能会添加成百上千的操作。
结果就是这项操作可能非常耗时，并且用处不大。</p>
<p>在 TypeScript 4.1 中，返回值类型有时会使用全部的可选类型。</p>
<pre><code>{
    x: number;
    name?: string;
    age?: number;
    location?: string;
}
</code></pre>
<p>这样的结果是有更好的性能以及更佳地展示。</p>
<p>更多详情，请参考<a href="https://github.com/microsoft/TypeScript/pull/40778">PR</a>。
目前，该行为还不完全一致，我们期待在未来会有所改进。</p>
<h3 id="unmatched-parameters-are-no-longer-related"><a class="header" href="#unmatched-parameters-are-no-longer-related">Unmatched parameters are no longer related</a></h3>
<p>从前 TypeScript 在关联参数时，如果参数之间没有联系，则会将其关联为<code>any</code>类型。
由于<a href="https://github.com/microsoft/TypeScript/pull/41308">TypeScript 4.1 的改动</a>，TypeScript 会完全跳过这个过程。
这意味着一些可赋值性检查会失败，同时也意味着重载解析可能会失败。
例如，在解析 Node.js 中<code>util.promisify</code>函数的重载时可能会选择不同的重载签名，这可能会导致产生新的错误。</p>
<p>做为一个变通方法，你可能需要使用类型断言来消除错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-40"><a class="header" href="#typescript-40">TypeScript 4.0</a></h1>
<h2 id="可变参元组类型"><a class="header" href="#可变参元组类型">可变参元组类型</a></h2>
<p>在JavaScript中有一个函数<code>concat</code>，它接受两个数组或元组并将它们连接在一起构成一个新数组。</p>
<pre><code class="language-js">function concat(arr1, arr2) {
  return [...arr1, ...arr2];
}
</code></pre>
<p>再假设有一个<code>tail</code>函数，它接受一个数组或元组并返回除首个元素外的所有元素。</p>
<pre><code class="language-js">function tail(arg) {
  const [_, ...result] = arg;
  return result;
}
</code></pre>
<p>那么，我们如何在TypeScript中为这两个函数添加类型？</p>
<p>在旧版本的TypeScript中，对于<code>concat</code>函数我们能做的是编写一些函数重载签名。</p>
<pre><code class="language-ts">function concat(arr1: [], arr2: []): [];
function concat&lt;A&gt;(arr1: [A], arr2: []): [A];
function concat&lt;A, B&gt;(arr1: [A, B], arr2: []): [A, B];
function concat&lt;A, B, C&gt;(arr1: [A, B, C], arr2: []): [A, B, C];
function concat&lt;A, B, C, D&gt;(arr1: [A, B, C, D], arr2: []): [A, B, C, D];
function concat&lt;A, B, C, D, E&gt;(arr1: [A, B, C, D, E], arr2: []): [A, B, C, D, E];
function concat&lt;A, B, C, D, E, F&gt;(arr1: [A, B, C, D, E, F], arr2: []): [A, B, C, D, E, F];)
</code></pre>
<p>在保持第二个数组为空的情况下，我们已经编写了七个重载签名。
接下来，让我们为<code>arr2</code>添加一个参数。</p>
<pre><code class="language-ts">function concat&lt;A2&gt;(arr1: [], arr2: [A2]): [A2];
function concat&lt;A1, A2&gt;(arr1: [A1], arr2: [A2]): [A1, A2];
function concat&lt;A1, B1, A2&gt;(arr1: [A1, B1], arr2: [A2]): [A1, B1, A2];
function concat&lt;A1, B1, C1, A2&gt;(arr1: [A1, B1, C1], arr2: [A2]): [A1, B1, C1, A2];
function concat&lt;A1, B1, C1, D1, A2&gt;(arr1: [A1, B1, C1, D1], arr2: [A2]): [A1, B1, C1, D1, A2];
function concat&lt;A1, B1, C1, D1, E1, A2&gt;(arr1: [A1, B1, C1, D1, E1], arr2: [A2]): [A1, B1, C1, D1, E1, A2];
function concat&lt;A1, B1, C1, D1, E1, F1, A2&gt;(arr1: [A1, B1, C1, D1, E1, F1], arr2: [A2]): [A1, B1, C1, D1, E1, F1, A2];
</code></pre>
<p>这已经开始变得不合理了。
不巧的是，在给<code>tail</code>函数添加类型时也会遇到同样的问题。</p>
<p>在受尽了“重载的折磨”后，它依然没有完全解决我们的问题。
它只能针对已编写的重载给出正确的类型。
如果我们想要处理所有情况，则还需要提供一个如下的重载：</p>
<pre><code class="language-ts">function concat&lt;T, U&gt;(arr1: T[], arr2: U[]): Array&lt;T | U&gt;;
</code></pre>
<p>但是这个重载签名没有反映出输入的长度，以及元组元素的顺序。</p>
<p>TypeScript 4.0带来了两项基础改动，还伴随着类型推断的改善，因此我们能够方便地添加类型。</p>
<p>第一个改动是展开元组类型的语法支持泛型。
这就是说，我们能够表示在元组和数组上的高阶操作，尽管我们不清楚它们的具体类型。
在实例化泛型展开时
当在这类元组上进行泛型展开实例化（或者使用实际类型参数进行替换）时，它们能够产生另一组数组和元组类型。</p>
<p>例如，我们可以像下面这样给<code>tail</code>函数添加类型，避免了“重载的折磨”。</p>
<pre><code class="language-ts twoslash">function tail&lt;T extends any[]&gt;(arr: readonly [any, ...T]) {
  const [_ignored, ...rest] = arr;
  return rest;
}

const myTuple = [1, 2, 3, 4] as const;
const myArray = ["hello", "world"];

const r1 = tail(myTuple);
//    [2, 3, 4]

const r2 = tail([...myTuple, ...myArray] as const);
//    [2, 3, 4, ...string[]]
</code></pre>
<p>第二个改动是，剩余元素可以出现在元组中的任意位置上 - 不只是末尾位置！</p>
<pre><code class="language-ts twoslash">type Strings = [string, string];
type Numbers = [number, number];

type StrStrNumNumBool = [...Strings, ...Numbers, boolean];
//   [string, string, number, number, boolean]
</code></pre>
<p>在以前，TypeScript会像下面这样产生一个错误：</p>
<pre><code>剩余元素必须出现在元组类型的末尾。
</code></pre>
<p>但是在TypeScript 4.0中放开了这个限制。</p>
<p>注意，如果展开一个长度未知的类型，那么后面的所有元素都将被纳入到剩余元素类型。</p>
<pre><code class="language-ts twoslash">type Strings = [string, string];
type Numbers = number[];

type Unbounded = [...Strings, ...Numbers, boolean];
//   [string, string, ...(number | boolean)[]]
</code></pre>
<p>结合使用这两种行为，我们能够为<code>concat</code>函数编写一个良好的类型签名：</p>
<pre><code class="language-ts twoslash">type Arr = readonly any[];

function concat&lt;T extends Arr, U extends Arr&gt;(arr1: T, arr2: U): [...T, ...U] {
  return [...arr1, ...arr2];
}
</code></pre>
<p>虽然这个签名仍有点长，但是我们不再需要像重载那样重复多次，并且对于任何数组或元组它都能够给出期望的类型。</p>
<p>该功能本身已经足够好了，但是它的强大更体现在一些复杂的场景中。
例如，考虑有一个支持<a href="https://en.wikipedia.org/wiki/Partial_application">部分参数应用</a>的函数<code>partialCall</code>。
<code>partialCall</code>接受一个函数（例如叫作<code>f</code>），以及函数<code>f</code>需要的一些初始参数。
它返回一个新的函数，该函数接受<code>f</code>需要的额外参数，并最终以初始参数和额外参数来调用<code>f</code>。</p>
<pre><code class="language-js">function partialCall(f, ...headArgs) {
  return (...tailArgs) =&gt; f(...headArgs, ...tailArgs);
}
</code></pre>
<p>TypeScript 4.0改进了剩余参数和剩余元组元素的类型推断，因此我们可以为这种使用场景添加类型。</p>
<pre><code class="language-ts twoslash">type Arr = readonly unknown[];

function partialCall&lt;T extends Arr, U extends Arr, R&gt;(
  f: (...args: [...T, ...U]) =&gt; R,
  ...headArgs: T
) {
  return (...tailArgs: U) =&gt; f(...headArgs, ...tailArgs);
}
</code></pre>
<p>此例中，<code>partialCall</code>知道能够接受哪些初始参数，并返回一个函数，它能够正确地选择接受或拒绝额外的参数。</p>
<pre><code class="language-ts twoslash">// @errors: 2345 2554 2554 2345
type Arr = readonly unknown[];

function partialCall&lt;T extends Arr, U extends Arr, R&gt;(
  f: (...args: [...T, ...U]) =&gt; R,
  ...headArgs: T
) {
  return (...tailArgs: U) =&gt; f(...headArgs, ...tailArgs);
}
// ---cut---
const foo = (x: string, y: number, z: boolean) =&gt; {};

const f1 = partialCall(foo, 100);
//                          ~~~
// Argument of type 'number' is not assignable to parameter of type 'string'.

const f2 = partialCall(foo, "hello", 100, true, "oops");
//                                              ~~~~~~
// Expected 4 arguments, but got 5.(2554)

// This works!
const f3 = partialCall(foo, "hello");
//    (y: number, z: boolean) =&gt; void

// What can we do with f3 now?

// Works!
f3(123, true);

f3();

f3(123, "hello");
</code></pre>
<p>可变参元组类型支持了许多新的激动人心的模式，尤其是函数组合。
我们期望能够通过它来为JavaScript内置的<code>bind</code>函数进行更好的类型检查。
还有一些其它的类型推断改进以及模式引入进来，如果你想了解更多，请参考<a href="https://github.com/microsoft/TypeScript/pull/39094">PR</a>。</p>
<h2 id="标签元组元素"><a class="header" href="#标签元组元素">标签元组元素</a></h2>
<p>改进元组类型和参数列表使用体验的重要性在于它允许我们为JavaScript中惯用的方法添加强类型验证 - 例如对参数列表进行切片而后传递给其它函数。
这里至关重要的一点是我们可以使用元组类型作为剩余参数类型。</p>
<p>例如，下面的函数使用元组类型作为剩余参数：</p>
<pre><code class="language-ts">function foo(...args: [string, number]): void {
  // ...
}
</code></pre>
<p>它与下面的函数基本没有区别：</p>
<pre><code class="language-ts">function foo(arg0: string, arg1: number): void {
  // ...
}
</code></pre>
<p>对于<code>foo</code>函数的任意调用者：</p>
<pre><code class="language-ts twoslash">function foo(arg0: string, arg1: number): void {
  // ...
}

foo("hello", 42);

foo("hello", 42, true); // Expected 2 arguments, but got 3.
foo("hello"); // Expected 2 arguments, but got 1.
</code></pre>
<p>但是，如果从代码可读性的角度来看，就能够看出两者之间的差别。
在第一个例子中，参数的第一个元素和第二个元素都没有参数名。
虽然这不影响类型检查，但是元组中元素位置上缺乏标签令它们难以使用 - 很难表达出代码的意图。</p>
<p>这就是为什么TypeScript 4.0中的元组可以提供标签。</p>
<pre><code class="language-ts">type Range = [start: number, end: number];
</code></pre>
<p>为了加强参数列表和元组类型之间的联系，剩余元素和可选元素的语法采用了参数列表的语法。</p>
<pre><code class="language-ts">type Foo = [first: number, second?: string, ...rest: any[]];
</code></pre>
<p>在使用标签元组时有一些规则要遵守。
其一是，如果一个元组元素使用了标签，那么所有元组元素必须都使用标签。</p>
<pre><code class="language-ts twoslash">type Bar = [first: string, number];
// Tuple members must all have names or all not have names.(5084)
</code></pre>
<p>元组标签名不影响解构变量名，它们不必相同。
元组标签仅用于文档和工具目的。</p>
<pre><code class="language-ts twoslash">function foo(x: [first: string, second: number]) {
    // ...

    // 注意：不需要命名为'first'和'second'
    const [a, b] = x;
    a
//  string
    b
//  number
}
</code></pre>
<p>总的来说，标签元组对于元组和参数列表模式以及实现类型安全的重载时是很便利的。
实际上，在代码编辑器中TypeScript会尽可能地将它们显示为重载。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/signatureHelpLabeledTuples.gif" alt="Signature help displaying a union of labeled tuples as in a parameter list as two signatures" /></p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/38234">PT</a>。</p>
<h2 id="从构造函数中推断类属性"><a class="header" href="#从构造函数中推断类属性">从构造函数中推断类属性</a></h2>
<p>在TypeScript 4.0中，当启用了<code>noImplicitAny</code>时，编译器能够根据基于控制流的分析来确定类中属性的类型</p>
<pre><code class="language-ts twoslash">class Square {
  // 在旧版本中，以下两个属性均为any类型
  area; // number
  sideLength; // number

  constructor(sideLength: number) {
    this.sideLength = sideLength;
    this.area = sideLength ** 2;
  }
}
</code></pre>
<p>如果没有在构造函数中的所有代码执行路径上为实例成员进行赋值，那么该属性会被认为可能为<code>undefined</code>类型。</p>
<pre><code class="language-ts twoslash">class Square {
  sideLength; // number | undefined

  constructor(sideLength: number) {
    if (Math.random()) {
      this.sideLength = sideLength;
    }
  }

  get area() {
    return this.sideLength ** 2;
    //     ~~~~~~~~~~~~~~~
    //     对象可能为'undefined'
  }
}
</code></pre>
<p>如果你清楚地知道属性类型（例如，类中存在类似于<code>initialize</code>的初始化方法），你仍需要明确地使用类型注解来指定类型，以及需要使用确切赋值断言（<code>!</code>）如果你启用了<code>strictPropertyInitialization</code>模式。</p>
<pre><code class="language-ts twoslash">class Square {
  // 确切赋值断言
  //        v
  sideLength!: number;
  //         ^^^^^^^^
  //         类型注解

  constructor(sideLength: number) {
    this.initialize(sideLength);
  }

  initialize(sideLength: number) {
    this.sideLength = sideLength;
  }

  get area() {
    return this.sideLength ** 2;
  }
}
</code></pre>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/379200">PR</a>.</p>
<h2 id="断路赋值运算符"><a class="header" href="#断路赋值运算符">断路赋值运算符</a></h2>
<p>JavaScript以及其它很多编程语言支持一些_复合赋值_运算符。
复合赋值运算符作用于两个操作数，并将运算结果赋值给左操作数。
你从前可能见到过以下代码：</p>
<pre><code class="language-ts">// 加
// a = a + b
a += b;

// 减
// a = a - b
a -= b;

// 乘
// a = a * b
a *= b;

// 除
// a = a / b
a /= b;

// 幂
// a = a ** b
a **= b;

// 左移位
// a = a &lt;&lt; b
a &lt;&lt;= b;
</code></pre>
<p>JavaScript中的许多运算符都具有一个对应的赋值运算符！
目前为止，有三个值得注意的例外：逻辑_与_（<code>&amp;&amp;</code>），逻辑_或_（<code>||</code>）和逻辑_空值合并_（<code>??</code>）。</p>
<p>这就是为什么TypeScript 4.0支持了一个ECMAScript的新特性，增加了三个新的赋值运算符<code>&amp;&amp;=</code>，<code>||=</code>和<code>??=</code>。</p>
<p>这三个运算符可以用于替换以下代码：</p>
<pre><code class="language-ts">a = a &amp;&amp; b;
a = a || b;
a = a ?? b;
</code></pre>
<p>或者相似的<code>if</code>语句</p>
<pre><code class="language-ts">// could be 'a ||= b'
if (!a) {
  a = b;
}
</code></pre>
<p>还有以下的惰性初始化值的例子：</p>
<pre><code class="language-ts">let values: string[];
(values ?? (values = [])).push("hello");

// After
(values ??= []).push("hello");
</code></pre>
<p>少数情况下当你使用带有副作用的存取器时，值得注意的是这些运算符只在必要时才执行赋值操作。
也就是说，不仅是运算符右操作数会“短路”，整个赋值操作也会“短路”</p>
<pre><code class="language-ts">obj.prop ||= foo();

// roughly equivalent to either of the following

obj.prop || (obj.prop = foo());

if (!obj.prop) {
    obj.prop = foo();
}
</code></pre>
<p><a href="https://www.typescriptlang.org/play?ts=Nightly#code/MYewdgzgLgBCBGArGBeGBvAsAKBnmA5gKawAOATiKQBQCUGO+TMokIANkQHTsgHUAiYlChFyMABYBDCDHIBXMANoBuHI2Z4A9FpgAlIqXZTgRGAFsiAQg2byJeeTAwAslKgSu5KWAAmIczoYAB4YAAYuAFY1XHwAXwAaWxgIEhgKKmoAfQA3KXYALhh4EA4iH3osWM1WCDKePkFUkTFJGTlFZRimOJw4mJwAM0VgKABLcBhB0qCqplr63n4BcjGCCVgIMd8zIjz2eXciXy7k+yhHZygFIhje7BwFzgblgBUJMdlwM3yAdykAJ6yBSQGAeMzNUTkU7YBCILgZUioOBIBGUJEAHwxUxmqnU2Ce3CWgnenzgYDMACo6pZxpYIJSOqDwSkSFCYXC0VQYFi0NMQHQVEA">尝试运行这个例子</a>来查看与 _始终_执行赋值间的差别。</p>
<pre><code class="language-ts twoslash">const obj = {
    get prop() {
        console.log("getter has run");

        // Replace me!
        return Math.random() &lt; 0.5;
    },
    set prop(_val: boolean) {
        console.log("setter has run");
    }
};

function foo() {
    console.log("right side evaluated");
    return true;
}

console.log("This one always runs the setter");
obj.prop = obj.prop || foo();

console.log("This one *sometimes* runs the setter");
obj.prop ||= foo();
</code></pre>
<p>非常感谢社区成员<a href="https://github.com/Kingwl">Wenlu Wang</a>为该功能的付出！</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/37727">PR</a>.
你还可以<a href="https://github.com/tc39/proposal-logical-assignment/">查看该特性的TC39提案</a>.</p>
<h2 id="catch语句中的unknown类型"><a class="header" href="#catch语句中的unknown类型"><code>catch</code>语句中的<code>unknown</code>类型</a></h2>
<p>在TypeScript的早期版本中，<code>catch</code>语句中的捕获变量总为<code>any</code>类型。
这意味着你可以在捕获变量上执行任意的操作。</p>
<pre><code class="language-ts twoslash">try {
  // Do some work
} catch (x) {
  // x 类型为 'any'
  console.log(x.message);
  console.log(x.toUpperCase());
  x++;
  x.yadda.yadda.yadda();
}
</code></pre>
<p>上述代码可能导致错误处理语句中产生了_更多_的错误，因此该行为是不合理的。
因为捕获变量默认为<code>any</code>类型，所以它不是类型安全的，你可以在上面执行非法操作。</p>
<p>TypeScript 4.0允许将<code>catch</code>语句中的捕获变量类型声明为<code>unknown</code>类型。
<code>unknown</code>类型比<code>any</code>类型更加安全，因为它要求在使用之前必须进行类型检查。</p>
<pre><code class="language-ts twoslash">try {
  // ...
} catch (e: unknown) {
  // Can't access values on unknowns
  console.log(e.toUpperCase());

  if (typeof e === "string") {
    // We've narrowed 'e' down to the type 'string'.
    console.log(e.toUpperCase());
  }
}
</code></pre>
<p>由于<code>catch</code>语句捕获变量的类型不会被默认地改变成<code>unknown</code>类型，因此我们考虑在未来添加一个新的<code>--strict</code>标记来有选择性地引入该行为。
目前，我们可以通过使用代码静态检查工具来强制<code>catch</code>捕获变量使用了明确的类型注解<code>: any</code>或<code>: unknown</code>。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/39015">PR</a>.</p>
<h2 id="自定义jsx工厂"><a class="header" href="#自定义jsx工厂">自定义JSX工厂</a></h2>
<p>在使用JSX时，<a href="https://reactjs.org/docs/fragments.html"><em>fragment</em></a>类型的JSX元素允许返回多个子元素。
当TypeScript刚开始实现fragments时，我们不太清楚其它代码库该如何使用它们。
最近越来越多的库开始使用JSX并支持与fragments结构相似的API。</p>
<p>在TypeScript 4.0中，用户可以使用<code>jsxFragmentFactory</code>选项来自定义fragment工厂。</p>
<p>例如，下例的<code>tsconfig.json</code>文件告诉TypeScript使用与React兼容的方式来转换JSX，但使用<code>h</code>来代替<code>React.createElement</code>工厂，同时使用<code>Fragment</code>来代替<code>React.Fragment</code>。</p>
<pre><code class="language-json5">{
  compilerOptions: {
    target: "esnext",
    module: "commonjs",
    jsx: "react",
    jsxFactory: "h",
    jsxFragmentFactory: "Fragment",
  },
}
</code></pre>
<p>如果针对每个文件具有不同的JSX工厂，你可以使用新的<code>/** @jsxFrag */</code>编译指令注释。
示例：</p>
<pre><code class="language-tsx twoslash">// 注意：这些编译指令注释必须使用JSDoc风格，否则不起作用

/** @jsx h */
/** @jsxFrag Fragment */

import { h, Fragment } from "preact";

export const Header = (
  &lt;&gt;
    &lt;h1&gt;Welcome&lt;/h1&gt;
  &lt;/&gt;
);
</code></pre>
<p>上述代码会转换为如下的JavaScript</p>
<pre><code class="language-tsx twoslash">// 注意：这些编译指令注释必须使用JSDoc风格，否则不起作用

/** @jsx h */
/** @jsxFrag Fragment */

import { h, Fragment } from "preact";

export const Header = (
  h(
    Fragment,
    null,
    h("h1", null, "Welcome")
  )
);
</code></pre>
<p>非常感谢社区成员<a href="https://github.com/nojvek">Noj Vek</a>为该特性的付出。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/38720">PR</a></p>
<h2 id="对启用了--noemitonerror的build模式进行速度优化"><a class="header" href="#对启用了--noemitonerror的build模式进行速度优化">对启用了<code>--noEmitOnError</code>的`build模式进行速度优化</a></h2>
<p>在以前，当启用了<code>--noEmitOnError</code>编译选项时，如果在<code>--incremental</code>构建模式下的前一次构建出错了，那么接下来的构建会很慢。
这是因为当启用了<code>--noEmitOnError</code>时，前一次失败构建的信息不会被缓存到<code>.tsbuildinfo</code>文件中。</p>
<p>TypeScript 4.0对此做出了一些改变，极大地提升了这种情况下的编译速度，改善了应用<code>--build</code>模式的场景（包含<code>--incremental</code>和<code>--noEmitOnError</code>）。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/38853">PR</a>。</p>
<h2 id="--incremental和--noemit"><a class="header" href="#--incremental和--noemit"><code>--incremental</code>和<code>--noEmit</code></a></h2>
<p>TypeScript 4.0允许同时使用<code>--incremental</code>和<code>--noEmit</code>。
这在之前是不允许的，因为<code>--incremental</code>需要生成<code>.tsbuildinfo</code>文件；
然而，提供更快地增量构建对所有用户来讲都是十分重要的。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/39122">PR</a>。</p>
<h2 id="编辑器改进"><a class="header" href="#编辑器改进">编辑器改进</a></h2>
<p>TypeScript编译器不但支持在大部分编辑器中编写TypeScript代码，还支持着在Visual Studio系列的编辑器中编写JavaScript代码。
因此，我们主要工作之一是改善编辑器支持 - 这也是程序员花费了大量时间的地方。</p>
<p>针对不同的编辑器，在使用TypeScript/JavaScript的新功能时可能会有所区别，但是</p>
<ul>
<li>Visual Studio Code支持<a href="https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript">选择不同的TypeScript版本</a>。或者，安装<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next">JavaScript/TypeScript Nightly Extension</a>插件来使用最新的版本。</li>
<li>Visual Studio 2017/2019提供了SDK安装包，以及<a href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild">MSBuild安装包</a>。</li>
<li>Sublime Text 3支持<a href="https://github.com/microsoft/TypeScript-Sublime-Plugin#note-using-different-versions-of-typescript">选择不同的TypeScript版本</a></li>
</ul>
<p><a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support">这里是支持TypeScript的编辑器列表</a>，到这里查看你喜爱的编译器是否支持最新版本的TypeScript。</p>
<h3 id="转换为可选链"><a class="header" href="#转换为可选链">转换为可选链</a></h3>
<p>可选链是一个较新的大家喜爱的特性。
TypeScript 4.0带来了一个新的重构工具来转换常见的代码模式，以利用<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#optional-chaining">可选链</a>和<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#nullish-coalescing">空值合并</a>！</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/convertToOptionalChain-4-0.gif" alt="将a &amp;&amp; a.b.c &amp;&amp; a.b.c.d.e.f()转换为a?.b.c?.d.e.f.()" /></p>
<p>注意，虽然该项重构不能_完美地_捕获真实情况（由于JavaScript中较复杂的真值/假值关系），但是我们坚信它能够适用于大多数使用场景，尤其是在TypeScript清楚地知道代码类型信息的时候。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/39135">PR</a>。</p>
<h3 id="-deprecated-支持"><a class="header" href="#-deprecated-支持"><code>/** @deprecated */</code>支持</a></h3>
<p>TypeScript现在能够识别代码中的<code>/** @deprecated *</code>JSDoc注释，并对编辑器提供支持。
该信息会显示在自动补全列表中以及建议诊断信息，编辑器可以特殊处理它。
在类似于VS Code的编辑器中，废弃的值会显示为删除线，例如<del>like this</del>。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/06/deprecated_4-0.png" alt="Some examples of deprecated declarations with strikethrough text in the editor" /></p>
<p>感谢<a href="https://github.com/Kingwl">Wenlu Wang</a>为该特性的付出。
更多详情请参考<a href="https://github.com/microsoft/TypeScript/pull/38523">PR</a>。</p>
<h3 id="启动时的局部语义模式"><a class="header" href="#启动时的局部语义模式">启动时的局部语义模式</a></h3>
<p>我们从用户反馈得知在启动一个大的工程时需要很长的时间。
罪魁祸首是一个叫作_程序构造_的处理过程。
该处理是从一系列根文件开始解析并查找它们的依赖，然后再解析依赖，然后再解析依赖的依赖，以此类推。
你的工程越大，你等待的时间就越长，在这之前你不能使用编辑器的诸如“跳转到定义”等功能。</p>
<p>这就是为什么我们要提供一个新的编辑器模式，在语言服务被完全加载之前提供局部编辑体验。
这里的主要想法是，编辑器可以运行一个轻量级的局部语言服务，它只关注编辑器当前打开的文件。</p>
<p>很难准确地形容能够获得多大的提升，但听说在Visual Studio Code项目中，以前需要等待_20秒到1分钟_的时间来完全加载语言服务。
做为对比，<em><em>新的局部语义模式看起来能够将上述时间减少到几秒钟</em>。</em>
示例，从下面的视频中，你可以看到左侧的TypeScript 3.9与右侧的TypeScript 4.0的对比。</p>
<video loop autoplay muted style="width:100%;height:100%;" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/partialModeFast.mp4">
</video>
<p>当在编辑器中打开一个大型的代码仓库时，TypeScript 3.9根本无法提供代码补全以及信息提示。
反过来，安装了TypeScript 4.0的编辑器能够在当前文件上_立即_提供丰富的编辑体验，尽管后台仍然在加载整个工程。</p>
<p>目前，唯一一个支持该模块的编辑器是<a href="http://code.visualstudio.com/">Visual Studio Code</a>，并且在<a href="http://code.visualstudio.com/insiders">Visual Studio Code Insiders</a>版本中还带来了一些体验上的优化。
我们发现该特性在用户体验和功能性上仍有优化空间，我们总结了一个<a href="https://github.com/microsoft/TypeScript/issues/39035">优化列表</a>。
我们也期待你的使用反馈。</p>
<p>更多详情请参考<a href="https://github.com/microsoft/TypeScript/issues/37713">原始的提议</a>，<a href="https://github.com/microsoft/TypeScript/pull/38561">功能实现的PR</a>，以及<a href="https://github.com/microsoft/TypeScript/issues/39035">后续的跟踪帖</a>.</p>
<h3 id="更智能的自动导入"><a class="header" href="#更智能的自动导入">更智能的自动导入</a></h3>
<p>自动导入是个特别好的功能，它让编码更加容易；然而，每一次自动导入不好用的时候，它就会导致一部分用户流失。
一个特殊的问题是，自动导入对于使用TypeScript编写的依赖不好用 - 也就是说，用户必须在工程中的某处明确地编写一个导入语句。</p>
<p>那么为什么自动导入在<code>@types</code>包上是好用的，但是对于自己编写的代码却不好用？
这表明自动导入功能只适用于工程中已经引入的包。
因为TypeScript会自动地将<code>node_modules/@types</code>下面的包引入进工程，_那些_包才会被自动导入。
另一方面，其它的包会被排除，因为遍历<code>node_modules</code>下所有的包_相当_费时。</p>
<p>这就导致了在自动导入一个刚刚安装完但还没有开始使用的包时具有相当差的体验。</p>
<p>TypeScript 4.0对编辑器环境进行了一点小改动，它会自动引入你的工程下的<code>package.json</code>文件中<code>dependencies</code>（和<code>peerDependencies</code>）字段里列出的包。
这些引入的包只用于改进自动导入功能，它们对类型检查等其它功能没有任何影响。
这使得自动导入功能对于项目中所有带有类型的依赖项都是可用的，同时不必遍历<code>node_modules</code>。</p>
<p>少数情况下，若在<code>package.json</code>中列出了多于10个未导入的带有类型的依赖，那么该功能会被自动禁用以避免过慢的工程加载。
若想要强制启用该功能，或完全禁用该功能，则需要配置你的编辑器。
针对Visual Studio Code，对应到“Include Package JSON Auto Imports”配置（或者<code>typescript.preferences.includePackageJsonAutoImports</code>配置）。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/configurePackageJsonAutoImports4-0.png" alt="Configuring &#39;include package JSON auto imports&#39;" />
For more details, you can see the <a href="https://github.com/microsoft/TypeScript/issues/37812">proposal issue</a> along with <a href="https://github.com/microsoft/TypeScript/pull/38923">the implementing pull request</a>.</p>
<h2 id="我们的新网站"><a class="header" href="#我们的新网站">我们的新网站</a></h2>
<p>最近，我们重写了<a href="https://www.typescriptlang.org/">TypeScript官网</a>并且已经发布！</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/ts-web.png" alt="A screenshot of the new TypeScript website" /></p>
<p><a href="https://devblogs.microsoft.com/typescript/announcing-the-new-typescript-website/">我们在这里介绍了关于新网站的一些信息</a>；但仍期望用户给予更多的反馈！
如果你有问题或建议，请到<a href="https://github.com/microsoft/TypeScript-Website">这里提交Issue</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="改进类型推断和promiseall"><a class="header" href="#改进类型推断和promiseall">改进类型推断和<code>Promise.all</code></a></h2>
<p>TypeScript的最近几个版本（3.7前后）更新了像<code>Promise.all</code>和<code>Promise.race</code>等的函数声明。
不巧的是，它引入了一些回归问题，尤其是在和<code>null</code>或<code>undefined</code>混合使用的场景中。</p>
<pre><code class="language-ts">interface Lion {
  roar(): void;
}

interface Seal {
  singKissFromARose(): void;
}

async function visitZoo(
  lionExhibit: Promise&lt;Lion&gt;,
  sealExhibit: Promise&lt;Seal | undefined&gt;
) {
  let [lion, seal] = await Promise.all([lionExhibit, sealExhibit]);
  lion.roar();
  //   ~~~~
  //  对象可能为'undefined'
}
</code></pre>
<p>这是一种奇怪的行为！
事实上，只有<code>sealExhibit</code>包含了<code>undefined</code>值，但是它却让<code>lion</code>也含有了<code>undefined</code>值。</p>
<p>得益于<a href="https://github.com/jablko">Jack Bates</a>提交的<a href="https://github.com/microsoft/TypeScript/pull/34501">PR</a>，这个问题已经被修复了，它改进了TypeScript 3.9中的类型推断流程。
上面的例子中已经不再产生错误。
如果你在旧版本的TypeScript中被<code>Promise</code>的这个问题所困扰，我们建议你尝试一下3.9版本！</p>
<h3 id="awaited-类型"><a class="header" href="#awaited-类型"><code>awaited</code> 类型</a></h3>
<p>如果你一直关注TypeScript，那么你可能会注意到<a href="https://github.com/microsoft/TypeScript/pull/35998">一个新的类型运算符<code>awaited</code></a>。
这个类型运算符的作用是准确地表达JavaScript中<code>Promise</code>的工作方式。</p>
<p>我们原计划在TypeScript 3.9中支持<code>awaited</code>，但在现有的代码中测试过该特性后，我们发现还需要进行一些设计，以便让所有人能够顺利地使用它。
因此，我们从主分支中暂时移除了这个特性。
我们将继续试验这个特性，它不会被包含进本次发布。</p>
<h2 id="速度优化"><a class="header" href="#速度优化">速度优化</a></h2>
<p>TypeScript 3.9提供了多项速度优化。
TypeScript在<code>material-ui</code>和<code>styled-components</code>代码包中拥有非常慢的编辑速度和编译速度。在发现了这点后，TypeScript团队集中了精力解决性能问题。
TypeScript优化了大型联合类型、交叉类型、有条件类型和映射类型。</p>
<ul>
<li>https://github.com/microsoft/TypeScript/pull/36576</li>
<li>https://github.com/microsoft/TypeScript/pull/36590</li>
<li>https://github.com/microsoft/TypeScript/pull/36607</li>
<li>https://github.com/microsoft/TypeScript/pull/36622</li>
<li>https://github.com/microsoft/TypeScript/pull/36754</li>
<li>https://github.com/microsoft/TypeScript/pull/36696</li>
</ul>
<p>上面列出的每一个PR都能够减少5-10%的编译时间（对于某些代码库）。
对于<code>material-ui</code>库而言，现在能够节约大约40%的编译时间！</p>
<p>我们还调整了在编辑器中的文件重命名功能。
从Visual Studio Code团队处得知，当重命名一个文件时，计算出需要更新的<code>import</code>语句要花费5到10秒的时间。
TypeScript 3.9通过<a href="https://github.com/microsoft/TypeScript/pull/37055">改变编译器和语言服务缓存文件查询的内部实现</a>解决了这个问题。</p>
<p>尽管仍有优化的空间，我们希望当前的改变能够为每个人带来更流畅的体验。</p>
<h2 id="-ts-expect-error-注释"><a class="header" href="#-ts-expect-error-注释"><code>// @ts-expect-error</code> 注释</a></h2>
<p>设想一下，我们正在使用TypeScript编写一个代码库，它对外开放了一个公共函数<code>doStuff</code>。
该函数的类型声明了它接受两个<code>string</code>类型的参数，因此其它TypeScript的用户能够看到类型检查的结果，但该函数还进行了运行时的检查以便JavaScript用户能够看到一个有帮助的错误。</p>
<pre><code class="language-ts">function doStuff(abc: string, xyz: string) {
  assert(typeof abc === "string");
  assert(typeof xyz === "string");

  // do some stuff
}
</code></pre>
<p>如果有人错误地使用了该函数，那么TypeScript用户能够看到红色的波浪线和错误提示，JavaScript用户会看到断言错误。
然后，我们想编写一条单元测试来测试该行为。</p>
<pre><code class="language-ts">expect(() =&gt; {
  doStuff(123, 456);
}).toThrow();
</code></pre>
<p>不巧的是，如果你使用TypeScript来编译单元测试，TypeScript会提示一个错误！</p>
<pre><code class="language-ts">doStuff(123, 456);
//      ~~~
// 错误：类型'number'不能够赋值给类型'string'。
</code></pre>
<p>这就是TypeScript 3.9添加了<code>// @ts-expect-error</code>注释的原因。
当一行代码带有<code>// @ts-expect-error</code>注释时，TypeScript不会提示上例的错误；
但如果该行代码没有错误，TypeScript会提示没有必要使用<code>// @ts-expect-error</code>。</p>
<p>示例，以下的代码是正确的：</p>
<pre><code class="language-ts">// @ts-expect-error
console.log(47 * "octopus");
</code></pre>
<p>但是下面的代码：</p>
<pre><code class="language-ts">// @ts-expect-error
console.log(1 + 1);
</code></pre>
<p>会产生错误：</p>
<pre><code>未使用的 '@ts-expect-error' 指令。
</code></pre>
<p>非常感谢<a href="https://github.com/JoshuaKGoldberg">Josh Goldberg</a>实现了这个功能。
更多信息请参考<a href="https://github.com/microsoft/TypeScript/pull/36014">the <code>ts-expect-error</code> pull request</a>。</p>
<h3 id="ts-ignore-还是-ts-expect-error"><a class="header" href="#ts-ignore-还是-ts-expect-error"><code>ts-ignore</code> 还是 <code>ts-expect-error</code>?</a></h3>
<p>某些情况下，<code>// @ts-expect-error</code>和<code>// @ts-ignore</code>是相似的，都能够阻止产生错误消息。
两者的不同在于，如果下一行代码没有错误，那么<code>// @ts-ignore</code>不会做任何事。</p>
<p>你可能会想要抛弃<code>// @ts-ignore</code>注释转而去使用<code>// @ts-expect-error</code>，并且想要知道哪一个更适用于以后的代码。
实际上，这完全取决于你和你的团队，下面列举了一些具体情况。</p>
<p>如果满足以下条件，那么选择<code>ts-expect-error</code>：</p>
<ul>
<li>你在编写单元测试，并且想让类型系统提示错误</li>
<li>你知道此处有问题，并且很快会回来改正它，只是暂时地忽略该错误</li>
<li>你的团队成员都很积极，大家想要在代码回归正常后及时地删除忽略类型检查注释</li>
</ul>
<p>如果满足以下条件，那么选择<code>ts-ignore</code>：</p>
<ul>
<li>项目规模较大，产生了一些错误但是找不到相应代码的负责人</li>
<li>正处于TypeScript版本升级的过程中，某些错误只在特定版本的TypeScript中存在，但是在其它版本中并不存在</li>
<li>你没有足够的时间考虑究竟应该使用<code>// @ts-ignore</code>还是<code>// @ts-expect-error</code></li>
</ul>
<h2 id="在条件表达式中检查未被调用的函数"><a class="header" href="#在条件表达式中检查未被调用的函数">在条件表达式中检查未被调用的函数</a></h2>
<p>在TypeScript 3.7中，我们引入了_未进行函数调用的检查_，当你忘记去调用某个函数时会产生错误。</p>
<pre><code class="language-ts">function hasImportantPermissions(): boolean {
  // ...
}

// Oops!
if (hasImportantPermissions) {
  //  ~~~~~~~~~~~~~~~~~~~~~~~
  // 这个条件永远返回true，因为函数已经被定义。
  // 你是否想要调用该函数？
  deleteAllTheImportantFiles();
}
</code></pre>
<p>然而，这个错误只会在<code>if</code>条件语句中才会提示。
多亏了<a href="https://github.com/a-tarasyuk">Alexander Tarasyuk</a>提交的<a href="https://github.com/microsoft/TypeScript/pull/36402">PR</a>，现在这个特性也支持在三元表达式中使用，例如<code>cond ? trueExpr : falseExpr</code>。</p>
<pre><code class="language-ts">declare function listFilesOfDirectory(dirPath: string): string[];
declare function isDirectory(): boolean;

function getAllFiles(startFileName: string) {
  const result: string[] = [];
  traverse(startFileName);
  return result;

  function traverse(currentPath: string) {
    return isDirectory
      ? // ~~~~~~~~~~~
        // 该条件永远返回true
        // 因为函数已经被定义。
        // 你是否想要调用该函数？
        listFilesOfDirectory(currentPath).forEach(traverse)
      : result.push(currentPath);
  }
}
</code></pre>
<p>https://github.com/microsoft/TypeScript/issues/36048</p>
<h2 id="编辑器改进-1"><a class="header" href="#编辑器改进-1">编辑器改进</a></h2>
<p>TypeScript编译器不但支持在大部分编辑器中编写TypeScript代码，还支持着在Visual Studio系列的编辑器中编写JavaScript代码。
针对不同的编辑器，在使用TypeScript/JavaScript的新功能时可能会有所区别，但是</p>
<ul>
<li>Visual Studio Code支持<a href="https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript">选择不同的TypeScript版本</a>。或者，安装<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next">JavaScript/TypeScript Nightly Extension</a>插件来使用最新的版本。</li>
<li>Visual Studio 2017/2019提供了SDK安装包，以及<a href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild">MSBuild安装包</a>。</li>
<li>Sublime Text 3支持<a href="https://github.com/microsoft/TypeScript-Sublime-Plugin#note-using-different-versions-of-typescript">选择不同的TypeScript版本</a></li>
</ul>
<h3 id="在javascript中自动导入commonjs模块"><a class="header" href="#在javascript中自动导入commonjs模块">在JavaScript中自动导入CommonJS模块</a></h3>
<p>在使用了CommonJS模块的JavaScript文件中，我们对自动导入功能进行了一个非常棒的改进。</p>
<p>在旧的版本中，TypeScript总是假设你想要使用ECMAScript模块风格的导入语句，并且无视你的文件类型。</p>
<pre><code class="language-js">import * as fs from "fs";
</code></pre>
<p>然而，在编写JavaScript文件时，并不总是想要使用ECMAScript模块风格。
非常多的用户仍然在使用CommonJS模块，例如<code>require(...)</code>。</p>
<pre><code class="language-js">const fs = require("fs");
</code></pre>
<p>现在，TypeScript会自动检测你正在使用的导入语句风格，并使用当前的导入语句风格。</p>
<p><video src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/03/ERkaliGU0AA5anJ1.mp4"></video></p>
<p>更新信息请参考<a href="https://github.com/microsoft/TypeScript/pull/37027">PR</a>.</p>
<h3 id="code-actions-保留换行符"><a class="header" href="#code-actions-保留换行符">Code Actions 保留换行符</a></h3>
<p>TypeScript的重构工具和快速修复工具对换行符的处理不是非常好。
一个基本的示例如下。</p>
<pre><code class="language-ts">const maxValue = 100;

/*start*/
for (let i = 0; i &lt;= maxValue; i++) {
  // First get the squared value.
  let square = i ** 2;

  // Now print the squared value.
  console.log(square);
}
/*end*/
</code></pre>
<p>如果我们选中从<code>/*start*/</code>到<code>/*end*/</code>，然后进行“提取到函数”操作，我们会得到如下的代码。</p>
<pre><code class="language-ts">const maxValue = 100;

printSquares();

function printSquares() {
  for (let i = 0; i &lt;= maxValue; i++) {
    // First get the squared value.
    let square = i ** 2;
    // Now print the squared value.
    console.log(square);
  }
}
</code></pre>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/03/printSquaresWithoutNewlines-3.9.gif.gif" alt="在旧版本的TypeScript中，将循环提取到函数时，换行符没有被保留。" /></p>
<p>这不是我们想要的 - 在<code>for</code>循环中，每条语句之间都有一个空行，但是重构后它们被移除了！
TypeScript 3.9调整后，它会保留我们编写的代码。</p>
<pre><code class="language-ts">const maxValue = 100;

printSquares();

function printSquares() {
  for (let i = 0; i &lt;= maxValue; i++) {
    // First get the squared value.
    let square = i ** 2;

    // Now print the squared value.
    console.log(square);
  }
}
</code></pre>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/03/printSquaresWithNewlines-3.9.gif.gif" alt="在TypeScript 3.9中，将循环提取到函数时，会保留一个换行符。" /></p>
<p>更多信息请参考<a href="https://github.com/microsoft/TypeScript/pull/36688">PR</a></p>
<h3 id="快速修复缺失的返回值表达式"><a class="header" href="#快速修复缺失的返回值表达式">快速修复：缺失的返回值表达式</a></h3>
<p>有时候，我们可能忘记在函数的最后添加返回值语句，尤其是在将简单箭头函数转换成还有花括号的箭头函数时。</p>
<pre><code class="language-ts">// before
let f1 = () =&gt; 42;

// oops - not the same!
let f2 = () =&gt; {
  42;
};
</code></pre>
<p>感谢开源社区的<a href="https://github.com/Kingwl">Wenlu Wang</a>的<a href="https://github.com/microsoft/TypeScript/pull/26434">PR</a>，TypeScript提供了快速修复功能来添加<code>return</code>语句，删除花括号，或者为箭头函数体添加小括号用以区分对象字面量。</p>
<p><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/04/missingReturnValue-3-9.gif" alt="示例" /></p>
<h3 id="支持solution-style的tsconfigjson文件"><a class="header" href="#支持solution-style的tsconfigjson文件">支持"Solution Style"的<code>tsconfig.json</code>文件</a></h3>
<p>编译器需要知道一个文件被哪个配置文件所管理，因此才能够应用适当的配置选项并且计算出当前“工程”包含了哪些文件。
在默认情况下，编辑器使用TypeScript语言服务来向上遍历父级目录以查找<code>tsconfig.json</code>文件。</p>
<p>有一种特殊情况是<code>tsconfig.json</code>文件仅用于引用其它<code>tsconfig.json</code>文件。</p>
<pre><code class="language-json5">// tsconfig.json
{
  files: [],
  references: [
    { path: "./tsconfig.shared.json" },
    { path: "./tsconfig.frontend.json" },
    { path: "./tsconfig.backend.json" },
  ],
}
</code></pre>
<p>这个文件除了用来管理其它项目的配置文件之外什么也没做，在某些环境中它被叫作“solution”。
这里，任何一个<code>tsconfig.*.json</code>文件都不会被TypeScript语言服务所选用，但是我们希望语言服务能够分析出当前的<code>.ts</code>文件被上述<code>tsconfig.json</code>中引用的哪个配置文件所管理。</p>
<p>TypeScript 3.9为这种类型的配置方式添加了编辑器的支持。
更多信息请参考<a href="https://github.com/microsoft/TypeScript/pull/37239">PR</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-38"><a class="header" href="#typescript-38">TypeScript 3.8</a></h1>
<ul>
<li><a href="zh/release-notes/typescript-3.8.html#type-only-imports-exports">Type-Only Imports and Exports</a></li>
<li><a href="zh/release-notes/typescript-3.8.html#ecmascript-private-fields">ECMAScript Private Fields</a></li>
<li><a href="zh/release-notes/typescript-3.8.html#export-star-as-namespace-syntax"><code>export * as ns</code> Syntax</a></li>
<li><a href="zh/release-notes/typescript-3.8.html#top-level-await">Top-Level <code>await</code></a></li>
<li><a href="zh/release-notes/typescript-3.8.html#jsdoc-modifiers">JSDoc Property Modifiers</a></li>
<li><a href="zh/release-notes/typescript-3.8.html#better-directory-watching">Better Directory Watching on Linux and <code>watchOptions</code></a></li>
<li><a href="zh/release-notes/typescript-3.8.html#assume-direct-dependencies">"Fast and Loose" Incremental Checking</a></li>
</ul>
<h2 id="类型导入和导出type-only-imports-and-exports"><a class="header" href="#类型导入和导出type-only-imports-and-exports"><span id="type-only-imports-exports" /> 类型导入和导出（Type-Only Imports and Exports）</a></h2>
<p>This feature is something most users may never have to think about; however, if you've hit issues under <code>--isolatedModules</code>, TypeScript's <code>transpileModule</code> API, or Babel, this feature might be relevant.</p>
<p>TypeScript 3.8 adds a new syntax for type-only imports and exports.</p>
<pre><code class="language-ts">import type { SomeThing } from "./some-module.js";

export type { SomeThing };
</code></pre>
<p><code>import type</code> only imports declarations to be used for type annotations and declarations.
It <em>always</em> gets fully erased, so there's no remnant of it at runtime.
Similarly, <code>export type</code> only provides an export that can be used for type contexts, and is also erased from TypeScript's output.</p>
<p>It's important to note that classes have a value at runtime and a type at design-time, and the use is context-sensitive.
When using <code>import type</code> to import a class, you can't do things like extend from it.</p>
<pre><code class="language-ts">import type { Component } from "react";

interface ButtonProps {
    // ...
}

class Button extends Component&lt;ButtonProps&gt; {
    //               ~~~~~~~~~
    // error! 'Component' only refers to a type, but is being used as a value here.

    // ...
}
</code></pre>
<p>If you've used Flow before, the syntax is fairly similar.
One difference is that we've added a few restrictions to avoid code that might appear ambiguous.</p>
<pre><code class="language-ts">// Is only 'Foo' a type? Or every declaration in the import?
// We just give an error because it's not clear.

import type Foo, { Bar, Baz } from "some-module";
//     ~~~~~~~~~~~~~~~~~~~~~~
// error! A type-only import can specify a default import or named bindings, but not both.
</code></pre>
<p>In conjunction with <code>import type</code>, TypeScript 3.8 also adds a new compiler flag to control what happens with imports that won't be utilized at runtime: <code>importsNotUsedAsValues</code>.
This flag takes 3 different values:</p>
<ul>
<li><code>remove</code>: this is today's behavior of dropping these imports. It's going to continue to be the default, and is a non-breaking change.</li>
<li><code>preserve</code>: this <em>preserves</em> all imports whose values are never used. This can cause imports/side-effects to be preserved.</li>
<li><code>error</code>: this preserves all imports (the same as the <code>preserve</code> option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.</li>
</ul>
<p>For more information about the feature, you can <a href="https://github.com/microsoft/TypeScript/pull/35200">take a look at the pull request</a>, and <a href="https://github.com/microsoft/TypeScript/pull/36092/">relevant changes</a> around broadening where imports from an <code>import type</code> declaration can be used.</p>
<h2 id="ecmascript-私有变量ecmascript-private-fields"><a class="header" href="#ecmascript-私有变量ecmascript-private-fields"><span id="ecmascript-private-fields" /> ECMAScript 私有变量（ECMAScript Private Fields</a></h2>
<p>TypeScript 3.8 brings support for ECMAScript's private fields, part of the <a href="https://github.com/tc39/proposal-class-fields/">stage-3 class fields proposal</a>.</p>
<pre><code class="language-ts">class Person {
    #name: string

    constructor(name: string) {
        this.#name = name;
    }

    greet() {
        console.log(`Hello, my name is ${this.#name}!`);
    }
}

let jeremy = new Person("Jeremy Bearimy");

jeremy.#name
//     ~~~~~
// Property '#name' is not accessible outside class 'Person'
// because it has a private identifier.
</code></pre>
<p>Unlike regular properties (even ones declared with the <code>private</code> modifier), private fields have a few rules to keep in mind.
Some of them are:</p>
<ul>
<li>Private fields start with a <code>#</code> character. Sometimes we call these <em>private names</em>.</li>
<li>Every private field name is uniquely scoped to its containing class.</li>
<li>TypeScript accessibility modifiers like <code>public</code> or <code>private</code> can't be used on private fields.</li>
<li>Private fields can't be accessed or even detected outside of the containing class - even by JS users! Sometimes we call this <em>hard privacy</em>.</li>
</ul>
<p>Apart from "hard" privacy, another benefit of private fields is that uniqueness we just mentioned.
For example, regular property declarations are prone to being overwritten in subclasses.</p>
<pre><code class="language-ts">class C {
    foo = 10;

    cHelper() {
        return this.foo;
    }
}

class D extends C {
    foo = 20;

    dHelper() {
        return this.foo;
    }
}

let instance = new D();
// 'this.foo' refers to the same property on each instance.
console.log(instance.cHelper()); // prints '20'
console.log(instance.dHelper()); // prints '20'
</code></pre>
<p>With private fields, you'll never have to worry about this, since each field name is unique to the containing class.</p>
<pre><code class="language-ts">class C {
    #foo = 10;

    cHelper() {
        return this.#foo;
    }
}

class D extends C {
    #foo = 20;

    dHelper() {
        return this.#foo;
    }
}

let instance = new D();
// 'this.#foo' refers to a different field within each class.
console.log(instance.cHelper()); // prints '10'
console.log(instance.dHelper()); // prints '20'
</code></pre>
<p>Another thing worth noting is that accessing a private field on any other type will result in a <code>TypeError</code>!</p>
<pre><code class="language-ts">class Square {
    #sideLength: number;

    constructor(sideLength: number) {
        this.#sideLength = sideLength;
    }

    equals(other: any) {
        return this.#sideLength === other.#sideLength;
    }
}

const a = new Square(100);
const b = { sideLength: 100 };

// Boom!
// TypeError: attempted to get private field on non-instance
// This fails because 'b' is not an instance of 'Square'.
console.log(a.equals(b));
</code></pre>
<p>Finally, for any plain <code>.js</code> file users, private fields <em>always</em> have to be declared before they're assigned to.</p>
<pre><code class="language-js">class C {
    // No declaration for '#foo'
    // :(

    constructor(foo: number) {
        // SyntaxError!
        // '#foo' needs to be declared before writing to it.
        this.#foo = foo;
    }
}
</code></pre>
<p>JavaScript has always allowed users to access undeclared properties, whereas TypeScript has always required declarations for class properties.
With private fields, declarations are always needed regardless of whether we're working in <code>.js</code> or <code>.ts</code> files.</p>
<pre><code class="language-js">class C {
    /** @type {number} */
    #foo;

    constructor(foo: number) {
        // This works.
        this.#foo = foo;
    }
}
</code></pre>
<p>For more information about the implementation, you can <a href="https://github.com/Microsoft/TypeScript/pull/30829">check out the original pull request</a></p>
<h3 id="which-should-i-use"><a class="header" href="#which-should-i-use">Which should I use?</a></h3>
<p>We've already received many questions on which type of privates you should use as a TypeScript user: most commonly, "should I use the <code>private</code> keyword, or ECMAScript's hash/pound (<code>#</code>) private fields?"
It depends!</p>
<p>When it comes to properties, TypeScript's <code>private</code> modifiers are fully erased - that means that at runtime, it acts entirely like a normal property and there's no way to tell that it was declared with a <code>private modifier. When using the </code>private` keyword, privacy is only enforced at compile-time/design-time, and for JavaScript consumers it's entirely intent-based.</p>
<pre><code class="language-ts">class C {
    private foo = 10;
}

// This is an error at compile time,
// but when TypeScript outputs .js files,
// it'll run fine and print '10'.
console.log(new C().foo);    // prints '10'
//                  ~~~
// error! Property 'foo' is private and only accessible within class 'C'.

// TypeScript allows this at compile-time
// as a "work-around" to avoid the error.
console.log(new C()["foo"]); // prints '10'
</code></pre>
<p>The upside is that this sort of "soft privacy" can help your consumers temporarily work around not having access to some API, and also works in any runtime.</p>
<p>On the other hand, ECMAScript's <code>#</code> privates are completely inaccessible outside of the class.</p>
<pre><code class="language-ts">class C {
    #foo = 10;
}

console.log(new C().#foo); // SyntaxError
//                  ~~~~
// TypeScript reports an error *and*
// this won't work at runtime!

console.log(new C()["#foo"]); // prints undefined
//          ~~~~~~~~~~~~~~~
// TypeScript reports an error under 'noImplicitAny',
// and this prints 'undefined'.
</code></pre>
<p>This hard privacy is really useful for strictly ensuring that nobody can take use of any of your internals.
If you're a library author, removing or renaming a private field should never cause a breaking change.</p>
<p>As we mentioned, another benefit is that subclassing can be easier with ECMAScript's <code>#</code> privates because they <em>really</em> are private.
When using ECMAScript <code>#</code> private fields, no subclass ever has to worry about collisions in field naming.
When it comes to TypeScript's <code>private</code> property declarations, users still have to be careful not to trample over properties declared in superclasses.</p>
<p>One more thing to think about is where you intend for your code to run.
TypeScript currently can't support this feature unless targeting ECMAScript 2015 (ES6) targets or higher.
This is because our downleveled implementation uses <code>WeakMap</code>s to enforce privacy, and <code>WeakMap</code>s can't be polyfilled in a way that doesn't cause memory leaks.
In contrast, TypeScript's <code>private</code>-declared properties work with all targets - even ECMAScript 3!</p>
<p>A final consideration might be speed: <code>private</code> properties are no different from any other property, so accessing them is as fast as any other property access no matter which runtime you target.
In contrast, because <code>#</code> private fields are downleveled using <code>WeakMap</code>s, they may be slower to use.
While some runtimes might optimize their actual implementations of <code>#</code> private fields, and even have speedy <code>WeakMap</code> implementations, that might not be the case in all runtimes.</p>
<h2 id="export--as-ns-syntax"><a class="header" href="#export--as-ns-syntax"><span id="export-star-as-namespace-syntax" /> <code>export * as ns</code> Syntax</a></h2>
<p>It's often common to have a single entry-point that exposes all the members of another module as a single member.</p>
<pre><code class="language-ts">import * as utilities from "./utilities.js";
export { utilities };
</code></pre>
<p>This is so common that ECMAScript 2020 recently added a new syntax to support this pattern!</p>
<pre><code class="language-ts">export * as utilities from "./utilities.js";
</code></pre>
<p>This is a nice quality-of-life improvement to JavaScript, and TypeScript 3.8 implements this syntax.
When your module target is earlier than <code>es2020</code>, TypeScript will output something along the lines of the first code snippet.</p>
<h2 id="顶层awaittop-level-await"><a class="header" href="#顶层awaittop-level-await"><span id="top-level-await" /> 顶层await（Top-Level await）</a></h2>
<p>TypeScript 3.8 provides support for a handy upcoming ECMAScript feature called "top-level <code>await</code>".</p>
<p>JavaScript users often introduce an <code>async</code> function in order to use <code>await</code>, and then immediately called the function after defining it.</p>
<pre><code class="language-js">async function main() {
    const response = await fetch("...");
    const greeting = await response.text();
    console.log(greeting);
}

main()
    .catch(e =&gt; console.error(e))
</code></pre>
<p>This is because previously in JavaScript (along with most other languages with a similar feature), <code>await</code> was only allowed within the body of an <code>async</code> function.
However, with top-level <code>await</code>, we can use <code>await</code> at the top level of a module.</p>
<pre><code class="language-ts">const response = await fetch("...");
const greeting = await response.text();
console.log(greeting);

// Make sure we're a module
export {};
</code></pre>
<p>Note there's a subtlety: top-level <code>await</code> only works at the top level of a <em>module</em>, and files are only considered modules when TypeScript finds an <code>import</code> or an <code>export</code>.
In some basic cases, you might need to write out <code>export {}</code> as some boilerplate to make sure of this.</p>
<p>Top level <code>await</code> may not work in all environments where you might expect at this point.
Currently, you can only use top level <code>await</code> when the <code>target</code> compiler option is <code>es2017</code> or above, and <code>module</code> is <code>esnext</code> or <code>system</code>.
Support within several environments and bundlers may be limited or may require enabling experimental support.</p>
<p>For more information on our implementation, you can <a href="https://github.com/microsoft/TypeScript/pull/35813">check out the original pull request</a>.</p>
<h2 id="es2020-for-target-and-module"><a class="header" href="#es2020-for-target-and-module"><span id="es2020-for-target-and-module" /> <code>es2020</code> for <code>target</code> and <code>module</code></a></h2>
<p>TypeScript 3.8 supports <code>es2020</code> as an option for <code>module</code> and <code>target</code>.
This will preserve newer ECMAScript 2020 features like optional chaining, nullish coalescing, <code>export * as ns</code>, and dynamic <code>import(...)</code> syntax.
It also means <code>bigint</code> literals now have a stable <code>target</code> below <code>esnext</code>.</p>
<h2 id="jsdoc-属性修饰词jsdoc-property-modifiers"><a class="header" href="#jsdoc-属性修饰词jsdoc-property-modifiers"><span id="jsdoc-modifiers" /> JSDoc 属性修饰词(JSDoc Property Modifiers)</a></h2>
<p>TypeScript 3.8 supports JavaScript files by turning on the <code>allowJs</code> flag, and also supports <em>type-checking</em> those JavaScript files via the <code>checkJs</code> option or by adding a <code>// @ts-check</code> comment to the top of your <code>.js</code> files.</p>
<p>Because JavaScript files don't have dedicated syntax for type-checking, TypeScript leverages JSDoc.
TypeScript 3.8 understands a few new JSDoc tags for properties.</p>
<p>First are the accessibility modifiers: <code>@public</code>, <code>@private</code>, and <code>@protected</code>.
These tags work exactly like <code>public</code>, <code>private</code>, and <code>protected</code> respectively work in TypeScript.</p>
<pre><code class="language-js">// @ts-check

class Foo {
    constructor() {
        /** @private */
        this.stuff = 100;
    }

    printStuff() {
        console.log(this.stuff);
    }
}

new Foo().stuff;
//        ~~~~~
// error! Property 'stuff' is private and only accessible within class 'Foo'.
</code></pre>
<ul>
<li><code>@public</code> 是默认的，可以省略，它代表了一个属性可以从任何地方访问它</li>
<li><code>@private</code> 表示一个属性只能在包含的类中访问</li>
<li><code>@protected</code> 表示该属性只能在所包含的类及子类中访问，但不能在类的实例中访问</li>
</ul>
<p>下一步，我们计划添加 <code>@readonly</code> 修饰符，来确保一个属性只能在初始化时被修改：</p>
<pre><code class="language-js">// @ts-check

class Foo {
    constructor() {
        /** @readonly */
        this.stuff = 100;
    }

    writeToStuff() {
        this.stuff = 200;
        //   ~~~~~
        // Cannot assign to 'stuff' because it is a read-only property.
    }
}

new Foo().stuff++;
//        ~~~~~
// Cannot assign to 'stuff' because it is a read-only property.
</code></pre>
<h2 id="better-directory-watching-on-linux-and-watchoptions"><a class="header" href="#better-directory-watching-on-linux-and-watchoptions"><span id="better-directory-watching" /> Better Directory Watching on Linux and <code>watchOptions</code></a></h2>
<p>TypeScript 3.8 ships a new strategy for watching directories, which is crucial for efficiently picking up changes to <code>node_modules</code>.</p>
<p>For some context, on operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on <code>node_modules</code> and many of its subdirectories to detect changes in dependencies.
This is because the number of available file watchers is often eclipsed by the of files in <code>node_modules</code>, whereas there are way fewer directories to track.</p>
<p>Older versions of TypeScript would <em>immediately</em> install directory watchers on folders, and at startup that would be fine; however, during an npm install, a lot of activity will take place within <code>node_modules</code> and that can overwhelm TypeScript, often slowing editor sessions to a crawl.
To prevent this, TypeScript 3.8 waits slightly before installing directory watchers to give these highly volatile directories some time to stabilize.</p>
<p>Because every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new <code>watchOptions</code> field in <code>tsconfig.json</code> and <code>jsconfig.json</code> which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.</p>
<pre><code class="language-json5">{
    // Some typical compiler options
    "compilerOptions": {
        "target": "es2020",
        "moduleResolution": "node",
        // ...
    },

    // NEW: Options for file/directory watching
    "watchOptions": {
        // Use native file system events for files and directories
        "watchFile": "useFsEvents",
        "watchDirectory": "useFsEvents",

        // Poll files for updates more frequently
        // when they're updated a lot.
        "fallbackPolling": "dynamicPriority"
    }
}
</code></pre>
<p><code>watchOptions</code> 包含四种新的选项:</p>
<ul>
<li><code>watchFile</code>: 监听单个文件的策略，它可以有以下值
<ul>
<li><code>fixedPollingInterval</code>: 以固定的时间间隔，检查文件的更改</li>
<li><code>priorityPollingInterval</code>: 以固定的时间间隔，检查文件的更改，但是使用「heuristics」检查某些类型的文件的频率比其他文件低（heuristics 怎么翻？）</li>
<li><code>dynamicPriorityPolling</code>: 使用动态队列，在该队列中，较少检查不经常修改的文件</li>
<li><code>useFsEvents</code> （默认）: 尝试使用操作系统/文件系统原生事件来监听文件更改</li>
<li><code>useFsEventsOnParentDirectory</code>: 尝试使用操作系统/文件系统原生事件来监听文件、目录的更改，这样可以使用较小的文件监听程序，但是准确性可能较低</li>
</ul>
</li>
<li><code>watchDirectory</code>: 在缺少递归文件监听功能的系统中，使用哪种策略监听整个目录树，它可以有以下值 :
<ul>
<li><code>fixedPollingInterval</code>: 以固定的时间间隔，检查目录树的更改</li>
<li><code>dynamicPriorityPolling</code>: 使用动态队列，在该队列中，较少检查不经常修改的目录</li>
<li><code>useFsEvents</code> （默认）: 尝试使用操作系统/文件系统原生事件来监听目录更改</li>
</ul>
</li>
<li><code>fallbackPolling</code>: 当使用文件系统的事件，该选项用来指定使用特定策略，它可以有以下值
<ul>
<li><code>fixedPollingInterval</code>: <em>(同上)</em></li>
<li><code>priorityPollingInterval</code>: <em>(同上)</em></li>
<li><code>dynamicPriorityPolling</code>: <em>(同上)</em></li>
</ul>
</li>
<li><code>synchronousWatchDirectory</code>: 在目录上禁用延迟监听功能。在可能一次发生大量文件（如 <code>node_modules</code>）更改时，它非常有用，但是你可能需要一些不太常见的设置时，禁用它。</li>
</ul>
<p>For more information on these changes, <a href="https://github.com/microsoft/TypeScript/pull/35615">head over to GitHub to see the pull request</a> to read more.</p>
<h2 id="fast-and-loose-incremental-checking"><a class="header" href="#fast-and-loose-incremental-checking"><span id="assume-direct-dependencies" /> "Fast and Loose" Incremental Checking</a></h2>
<p>TypeScript 3.8 introduces a new compiler option called <code>assumeChangesOnlyAffectDirectDependencies</code>.
When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.</p>
<p>For example, consider a file <code>fileD.ts</code> that imports <code>fileC.ts</code> that imports <code>fileB.ts</code> that imports <code>fileA.ts</code> as follows:</p>
<pre><code>fileA.ts &lt;- fileB.ts &lt;- fileC.ts &lt;- fileD.ts
</code></pre>
<p>In <code>--watch</code> mode, a change in <code>fileA.ts</code> would typically mean that TypeScript would need to at least re-check <code>fileB.ts</code>, <code>fileC.ts</code>, and <code>fileD.ts</code>.
Under <code>assumeChangesOnlyAffectDirectDependencies</code>, a change in <code>fileA.ts</code> means that only <code>fileA.ts</code> and <code>fileB.ts</code> need to be re-checked.</p>
<p>In a codebase like Visual Studio Code, this reduced rebuild times for changes in certain files from about 14 seconds to about 1 second.
While we don't necessarily recommend this option for all codebases, you might be interested if you have an extremely large codebase and are willing to defer full project errors until later (e.g. a dedicated build via a <code>tsconfig.fullbuild.json</code> or in CI).</p>
<p>For more details, you can <a href="https://github.com/microsoft/TypeScript/pull/35711">see the original pull request</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-37"><a class="header" href="#typescript-37">TypeScript 3.7</a></h1>
<h2 id="可选链optional-chaining"><a class="header" href="#可选链optional-chaining">可选链（Optional Chaining）</a></h2>
<p><a href="http://www.typescriptlang.org/play/#example/optional-chaining">Playground</a></p>
<p>在我们的 issue 列表上，可选链是 <a href="https://github.com/microsoft/TypeScript/issues/16">issue #16</a>。感受一下，从那之后 TypeScript 的 issue 列表中新增了 23,000 条 issues。</p>
<p>可选链的核心是，在我们编写代码中，当遇到 <code>null</code> 或 <code>undefined</code>，TypeScript 可以立即停止解析一部分表达式。
可选链的关键点是一个为 <em>可选属性访问</em> 提供的新的运算符 <code>?.</code>。
比如我们可以这样写代码：</p>
<pre><code class="language-ts">let x = foo?.bar.baz();
</code></pre>
<p>意思是，当 <code>foo</code> 有定义时，执行 <code>foo.bar.baz()</code> 的计算；但是当 <code>foo</code> 是 <code>null</code> 或 <code>undefined</code> 时，停止后续的解析，直接返回 <code>undefined</code>。</p>
<p>更明确地说，上面的代码和下面的代码等价。</p>
<pre><code class="language-ts">let x = (foo === null || foo === undefined) ?
    undefined :
    foo.bar.baz();
</code></pre>
<p>注意，当 <code>bar</code> 是 <code>null</code> 或 <code>undefined</code>，我们的代码访问 <code>baz</code> 依然会报错。
同理，当 <code>baz</code> 是 <code>null</code> 或 <code>undefined</code>，在调用时也会报错。
<code>?.</code> 只检查它 <em>左边</em> 的值是不是 <code>null</code> 或 <code>undefined</code>，不检查后续的属性。</p>
<p>你会发现自己可以使用 <code>?.</code> 来替换用了 <code>&amp;&amp;</code> 的大量空值检查代码。</p>
<pre><code class="language-ts">// 以前
if (foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz) {
    // ...
}

// 以后
if (foo?.bar?.baz) {
    // ...
}
</code></pre>
<p>注意，<code>?.</code> 与 <code>&amp;&amp;</code> 的行为略有不同，因为 <code>&amp;&amp;</code> 会作用在所有“假”值上（例如，空字符串、<code>0</code>、<code>NaN</code> 以及 <code>false</code>），但 <code>?.</code> 是一个仅作用于结构上的特性。
它不会在有效数据（比如 <code>0</code> 或空字符串）上进行短路计算。</p>
<p>可选链还包括两个另外的用法。
首先是 <em>可选元素访问</em>，表现类似于可选属性访问，但是也允许我们访问非标识符属性（例如：任意字符串、数字和 symbol）：</p>
<pre><code class="language-ts">/**
 * 如果 arr 是一个数组，返回第一个元素
 * 否则返回 undefined
 */
function tryGetFirstElement&lt;T&gt;(arr?: T[]) {
    return arr?.[0];
    // 等价于：
    //   return (arr === null || arr === undefined) ?
    //       undefined :
    //       arr[0];
}
</code></pre>
<p>另一个是 <em>可选调用</em>，判断条件是当该表达式不是 <code>null</code> 或 <code>undefined</code>，我们就可以调用它。</p>
<pre><code class="language-ts">async function makeRequest(url: string, log?: (msg: string) =&gt; void) {
    log?.(`Request started at ${new Date().toISOString()}`);
    // 基本等价于：
    //   if (log != null) {
    //       log(`Request started at ${new Date().toISOString()}`);
    //   }

    const result = (await fetch(url)).json();

    log?.(`Request finished at at ${new Date().toISOString()}`);

    return result;
}
</code></pre>
<p>可选链的“短路计算”行为仅限于属性访问、调用、元素访问——它不会延伸到后续的表达式中。
也就是说，</p>
<pre><code class="language-ts">let result = foo?.bar / someComputation()
</code></pre>
<p>可选链不会阻止除法运算或 <code>someComputation()</code> 的进行。
上面这段代码实际上等价于：</p>
<pre><code class="language-ts">let temp = (foo === null || foo === undefined) ?
    undefined :
    foo.bar;

let result = temp / someComputation();
</code></pre>
<p>当然，这可能会使得 <code>undefined</code> 参与了除法运算，导致在 <code>strictNullChecks</code> 编译选项下产生报错。</p>
<pre><code class="language-ts">function barPercentage(foo?: { bar: number }) {
    return foo?.bar / 100;
    //     ~~~~~~~~
    // Error: Object is possibly undefined.
}
</code></pre>
<p>想了解更多细节，你可以 <a href="https://github.com/tc39/proposal-optional-chaining/">检阅完整的草案</a> 以及 <a href="https://github.com/microsoft/TypeScript/pull/33294">查看原始的 PR</a>。</p>
<h2 id="空值合并nullish-coalescing"><a class="header" href="#空值合并nullish-coalescing">空值合并（Nullish Coalescing）</a></h2>
<p><a href="http://www.typescriptlang.org/play/#example/nullish-coalescing">Playground</a></p>
<p><em>空值合并运算符</em> 是另一个即将到来的 ECMAScript 特性（与可选链一起），我们的团队也参与了 TC39 的的讨论工作。</p>
<p>你可以考虑使用 <code>??</code> 运算符来实现：当字段是 <code>null</code> 或 <code>undefined</code> 时，“回退”到默认值。
比如我们可以这样写代码：</p>
<pre><code class="language-ts">let x = foo ?? bar();
</code></pre>
<p>这种新方式的意思是，当 <code>foo</code> “存在”时 x 等于 foo；
但假如 <code>foo</code> 是 <code>null</code> 或 <code>undefined</code> ，x 等于 <code>bar()</code> 的计算结果。</p>
<p>同样的，上面的代码可以写出等价代码。</p>
<pre><code class="language-ts">let x = (foo !== null &amp;&amp; foo !== undefined) ?
    foo :
    bar();
</code></pre>
<p>当尝试使用默认值时，<code>??</code> 运算符可以代替 <code>||</code> 的作用。
例如，下面的代码片段尝试获取上一次储存在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage"><code>localStorage</code></a> 中的 volume（如果它已保存）;
但是因为使用了 <code>||</code> ，留下一个 bug。</p>
<pre><code class="language-ts">function initializeAudio() {
    let volume = localStorage.volume || 0.5

    // ...
}
</code></pre>
<p>如果 <code>localStorage.volume</code> 的值是 <code>0</code>，这段代码将会把 volume 的值设置为 <code>0.5</code>，这是一个意外情况。
而 <code>??</code> 避免了将 <code>0</code>、<code>NaN</code> 和 <code>""</code> 视为假值的意外情况。</p>
<p>我们非常感谢社区成员 <a href="https://github.com/Kingwl">Wenlu Wang</a> 和 <a href="https://github.com/dragomirtitian">Titian Cernicova Dragomir</a> 实现了这个特性！
想了解更多细节，你可以 <a href="https://github.com/microsoft/TypeScript/pull/32883">查看他们的 PR</a> 和 <a href="https://github.com/tc39/proposal-nullish-coalescing/">空值合并草案的 Repo</a>。</p>
<h2 id="断言函数"><a class="header" href="#断言函数">断言函数</a></h2>
<p><a href="http://www.typescriptlang.org/play/#example/assertion-functions">Playground</a></p>
<p>有一类特定的函数，用于在出现非预期结果时抛出一个错误。
这样的函数叫做“断言”函数（Assertion Function）。
比方说，Node.js 中就有一个名为 <code>assert</code> 的断言函数。</p>
<pre><code class="language-js">assert(someValue === 42);
</code></pre>
<p>在上面的例子中，如果 <code>someValue</code> 不等于 42，那么 <code>assert</code> 就会抛出一个 <code>AssertionError</code> 错误。</p>
<p>在 JavaScript 中，断言经常被用于防止不正确传参。
举个例子：</p>
<pre><code class="language-js">function multiply(x, y) {
    assert(typeof x === "number");
    assert(typeof y === "number");

    return x * y;
}
</code></pre>
<p>很遗憾，在 TypeScript 中，这些检查没办法正确编码。
对于类型宽松的代码，意味着 TypeScript 检查得更少，而对于更加规范的代码，通常迫使使用者添加类型断言。</p>
<pre><code class="language-ts">function yell(str) {
    assert(typeof str === "string");

    return str.toUppercase();
    // 糟了！我们拼错了 'toUpperCase'。
    // 如果 TypeScript 依然能检查出来就太棒了！
}
</code></pre>
<p>有一个替代的写法，可以让 TypeScript 能够分析出问题，不过这样并不方便。</p>
<pre><code class="language-ts">function yell(str) {
    if (typeof str !== "string") {
        throw new TypeError("str should have been a string.")
    }
    // 发现错误！
    return str.toUppercase();
}
</code></pre>
<p>归根结底，TypeScript 的目标是以最小的改动为现存的 JavaScript 结构添加上类型声明。
因此，TypeScript 3.7 引入了一个称为“断言签名”的新概念，用于模拟这些断言函数。</p>
<p>第一种断言签名模拟了 Node 中 <code>assert</code> 函数的功能。
它确保在断言的范围内，无论什么判断条件都为必须真。</p>
<pre><code class="language-ts">function assert(condition: any, msg?: string): asserts condition {
    if (!condition) {
        throw new AssertionError(msg)
    }
}
</code></pre>
<p><code>asserts condition</code> 表示：如果 <code>assert</code> 函数成功返回，则传入的 <code>condition</code> 参数必须为真（否则它应该抛出一个 Error）。
这意味着对于同作用域中的后续代码，条件必须为真。
回到例子上，用这个断言函数意味着我们 <em>能够</em> 捕获之前 <code>yell</code> 示例中的错误。</p>
<pre><code class="language-ts">function yell(str) {
    assert(typeof str === "string");

    return str.toUppercase();
    //         ~~~~~~~~~~~
    // error: Property 'toUppercase' does not exist on type 'string'.
    //        Did you mean 'toUpperCase'?
}

function assert(condition: any, msg?: string): asserts condition {
    if (!condition) {
        throw new AssertionError(msg)
    }
}
</code></pre>
<p>另一种类型的断言签名不通过检查条件语句实现，而是在 TypeScript 里显式指定某个变量或属性具有不同的类型。</p>
<pre><code class="language-ts">function assertIsString(val: any): asserts val is string {
    if (typeof val !== "string") {
        throw new AssertionError("Not a string!");
    }
}
</code></pre>
<p>这里的 <code>asserts val is string</code> 保证了在 <code>assertIsString</code> 调用之后，传入的任何变量都有可以被视为是 <code>string</code> 类型的。</p>
<pre><code class="language-ts">function yell(str: any) {
    assertIsString(str);

    // 现在 TypeScript 知道 'str' 是一个 'string'。

    return str.toUppercase();
    //         ~~~~~~~~~~~
    // error: Property 'toUppercase' does not exist on type 'string'.
    //        Did you mean 'toUpperCase'?
}
</code></pre>
<p>这些断言方法签名类似于类型谓词（type predicate）签名：</p>
<pre><code class="language-ts">function isString(val: any): val is string {
    return typeof val === "string";
}

function yell(str: any) {
    if (isString(str)) {
        return str.toUppercase();
    }
    throw "Oops!";
}
</code></pre>
<p>就像类型谓词签名一样，这些断言签名具有清晰的表现力。
我们可以用它们表达一些非常复杂的想法。</p>
<pre><code class="language-ts">function assertIsDefined&lt;T&gt;(val: T): asserts val is NonNullable&lt;T&gt; {
    if (val === undefined || val === null) {
        throw new AssertionError(
            `Expected 'val' to be defined, but received ${val}`
        );
    }
}
</code></pre>
<p>想了解更多断言签名的细节，可以 <a href="https://github.com/microsoft/TypeScript/pull/32695">查看原始的 PR</a>。</p>
<h2 id="更好地支持返回-never-的函数"><a class="header" href="#更好地支持返回-never-的函数">更好地支持返回 <code>never</code> 的函数</a></h2>
<p>作为断言签名实现的一部分，TypeScript 需要编码更多关于调用位置和调用函数的细节。
这给了我们机会扩展对另一类函数的支持——返回 <code>never</code> 的函数。</p>
<p>返回 <code>never</code> 的函数，即永远不会返回的函数。
它表明抛出了异常、触发了停止错误条件、或程序退出的情况。
例如，<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874"><code>@types/node</code> 中的 <code>process.exit(...)</code></a> 就被指定为返回 <code>never</code>。</p>
<p>为了确保函数永远不会潜在地返回 <code>undefined</code>、或者从所有代码路径中有效地返回，TypeScript 需要借助一些语法标志——函数结尾处的 <code>return</code> 或 <code>throw</code>。
这样，使用者就会发现自己的代码在“返回”一个停机函数。</p>
<pre><code class="language-ts">function dispatch(x: string | number): SomeType {
    if (typeof x === "string") {
        return doThingWithString(x);
    }
    else if (typeof x === "number") {
        return doThingWithNumber(x);
    }
    return process.exit(1);
}
</code></pre>
<p>现在，这些返回 <code>never</code> 的函数被调用时，TypeScript 能识别出它们将影响代码执行流程，同时说明原因。</p>
<pre><code class="language-ts">function dispatch(x: string | number): SomeType {
    if (typeof x === "string") {
        return doThingWithString(x);
    }
    else if (typeof x === "number") {
        return doThingWithNumber(x);
    }
    process.exit(1);
}
</code></pre>
<p>你可以和在断言函数的 <a href="https://github.com/microsoft/TypeScript/pull/32695">同一个 PR 中查看更多细节</a>。</p>
<h2 id="更加递归的类型别名"><a class="header" href="#更加递归的类型别名">（更加）递归的类型别名</a></h2>
<p><a href="http://www.typescriptlang.org/play/#example/recursive-type-references">Playground</a></p>
<p>类型别名在“递归”引用方面一直存在局限性。
原因是，类型别名必须能用它代表的东西来代替自己。
这在某些情况下是不可能的，因此编译器会拒绝某些递归别名，比如下面这个：</p>
<pre><code class="language-ts">type Foo = Foo;
</code></pre>
<p>这是一个合理的限制，因为任何对 <code>Foo</code> 的使用都可以替换为 <code>Foo</code>，同时这个 <code>Foo</code> 能够替换为 <code>Foo</code>，而这个 <code>Foo</code> 应该……（产生了无限循环）希望你理解到这个意思了！
到最后，没有类型可以用来代替 <code>Foo</code>。</p>
<p><a href="https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;oldid=913091335#in_type_synonyms">其他语言也是这么处理类型别名的</a>，但是它确实会产生一些令人困惑的情形，影响类型别名的使用。
例如，在 TypeScript 3.6 和更低的版本中，下面的代码会报错：</p>
<pre><code class="language-ts">type ValueOrArray&lt;T&gt; = T | Array&lt;ValueOrArray&lt;T&gt;&gt;;
//   ~~~~~~~~~~~~
// error: Type alias 'ValueOrArray' circularly references itself.
</code></pre>
<p>这很令人困惑，因为使用者总是可以用接口来编写具有相同作用的代码，那么从技术上讲这没什么问题。</p>
<pre><code class="language-ts">type ValueOrArray&lt;T&gt; = T | ArrayOfValueOrArray&lt;T&gt;;

interface ArrayOfValueOrArray&lt;T&gt; extends Array&lt;ValueOrArray&lt;T&gt;&gt; {}
</code></pre>
<p>因为接口（以及其他对象 type）引入了一个间接的层级，并且它们的完整结构不需要立即建立，所以 TypeScript 可以处理这种结构。</p>
<p>但是，对于使用者而言，引入接口的方案并不直观。
并且，用了 <code>Array</code> 的初始版 <code>ValueOrArray</code> 没什么原则性问题。
如果编译器多一点“惰性”，并且只按需计算 <code>Array</code> 的类型参数，那么 TypeScript 就可以正确地表示出这些了。</p>
<p>这正是 TypeScript 3.7 引入的。
在类型别名的“顶层”，TypeScript 将推迟解析类型参数以便支持这些模式。</p>
<p>这意味着，用于表示 JSON 的以下代码……</p>
<pre><code class="language-ts">type Json =
    | string
    | number
    | boolean
    | null
    | JsonObject
    | JsonArray;

interface JsonObject {
    [property: string]: Json;
}

interface JsonArray extends Array&lt;Json&gt; {}
</code></pre>
<p>终于可以重写成不需要借助 interface 的形式。</p>
<pre><code class="language-ts">type Json =
    | string
    | number
    | boolean
    | null
    | { [property: string]: Json }
    | Json[];
</code></pre>
<p>这个新的机制让我们在元组中，同样也可以递归地使用类型别名。
下面的 TypeScript 代码在以前会报错，但现在是合法的：</p>
<pre><code class="language-ts">type VirtualNode =
    | string
    | [string, { [key: string]: any }, ...VirtualNode[]];

const myNode: VirtualNode =
    ["div", { id: "parent" },
        ["div", { id: "first-child" }, "I'm the first child"],
        ["div", { id: "second-child" }, "I'm the second child"]
    ];
</code></pre>
<p>想了解更多细节，你可以 <a href="https://github.com/microsoft/TypeScript/pull/33050">查看原始的 PR</a>。</p>
<h2 id="--declaration-和---allowjs"><a class="header" href="#--declaration-和---allowjs"><code>--declaration</code> 和 <code>--allowJs</code></a></h2>
<p><code>--declaration</code> 选项允许我们从 TypeScript 源文件（诸如 <code>.ts</code> 和 <code>.tsx</code> 文件）生成 <code>.d.ts</code> 文件（声明文件）。
<code>.d.ts</code> 文件的重要性有几个方面：</p>
<p>首先，它们使得 TypeScript 能够对外部项目进行类型检查，同时避免重复检查其源代码。
另一方面，它们使得 TypeScript 能够与现存的 JavaScript 库相互配合，即使这些库构建时并未使用 TypeScript。
最后，还有一个通常被忽略的好处：在使用支持 TypeScript 的编辑器时，TypeScript <em>和</em> JavaScript 使用者都可以从这些文件中受益，例如更高级的自动完成。</p>
<p>不幸的是，<code>--declaration</code> 不能与 <code>--allowJs</code> 选项一起使用，<code>--allowJs</code> 选项允许混合使用 TypeScript 和 JavaScript 文件。
这是一个令人沮丧的限制，因为它意味着使用者在迁移代码库时无法使用 <code>--declaration</code> 选项，即使代码包含了 JSDoc 注释。
TypeScript 3.7 对此进行了改进，允许这两个选项一起使用！</p>
<p>这个功能最大的影响可能比较微妙：在 TypeScript 3.7 中，编写带有 JSDoc 注释的 JavaScript 库，也能帮助 TypeScript 的使用者。</p>
<p>它的实现原理是，在启用 <code>allowJs</code> 时，TypeScript 会尽可能地分析并理解常见的 JavaScript 模式；然而，用 JavaScript 表达的某些模式看起来不一定像它们在 TypeScript 中的等效形式。
启用 <code>declaration</code> 选项后，TypeScript 会尽力识别 JSDoc 注释和 CommonJS 形式的模块输出，并转换为有效的类型声明输出到 <code>.d.ts</code> 文件上。</p>
<p>比如下面这个代码片段</p>
<pre><code class="language-js">const assert = require("assert")

module.exports.blurImage = blurImage;

/**
 * Produces a blurred image from an input buffer.
 * 
 * @param input {Uint8Array}
 * @param width {number}
 * @param height {number}
 */
function blurImage(input, width, height) {
    const numPixels = width * height * 4;
    assert(input.length === numPixels);
    const result = new Uint8Array(numPixels);

    // TODO

    return result;
}
</code></pre>
<p>将会生成如下 <code>.d.ts</code> 文件</p>
<pre><code class="language-ts">/**
 * Produces a blurred image from an input buffer.
 *
 * @param input {Uint8Array}
 * @param width {number}
 * @param height {number}
 */
export function blurImage(input: Uint8Array, width: number, height: number): Uint8Array;
</code></pre>
<p>除了基本的带有 <code>@param</code> 标记的函数，也支持其他情形, 请看下面这个例子：</p>
<pre><code class="language-js">/**
 * @callback Job
 * @returns {void}
 */

/** Queues work */
export class Worker {
    constructor(maxDepth = 10) {
        this.started = false;
        this.depthLimit = maxDepth;
        /**
         * NOTE: queued jobs may add more items to queue
         * @type {Job[]}
         */
        this.queue = [];
    }
    /**
     * Adds a work item to the queue
     * @param {Job} work 
     */
    push(work) {
        if (this.queue.length + 1 &gt; this.depthLimit) throw new Error("Queue full!");
        this.queue.push(work);
    }
    /**
     * Starts the queue if it has not yet started
     */
    start() {
        if (this.started) return false;
        this.started = true;
        while (this.queue.length) {
            /** @type {Job} */(this.queue.shift())();
        }
        return true;
    }
}
</code></pre>
<p>会生成如下 <code>.d.ts</code> 文件：</p>
<pre><code class="language-ts">/**
 * @callback Job
 * @returns {void}
 */
/** Queues work */
export class Worker {
    constructor(maxDepth?: number);
    started: boolean;
    depthLimit: number;
    /**
     * NOTE: queued jobs may add more items to queue
     * @type {Job[]}
     */
    queue: Job[];
    /**
     * Adds a work item to the queue
     * @param {Job} work
     */
    push(work: Job): void;
    /**
     * Starts the queue if it has not yet started
     */
    start(): boolean;
}
export type Job = () =&gt; void;
</code></pre>
<p>注意，当同时启用这两个选项时，TypeScript 不一定必须得编译成 <code>.js</code> 文件。
如果只是简单的想让 TypeScript 创建 <code>.d.ts</code> 文件，你可以启用 <code>--emitDeclarationOnly</code> 编译选项。</p>
<p>想了解更多细节，你可以 <a href="https://github.com/microsoft/TypeScript/pull/32372">查看原始的 PR</a>。</p>
<h2 id="usedefineforclassfields-编译选项和-declare-属性修饰符"><a class="header" href="#usedefineforclassfields-编译选项和-declare-属性修饰符"><code>useDefineForClassFields</code> 编译选项和 <code>declare</code> 属性修饰符</a></h2>
<p>当在 TypeScript 中写类公共字段时，我们尽力保证以下代码</p>
<pre><code class="language-ts">class C {
    foo = 100;
    bar: string;
}
</code></pre>
<p>等价于构造函数中的相似语句</p>
<pre><code class="language-ts">class C {
    constructor() {
        this.foo = 100;
    }
}
</code></pre>
<p>不幸的是，虽然这符合该提案早期的发展方向，但类公共字段极有可能以不同的方式进行标准化。
所以取而代之的，原始代码示例可能需要进行脱糖处理，变成类似下面的代码：</p>
<pre><code class="language-ts">class C {
    constructor() {
        Object.defineProperty(this, "foo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 100
        });
        Object.defineProperty(this, "bar", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
</code></pre>
<p>当然，TypeScript 3.7 在默认情况下的编译结果与之前版本没有变化，我们增量地发布改动，以便帮助使用者减少未来潜在的破坏性变更。
我们提供了一个新的编译选项 <code>useDefineForClassFields</code>，根据一些新的检查逻辑使用上面这种编译模式。</p>
<p>最大的两个改变如下：</p>
<ul>
<li>声明通过 <code>Object.defineProperty</code> 完成。</li>
<li>声明 <em>总是</em> 被初始化为 <code>undefined</code>，即使原有代码中没有显式的初始值。</li>
</ul>
<p>对于现存的含有继承的代码，这可能会造成一些问题。首先，基类的 <code>set</code> 访问器不再被触发——它们将被完全覆写。</p>
<pre><code class="language-ts">class Base {
    set data(value: string) {
        console.log("data changed to " + value);
    }
}

class Derived extends Base {
    // 当启用 'useDefineForClassFields' 时
    // 不再触发 'console.log'
    data = 10;
}
</code></pre>
<p>其次，基类中的属性设定也将不起作用。</p>
<pre><code class="language-ts">interface Animal { animalStuff: any }
interface Dog extends Animal { dogStuff: any }

class AnimalHouse {
    resident: Animal;
    constructor(animal: Animal) {
        this.resident = animal;
    }
}

class DogHouse extends AnimalHouse {
    // 当启用 'useDefineForClassFields' 时
    // 调用 'super()' 后
    // 'resident' 只会被初始化成 'undefined'！
    resident: Dog;

    constructor(dog: Dog) {
        super(dog);
    }
}
</code></pre>
<p>这两个问题归结为，继承时混合覆写属性与访问器，以及属性不带初始值的重新声明。</p>
<p>为了检测这个访问器的问题，TypeScript 3.7 现在可以在 <code>.d.ts</code> 文件中编译出 <code>get</code>/<code>set</code>，这样 TypeScript 就能检查出访问器覆写的情况。</p>
<p>对于改变类字段的代码，将字段初始化写成构造函数内的语句，就可以解决此问题。</p>
<pre><code class="language-ts">class Base {
    set data(value: string) {
        console.log("data changed to " + value);
    }
}

class Derived extends Base {
    constructor() {
        data = 10;
    }
}
</code></pre>
<p>而解决第二个问题，你可以显式地提供一个初始值，或添加一个<code>declare</code> 修饰符来表示这个属性不要被编译。</p>
<pre><code class="language-ts">interface Animal { animalStuff: any }
interface Dog extends Animal { dogStuff: any }

class AnimalHouse {
    resident: Animal;
    constructor(animal: Animal) {
        this.resident = animal;
    }
}

class DogHouse extends AnimalHouse {
    declare resident: Dog;
//  ^^^^^^^
// 'resident' now has a 'declare' modifier,
// and won't produce any output code.

    constructor(dog: Dog) {
        super(dog);
    }
}
</code></pre>
<p>目前，只有当编译目标是 ES5 及以上时 <code>useDefineForClassFields</code> 才可用，因为 ES3 中不支持 <code>Object.defineProperty</code>。
要检查类似的问题，你可以创建一个分离的项目，设定编译目标为 ES5 并使用 <code>--noEmit</code> 来避免完全构建。</p>
<p>想了解更多细节，你可以 <a href="https://github.com/microsoft/TypeScript/pull/33509">去原始的 PR 查看这些改动</a>。</p>
<p>我们强烈建议使用者尝试 <code>useDefineForClassFields</code>，并在 issues 或下面的评论区域中提供反馈。
应该碰到编译选项在使用难度上的反馈，这样我们就能够了解如何使迁移变得更容易。</p>
<h2 id="利用项目引用实现无构建编辑"><a class="header" href="#利用项目引用实现无构建编辑">利用项目引用实现无构建编辑</a></h2>
<p>TypeScript 的项目引用功能，为我们提供了一种简单的方法来分解代码库，从而使编译速度更快。
遗憾的是，当我们编辑一个依赖未曾构建（或者构建结果过时）的项目时，体验不好。</p>
<p>在 TypeScript 3.7 中，当打开一个带有依赖的项目时，TypeScript 将自动切换为使用依赖中的 <code>.ts</code>/<code>.tsx</code> 源码文件。
这意味着在带有外部引用的项目中，代码的修改会即时同步和生效，编码体验会得到提升。
你也可以适当地打开编译器选项 <code>disableSourceOfProjectReferenceRedirect</code> 来禁用这个引用的功能，因为在超大型项目中这个功能可能会影响性能。</p>
<p>你可以 <a href="https://github.com/microsoft/TypeScript/pull/32028">阅读这个 PR 来了解这个改动的更多细节</a>。</p>
<h2 id="检查未调用的函数"><a class="header" href="#检查未调用的函数">检查未调用的函数</a></h2>
<p>一个常见且危险的错误是：忘记调用一个函数，特别是当该函数不需要参数，或者它的命名容易被误认为是一个属性而不是函数时。</p>
<pre><code class="language-ts">interface User {
    isAdministrator(): boolean;
    notify(): void;
    doNotDisturb?(): boolean;
}

// 之后…

// 有问题的代码，别用！
function doAdminThing(user: User) {
    // 糟了！
    if (user.isAdministrator) {
        sudo();
        editTheConfiguration();
    }
    else {
        throw new AccessDeniedError("User is not an admin");
    }
}
</code></pre>
<p>在这段代码中，我们忘了调用 <code>isAdministrator</code>，导致该代码错误地允许非管理员用户修改配置！</p>
<p>在 TypeScript 3.7 中，它会被识别成一个潜在的错误：</p>
<pre><code class="language-ts">function doAdminThing(user: User) {
    if (user.isAdministrator) {
    //  ~~~~~~~~~~~~~~~~~~~~
    // error! This condition will always return true since the function is always defined.
    //        Did you mean to call it instead?
</code></pre>
<p>这个检查功能是一个破坏性变更，基于这个因素，检查会非常保守。
因此对这类错误的提示仅限于 <code>if</code> 条件语句中。当问题函数是可选属性、或未开启 <code>strictNullChecks</code> 选项、或该函数在 <code>if</code> 的代码块中有被调用，在这些情况下不会被视为错误：</p>
<pre><code class="language-ts">interface User {
    isAdministrator(): boolean;
    notify(): void;
    doNotDisturb?(): boolean;
}

function issueNotification(user: User) {
    if (user.doNotDisturb) {
        // OK，属性是可选的
    }
    if (user.notify) {
        // OK，调用了该函数
        user.notify();
    }
}
</code></pre>
<p>如果你打算对该函数进行测试但不调用它，你可以修改它的类型定义，让它可能是 <code>undefined</code>/<code>null</code>，或使用 <code>!!</code> 来编写类似 <code>if (!!user.isAdministrator)</code> 的代码，表示代码逻辑确实是这样的。</p>
<p>我们非常感谢社区成员 <a href="https://github.com/jwbay">@jwbay</a> 提出了 <a href="https://github.com/microsoft/TypeScript/pull/32802">这个问题的概念</a> 并持续跟进实现了 <a href="https://github.com/microsoft/TypeScript/pull/33178">这个需求的当前版本</a>。</p>
<h2 id="typescript-文件中的--ts-nocheck"><a class="header" href="#typescript-文件中的--ts-nocheck">TypeScript 文件中的 <code>// @ts-nocheck</code></a></h2>
<p>TypeScript 3.7 允许我们在 TypeScript 文件的顶部添加一行 <code>// @ts-nocheck</code> 注释来关闭语义检查。
这个注释原本只在 <code>checkJs</code> 选项启用时的 JavaScript 源文件中有效，但我们扩展了它，让它能够支持 TypeScript 文件，这样所有使用者在迁移的时候会更方便。</p>
<h2 id="分号格式化选项"><a class="header" href="#分号格式化选项">分号格式化选项</a></h2>
<p>JavaScript 有一个自动分号插入（ASI，automatic semicolon insertion）规则，TypeScript 内置的格式化程序现在能支持在可选的尾分号位置插入或删除分号。该设置现在在 <a href="https://code.visualstudio.com/insiders/">Visual Studio Code Insiders</a> ，以及 Visual Studio 16.4 Preview 2 中的“工具选项”菜单中可用。</p>
<img width="833" alt="New semicolon formatter option in VS Code" src="https://user-images.githubusercontent.com/3277153/65913194-10066e80-e395-11e9-8a3a-4f7305c397d5.png">
<p>将值设定为 “insert” 或 “remove” 同时也会影响自动导入、类型提取、以及其他 TypeScript 服务提供的自动生成代码的格式。将设置保留为默认值 “ignore” 可以使生成代码的分号自动配置匹配当前文件的风格。</p>
<h2 id="37-的破坏性变更"><a class="header" href="#37-的破坏性变更">3.7 的破坏性变更</a></h2>
<h3 id="dom-变更"><a class="header" href="#dom-变更">DOM 变更</a></h3>
<p><a href="https://github.com/microsoft/TypeScript/pull/33627"><code>lib.dom.d.ts</code> 中的类型声明已更新</a>。
这些变更大部分是与空值检查有关的检测准确性变更，最终的影响取决于你的代码库。</p>
<h3 id="类字段处理"><a class="header" href="#类字段处理">类字段处理</a></h3>
<p><a href="zh/release-notes/typescript-3.7.html#usedefineforclassfields-%e7%bc%96%e8%af%91%e9%80%89%e9%a1%b9%e5%92%8c-declare-%e5%b1%9e%e6%80%a7%e4%bf%ae%e9%a5%b0%e7%ac%a6">正如上文提到的</a>，TypeScript 3.7 现在能够在 <code>.d.ts</code> 文件中编译出 <code>get</code>/<code>set</code>，这可能对 3.5 和更低版本的 TypeScript 使用者来说是破坏性变更。
TypeScript 3.6 的使用者不会受影响，因为该版本对这个功能已经进行了预兼容。</p>
<p><code>useDefineForClassFields</code> 选项虽然自身没有破坏性变更，但不排除以下情形：</p>
<ul>
<li>在派生类中用属性声明覆盖了基类的访问器</li>
<li>覆盖声明属性，但是没有初始值</li>
</ul>
<p>要了解全部的影响，请查看 <a href="zh/release-notes/typescript-3.7.html#usedefineforclassfields-%e7%bc%96%e8%af%91%e9%80%89%e9%a1%b9%e5%92%8c-declare-%e5%b1%9e%e6%80%a7%e4%bf%ae%e9%a5%b0%e7%ac%a6">上面关于 <code>useDefineForClassFields</code> 的章节</a>。</p>
<h3 id="函数真值检查"><a class="header" href="#函数真值检查">函数真值检查</a></h3>
<p>正如上文提到的，现在当函数在 <code>if</code> 条件语句中未被调用时 TypeScript 会报错。
当 <code>if</code> 条件语句中判断的是函数时将会报错，除非符合以下情形：</p>
<ul>
<li>该函数是可选属性</li>
<li>未开启 <code>strictNullChecks</code> 选项</li>
<li>该函数在 <code>if</code> 的代码块中有被调用</li>
</ul>
<h3 id="本地和导入的类型声明现在会产生冲突"><a class="header" href="#本地和导入的类型声明现在会产生冲突">本地和导入的类型声明现在会产生冲突</a></h3>
<p>TypeScript 之前有一个 bug，导致允许以下代码结构：</p>
<pre><code class="language-ts">// ./someOtherModule.ts
interface SomeType {
    y: string;
}

// ./myModule.ts
import { SomeType } from "./someOtherModule";
export interface SomeType {
    x: number;
}

function fn(arg: SomeType) {
    console.log(arg.x); // Error! 'x' doesn't exist on 'SomeType'
}
</code></pre>
<p>这里，<code>SomeType</code> 同时来源于 <code>import</code> 声明和本地 <code>interface</code> 声明。
出人意料的是，在模块内部，<code>SomeType</code> 只会指向 <code>import</code> 的定义，而本地声明的 <code>SomeType</code> 仅在另一个文件的导入中起效。
这很令人困惑，我们对类似的个例进行的调查表明，广大开发者通常理解的情况不一样。</p>
<p>在 TypeScript 3.7 中，<a href="https://github.com/microsoft/TypeScript/pull/31231">这个问题中的重复声明现在可以被正确地识别为一个错误</a>。
合理的修复方案取决于开发者的原始意图，并应该逐案解决。
通常，命名冲突不是故意的，最好的办法是重命名导入的那个类型。
如果是要扩展导入的类型，则可以编写模块扩展（module augmentation）来代替。</p>
<h3 id="37-api-变化"><a class="header" href="#37-api-变化">3.7 API 变化</a></h3>
<p>为了实现上文中提到的递归的类型别名模式，<code>TypeReference</code> 接口已经移除了 <code>typeArguments</code> 属性。开发者应该在 <code>TypeChecker</code> 实例上使用 <code>getTypeArguments</code> 函数来代替。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-36"><a class="header" href="#typescript-36">TypeScript 3.6</a></h1>
<h2 id="更严格的生成器"><a class="header" href="#更严格的生成器">更严格的生成器</a></h2>
<p>TypeScript 3.6 对迭代器和生成器函数引入了更严格的检查。在之前的版本中，用户无法区分一个值是生成的还是被返回的。</p>
<pre><code class="language-typescript">function* foo() {
  if (Math.random() &lt; 0.5) yield 100;
  return "Finished!"
}

let iter = foo();
let curr = iter.next();
if (curr.done) {
  // TypeScript 3.5 以及之前的版本会认为 `value` 为 'string | number'。
  // 当 `done` 为 `true` 的时候，它应该知道 `value` 为 'string'！
  curr.value
}
</code></pre>
<p>另外，生成器只假定 <code>yield</code> 的类型为 <code>any</code>。</p>
<pre><code class="language-typescript">function* bar() {
  let x: { hello(): void } = yield;
  x.hello();
}

let iter = bar();
iter.next();
iter.next(123); // 不好! 运行时错误!
</code></pre>
<p>在 TypeScript 3.6 中，在我们第一个例子中检查器现在知道 <code>curr.value</code> 的正确类型应该是 <code>string</code> ，并且，在最后一个例子中当我们调用 <code>next()</code> 时会准确的提示错误。这要感谢在 <code>Iterator</code> 和 <code>IteratorResule</code> 的类型定义包含了一些新的类型参数，并且一个被叫做 <code>Generator</code> 的新类型在 TypeScript 中用来表示生成器。</p>
<p>类型 <code>Iterator</code> 现在允许用户明确的定义生成的类型，返回的类型和 <code>next</code> 能够接收的类型。</p>
<pre><code class="language-typescript">interface Iterator&lt;T, TReturn = any, TNext = undefined&gt; {
  // 接受 0 或者 1 个参数 - 不接受 'undefined'
  next(...args: [] | [TNext]): IteratorResult&lt;T, TReturn&gt;;
  return?(value?: TReturn): IteratorResult&lt;T, TReturn&gt;;
  throw?(e?: any): IteratorResult&lt;T, TReturn&gt;;
}
</code></pre>
<p>以此为基础，新的 <code>Generator</code> 类型是一个迭代器，它总是有 <code>return</code> 和 <code>throw</code> 方法，并且也是可迭代的。</p>
<pre><code class="language-typescript">interface Generator&lt;T = unknown, TReturn = any, TNext = unknown&gt; extends Iterator&lt;T, TReturn, TNext&gt; {
  next(...args: [] | [TNext]): IteratorResult&lt;T, TReturn&gt;;
  return(value: TReturn): IteratorResult&lt;T, TReturn&gt;;
  throw(e: any): IteratorResult&lt;T, TReturn&gt;;
  [Symbol.iterator](): Generator&lt;T, TReturn, TNext&gt;;
}
</code></pre>
<p>为了允许在返回值和生成值之间进行区分，TypeScript 3.6 转变 <code>IteratorResult</code> 类型为一个区别对待的联合类型：</p>
<pre><code class="language-typescript">type IteratorResult&lt;T, TReturn = any&gt; = IteratorYieldResult&lt;T&gt; | IteratorReturnResult&lt;TReturn&gt;;

interface IteratorYieldResult&lt;TYield&gt; {
  done?: false;
  value: TYield;
}

interface IteratorReturnResult&lt;TReturn&gt; {
  done: true;
  value: TReturn;
}
</code></pre>
<p>简而言之，这意味当直接处理迭代器时，你将有能力细化值的类型。</p>
<p>为了正确的表示在调用生成器的 <code>next()</code> 方法的时候能被传入的类型，TypeScript 3.6 还可以在生成器函数内推断出 <code>yield</code> 的某些用法。</p>
<pre><code class="language-typescript">function* foo() {
  let x: string = yield;
  console.log(x.toUpperCase());
}

let x = foo();
x.next(); // 第一次调用 `next` 总是被忽略
x.next(42); // 错啦！'number' 和 'string' 不匹配
</code></pre>
<p>如果你更喜欢显示的，你还可以使用显示的返回类型强制申明从生成表达式返回的、生成的和计算的的值的类型。下面，<code>next()</code> 只能被 <code>booleans</code> 值调用，并且根据 <code>done</code> 的值，<code>value</code> 可以是 <code>string</code> 或者 <code>number</code>。</p>
<pre><code class="language-typescript">/**
 * - yields numbers
 * - returns strings
 * - can be passed in booleans
 */
function* counter(): Generator&lt;number, string, boolean&gt; {
  let i = 0;
  while (true) {
    if (yield i++) {
      break;
    }
  }
  return "done!";
}

var iter = counter();
var curr = iter.next()
while (!curr.done) {
  console.log(curr.value);
  curr = iter.next(curr.value === 5)
}
console.log(curr.value.toUpperCase());

// prints:
//
// 0
// 1
// 2
// 3
// 4
// 5
// DONE!
</code></pre>
<p>有关更多详细的改变，<a href="https://github.com/Microsoft/TypeScript/issues/2983">查看 pull request</a>。</p>
<h2 id="更准确的数组展开"><a class="header" href="#更准确的数组展开">更准确的数组展开</a></h2>
<p>在 ES2015 之前的目标中，对于像循环和数组展开之类的结构最忠实的生成可能有点繁重。因此，TypeScript 默认使用更简单的生成，它只支持数组类型，并支持使用 <code>--downlevelIteration</code> 标志迭代其它类型。在此标志下，发出的代码更准确，但更大。</p>
<p>默认情况下 <code>--downlevelIteration</code> 默认关闭效果很好，因为大多数以 ES5 为目标的用户只计划使用带数组的迭代结构。但是，我们支持数组的生成在某些边缘情况下仍然存在一些可观察到的差异。</p>
<p>例如，以下示例：</p>
<pre><code class="language-typescript">[...Array(5)]
</code></pre>
<p>相当于以下数组：</p>
<pre><code class="language-typescript">[undefined, undefined, undefined, undefined, undefined]
</code></pre>
<p>但是，TypeScript 会将原始代码转换为此代码：</p>
<pre><code class="language-typescript">Array(5).slice();
</code></pre>
<p>这略有不同。 <code>Array(5)</code> 生成一个长度为 5 的数组，但并没有在其中插入任何元素！</p>
<pre><code class="language-typescript">1 in [undefined, undefined, undefined] // true
1 in Array(3) // false
</code></pre>
<p>当 TypeScript 调用 <code>slice()</code> 时，它还会创建一个索引尚未设置的数组。</p>
<p>这可能看起来有点深奥，但事实证明许多用户遇到了这种令人不快的行为。 TypeScript 3.6 不是使用 <code>slice()</code> 和内置函数，而是引入了一个新的 <code>__spreadArrays</code> 辅助程序，以准确地模拟 ECMAScript 2015 中在 <code>--downlevelIteration</code> 之外的旧目标中发生的事情。 <code>__spreadArrays</code> 也可以在 <a href="https://github.com/Microsoft/tslib/"><code>tslib</code></a> 中使用（如果你正在寻找更小的包，那么值得一试）。</p>
<p>有关更多信息，请<a href="https://github.com/microsoft/TypeScript/pull/31166">参阅相关的 pull request</a>。</p>
<h2 id="改进了-promises-的-ux"><a class="header" href="#改进了-promises-的-ux">改进了 <code>Promises</code> 的 UX</a></h2>
<p><code>Promise</code> 是当今使用异步数据的常用方法之一。不幸的是，使用面向 <code>Promise</code> 的 API 通常会让用户感到困惑。 TypeScript 3.6 引入了一些改进，以防止错误的处理 <code>Promise</code>。</p>
<p>例如，在将它传递给另一个函数之前忘记 <code>.then()</code> 或等待 <code>Promise</code> 的完成通常是很常见的。TypeScript 的错误消息现在是专门的，并告知用户他们可能应该考虑使用 <code>await</code> 关键字。</p>
<pre><code class="language-typescript">interface User {
  name: string;
  age: number;
  location: string;
}

declare function getUserData(): Promise&lt;User&gt;;
declare function displayUser(user: User): void;

async function f() {
  displayUser(getUserData());
//            ~~~~~~~~~~~~~
// 'Promise &lt;User&gt;' 类型的参数不能分配给 'User' 类型的参数。
//   ...
// 你忘记使用 'await' 吗？
}
</code></pre>
<p>在等待或 <code>.then()</code> - <code>Promise</code> 之前尝试访问方法也很常见。这是另一个例子，在许多其他方面，我们能够做得更好。</p>
<pre><code class="language-typescript">async function getCuteAnimals() {
  fetch("https://reddit.com/r/aww.json")
    .json()
  // ~~~~
  // 'Promise &lt;Response&gt;'类型中不存在属性'json'。
  // 你忘记使用'await'吗？
}
</code></pre>
<p>目的是即使用户不知道需要等待，至少，这些消息提供了更多关于从何处开始的上下文。</p>
<p>与可发现性相同，让您的生活更轻松 - 除了 <code>Promises</code> 上更好的错误消息之外，我们现在还在某些情况下提供快速修复。</p>
<p><img src="https://user-images.githubusercontent.com/3277153/61071690-8ca53480-a3c6-11e9-9b08-4e6d9851c9db.gif" alt="正在应用快速修复以添加缺少的 `await` 关键字。" /></p>
<p>有关更多详细信息，请<a href="https://github.com/microsoft/TypeScript/issues/30646">参阅原始问题以及链接回来的 pull request</a>。</p>
<h2 id="标识符更好的支持-unicode"><a class="header" href="#标识符更好的支持-unicode">标识符更好的支持 Unicode</a></h2>
<p>当发射到 ES2015 及更高版本的目标时，TypeScript 3.6 在标识符中包含对 Unicode 字符的更好支持。</p>
<pre><code class="language-typescript">const 𝓱𝓮𝓵𝓵𝓸 = "world"; // previously disallowed, now allowed in '--target es2015'
// 以前不允许，现在在 '--target es2015' 中允许
</code></pre>
<h2 id="支持在-systemjs-中使用-importmeta"><a class="header" href="#支持在-systemjs-中使用-importmeta">支持在 SystemJS 中使用 <code>import.meta</code></a></h2>
<p>当模块目标设置为 <code>system</code> 时，TypeScript 3.6 支持将 <code>import.meta</code> 转换为 <code>context.meta</code>。</p>
<pre><code class="language-typescript">// 此模块:
console.log(import.meta.url)

// 获得如下的转变:
System.register([], function (exports, context) {
  return {
    setters: [],
    execute: function () {
      console.log(context.meta.url);
    }
  };
});
</code></pre>
<h2 id="在环境上下文中允许-get-和-set-访问者"><a class="header" href="#在环境上下文中允许-get-和-set-访问者">在环境上下文中允许 <code>get</code> 和 <code>set</code> 访问者</a></h2>
<p>在以前的 TypeScript 版本中，该语言不允许在环境上下文中使用 <code>get</code> 和 <code>set</code> 访问器（例如，在 <code>declare-d</code> 类中，或者在 <code>.d.ts</code> 文件中）。理由是，就这些属性的写作和阅读而言，访问者与属性没有区别，但是，<a href="https://github.com/tc39/proposal-class-fields/issues/248">因为 ECMAScript 的类字段提议可能与现有版本的 TypeScript 具有不同的行为</a>，我们意识到我们需要一种方法来传达这种不同的行为，以便在子类中提供适当的错误。</p>
<p>因此，用户可以在 TypeScript 3.6 中的环境上下文中编写 <code>getter</code> 和 <code>setter</code>。</p>
<pre><code class="language-typescript">declare class Foo {
  // 3.6+ 允许
  get x(): number;
  set x(val: number): void;
}
</code></pre>
<p>在TypeScript 3.7中，编译器本身将利用此功能，以便生成的 <code>.d.ts</code> 文件也将生成 <code>get</code> / <code>set</code> 访问器。</p>
<h2 id="环境类和函数可以合并"><a class="header" href="#环境类和函数可以合并">环境类和函数可以合并</a></h2>
<p>在以前版本的 TypeScript 中，在任何情况下合并类和函数都是错误的。现在，环境类和函数（具有 <code>declare</code> 修饰符的类/函数或 <code>.d.ts</code> 文件中）可以合并。这意味着现在您可以编写以下内容：</p>
<pre><code class="language-typescript">export declare function Point2D(x: number, y: number): Point2D;
export declare class Point2D {
  x: number;
  y: number;
  constructor(x: number, y: number);
}
</code></pre>
<p>而不需要使用</p>
<pre><code class="language-typescript">export interface Point2D {
    x: number;
    y: number;
}
export declare var Point2D: {
    (x: number, y: number): Point2D;
    new (x: number, y: number): Point2D;
}
</code></pre>
<p>这样做的一个优点是可以很容易地表达可调用的构造函数模式，同时还允许名称空间与这些声明合并（因为 <code>var</code> 声明不能与名称空间合并）。</p>
<p>在 TypeScript 3.7 中，编译器将利用此功能，以便从 <code>.js</code> 文件生成的 <code>.d.ts</code> 文件可以适当地捕获类类函数的可调用性和可构造性。</p>
<p>有关更多详细信息，请<a href="https://github.com/microsoft/TypeScript/pull/32584">参阅 GitHub 上的原始 PR</a>。</p>
<h2 id="apis-支持---build-和---incremental"><a class="header" href="#apis-支持---build-和---incremental">APIs 支持 <code>--build</code> 和 <code>--incremental</code></a></h2>
<p>TypeScript 3.0 引入了对引用其他项目的支持，并使用 <code>--build</code> 标志以增量方式构建它们。此外，TypeScript 3.4 引入了 <code>--incremental</code> 标志，用于保存有关以前编译的信息，仅重建某些文件。这些标志对于更灵活地构建项目和加速构建非常有用。不幸的是，使用这些标志不适用于 Gulp 和 Webpack 等第三方构建工具。TypeScript 3.6 现在公开了两组 API 来操作项目引用和增量构建。</p>
<p>对于创建 <code>--incremental</code> 构建，用户可以利用 <code>createIncrementalProgram</code> 和 <code>createIncrementalCompilerHost</code> API。用户还可以使用新公开的 <code>readBuilderProgram</code> 函数从此 API 生成的 <code>.tsbuildinfo</code> 文件中重新保存旧程序实例，该函数仅用于创建新程序（即，您无法修改返回的实例 - 它意味着用于其他 <code>create * Program</code> 函数中的 <code>oldProgram</code> 参数）。</p>
<p>为了利用项目引用，公开了一个新的 <code>createSolutionBuilder</code> 函数，它返回一个新类型 <code>SolutionBuilder</code> 的实例。</p>
<p>有关这些 API 的更多详细信息，您可以<a href="https://github.com/microsoft/TypeScript/pull/31432">查看原始 pull request</a>。</p>
<h2 id="新的-typescript-playground"><a class="header" href="#新的-typescript-playground">新的 TypeScript Playground</a></h2>
<p>TypeScript Playground 已经获得了急需的刷新功能，并提供了便利的新功能！Playground 主要是 <a href="https://github.com/agentcooper">Artem Tyurin</a> 的 <a href="https://github.com/agentcooper/typescript-play">TypeScript Playground</a> 的一个分支，社区成员越来越多地使用它。我们非常感谢 Artem 在这里提供帮助！</p>
<p>新的 Playground 现在支持许多新的选项，包括：</p>
<ul>
<li><code>target</code> 选项（允许用户切换输出 <code>es5</code> 到 <code>es3</code>、<code>es2015</code>、<code>esnext</code> 等）</li>
<li>所有的严格检查标记（包括 <code>just strict</code>）</li>
<li>支持纯 JavaScript 文件（使用 <code>allowJs</code> 和可选的 <code>checkJs</code>）</li>
</ul>
<p>当分享 Playground 的链接时，这些选项也会保存下来，允许用户更可靠地分享示例，而无需告诉受众“哦，别忘了打开 <code>noImplicitAny</code> 选项！”。</p>
<p>在不久的将来，我们将更新 Playground 样本，添加 <code>JSX</code> 支持和改进自动类型获取，这意味着您将能够在 Playground 上体验到与编辑器中相同的体验。</p>
<p>随着我们改进 Playground 和网站，我们欢迎GitHub上的<a href="https://github.com/microsoft/TypeScript-Website/">issue 和 pull request</a>！</p>
<h2 id="代码编辑的分号感知"><a class="header" href="#代码编辑的分号感知">代码编辑的分号感知</a></h2>
<p>对于 Visual Studio 和 Visual Studio Code 编辑器可以自动的应用快速修复、重构和自动从其它模块导入值等其它的转换。这些转换都由 TypeScript 来驱动，老版本的 TypeScript 无条件的在语句的末尾添加分号，不幸的是，这和大多数用户的代码风格不相符，并且，很多用户对于编辑器自动输入分号很不爽。</p>
<p>TypeScript 现在在应用这些简短的编辑的时候，已经足够的智能去检测你的文件分号的使用情况。如果你的文件通常缺少分号，TypeScript 就不会添加分号。</p>
<p>更多细节，查看<a href="https://github.com/microsoft/TypeScript/pull/31801">这些 pull request</a>。</p>
<h2 id="更智能的自动导入-1"><a class="header" href="#更智能的自动导入-1">更智能的自动导入</a></h2>
<p>JavaScript 有大量不同的模块语法或者约定：EMACScript standard、CommonJS、AMD、System.js 等等。在大多数的情况下，TypeScript 默认使用 ECMAScript standard 语法自动导入，这在具有不同编译器设置的某些 TypeScript 项目中通常是不合适的，或者在使用纯 JavaScript 和需要调用的 Node 项目中。</p>
<p>在决定如何自动导入模块之前，TypeScript 3.6 现在会更加智能的查看你的现有导入。你可以通过<a href="https://github.com/microsoft/TypeScript/pull/32684">这些 pull request</a>查看更多细节。</p>
<h2 id="接下来"><a class="header" href="#接下来">接下来？</a></h2>
<p>要了解团队将要开展的工作，请<a href="https://github.com/microsoft/TypeScript/issues/33118">查看今年 7 月至 12 月的 6 个月路线图</a>。</p>
<p>与往常一样，我们希望这个版本的 TypeScript 能让编码体验更好，让您更快乐。如果您有任何建议或遇到任何问题，我们总是感兴趣，所以随时<a href="https://github.com/microsoft/TypeScript/issues/new/choose">在GitHub上提一个 issue</a>。</p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-6/">Announcing TypeScript 3.6</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-35"><a class="header" href="#typescript-35">TypeScript 3.5</a></h1>
<h2 id="改进速度"><a class="header" href="#改进速度">改进速度</a></h2>
<p>TypeScript 3.5 为类型检查和增量构建采用了几个优化。</p>
<h3 id="类型检查速度提升"><a class="header" href="#类型检查速度提升">类型检查速度提升</a></h3>
<p>TypeScript 3.5 包含对 TypeScript 3.4 的某些优化，可以更高效地进行类型检查。 在代码补全列表等类型检查驱动的操作上，这些改进效果显著。</p>
<h3 id="改进---incremental"><a class="header" href="#改进---incremental">改进 <code>--incremental</code></a></h3>
<p>TypeScript 3.5 通过缓存计算状态的信息（编译器设置、寻找文件的原因、文件在哪里被找到等等），改进了在 3.4 中的 <code>--incremental</code> 构建模式。<a href="https://github.com/Microsoft/TypeScript/pull/31101">我们发现重新构建花费的时间比 TypeScript 3.4 减少了 68%</a>!</p>
<p>有关更多信息，你可以查看这些 pull requests</p>
<ul>
<li><a href="https://github.com/Microsoft/TypeScript/pull/31100">缓存模块解析</a></li>
<li><a href="https://github.com/Microsoft/TypeScript/pull/31101">缓存 <code>tsconfig.json</code> 计算</a></li>
</ul>
<h2 id="omit-辅助类型"><a class="header" href="#omit-辅助类型"><code>Omit</code> 辅助类型</a></h2>
<p>TypeScript 3.5 添加了新的 <code>Omit</code> 辅助类型，这个类型用来创建从原始类型中移除了某些属性的新类型。</p>
<pre><code class="language-typescript">type Person = {
  name: string;
  age: number;
  location: string;
};

type QuantumPerson = Omit&lt;Person, "location"&gt;;

// 相当于
type QuantumPerson = {
  name: string;
  age: number;
};
</code></pre>
<p>使用 <code>Omit</code> 辅助，我们有能力复制 <code>Person</code> 中除了 <code>location</code> 之外的所有属性。</p>
<p>有关更多细节，<a href="https://github.com/Microsoft/TypeScript/pull/30552">在 GitHub 查看添加 <code>Omit</code> 的 pull request</a>, 以及<a href="https://github.com/microsoft/TypeScript/pull/31134">有关剩余对象使用 <code>Omit</code> 的更改</a>。</p>
<h3 id="改进了联合类型中多余属性的检查"><a class="header" href="#改进了联合类型中多余属性的检查">改进了联合类型中多余属性的检查</a></h3>
<p>在 TypeScript 3.4 及之前的版本中，会出现确实不应该存在的多余属性却被允许存在的情况。 例如，TypeScript 3.4 在对象字面量上允许不正确的 <code>name</code> 属性，甚至它的类型在 <code>Point</code> 和 <code>Label</code> 之中都不匹配。</p>
<pre><code class="language-typescript">type Point = {
  x: number;
  y: number;
};

type Label = {
  name: string;
};

const thing: Point | Label = {
  x: 0,
  y: 0,
  name: true // uh-oh!
};
</code></pre>
<p>以前，一个无区别的联合在它的成员上不会进行_任何_多余属性的检查，结果，类型错误的 <code>name</code> 属性溜了进来。</p>
<p>在 TypeScript 3.5 中，类型检查器至少会验证所有提供的属性属于_某个_联合类型的成员，且类型恰当，这意味着，上面的例子会正确的进行错误提示。</p>
<p>注意，只要属性类型有效，仍允许部分重叠。</p>
<pre><code class="language-typescript">const pl: Point | Label = {
  x: 0,
  y: 0,
  name: "origin" // okay
};
</code></pre>
<h2 id="--allowumdglobalaccess-标志"><a class="header" href="#--allowumdglobalaccess-标志"><code>--allowUmdGlobalAccess</code> 标志</a></h2>
<p>在 TypeScript 3.5 中，使用新的 <code>--allowUmdGlobalAccess</code> 标志，你现在可以从任何位置引用全局的 UMD 申明——甚至模块。</p>
<pre><code class="language-typescript">export as namespace foo;
</code></pre>
<p>此模式增加了混合和匹配第三方库的灵活性，其中库声明的全局变量总是可以被使用，甚至可以从模块内部使用。</p>
<p>有关更多细节，<a href="https://github.com/Microsoft/TypeScript/pull/30776/files">查看 GitHub 上的 pull request</a>。</p>
<h2 id="更智能的联合类型检查"><a class="header" href="#更智能的联合类型检查">更智能的联合类型检查</a></h2>
<p>在 TypeScript 3.4 以及之前的版本中，下面的例子会无效：</p>
<pre><code class="language-typescript">type S = { done: boolean, value: number }
type T =
  | { done: false, value: number }
  | { done: true, value: number };

declare let source: S;
declare let target: T;

target = source;
</code></pre>
<p>这是因为 <code>S</code> 无法被分配给 <code>{ done: false, value: number }</code> 或者 <code>{ done: true, value: number }</code>。 为啥？ 因为属性 <code>done</code> 在 <code>S</code> 不够具体——他是 <code>boolean</code>。而 <code>T</code> 的的每个成员有一个明确的为 <code>true</code> 或者 <code>false</code> 属性 <code>done</code>。</p>
<p>这就是我们单独检查每个成员的意义：TypeScript 不只是将每个属性合并在一起，看看是否可以赋予 <code>S</code> 。</p>
<p>如果这样做，一些糟糕的代码可能会像下面这样：</p>
<pre><code class="language-typescript">interface Foo {
  kind: "foo";
  value: string;
}

interface Bar {
  kind: "bar";
  value: number;
}

function doSomething(x: Foo | Bar) {
  if (x.kind === "foo") {
    x.value.toLowerCase();
  }
}

// uh-oh - 幸运的是， TypeScript 在这里会提示错误!
doSomething({
  kind: "foo",
  value: 123,
});
</code></pre>
<p>然而，对于原始的例子，这有点过于严格。 如果你弄清除 <code>S</code> 的任何可能值的精确类型，你实际上可以看到它与 <code>T</code> 中的类型完全匹配。</p>
<p>在 TypeScript 3.5 中，当分配具有辨别属性的类型时，如 <code>T</code>，实际上_将_进一步将类似 <code>S</code> 的类型分解为每个可能的成员类型的并集。 在这种情况下，由于 <code>boolean</code> 是 <code>true</code> 和 <code>false</code> 的联合，<code>S</code> 将被视为 <code>{done：false，value：number}</code> 和 <code>{done：true，value：number }</code>。</p>
<p>有关更多细节，你可以<a href="https://github.com/microsoft/TypeScript/pull/30779">在 GitHub 上查看原始的 pull request</a>。</p>
<h2 id="泛型构造函数的高阶类型推断"><a class="header" href="#泛型构造函数的高阶类型推断">泛型构造函数的高阶类型推断</a></h2>
<p>在 TypeScript 3.4 中，我们改进了对返回函数的泛型函数的推断：</p>
<pre><code class="language-typescript">function compose&lt;T, U, V&gt;(f: (x: T) =&gt; U, g: (y: U) =&gt; V): (x: T) =&gt; V {
  return x =&gt; g(f(x))
}
</code></pre>
<p>将其他泛型函数作为参数，如下所示：</p>
<pre><code class="language-typescript">function arrayify&lt;T&gt;(x: T): T[] {
  return [x];
}

type Box&lt;U&gt; = { value: U }
function boxify&lt;U&gt;(y: U): Box&lt;U&gt; {
  return { value: y };
}

let newFn = compose(arrayify, boxify);
</code></pre>
<p>TypeScript 3.4 的推断允许 <code>newFn</code> 是泛型的。它的新类型是 <code>&lt;T&gt;（x：T）=&gt; Box &lt;T []&gt;</code>。而不是旧版本推断的，相对无用的类型，如 <code>（x：{}）=&gt; Box &lt;{} []&gt;</code>。</p>
<p>TypeScript 3.5 在处理构造函数的时候推广了这种行为。</p>
<pre><code class="language-typescript">class Box&lt;T&gt; {
  kind: "box";
  value: T;
  constructor(value: T) {
    this.value = value;
  }
}

class Bag&lt;U&gt; {
  kind: "bag";
  value: U;
  constructor(value: U) {
    this.value = value;
  }
}

function composeCtor&lt;T, U, V&gt;(F: new (x: T) =&gt; U, G: new (y: U) =&gt; V): (x: T) =&gt; V {
  return x =&gt; new G(new F(x))
}

let f = composeCtor(Box, Bag); // 拥有类型 '&lt;T&gt;(x: T) =&gt; Bag&lt;Box&lt;T&gt;&gt;'
let a = f(1024); // 拥有类型 'Bag&lt;Box&lt;number&gt;&gt;'
</code></pre>
<p>除了上面的组合模式之外，这种对泛型构造函数的新推断意味着在某些 UI 库（如 React ）中对类组件进行操作的函数可以更正确地对泛型类组件进行操作。</p>
<pre><code class="language-typescript">type ComponentClass&lt;P&gt; = new (props: P) =&gt; Component&lt;P&gt;;
declare class Component&lt;P&gt; {
  props: P;
  constructor(props: P);
}

declare function myHoc&lt;P&gt;(C: ComponentClass&lt;P&gt;): ComponentClass&lt;P&gt;;

type NestedProps&lt;T&gt; = { foo: number, stuff: T };

declare class GenericComponent&lt;T&gt; extends Component&lt;NestedProps&lt;T&gt;&gt; { }

// 类型为 'new &lt;T&gt;(props: NestedProps&lt;T&gt;) =&gt; Component&lt;NestedProps&lt;T&gt;&gt;'
const GenericComponent2 = myHoc(GenericComponent);
</code></pre>
<p>想学习更多，<a href="https://github.com/microsoft/TypeScript/pull/31116">在 GitHub 上查看原始的 pull requet</a>。</p>
<h2 id="参考-1"><a class="header" href="#参考-1">参考</a></h2>
<ul>
<li><a href="https://github.com/microsoft/TypeScript-Handbook/blob/master/pages/release%20notes/TypeScript%203.5.md">原文</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-34"><a class="header" href="#typescript-34">TypeScript 3.4</a></h1>
<h2 id="使用---incremental-标志加快后续构建"><a class="header" href="#使用---incremental-标志加快后续构建">使用 <code>--incremental</code> 标志加快后续构建</a></h2>
<p>TypeScript 3.4 引入了一个名为 <code>--incremental</code> 的新标志，它告诉 TypeScript 从上一次编译中保存有关项目图的信息。</p>
<p>下次使用 <code>--incremental</code> 调用 TypeScript 时，它将使用该信息来检测类型检查和生成对项目更改成本最低的方法。</p>
<pre><code class="language-text">// tsconfig.json
{
  "compilerOptions": {
    "incremental": true,
    "outDir": "./lib"
  },
  "include": ["./src"]
}
</code></pre>
<p>默认使用这些设置，当我们运行 <code>tsc</code> 时，TypeScript 将在输出目录（<code>./lib</code>）中查找名为 <code>.tsbuildinfo</code> 的文件。 如果 <code>./lib/.tsbuildinfo</code> 不存在，它将被生成。 但如果存在，<code>tsc</code> 将尝试使用该文件逐步进行类型检查并更新输出文件。</p>
<p>这些 <code>.tsbuildinfo</code> 文件可以安全地删除，并且在运行时对我们的代码没有任何影响——它们纯粹用于更快地编译。 我们也可以将它们命名为我们想要的任何名字，并使用 <code>--tsBuildInfoFile</code> 标志将它们放在我们想要的任何位置。</p>
<pre><code class="language-text">// front-end.tsconfig.json
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./buildcache/front-end",
    "outDir": "./lib"
  },
  "include": ["./src"]
}
</code></pre>
<h3 id="复合项目"><a class="header" href="#复合项目">复合项目</a></h3>
<p>复合项目的意图的一部分（<code>tsconfig.json</code>s，<code>composite</code> 设置为 <code>true</code>）是不同项目之间的引用可以增量构建。 因此，复合项目将<strong>始终</strong>生成 <code>.tsbuildinfo</code> 文件。</p>
<h3 id="outfile"><a class="header" href="#outfile"><code>outFile</code></a></h3>
<p>当使用 <code>outFile</code> 时，构建信息文件的名称将基于输出文件的名称。 例如，如果我们的输出 JavaScript 文件是 <code>./ output / foo.js</code>，那么在 <code>--incremental</code> 标志下，TypeScript 将生成文件<code>./output/foo.tsbuildinfo</code>。 如上所述，这可以通过 <code>--tsBuildInfoFile</code> 标志来控制。</p>
<h2 id="泛型函数的高阶类型推断"><a class="header" href="#泛型函数的高阶类型推断">泛型函数的高阶类型推断</a></h2>
<p>当来自其它泛型函数的推断产生用于推断的自由类型变量时，TypeScript 3.4 现在可以生成泛型函数类型。</p>
<p>这意味着在 3.4 中许多函数组合模式现在运行的更好了。</p>
<p>为了更具体，让我们建立一些动机并考虑以下 <code>compose</code> 函数：</p>
<pre><code class="language-typescript">function compose&lt;A, B, C&gt;(f: (arg: A) =&gt; B, g: (arg: B) =&gt; C): (arg: A) =&gt; C {
  return x =&gt; g(f(x));
}
</code></pre>
<p><code>compose</code> 还有两个其他函数：</p>
<ul>
<li><code>f</code> 它接受一些参数（类型为 <code>A</code>）并返回类型为 <code>B</code> 的值</li>
<li><code>g</code> 采用类型为 <code>B</code> 的参数（类型为 <code>f</code> 返回），并返回类型为 <code>C</code> 的值</li>
</ul>
<p><code>compose</code> 然后返回一个函数，它通过 <code>f</code> 然后 <code>g</code> 来提供它的参数。</p>
<p>调用此函数时，TypeScript 将尝试通过一个名为 <em>type argument inference</em> 的进程来计算出 <code>A</code>，<code>B</code> 和 <code>C</code> 的类型。 这个推断过程通常很有效：</p>
<pre><code class="language-typescript">interface Person {
  name: string;
  age: number;
}

function getDisplayName(p: Person) {
  return p.name.toLowerCase();
}

function getLength(s: string) {
  return s.length;
}

// 拥有类型 '(p: Person) =&gt; number'
const getDisplayNameLength = compose(
  getDisplayName,
  getLength,
);

// 有效并返回 `number` 类型
getDisplayNameLength({ name: "Person McPersonface", age: 42 });
</code></pre>
<p>推断过程在这里相当简单，因为 <code>getDisplayName</code> 和 <code>getLength</code> 使用的是可以轻松引用的类型。 但是，在 TypeScript 3.3 及更早版本中，泛型函数如 <code>compose</code> 在传递其他泛型函数时效果不佳。</p>
<pre><code class="language-typescript">interface Box&lt;T&gt; {
  value: T;
}

function makeArray&lt;T&gt;(x: T): T[] {
  return [x];
}

function makeBox&lt;U&gt;(value: U): Box&lt;U&gt; {
  return { value };
}

// 类型为 '(arg: {}) =&gt; Box&lt;{}[]&gt;'
const makeBoxedArray = compose(
  makeArray,
  makeBox,
)

makeBoxedArray("hello!").value[0].toUpperCase();
//                                ~~~~~~~~~~~
// 错误：类型 '{}' 没有 'toUpperCase' 属性
</code></pre>
<p>在旧版本中，当从其他类型变量（如 <code>T</code> 和 <code>U</code>）推断时，TypeScript 会推断出空对象类型（<code>{}</code>）。</p>
<p>在 TypeScript 3.4 中的类型参数推断时，对于返回函数的泛型函数的调用，TypeScript <em>将</em>（视情况而定）把类型参数从泛型函数参数传递到生成的函数类型中。</p>
<p>换句话说，而不是生成类型</p>
<pre><code class="language-typescript">(arg: {}) =&gt; Box&lt;{}[]&gt;
</code></pre>
<p>TypeScript 3.4 生成的类型</p>
<pre><code class="language-typescript">&lt;T&gt;(arg: T) =&gt; Box&lt;T[]&gt;
</code></pre>
<p>注意，<code>T</code> 已从 <code>makeArray</code> 传递到结果类型的类型参数列表中。 这意味着来自 <code>compose</code> 参数的泛型已被保留，我们的 <code>makeBoxedArray</code> 示例将正常运行！</p>
<pre><code class="language-typescript">interface Box&lt;T&gt; {
  value: T;
}

function makeArray&lt;T&gt;(x: T): T[] {
  return [x];
}

function makeBox&lt;U&gt;(value: U): Box&lt;U&gt; {
  return { value };
}

// 类型为 '&lt;T&gt;(arg: T) =&gt; Box&lt;T[]&gt;'
const makeBoxedArray = compose(
  makeArray,
  makeBox,
)

// 正常运行！
makeBoxedArray("hello!").value[0].toUpperCase();
</code></pre>
<p>更多细节，你可以<a href="https://github.com/Microsoft/TypeScript/pull/30215">读到更多从这些原始的变动</a>。</p>
<h2 id="改进-readonlyarray-和-readonly-元祖"><a class="header" href="#改进-readonlyarray-和-readonly-元祖">改进 <code>ReadonlyArray</code> 和 <code>readonly</code> 元祖</a></h2>
<p>TypeScript 3.4 让使用只读的类似数组的类型更简单了。</p>
<h3 id="一个与-readonlyarray-相关的新语法"><a class="header" href="#一个与-readonlyarray-相关的新语法">一个与 <code>ReadonlyArray</code> 相关的新语法</a></h3>
<p><code>ReadonlyArray</code> 类型描述 <code>Array</code> 是只读的。</p>
<p>任何带有 <code>ReadonlyArray</code> 引用的变量不能被添加、移除或者替换数组中的任何元素。</p>
<pre><code class="language-typescript">function foo(arr: ReadonlyArray&lt;string&gt;) {
  arr.slice();        // okay
  arr.push("hello!"); // error!
}
</code></pre>
<p>当期待数组不可变时使用 <code>ReadonlyArray</code> 替代 <code>Array</code> 是好实践，考虑到数组有一个更棒的语法的情况下这通常有一点痛苦。 尤其是，<code>number[]</code> 是一个省略版的 <code>Array&lt;number&gt;</code>，就像 <code>Date[]</code> 是省略版的 <code>Array&lt;Date&gt;</code>。</p>
<p>TypeScript 3.4 为 <code>ReadonlyArray</code> 引入了一个新的语法，就是在数组类型上使用了新的 <code>readonly</code> 修饰语。</p>
<pre><code class="language-typescript">function foo(arr: readonly string[]) {
  arr.slice();        // okay
  arr.push("hello!"); // 错误！
}
</code></pre>
<h3 id="readonly-元祖"><a class="header" href="#readonly-元祖"><code>readonly</code> 元祖</a></h3>
<p>TypeScript 3.4 同样引入了对 <code>readonly</code> 元祖的支持。 我们可以在任何元祖类型上加上前置 <code>readonly</code> 关键字用来表示它是 <code>readonly</code> 元祖，非常像我们现在可以对数组使用的省略版语法。 就像你可能期待的，不像插槽可写的普通元祖，<code>readonly</code> 元祖只允许从那些位置读。</p>
<pre><code class="language-typescript">function foo(pair: readonly [string, string]) {
  console.log(pair[0]);   // okay
  pair[1] = "hello!";     // 错误
}
</code></pre>
<p>普通的元祖是用相同的方式从 <code>Array</code> 继承的——一个元祖<code>T1</code>, <code>T2</code>, ... <code>Tn</code> 继承自 <code>Array&lt; T1 | T2 | ... Tn &gt;</code> - <code>readonly</code> 元祖是继承自类型 <code>ReadonlyArray</code>。所以，一个 <code>readonly</code> 元祖 <code>T1</code>, <code>T2</code>, ... <code>Tn</code> 继承自 <code>ReadonlyArray&lt; T1 | T2 | ... Tn &gt;</code>。</p>
<h3 id="映射类型修饰语-readonly-和-readonly-数组"><a class="header" href="#映射类型修饰语-readonly-和-readonly-数组">映射类型修饰语 <code>readonly</code> 和 <code>readonly</code> 数组</a></h3>
<p>在之前的 TypeScript 版本中，我们一般使用映射类型操作不同的类似数组的结构。</p>
<p>这意味着，一个映射类型像 <code>Boxify</code> 可以在数组上生效，元祖也是。</p>
<pre><code class="language-typescript">interface Box&lt;T&gt; { value: T }

type Boxify&lt;T&gt; = {
}

// { a: Box&lt;string&gt;, b: Box&lt;number&gt; }
type A = Boxify&lt;{ a: string, b: number }&gt;;

// Array&lt;Box&lt;number&gt;&gt;
type B = Boxify&lt;number[]&gt;;

// [Box&lt;string&gt;, Box&lt;number&gt;]
type C = Boxify&lt;[string, boolean]&gt;;
</code></pre>
<p>不幸的是，映射类型像 <code>Readonly</code> 实用类型在数组和元祖类型上实际上是无用的。</p>
<pre><code class="language-typescript">// lib.d.ts
type Readonly&lt;T&gt; = {
  readonly [K in keyof T]: T[K]
}

// 在 TypeScript 3.4 之前代码会如何执行

// { readonly a: string, readonly b: number }
type A = Readonly&lt;{ a: string, b: number }&gt;;

// number[]
type B = Readonly&lt;number[]&gt;;

// [string, boolean]
type C = Readonly&lt;[string, boolean]&gt;;
</code></pre>
<p>在 TypeScript 3.4，在映射类型中的 <code>readonly</code> 修饰符将自动的转换类似数组结构到他们相符合的 <code>readonly</code> 副本。</p>
<pre><code class="language-typescript">// 在 TypeScript 3.4 中代码会如何运行

// { readonly a: string, readonly b: number }
type A = Readonly&lt;{ a: string, b: number }&gt;;

// readonly number[]
type B = Readonly&lt;number[]&gt;;

// readonly [string, boolean]
type C = Readonly&lt;[string, boolean]&gt;;
</code></pre>
<p>类似地，你可以编写一个类似 <code>Writable</code> 映射类型的实用程序类型来移除 <code>readonly</code>-ness，并将 <code>readonly</code> 数组容器转换回它们的可变等价物。</p>
<pre><code class="language-typescript">type Writable&lt;T&gt; = {
  -readonly [K in keyof T]: T[K]
}

// { a: string, b: number }
type A = Writable&lt;{
  readonly a: string;
  readonly b: number
}&gt;;

// number[]
type B = Writable&lt;readonly number[]&gt;;

// [string, boolean]
type C = Writable&lt;readonly [string, boolean]&gt;;
</code></pre>
<h3 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h3>
<p>它不是一个通用型操作，尽管它看起来像。 <code>readonly</code> 类型修饰符只能用于数组类型和元组类型的语法。</p>
<pre><code class="language-typescript">let err1: readonly Set&lt;number&gt;; // 错误！
let err2: readonly Array&lt;boolean&gt;; // 错误！

let okay: readonly boolean[]; // 有效
</code></pre>
<p>你可以<a href="https://github.com/Microsoft/TypeScript/pull/29435">查看 pull request 了解更多详情</a>。</p>
<h2 id="const-断言"><a class="header" href="#const-断言"><code>const</code> 断言</a></h2>
<p>TypeScript 3.4 引入了一个叫 <em><code>const</code></em> 断言的字面量值的新构造。 它的语法是用 <code>const</code> 代替类型名称的类型断言（例如 <code>123 as const</code>）。 当我们用 <code>const</code> 断言构造新的字面量表达式时，我们可以用来表示：</p>
<ul>
<li>该表达式中的字面量类型不应粗化（例如，不要从 <code>'hello'</code> 到<code>string</code>）</li>
<li>对象字面量获得 <code>readonly</code> 属性</li>
<li>数组字面量成为 <code>readonly</code> 元组</li>
</ul>
<pre><code class="language-typescript">// Type '"hello"'
let x = "hello" as const;

// Type 'readonly [10, 20]'
let y = [10, 20] as const;

// Type '{ readonly text: "hello" }'
let z = { text: "hello" } as const;
</code></pre>
<p>也可以使用尖括号断言语法，除了 <code>.tsx</code> 文件之外。</p>
<pre><code class="language-typescript">// Type '"hello"'
let x = &lt;const&gt;"hello";

// Type 'readonly [10, 20]'
let y = &lt;const&gt;[10, 20];

// Type '{ readonly text: "hello" }'
let z = &lt;const&gt;{ text: "hello" };
</code></pre>
<p>此功能意味着通常可以省略掉仅用于将不可变性示意给编译器的类型。</p>
<pre><code class="language-typescript">// 不使用引用或声明的类型。
// 我们只需要一个 const 断言。
function getShapes() {
  let result = [
    { kind: "circle", radius: 100, },
    { kind: "square", sideLength: 50, },
  ] as const;

  return result;
}

for (const shape of getShapes()) {
  // 完美细化
  if (shape.kind === "circle") {
    console.log("Circle radius", shape.radius);
  }
  else {
    console.log("Square side length", shape.sideLength);
  }
}
</code></pre>
<p>请注意，上面的例子不需要类型注释。 <code>const</code> 断言允许 TypeScript 采用最具体的类型表达式。</p>
<p>如果你选择不使用 TypeScript 的 <code>enum</code> 结构，这甚至可以用于在纯 JavaScript 代码中使用类似 <code>enum</code> 的模式。</p>
<pre><code class="language-typescript">export const Colors = {
  red: "RED",
  blue: "BLUE",
  green: "GREEN",
} as const;

// 或者使用 'export default'

export default {
  red: "RED",
  blue: "BLUE",
  green: "GREEN",
} as const;
</code></pre>
<h3 id="注意事项-1"><a class="header" href="#注意事项-1">注意事项</a></h3>
<p>需要注意的是，<code>const</code> 断言只能直接应用于简单的字面量表达式上。</p>
<pre><code class="language-typescript">// 错误！'const' 断言只能用在 string, number, boolean, array, object literal。
let a = (Math.random() &lt; 0.5 ? 0 : 1) as const;

// 有效！
let b = Math.random() &lt; 0.5 ?
  0 as const :
  1 as const;
</code></pre>
<p>另一件得记住的事是 <code>const</code> 上下文不会直接将表达式转换为完全不可变的。</p>
<pre><code class="language-typescript">let arr = [1, 2, 3, 4];

let foo = {
  name: "foo",
  contents: arr,
} as const;

foo.name = "bar";   // 错误！
foo.contents = [];  // 错误！

foo.contents.push(5); // ...有效！
</code></pre>
<p>更多详情，你可以<a href="https://github.com/Microsoft/TypeScript/pull/29510">查看相应的 pull request</a>。</p>
<h2 id="对-globalthis-的类型检查"><a class="header" href="#对-globalthis-的类型检查">对 <code>globalThis</code> 的类型检查</a></h2>
<p>TypeScript 3.4 引入了对 ECMAScript 新 <code>globalThis</code> 全局变量的类型检查的支持，它指向的是全局作用域。 与上述解决方案不同，<code>globalThis</code> 提供了一种访问全局作用域的标准方法，可以在不同环境中使用。</p>
<pre><code class="language-typescript">// 在一个全局文件里:

var abc = 100;

// 指向上面的 `abc`
globalThis.abc = 200;
</code></pre>
<p>注意，使用 <code>let</code> 和 <code>const</code> 声明的全局变量不会显示在 <code>globalThis</code> 上。</p>
<pre><code class="language-typescript">let answer = 42;

// 错误！'typeof globalThis' 没有 'answer' 属性。
globalThis.answer = 333333;
</code></pre>
<p>同样重要的是要注意，在编译为老版本的 ECMAScript 时，TypeScript 不会转换引用到 <code>globalThis</code> 上。 因此，除非您的目标是常青浏览器（已经支持 <code>globalThis</code>），否则您可能需要<a href="https://github.com/ljharb/globalThis">使用 polyfill</a>。</p>
<p>更多详细信息，请参阅<a href="https://github.com/Microsoft/TypeScript/pull/29332">该功能的 pull request</a>。</p>
<h2 id="参考-2"><a class="header" href="#参考-2">参考</a></h2>
<ul>
<li><a href="https://github.com/microsoft/TypeScript-Handbook/blob/master/pages/release%20notes/TypeScript%203.4.md">原文</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-33"><a class="header" href="#typescript-33">TypeScript 3.3</a></h1>
<h2 id="改进调用联合类型时的行为"><a class="header" href="#改进调用联合类型时的行为">改进调用联合类型时的行为</a></h2>
<p>在 TypeScript 之前的版本中，将可调用类型联合后仅在它们具有相同的参数列表时才能被调用。</p>
<pre><code class="language-typescript">type Fruit = "apple" | "orange";
type Color = "red" | "orange";

type FruitEater = (fruit: Fruit) =&gt; number; // eats and ranks the fruit
type ColorConsumer = (color: Color) =&gt; string; // consumes and describes the colors

declare let f: FruitEater | ColorConsumer;

// Cannot invoke an expression whose type lacks a call signature.
//   Type 'FruitEater | ColorConsumer' has no compatible call signatures.ts(2349)
f("orange");
</code></pre>
<p>然而，上例中，<code>FruitEater</code>和<code>ColorConsumer</code>应该都可以使用<code>"orange"</code>，并返回<code>number</code>或<code>string</code>。</p>
<p>在 TypeScript 3.3 里，这个错误不存在了。</p>
<pre><code class="language-typescript">type Fruit = "apple" | "orange";
type Color = "red" | "orange";

type FruitEater = (fruit: Fruit) =&gt; number; // eats and ranks the fruit
type ColorConsumer = (color: Color) =&gt; string; // consumes and describes the colors

declare let f: FruitEater | ColorConsumer;

f("orange"); // It works! Returns a 'number | string'.

f("apple"); // error - Argument of type '"apple"' is not assignable to parameter of type '"orange"'.

f("red"); // error - Argument of type '"red"' is not assignable to parameter of type '"orange"'.
</code></pre>
<p>TypeScript 3.3，这些签名的参数被连结在一起构成了一个新的签名。</p>
<p>在上例中，<code>fruit</code>和<code>color</code>连结在一起形成新的参数类型<code>Fruit &amp; Color</code>。 <code>Fruit &amp; Color</code>和<code>("apple" | "orange") &amp; ("red" | "orange")</code>是一样的，都相当于<code>("apple" &amp; "red") | ("apple" &amp; "orange") | ("orange" &amp; "red") | ("orange" &amp; "orange")</code>。 那些不可能交叉的会规约成<code>never</code>类型，只剩下<code>"orange" &amp; "orange"</code>，就是<code>"orange"</code>。</p>
<h3 id="警告"><a class="header" href="#警告">警告</a></h3>
<p>这个新行为仅在满足如下情形时生效：</p>
<ul>
<li>联合类型中最多有一个类型具有多个重载，</li>
<li>联合类型中最多有一个类型有泛型签名。</li>
</ul>
<p>这意味着，像<code>map</code>这种操作<code>number[] | string[]</code>的方法，还是不能调用，因为<code>map</code>是泛型函数。</p>
<p>另一方面，像<code>forEach</code>就可以调用，因为它不是泛型函数，但在<code>noImplicitAny</code>模式可能有些问题。</p>
<pre><code class="language-typescript">interface Dog {
  kind: "dog";
  dogProp: any;
}
interface Cat {
  kind: "cat";
  catProp: any;
}

const catOrDogArray: Dog[] | Cat[] = [];

catOrDogArray.forEach(animal =&gt; {
  //                ~~~~~~ error!
  // Parameter 'animal' implicitly has an 'any' type.
});
</code></pre>
<p>添加显式的类型信息可以解决。</p>
<pre><code class="language-typescript">interface Dog {
  kind: "dog";
  dogProp: any;
}
interface Cat {
  kind: "cat";
  catProp: any;
}

const catOrDogArray: Dog[] | Cat[] = [];
catOrDogArray.forEach((animal: Dog | Cat) =&gt; {
  if (animal.kind === "dog") {
    animal.dogProp;
    // ...
  } else if (animal.kind === "cat") {
    animal.catProp;
    // ...
  }
});
</code></pre>
<h2 id="在合复合工程中增量地检测文件的变化---build---watch"><a class="header" href="#在合复合工程中增量地检测文件的变化---build---watch">在合复合工程中增量地检测文件的变化 <code>--build --watch</code></a></h2>
<p>TypeScript 3.0 引入了一个新特性来按结构进行构建，称做“复合工程”。 目的是让用户能够把大型工程拆分成小的部分从而快速构建并保留项目结构。 正是因为支持了复合工程，TypeScript 可以使用<code>--build</code>模式仅重新编译部分工程和依赖。 可以把它当做工作内部构建的一种优化。</p>
<p>TypeScript 2.7 还引入了<code>--watch</code>构建模式，它使用了新的增量"builder"API。 背后的想法都是仅重新检查和生成改动过的文件或者是依赖项可能影响类型检查的文件。 可以把它们当成工程内部构建的优化。</p>
<p>在 3.3 之前，使用<code>--build --watch</code>构建复合工程不会真正地使用增量文件检测机制。 在<code>--build --watch</code>模式下，一个工程里的一处改动会导致整个工程重新构建，而非仅检查那些真正受到影响的文件。</p>
<p>在 TypeScript 3.3 里，<code>--build</code>模式的<code>--watch</code>标记也会使用增量文件检测。 因此<code>--build --watch</code>模式下构建非常快。 我们的测试结果显示，这个功能会减少 50%到 75%的构建时间，相比于原先的<code>--build --watch</code>。 具体数字在这这个<a href="https://github.com/Microsoft/TypeScript/pull/29161">pull request</a>里，我们相信大多数复合工程用户会看到明显效果。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-32"><a class="header" href="#typescript-32">TypeScript 3.2</a></h1>
<h2 id="strictbindcallapply"><a class="header" href="#strictbindcallapply"><code>strictBindCallApply</code></a></h2>
<p>TypeScript 3.2引入了一个新的<code>--strictBindCallApply</code>编译选项（是<code>--strict</code>选项家族之一）。在使用了此选项后，函数对象上的<code>bind</code>，<code>call</code>和<code>apply</code>方法将应用强类型并进行严格的类型检查。</p>
<pre><code class="language-typescript">function foo(a: number, b: string): string {
    return a + b;
}

let a = foo.apply(undefined, [10]);              // error: too few argumnts
let b = foo.apply(undefined, [10, 20]);          // error: 2nd argument is a number
let c = foo.apply(undefined, [10, "hello", 30]); // error: too many arguments
let d = foo.apply(undefined, [10, "hello"]);     // okay! returns a string
</code></pre>
<p>它的实现是通过引入了两种新类型来完成的，即<code>lib.d.ts</code>里的<code>CallableFunction</code>和<code>NewableFunction</code>。这些类型包含了针对常规函数和构造函数上<code>bind</code>、<code>call</code>和<code>apply</code>的泛型方法声明。这些声明使用了泛型剩余参数来捕获和反射参数列表，使之具有强类型。在<code>--strictBindCallApply</code>模式下，这些声明作用在<code>Function</code>类型声明出现的位置。</p>
<h3 id="警告-1"><a class="header" href="#警告-1">警告</a></h3>
<p>由于更严格的检查可能暴露之前没发现的错误，因此这是<code>--strict</code>模式下的一个破坏性改动。</p>
<p>此外，这个新功能还有<a href="https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450">另一个警告</a>。由于有这些限制，<code>bind</code>、<code>call</code>和<code>apply</code>无法为重载的泛型函数或重载的函数进行完整地建模。 当在泛型函数上使用这些方法时，类型参数会被替换为空对象类型（<code>{}</code>），并且若在有重载的函数上使用这些方法时，只有最后一个重载会被建模。</p>
<h2 id="对象字面量的泛型展开表达式"><a class="header" href="#对象字面量的泛型展开表达式">对象字面量的泛型展开表达式</a></h2>
<p>TypeScript 3.2开始，对象字面量允许泛型展开表达式，它产生交叉类型，和<code>Object.assign</code>函数或JSX字面量类似。例如：</p>
<pre><code class="language-typescript">function taggedObject&lt;T, U extends string&gt;(obj: T, tag: U) {
    return { ...obj, tag };  // T &amp; { tag: U }
}

let x = taggedObject({ x: 10, y: 20 }, "point");  // { x: number, y: number } &amp; { tag: "point" }
</code></pre>
<p>属性赋值和非泛型展开表达式会最大程度地合并到泛型展开表达式的一侧。例如：</p>
<pre><code class="language-typescript">function foo1&lt;T&gt;(t: T, obj1: { a: string }, obj2: { b: string }) {
    return { ...obj1, x: 1, ...t, ...obj2, y: 2 };  // { a: string, x: number } &amp; T &amp; { b: string, y: number }
}
</code></pre>
<p>非泛型展开表达式与之前的行为相同：函数调用签名和构造签名被移除，仅有非方法的属性被保留，针对同名属性则只有出现在最右侧的会被使用。它与交叉类型不同，交叉类型会连接调用签名和构造签名，保留所有的属性，合并同名属性的类型。因此，当展开使用泛型初始化的相同类型时可能会产生不同的结果：</p>
<pre><code class="language-typescript">function spread&lt;T, U&gt;(t: T, u: U) {
    return { ...t, ...u };  // T &amp; U
}

declare let x: { a: string, b: number };
declare let y: { b: string, c: boolean };

let s1 = { ...x, ...y };  // { a: string, b: string, c: boolean }
let s2 = spread(x, y);    // { a: string, b: number } &amp; { b: string, c: boolean }
let b1 = s1.b;  // string
let b2 = s2.b;  // number &amp; string
</code></pre>
<h2 id="泛型对象剩余变量和参数"><a class="header" href="#泛型对象剩余变量和参数">泛型对象剩余变量和参数</a></h2>
<p>TypeScript 3.2开始允许从泛型变量中解构剩余绑定。它是通过使用<code>lib.d.ts</code>里预定义的<code>Pick</code>和<code>Exclude</code>助手类型，并结合使用泛型类型和解构式里的其它绑定名实现的。</p>
<pre><code class="language-typescript">function excludeTag&lt;T extends { tag: string }&gt;(obj: T) {
    let { tag, ...rest } = obj;
    return rest;  // Pick&lt;T, Exclude&lt;keyof T, "tag"&gt;&gt;
}

const taggedPoint = { x: 10, y: 20, tag: "point" };
const point = excludeTag(taggedPoint);  // { x: number, y: number }
</code></pre>
<h2 id="bigint"><a class="header" href="#bigint">BigInt</a></h2>
<p>BigInt里ECMAScript的一项提案，它在理论上允许我们建模任意大小的整数。 TypeScript 3.2可以为BigInit进行类型检查，并支持在目标为<code>esnext</code>时输出BigInit字面量。</p>
<p>为支持BigInt，TypeScript引入了一个新的原始类型<code>bigint</code>（全小写）。 可以通过调用<code>BigInt()</code>函数或书写BigInt字面量（在整型数字字面量末尾添加<code>n</code>）来获取<code>bigint</code>。</p>
<pre><code class="language-typescript">let foo: bigint = BigInt(100); // the BigInt function
let bar: bigint = 100n;        // a BigInt literal

// *Slaps roof of fibonacci function*
// This bad boy returns ints that can get *so* big!
function fibonacci(n: bigint) {
    let result = 1n;
    for (let last = 0n, i = 0n; i &lt; n; i++) {
        const current = result;
        result += last;
        last = current;
    }
    return result;
}

fibonacci(10000n)
</code></pre>
<p>尽管你可能会认为<code>number</code>和<code>bigint</code>能互换使用，但它们是不同的东西。</p>
<pre><code class="language-typescript">declare let foo: number;
declare let bar: bigint;

foo = bar; // error: Type 'bigint' is not assignable to type 'number'.
bar = foo; // error: Type 'number' is not assignable to type 'bigint'.
</code></pre>
<p>ECMAScript里规定，在算术运算符里混合使用<code>number</code>和<code>bigint</code>是一个错误。 应该显式地将值转换为<code>BigInt</code>。</p>
<pre><code class="language-typescript">console.log(3.141592 * 10000n);     // error
console.log(3145 * 10n);            // error
console.log(BigInt(3145) * 10n);    // okay!
</code></pre>
<p>还有一点要注意的是，对<code>bigint</code>使用<code>typeof</code>操作符返回一个新的字符串：<code>"bigint"</code>。 因此，TypeScript能够正确地使用<code>typeof</code>细化类型。</p>
<pre><code class="language-typescript">function whatKindOfNumberIsIt(x: number | bigint) {
    if (typeof x === "bigint") {
        console.log("'x' is a bigint!");
    }
    else {
        console.log("'x' is a floating-point number");
    }
}
</code></pre>
<p>感谢<a href="https://github.com/calebsander">Caleb Sander</a>为实现此功能的付出。</p>
<h3 id="警告-2"><a class="header" href="#警告-2">警告</a></h3>
<p>BigInt仅在目标为<code>esnext</code>时才支持。 可能不是很明显的一点是，因为BigInts针对算术运算符<code>+</code>, <code>-</code>, <code>*</code>等具有不同的行为，为老旧版（如<code>es2017</code>及以下）提供此功能时意味着重写出现它们的每一个操作。 TypeScript需根据类型和涉及到的每一处加法，字符串拼接，乘法等产生正确的行为。</p>
<p>因为这个原因，我们不会立即提供向下的支持。 好的一面是，Node 11和较新版本的Chrome已经支持了这个特性，因此你可以在目标为<code>esnext</code>时，使用BigInt。</p>
<p>一些目标可能包含polyfill或类似BigInt的运行时对象。 基于这些考虑，你可能会想要添加<code>esnext.bigint</code>到<code>lib</code>编译选项里。</p>
<h2 id="non-unit-types-as-union-discriminants"><a class="header" href="#non-unit-types-as-union-discriminants">Non-unit types as union discriminants</a></h2>
<p>TypeScript 3.2放宽了作为判别式属性的限制，来让类型细化变得容易。 如果联合类型的共同属性包含了_某些_单体类型（如，字面符字面量，<code>null</code>或<code>undefined</code>）且不包含泛型，那么它就可以做为判别式。</p>
<p>因此，TypeScript 3.2认为下例中的<code>error</code>属性可以做为判别式。这在之前是不可以的，因为<code>Error</code>并非是一个单体类型。 那么，<code>unwrap</code>函数体里的类型细化就可以正确地工作了。</p>
<pre><code class="language-typescript">type Result&lt;T&gt; =
    | { error: Error; data: null }
    | { error: null; data: T };

function unwrap&lt;T&gt;(result: Result&lt;T&gt;) {
    if (result.error) {
        // Here 'error' is non-null
        throw result.error;
    }

    // Now 'data' is non-null
    return result.data;
}
</code></pre>
<h2 id="tsconfigjson可以通过nodejs包来继承"><a class="header" href="#tsconfigjson可以通过nodejs包来继承"><code>tsconfig.json</code>可以通过Node.js包来继承</a></h2>
<p>TypeScript 3.2现在可以从<code>node_modules</code>里解析<code>tsconfig.json</code>。如果<code>tsconfig.json</code>文件里的<code>"extends"</code>设置为空，那么TypeScript会检测<code>node_modules</code>包。 When using a bare path for the <code>"extends"</code> field in <code>tsconfig.json</code>, TypeScript will dive into <code>node_modules</code> packages for us.</p>
<pre><code class="language-text">{
    "extends": "@my-team/tsconfig-base",
    "include": ["./**/*"]
    "compilerOptions": {
        // Override certain options on a project-by-project basis.
        "strictBindCallApply": false,
    }
}
</code></pre>
<p>这里，TypeScript会去<code>node_modules</code>目录里查找<code>@my-team/tsconfig-base</code>包。针对每一个包，TypeScript检查<code>package.json</code>里是否包含<code>"tsconfig"</code>字段，如果是，TypeScript会尝试从那里加载配置文件。如果两者都不存在，TypeScript尝试从根目录读取<code>tsconfig.json</code>。这与Nodejs查找<code>.js</code>文件或TypeScript查找<code>.d.ts</code>文件的已有过程类似。</p>
<p>这个特性对于大型组织或具有很多分布的依赖的工程特别有帮助。</p>
<h2 id="the-new---showconfig-flag"><a class="header" href="#the-new---showconfig-flag">The new <code>--showConfig</code> flag</a></h2>
<p><code>tsc</code>，TypeScript编译器，支持一个新的标记<code>--showConfig</code>。 运行<code>tsc --showConfig</code>时，TypeScript计算生效的<code>tsconfig.json</code>并打印（继承的配置也会计算在内）。 这对于调试诊断配置问题很有帮助。</p>
<h2 id="javascript的objectdefineproperty声明"><a class="header" href="#javascript的objectdefineproperty声明">JavaScript的<code>Object.defineProperty</code>声明</a></h2>
<p>在编写JavaScript文件时（使用<code>allowJs</code>），TypeScript能识别出使用<code>Object.defineProperty</code>声明。 也就是说会有更好的代码补全功能，和强类型检查，这需要在JavaScript文件里启用类型检查功能（打开<code>checkJs</code>选项或在文件顶端添加<code>// @ts-check</code>注释）。</p>
<pre><code class="language-javascript">// @ts-check

let obj = {};
Object.defineProperty(obj, "x", { value: "hello", writable: false });

obj.x.toLowercase();
//    ~~~~~~~~~~~
//    error:
//     Property 'toLowercase' does not exist on type 'string'.
//     Did you mean 'toLowerCase'?

obj.x = "world";
//  ~
//  error:
//   Cannot assign to 'x' because it is a read-only property.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-31"><a class="header" href="#typescript-31">TypeScript 3.1</a></h1>
<h2 id="元组和数组上的映射类型"><a class="header" href="#元组和数组上的映射类型">元组和数组上的映射类型</a></h2>
<p>TypeScript 3.1，在元组和数组上的映射对象类型现在会生成新的元组/数组，而非创建一个新的类型并且这个类型上具有如<code>push()</code>，<code>pop()</code>和<code>length</code>这样的成员。 例子：</p>
<pre><code class="language-typescript">type MapToPromise&lt;T&gt; = { [K in keyof T]: Promise&lt;T[K]&gt; };

type Coordinate = [number, number]

type PromiseCoordinate = MapToPromise&lt;Coordinate&gt;; // [Promise&lt;number&gt;, Promise&lt;number&gt;]
</code></pre>
<p><code>MapToPromise</code>接收参数<code>T</code>，当它是个像<code>Coordinate</code>这样的元组时，只有数值型属性会被转换。 <code>[number, number]</code>具有两个数值型属性：<code>0</code>和<code>1</code>。 针对这样的数组，<code>MapToPromise</code>会创建一个新的元组，<code>0</code>和<code>1</code>属性是原类型的一个<code>Promise</code>。 因此<code>PromiseCoordinate</code>的类型为<code>[Promise&lt;number&gt;, Promise&lt;number&gt;]</code>。</p>
<h2 id="函数上的属性声明"><a class="header" href="#函数上的属性声明">函数上的属性声明</a></h2>
<p>TypeScript 3.1提供了在函数声明上定义属性的能力，还支持<code>const</code>声明的函数。只需要在函数直接给属性赋值就可以了。 这样我们就可以规范JavaScript代码，不必再借助于<code>namespace</code>。 例子：</p>
<pre><code class="language-typescript">function readImage(path: string, callback: (err: any, image: Image) =&gt; void) {
    // ...
}

readImage.sync = (path: string) =&gt; {
    const contents = fs.readFileSync(path);
    return decodeImageSync(contents);
}
</code></pre>
<p>这里，<code>readImage</code>函数异步地读取一张图片。 此外，我们还在<code>readImage</code>上提供了一个便捷的函数<code>readImage.sync</code>。</p>
<p>一般来说，使用ECMAScript导出是个更好的方式，但这个新功能支持此风格的代码能够在TypeScript里执行。 此外，这种属性声明的方式允许我们表达一些常见的模式，例如React函数组件（之前叫做SFC）里的<code>defaultProps</code>和<code>propTpes</code> 。</p>
<pre><code class="language-typescript">export const FooComponent = ({ name }) =&gt; (
    &lt;div&gt;Hello! I am {name}&lt;/div&gt;
);

FooComponent.defaultProps = {
    name: "(anonymous)",
};
</code></pre>
<p>[1] 更确切地说，是上面那种同态映射类型。</p>
<h2 id="使用typesversions选择版本-1"><a class="header" href="#使用typesversions选择版本-1">使用<code>typesVersions</code>选择版本</a></h2>
<p>由社区的反馈还有我们的经验得知，利用最新的TypeScript功能的同时容纳旧版本的用户很困难。 TypeScript引入了叫做<code>typesVersions</code>的新特性来解决这种情况。</p>
<p>在TypeScript 3.1里使用Node模块解析时，TypeScript会读取<code>package.json</code>文件，找到它需要读取的文件，它首先会查看名字为<code>typesVersions</code>的字段。 一个带有<code>typesVersions</code>字段的<code>package.json</code>文件：</p>
<pre><code class="language-javascript">{
  "name": "package-name",
  "version": "1.0",
  "types": "./index.d.ts",
  "typesVersions": {
    "&gt;=3.1": { "*": ["ts3.1/*"] }
  }
}
</code></pre>
<p><code>package.json</code>告诉TypeScript去检查当前版本的TypeScript是否正在运行。 如果是3.1或以上的版本，它会找出你导入的包的路径，然后读取这个包里面的<code>ts3.1</code>文件夹里的内容。 这就是<code>{ "*": ["ts3.1/*"] }</code>的意义 - 如果你对路径映射熟悉，它们的工作方式类似。</p>
<p>因此在上例中，如果我们正在从<code>"package-name"</code>中导入，并且正在运行的TypeScript版本为3.1，我们会尝试从<code>[...]/node_modules/package-name/ts3.1/index.d.ts</code>开始解析。 如果是从<code>package-name/foo</code>导入，由会查找<code>[...]/node_modules/package-name/ts3.1/foo.d.ts</code>和<code>[...]/node_modules/package-name/ts3.1/foo/index.d.ts</code>。</p>
<p>那如果当前运行的TypeScript版本不是3.1呢？ 如果<code>typesVersions</code>里没有能匹配上的版本，TypeScript将回退到查看<code>types</code>字段，因此TypeScript 3.0及之前的版本会重定向到<code>[...]/node_modules/package-name/index.d.ts</code>。</p>
<h3 id="匹配行为-1"><a class="header" href="#匹配行为-1">匹配行为</a></h3>
<p>TypeScript使用Node的<a href="https://github.com/npm/node-semver#ranges">semver ranges</a>去决定编译器和语言版本。</p>
<h3 id="多个字段"><a class="header" href="#多个字段">多个字段</a></h3>
<p><code>typesVersions</code>支持多个字段，每个字段都指定了一个匹配范围。</p>
<pre><code class="language-javascript">{
  "name": "package-name",
  "version": "1.0",
  "types": "./index.d.ts",
  "typesVersions": {
    "&gt;=3.2": { "*": ["ts3.2/*"] },
    "&gt;=3.1": { "*": ["ts3.1/*"] }
  }
}
</code></pre>
<p>因为范围可能会重叠，因此指定的顺序是有意义的。 在上例中，尽管<code>&gt;=3.2</code>和<code>&gt;=3.1</code>都匹配TypeScript 3.2及以上版本，反转它们的顺序将会有不同的结果，因此上例与下面的代码并不等同。</p>
<pre><code class="language-text">{
  "name": "package-name",
  "version": "1.0",
  "types": "./index.d.ts",
  "typesVersions": {
    // 注意，这样写不生效
    "&gt;=3.1": { "*": ["ts3.1/*"] },
    "&gt;=3.2": { "*": ["ts3.2/*"] }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-30"><a class="header" href="#typescript-30">TypeScript 3.0</a></h1>
<h2 id="工程引用-1"><a class="header" href="#工程引用-1">工程引用</a></h2>
<p>TypeScript 3.0 引入了一个叫做工程引用的新概念。工程引用允许TypeScript工程依赖于其它TypeScript工程 - 特别要提的是允许<code>tsconfig.json</code>文件引用其它<code>tsconfig.json</code>文件。当指明了这些依赖后，就可以方便地将代码分割成单独的小工程，有助于TypeScript（以及周边的工具）了解构建顺序和输出结构。</p>
<p>TypeScript 3.0 还引入了一种新的<code>tsc</code>模式，即<code>--build</code>标记，它与工程引用同时运用可以加速构建TypeScript。</p>
<p>相关详情请阅读<a href="zh/release-notes/../project-config/project-references.html">工程引用手册</a>。</p>
<h2 id="剩余参数和展开表达式里的元组"><a class="header" href="#剩余参数和展开表达式里的元组">剩余参数和展开表达式里的元组</a></h2>
<p>TypeScript 3.0 增加了支持以元组类型与函数参数列表进行交互的能力。 如下：</p>
<ul>
<li><a href="zh/release-notes/typescript-3.0.html#rest-parameters-with-tuple-types">将带有元组类型的剩余参数扩展为离散参数</a></li>
<li><a href="zh/release-notes/typescript-3.0.html#spread-expressions-with-tuple-types">将带有元组类型的展开表达式扩展为离散参数</a></li>
<li><a href="zh/release-notes/typescript-3.0.html#generic-rest-parameters">泛型剩余参数以及相应的元组类型推断</a></li>
<li><a href="zh/release-notes/typescript-3.0.html#optional-elements-in-tuple-types">元组类型里的可选元素</a></li>
<li><a href="zh/release-notes/typescript-3.0.html#rest-elements-in-tuple-types">元组类型里的剩余元素</a></li>
</ul>
<p>有了这些特性后，便有可能将转换函数和它们参数列表的高阶函数变为强类型的。</p>
<h3 id="带元组类型的剩余参数"><a class="header" href="#带元组类型的剩余参数">带元组类型的剩余参数</a></h3>
<p>当剩余参数里有元组类型时，元组类型被扩展为离散参数序列。 例如，如下两个声明是等价的：</p>
<pre><code class="language-typescript">declare function foo(...args: [number, string, boolean]): void;
</code></pre>
<pre><code class="language-typescript">declare function foo(args_0: number, args_1: string, args_2: boolean): void;
</code></pre>
<h3 id="带有元组类型的展开表达式"><a class="header" href="#带有元组类型的展开表达式">带有元组类型的展开表达式</a></h3>
<p>在函数调用中，若最后一个参数是元组类型的展开表达式，那么这个展开表达式相当于元组元素类型的离散参数序列。</p>
<p>因此，下面的调用都是等价的：</p>
<pre><code class="language-typescript">const args: [number, string, boolean] = [42, "hello", true];
foo(42, "hello", true);
foo(args[0], args[1], args[2]);
foo(...args);
</code></pre>
<h3 id="泛型剩余参数"><a class="header" href="#泛型剩余参数">泛型剩余参数</a></h3>
<p>剩余参数允许带有泛型类型，这个泛型类型被限制为是一个数组类型，类型推断系统能够推断这类泛型剩余参数里的元组类型。这样就可以进行高阶捕获和展开部分参数列表:</p>
<h4 id="例子-17"><a class="header" href="#例子-17">例子</a></h4>
<pre><code class="language-typescript">declare function bind&lt;T, U extends any[], V&gt;(f: (x: T, ...args: U) =&gt; V, x: T): (...args: U) =&gt; V;

declare function f3(x: number, y: string, z: boolean): void;

const f2 = bind(f3, 42);  // (y: string, z: boolean) =&gt; void
const f1 = bind(f2, "hello");  // (z: boolean) =&gt; void
const f0 = bind(f1, true);  // () =&gt; void

f3(42, "hello", true);
f2("hello", true);
f1(true);
f0();
</code></pre>
<p>上例的<code>f2</code>声明，类型推断可以推断出<code>number</code>，<code>[string, boolean]</code>和<code>void</code>做为<code>T</code>，<code>U</code>和<code>V</code>。</p>
<p>注意，如果元组类型是从参数序列中推断出来的，之后又扩展成参数列表，就像<code>U</code>那样，原来的参数名称会被用在扩展中（然而，这个名字没有语义上的意义且是察觉不到的）。</p>
<h3 id="元组类型里的可选元素"><a class="header" href="#元组类型里的可选元素">元组类型里的可选元素</a></h3>
<p>元组类型现在允许在其元素类型上使用<code>?</code>后缀，表示这个元素是可选的：</p>
<h4 id="例子-18"><a class="header" href="#例子-18">例子</a></h4>
<pre><code class="language-typescript">let t: [number, string?, boolean?];
t = [42, "hello", true];
t = [42, "hello"];
t = [42];
</code></pre>
<p>在<code>--strictNullChecks</code>模式下，<code>?</code>修饰符会自动地在元素类型中包含<code>undefined</code>，类似于可选参数。</p>
<p>在元组类型的一个元素类型上使用<code>?</code>后缀修饰符来把它标记为可忽略的元素，且它右侧所有元素也同时带有了<code>?</code>修饰符。</p>
<p>当剩余参数推断为元组类型时，源码中的可选参数在推断出的类型里成为了可选元组元素。</p>
<p>带有可选元素的元组类型的<code>length</code>属性是表示可能长度的数字字面量类型的联合类型。 例如，<code>[number, string?, boolean?]</code>元组类型的<code>length</code>属性的类型是<code>1 | 2 | 3</code>。</p>
<h3 id="元组类型里的剩余元素"><a class="header" href="#元组类型里的剩余元素">元组类型里的剩余元素</a></h3>
<p>元组类型里最后一个元素可以是剩余元素，形式为<code>...X</code>，这里<code>X</code>是数组类型。 剩余元素代表元组类型是开放的，可以有零个或多个额外的元素。 例如，<code>[number, ...string[]]</code>表示带有一个<code>number</code>元素和任意数量<code>string</code>类型元素的元组类型。</p>
<h4 id="例子-19"><a class="header" href="#例子-19">例子</a></h4>
<pre><code class="language-typescript">function tuple&lt;T extends any[]&gt;(...args: T): T {
    return args;
}

const numbers: number[] = getArrayOfNumbers();
const t1 = tuple("foo", 1, true);  // [string, number, boolean]
const t2 = tuple("bar", ...numbers);  // [string, ...number[]]
</code></pre>
<p>这个带有剩余元素的元组类型的<code>length</code>属性类型是<code>number</code>。</p>
<h2 id="新的unknown类型"><a class="header" href="#新的unknown类型">新的<code>unknown</code>类型</a></h2>
<p>TypeScript 3.0引入了一个顶级的<code>unknown</code>类型。 对照于<code>any</code>，<code>unknown</code>是类型安全的。 任何值都可以赋给<code>unknown</code>，但是当没有类型断言或基于控制流的类型细化时<code>unknown</code>不可以赋值给其它类型，除了它自己和<code>any</code>外。 同样地，在<code>unknown</code>没有被断言或细化到一个确切类型之前，是不允许在其上进行任何操作的。</p>
<h3 id="例子-20"><a class="header" href="#例子-20">例子</a></h3>
<pre><code class="language-typescript">// In an intersection everything absorbs unknown

type T00 = unknown &amp; null;  // null
type T01 = unknown &amp; undefined;  // undefined
type T02 = unknown &amp; null &amp; undefined;  // null &amp; undefined (which becomes never)
type T03 = unknown &amp; string;  // string
type T04 = unknown &amp; string[];  // string[]
type T05 = unknown &amp; unknown;  // unknown
type T06 = unknown &amp; any;  // any

// In a union an unknown absorbs everything

type T10 = unknown | null;  // unknown
type T11 = unknown | undefined;  // unknown
type T12 = unknown | null | undefined;  // unknown
type T13 = unknown | string;  // unknown
type T14 = unknown | string[];  // unknown
type T15 = unknown | unknown;  // unknown
type T16 = unknown | any;  // any

// Type variable and unknown in union and intersection

type T20&lt;T&gt; = T &amp; {};  // T &amp; {}
type T21&lt;T&gt; = T | {};  // T | {}
type T22&lt;T&gt; = T &amp; unknown;  // T
type T23&lt;T&gt; = T | unknown;  // unknown

// unknown in conditional types

type T30&lt;T&gt; = unknown extends T ? true : false;  // Deferred
type T31&lt;T&gt; = T extends unknown ? true : false;  // Deferred (so it distributes)
type T32&lt;T&gt; = never extends T ? true : false;  // true
type T33&lt;T&gt; = T extends never ? true : false;  // Deferred

// keyof unknown

type T40 = keyof any;  // string | number | symbol
type T41 = keyof unknown;  // never

// Only equality operators are allowed with unknown

function f10(x: unknown) {
    x == 5;
    x !== 10;
    x &gt;= 0;  // Error
    x + 1;  // Error
    x * 2;  // Error
    -x;  // Error
    +x;  // Error
}

// No property accesses, element accesses, or function calls

function f11(x: unknown) {
    x.foo;  // Error
    x[5];  // Error
    x();  // Error
    new x();  // Error
}

// typeof, instanceof, and user defined type predicates

declare function isFunction(x: unknown): x is Function;

function f20(x: unknown) {
    if (typeof x === "string" || typeof x === "number") {
        x;  // string | number
    }
    if (x instanceof Error) {
        x;  // Error
    }
    if (isFunction(x)) {
        x;  // Function
    }
}

// Homomorphic mapped type over unknown

type T50&lt;T&gt; = { [P in keyof T]: number };
type T51 = T50&lt;any&gt;;  // { [x: string]: number }
type T52 = T50&lt;unknown&gt;;  // {}

// Anything is assignable to unknown

function f21&lt;T&gt;(pAny: any, pNever: never, pT: T) {
    let x: unknown;
    x = 123;
    x = "hello";
    x = [1, 2, 3];
    x = new Error();
    x = x;
    x = pAny;
    x = pNever;
    x = pT;
}

// unknown assignable only to itself and any

function f22(x: unknown) {
    let v1: any = x;
    let v2: unknown = x;
    let v3: object = x;  // Error
    let v4: string = x;  // Error
    let v5: string[] = x;  // Error
    let v6: {} = x;  // Error
    let v7: {} | null | undefined = x;  // Error
}

// Type parameter 'T extends unknown' not related to object

function f23&lt;T extends unknown&gt;(x: T) {
    let y: object = x;  // Error
}

// Anything but primitive assignable to { [x: string]: unknown }

function f24(x: { [x: string]: unknown }) {
    x = {};
    x = { a: 5 };
    x = [1, 2, 3];
    x = 123;  // Error
}

// Locals of type unknown always considered initialized

function f25() {
    let x: unknown;
    let y = x;
}

// Spread of unknown causes result to be unknown

function f26(x: {}, y: unknown, z: any) {
    let o1 = { a: 42, ...x };  // { a: number }
    let o2 = { a: 42, ...x, ...y };  // unknown
    let o3 = { a: 42, ...x, ...y, ...z };  // any
}

// Functions with unknown return type don't need return expressions

function f27(): unknown {
}

// Rest type cannot be created from unknown

function f28(x: unknown) {
    let { ...a } = x;  // Error
}

// Class properties of type unknown don't need definite assignment

class C1 {
    a: string;  // Error
    b: unknown;
    c: any;
}
</code></pre>
<h2 id="在jsx里支持defaultprops"><a class="header" href="#在jsx里支持defaultprops">在JSX里支持<code>defaultProps</code></a></h2>
<p>TypeScript 2.9和之前的版本不支持在JSX组件里使用<a href="https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values">React的<code>defaultProps</code></a>声明。 用户通常不得不将属性声明为可选的，然后在<code>render</code>里使用非<code>null</code>的断言，或者在导出之前对组件的类型使用类型断言。</p>
<p>TypeScript 3.0在<code>JSX</code>命名空间里支持一个新的类型别名<code>LibraryManagedAttributes</code>。 这个助手类型定义了在检查JSX表达式之前在组件<code>Props</code>上的一个类型转换；因此我们可以进行定制：如何处理提供的<code>props</code>与推断<code>props</code>之间的冲突，推断如何映射，如何处理可选性以及不同位置的推断如何结合在一起。</p>
<p>我们可以利用它来处理React的<code>defaultProps</code>以及<code>propTypes</code>。</p>
<pre><code class="language-text">export interface Props {
    name: string;
}

export class Greet extends React.Component&lt;Props&gt; {
    render() {
        const { name } = this.props;
        return &lt;div&gt;Hello {name.toUpperCase()}!&lt;/div&gt;;
    }
    static defaultProps = { name: "world"};
}

// Type-checks! No type assertions needed!
let el = &lt;Greet /&gt;
</code></pre>
<h3 id="说明-1"><a class="header" href="#说明-1">说明</a></h3>
<h4 id="defaultprops的确切类型"><a class="header" href="#defaultprops的确切类型"><code>defaultProps</code>的确切类型</a></h4>
<p>默认类型是从<code>defaultProps</code>属性的类型推断而来。如果添加了显式的类型注释，比如<code>static defaultProps: Partial&lt;Props&gt;;</code>，编译器无法识别哪个属性具有默认值（因为<code>defaultProps</code>类型包含了<code>Props</code>的所有属性）。</p>
<p>使用<code>static defaultProps: Pick&lt;Props, "name"&gt;;</code>做为显式的类型注释，或者不添加类型注释。</p>
<p>对于函数组件（之前叫做SFC），使用ES2015默认的初始化器：</p>
<pre><code class="language-text">function Greet({ name = "world" }: Props) {
    return &lt;div&gt;Hello {name.toUpperCase()}!&lt;/div&gt;;
}
</code></pre>
<h4 id="typesreact的改动"><a class="header" href="#typesreact的改动"><code>@types/React</code>的改动</a></h4>
<p>仍需要在<code>@types/React</code>里<code>JSX</code>命名空间上添加<code>LibraryManagedAttributes</code>定义。</p>
<h2 id="-reference-lib-指令"><a class="header" href="#-reference-lib-指令"><code>/// &lt;reference lib="..." /&gt;</code>指令</a></h2>
<p>TypeScript增加了一个新的三斜线指令（<code>/// &lt;reference lib="name" /&gt;</code>），允许一个文件显式地包含一个已知的内置_lib_文件。</p>
<p>内置的_lib_文件的引用和_tsconfig.json_里的编译器选项<code>"lib"</code>相同（例如，使用<code>lib="es2015"</code>而不是<code>lib="lib.es2015.d.ts"</code>等）。</p>
<p>当你写的声明文件依赖于内置类型时，例如DOM APIs或内置的JS运行时构造函数如<code>Symbol</code>或<code>Iterable</code>，推荐使用三斜线引用指令。之前，这个<code>.d.ts</code>文件不得不添加重覆的类型声明。</p>
<h3 id="例子-21"><a class="header" href="#例子-21">例子</a></h3>
<p>在某个文件里使用 <code>/// &lt;reference lib="es2017.string" /&gt;</code>等同于指定<code>--lib es2017.string</code>编译选项。</p>
<pre><code class="language-typescript">/// &lt;reference lib="es2017.string" /&gt;

"foo".padStart(4);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-29"><a class="header" href="#typescript-29">TypeScript 2.9</a></h1>
<h2 id="keyof和映射类型支持用number和symbol命名的属性"><a class="header" href="#keyof和映射类型支持用number和symbol命名的属性"><code>keyof</code>和映射类型支持用<code>number</code>和<code>symbol</code>命名的属性</a></h2>
<p>TypeScript 2.9增加了在索引类型和映射类型上支持用<code>number</code>和<code>symbol</code>命名属性。 在之前，<code>keyof</code>操作符和映射类型只支持<code>string</code>命名的属性。</p>
<p>改动包括：</p>
<ul>
<li>对某些类型<code>T</code>，索引类型<code>keyof T</code>是<code>string | number | symbol</code>的子类型。</li>
<li>映射类型<code>{ [P in K]: XXX }</code>，其中<code>K</code>允许是可以赋值给<code>string | number | symbol</code>的任何值。</li>
<li>针对泛型<code>T</code>的对象的<code>for...in</code>语句，迭代变量推断类型之前为<code>keyof T</code>，现在是<code>Extract&lt;keyof T, string&gt;</code>。（换句话说，是<code>keyof T</code>的子集，它仅包含类字符串的值。）</li>
</ul>
<p>对于对象类型<code>X</code>，<code>keyof X</code>将按以下方式解析：</p>
<ul>
<li>如果<code>X</code>带有字符串索引签名，则<code>keyof X</code>为<code>string</code>，<code>number</code>和表示symbol-like属性的字面量类型的联合，否则</li>
<li>如果<code>X</code>带有数字索引签名，则<code>keyof X</code>为<code>number</code>和表示string-like和symbol-like属性的字面量类型的联合，否则</li>
<li><code>keyof X</code>为表示string-like，number-like和symbol-like属性的字面量类型的联合。</li>
</ul>
<p>在何处：</p>
<ul>
<li>对象类型的string-like属性，是那些使用标识符，字符串字面量或计算后值为字符串字面量类型的属性名所声明的。</li>
<li>对象类型的number-like属性是那些使用数字字面量或计算后值为数字字面量类型的属性名所声明的。</li>
<li>对象类型的symbol-like属性是那些使用计算后值为symbol字面量类型的属性名所声明的。</li>
</ul>
<p>对于映射类型<code>{ [P in K]: XXX }</code>，<code>K</code>的每个字符串字面量类型都会引入一个名字为字符串的属性，<code>K</code>的每个数字字面量类型都会引入一个名字为数字的属性，<code>K</code>的每个symbol字面量类型都会引入一个名字为symbol的属性。 并且，如果<code>K</code>包含<code>string</code>类型，那个同时也会引入字符串索引类型，如果<code>K</code>包含<code>number</code>类型，那个同时也会引入数字索引类型。</p>
<h3 id="例子-22"><a class="header" href="#例子-22">例子</a></h3>
<pre><code class="language-typescript">const c = "c";
const d = 10;
const e = Symbol();

const enum E1 { A, B, C }
const enum E2 { A = "A", B = "B", C = "C" }

type Foo = {
    a: string;       // String-like name
    5: string;       // Number-like name
    [c]: string;     // String-like name
    [d]: string;     // Number-like name
    [e]: string;     // Symbol-like name
    [E1.A]: string;  // Number-like name
    [E2.A]: string;  // String-like name
}

type K1 = keyof Foo;  // "a" | 5 | "c" | 10 | typeof e | E1.A | E2.A
type K2 = Extract&lt;keyof Foo, string&gt;;  // "a" | "c" | E2.A
type K3 = Extract&lt;keyof Foo, number&gt;;  // 5 | 10 | E1.A
type K4 = Extract&lt;keyof Foo, symbol&gt;;  // typeof e
</code></pre>
<p>现在通过在键值类型里包含<code>number</code>类型，<code>keyof</code>就能反映出数字索引签名的存在，因此像<code>Partial&lt;T&gt;</code>和<code>Readonly&lt;T&gt;</code>的映射类型能够正确地处理带数字索引签名的对象类型：</p>
<pre><code class="language-typescript">type Arrayish&lt;T&gt; = {
    length: number;
    [x: number]: T;
}

type ReadonlyArrayish&lt;T&gt; = Readonly&lt;Arrayish&lt;T&gt;&gt;;

declare const map: ReadonlyArrayish&lt;string&gt;;
let n = map.length;
let x = map[123];  // Previously of type any (or an error with --noImplicitAny)
</code></pre>
<p>此外，由于<code>keyof</code>支持用<code>number</code>和<code>symbol</code>命名的键值，现在可以对对象的数字字面量（如数字枚举类型）和唯一的symbol属性的访问进行抽象。</p>
<pre><code class="language-typescript">const enum Enum { A, B, C }

const enumToStringMap = {
    [Enum.A]: "Name A",
    [Enum.B]: "Name B",
    [Enum.C]: "Name C"
}

const sym1 = Symbol();
const sym2 = Symbol();
const sym3 = Symbol();

const symbolToNumberMap = {
    [sym1]: 1,
    [sym2]: 2,
    [sym3]: 3
};

type KE = keyof typeof enumToStringMap;     // Enum (i.e. Enum.A | Enum.B | Enum.C)
type KS = keyof typeof symbolToNumberMap;   // typeof sym1 | typeof sym2 | typeof sym3

function getValue&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
    return obj[key];
}

let x1 = getValue(enumToStringMap, Enum.C);  // Returns "Name C"
let x2 = getValue(symbolToNumberMap, sym3);  // Returns 3
</code></pre>
<p>这是一个破坏性改动；之前，<code>keyof</code>操作符和映射类型只支持<code>string</code>命名的属性。 那些把总是把<code>keyof T</code>的类型当做<code>string</code>的代码现在会报错。</p>
<h3 id="例子-23"><a class="header" href="#例子-23">例子</a></h3>
<pre><code class="language-typescript">function useKey&lt;T, K extends keyof T&gt;(o: T, k: K) {
    var name: string = k;  // 错误：keyof T不能赋值给字符串
}
</code></pre>
<h3 id="推荐"><a class="header" href="#推荐">推荐</a></h3>
<ul>
<li>
<p>如果函数只能处理字符串命名属性的键，在声明里使用<code>Extract&lt;keyof T, string&gt;</code>：</p>
<pre><code class="language-typescript">function useKey&lt;T, K extends Extract&lt;keyof T, string&gt;&gt;(o: T, k: K) {
  var name: string = k;  // OK
}
</code></pre>
</li>
<li>
<p>如果函数能处理任何属性的键，那么可以在下游进行改动：</p>
<pre><code class="language-typescript">function useKey&lt;T, K extends keyof T&gt;(o: T, k: K) {
  var name: string | number | symbol = k;
}
</code></pre>
</li>
<li>
<p>否则，使用<code>--keyofStringsOnly</code>编译器选项来禁用新的行为。</p>
</li>
</ul>
<h2 id="jsx元素里的泛型参数"><a class="header" href="#jsx元素里的泛型参数">JSX元素里的泛型参数</a></h2>
<p>JSX元素现在允许传入类型参数到泛型组件里。</p>
<h3 id="例子-24"><a class="header" href="#例子-24">例子</a></h3>
<pre><code class="language-typescript">class GenericComponent&lt;P&gt; extends React.Component&lt;P&gt; {
    internalProp: P;
}

type Props = { a: number; b: string; };

const x = &lt;GenericComponent&lt;Props&gt; a={10} b="hi"/&gt;; // OK

const y = &lt;GenericComponent&lt;Props&gt; a={10} b={20} /&gt;; // Error
</code></pre>
<h2 id="泛型标记模版里的泛型参数"><a class="header" href="#泛型标记模版里的泛型参数">泛型标记模版里的泛型参数</a></h2>
<p>标记模版是ECMAScript 2015引入的一种调用形式。 类似调用表达式，可以在标记模版里使用泛型函数，TypeScript会推断使用的类型参数。</p>
<p>TypeScript 2.9允许传入泛型参数到标记模版字符串。</p>
<h3 id="例子-25"><a class="header" href="#例子-25">例子</a></h3>
<pre><code class="language-typescript">declare function styledComponent&lt;Props&gt;(strs: TemplateStringsArray): Component&lt;Props&gt;;

interface MyProps {
  name: string;
  age: number;
}

styledComponent&lt;MyProps&gt; `
  font-size: 1.5em;
  text-align: center;
  color: palevioletred;
`;

declare function tag&lt;T&gt;(strs: TemplateStringsArray, ...args: T[]): T;

// inference fails because 'number' and 'string' are both candidates that conflict
let a = tag&lt;string | number&gt; `${100} ${"hello"}`;
</code></pre>
<h2 id="import类型"><a class="header" href="#import类型"><code>import</code>类型</a></h2>
<p>模块可以导入在其它模块里声明的类型。但是非模块的全局脚本不能访问模块里声明的类型。这里，<code>import</code>类型登场了。</p>
<p>在类型注释的位置使用<code>import("mod")</code>，就可以访问一个模块和它导出的声明，而不必导入它。</p>
<h3 id="例子-26"><a class="header" href="#例子-26">例子</a></h3>
<p>在一个模块文件里，有一个<code>Pet</code>类的声明：</p>
<pre><code class="language-typescript">// module.d.ts

export declare class Pet {
   name: string;
}
</code></pre>
<p>它可以被用在非模块文件<code>global-script.ts</code>：</p>
<pre><code class="language-typescript">// global-script.ts

function adopt(p: import("./module").Pet) {
    console.log(`Adopting ${p.name}...`);
}
</code></pre>
<p>它也可以被放在<code>.js</code>文件的JSDoc注释里，来引用模块里的类型：</p>
<pre><code class="language-javascript">// a.js

/**
 * @param p { import("./module").Pet }
 */
function walk(p) {
    console.log(`Walking ${p.name}...`);
}
</code></pre>
<h2 id="放开声明生成时可见性规则"><a class="header" href="#放开声明生成时可见性规则">放开声明生成时可见性规则</a></h2>
<p>随着<code>import</code>类型的到来，许多在声明文件生成阶段报的可见性错误可以被编译器正确地处理，而不需要改变输入。</p>
<p>例如：</p>
<pre><code class="language-typescript">import { createHash } from "crypto";

export const hash = createHash("sha256");
//           ^^^^
// Exported variable 'hash' has or is using name 'Hash' from external module "crypto" but cannot be named.
</code></pre>
<p>TypeScript 2.9不会报错，生成文件如下：</p>
<pre><code class="language-typescript">export declare const hash: import("crypto").Hash;
</code></pre>
<h2 id="支持importmeta"><a class="header" href="#支持importmeta">支持<code>import.meta</code></a></h2>
<p>TypeScript 2.9引入对<code>import.meta</code>的支持，它是当前<a href="https://github.com/tc39/proposal-import-meta">TC39建议</a>里的一个元属性。</p>
<p><code>import.meta</code>类型是全局的<code>ImportMeta</code>类型，它在<code>lib.es5.d.ts</code>里定义。 这个接口地使用十分有限。 添加众所周知的Node和浏览器属性需要进行接口合并，还有可能需要根据上下文来增加全局空间。</p>
<h3 id="例子-27"><a class="header" href="#例子-27">例子</a></h3>
<p>假设<code>__dirname</code>永远存在于<code>import.meta</code>，那么可以通过重新开放<code>ImportMeta</code>接口来进行声明：</p>
<pre><code class="language-typescript">// node.d.ts
interface ImportMeta {
    __dirname: string;
}
</code></pre>
<p>用法如下：</p>
<pre><code class="language-typescript">import.meta.__dirname // Has type 'string'
</code></pre>
<p><code>import.meta</code>仅在输出目标为<code>ESNext</code>模块和ECMAScript时才生效。</p>
<h2 id="新的--resolvejsonmodule"><a class="header" href="#新的--resolvejsonmodule">新的<code>--resolveJsonModule</code></a></h2>
<p>在Node.js应用里经常需要使用<code>.json</code>。TypeScript 2.9的<code>--resolveJsonModule</code>允许从<code>.json</code>文件里导入，获取类型。</p>
<h3 id="例子-28"><a class="header" href="#例子-28">例子</a></h3>
<pre><code class="language-typescript">// settings.json

{
    "repo": "TypeScript",
    "dry": false,
    "debug": false
}
</code></pre>
<pre><code class="language-typescript">// a.ts

import settings from "./settings.json";

settings.debug === true;  // OK
settings.dry === 2;  // Error: Operator '===' cannot be applied boolean and number
</code></pre>
<pre><code class="language-typescript">// tsconfig.json

{
    "compilerOptions": {
        "module": "commonjs",
        "resolveJsonModule": true,
        "esModuleInterop": true
    }
}
</code></pre>
<h2 id="默认--pretty输出"><a class="header" href="#默认--pretty输出">默认<code>--pretty</code>输出</a></h2>
<p>从TypeScript 2.9开始，如果应用支持彩色文字，那么错误输出时会默认应用<code>--pretty</code>。 TypeScript会检查输出流是否设置了<a href="https://nodejs.org/api/tty.html"><code>isTty</code></a>属性。</p>
<p>使用<code>--pretty false</code>命令行选项或<code>tsconfig.json</code>里设置<code>"pretty": false</code>来禁用<code>--pretty</code>输出。</p>
<h2 id="新的--declarationmap"><a class="header" href="#新的--declarationmap">新的<code>--declarationMap</code></a></h2>
<p>随着<code>--declaration</code>一起启用<code>--declarationMap</code>，编译器在生成<code>.d.ts</code>的同时还会生成<code>.d.ts.map</code>。 语言服务现在也能够理解这些map文件，将声明文件映射到源码。</p>
<p>换句话说，在启用了<code>--declarationMap</code>后生成的<code>.d.ts</code>文件里点击go-to-definition，将会导航到源文件里的位置（<code>.ts</code>），而不是导航到<code>.d.ts</code>文件里。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-28"><a class="header" href="#typescript-28">TypeScript 2.8</a></h1>
<h2 id="有条件类型-1"><a class="header" href="#有条件类型-1">有条件类型</a></h2>
<p>TypeScript 2.8引入了_有条件类型_，它能够表示非统一的类型。 有条件的类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：</p>
<pre><code class="language-typescript">T extends U ? X : Y
</code></pre>
<p>上面的类型意思是，若<code>T</code>能够赋值给<code>U</code>，那么类型是<code>X</code>，否则为<code>Y</code>。</p>
<p>有条件的类型<code>T extends U ? X : Y</code>或者_解析_为<code>X</code>，或者_解析_为<code>Y</code>，再或者_延迟_解析，因为它可能依赖一个或多个类型变量。 是否直接解析或推迟取决于：</p>
<ul>
<li>首先，令<code>T'</code>和<code>U'</code>分别为<code>T</code>和<code>U</code>的实例，并将所有类型参数替换为<code>any</code>，如果<code>T'</code>不能赋值给<code>U'</code>，则将有条件的类型解析成<code>Y</code>。直观上讲，如果最宽泛的<code>T</code>的实例不能赋值给最宽泛的<code>U</code>的实例，那么我们就可以断定不存在可以赋值的实例，因此可以解析为<code>Y</code>。</li>
<li>其次，针对每个在<code>U</code>内由<code>推断</code>声明引入的类型变量，依据从<code>T</code>推断到<code>U</code>来收集一组候选类型（使用与泛型函数类型推断相同的推断算法）。对于给定的<code>推断</code>类型变量<code>V</code>，如果有候选类型是从协变的位置上推断出来的，那么<code>V</code>的类型是那些候选类型的联合。反之，如果有候选类型是从逆变的位置上推断出来的，那么<code>V</code>的类型是那些候选类型的交叉类型。否则<code>V</code>的类型是<code>never</code>。</li>
<li>然后，令<code>T''</code>为<code>T</code>的一个实例，所有<code>推断</code>的类型变量用上一步的推断结果替换，如果<code>T''</code>_明显可赋值_给<code>U</code>，那么将有条件的类型解析为<code>X</code>。除去不考虑类型变量的限制之外，_明显可赋值_的关系与正常的赋值关系一致。直观上，当一个类型明显可赋值给另一个类型，我们就能够知道它可以赋值给那些类型的_所有_实例。</li>
<li>否则，这个条件依赖于一个或多个类型变量，有条件的类型解析被推迟进行。</li>
</ul>
<h4 id="例子-29"><a class="header" href="#例子-29">例子</a></h4>
<pre><code class="language-typescript">type TypeName&lt;T&gt; =
    T extends string ? "string" :
    T extends number ? "number" :
    T extends boolean ? "boolean" :
    T extends undefined ? "undefined" :
    T extends Function ? "function" :
    "object";

type T0 = TypeName&lt;string&gt;;  // "string"
type T1 = TypeName&lt;"a"&gt;;  // "string"
type T2 = TypeName&lt;true&gt;;  // "boolean"
type T3 = TypeName&lt;() =&gt; void&gt;;  // "function"
type T4 = TypeName&lt;string[]&gt;;  // "object"
</code></pre>
<h3 id="分布式有条件类型-1"><a class="header" href="#分布式有条件类型-1">分布式有条件类型</a></h3>
<p>如果有条件类型里待检查的类型是<code>naked type parameter</code>，那么它也被称为“分布式有条件类型”。 分布式有条件类型在实例化时会自动分发成联合类型。 例如，实例化<code>T extends U ? X : Y</code>，<code>T</code>的类型为<code>A | B | C</code>，会被解析为<code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>。</p>
<h4 id="例子-30"><a class="header" href="#例子-30">例子</a></h4>
<pre><code class="language-typescript">type T10 = TypeName&lt;string | (() =&gt; void)&gt;;  // "string" | "function"
type T12 = TypeName&lt;string | string[] | undefined&gt;;  // "string" | "object" | "undefined"
type T11 = TypeName&lt;string[] | number[]&gt;;  // "object"
</code></pre>
<p>在<code>T extends U ? X : Y</code>的实例化里，对<code>T</code>的引用被解析为联合类型的一部分（比如，<code>T</code>指向某一单个部分，在有条件类型分布到联合类型之后）。 此外，在<code>X</code>内对<code>T</code>的引用有一个附加的类型参数约束<code>U</code>（例如，<code>T</code>被当成在<code>X</code>内可赋值给<code>U</code>）。</p>
<h4 id="例子-31"><a class="header" href="#例子-31">例子</a></h4>
<pre><code class="language-typescript">type BoxedValue&lt;T&gt; = { value: T };
type BoxedArray&lt;T&gt; = { array: T[] };
type Boxed&lt;T&gt; = T extends any[] ? BoxedArray&lt;T[number]&gt; : BoxedValue&lt;T&gt;;

type T20 = Boxed&lt;string&gt;;  // BoxedValue&lt;string&gt;;
type T21 = Boxed&lt;number[]&gt;;  // BoxedArray&lt;number&gt;;
type T22 = Boxed&lt;string | number[]&gt;;  // BoxedValue&lt;string&gt; | BoxedArray&lt;number&gt;;
</code></pre>
<p>注意在<code>Boxed&lt;T&gt;</code>的<code>true</code>分支里，<code>T</code>有个额外的约束<code>any[]</code>，因此它适用于<code>T[number]</code>数组元素类型。同时也注意一下有条件类型是如何分布成联合类型的。</p>
<p>有条件类型的分布式的属性可以方便地用来_过滤_联合类型：</p>
<pre><code class="language-typescript">type Diff&lt;T, U&gt; = T extends U ? never : T;  // Remove types from T that are assignable to U
type Filter&lt;T, U&gt; = T extends U ? T : never;  // Remove types from T that are not assignable to U

type T30 = Diff&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "b" | "d"
type T31 = Filter&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "a" | "c"
type T32 = Diff&lt;string | number | (() =&gt; void), Function&gt;;  // string | number
type T33 = Filter&lt;string | number | (() =&gt; void), Function&gt;;  // () =&gt; void

type NonNullable&lt;T&gt; = Diff&lt;T, null | undefined&gt;;  // Remove null and undefined from T

type T34 = NonNullable&lt;string | number | undefined&gt;;  // string | number
type T35 = NonNullable&lt;string | string[] | null | undefined&gt;;  // string | string[]

function f1&lt;T&gt;(x: T, y: NonNullable&lt;T&gt;) {
    x = y;  // Ok
    y = x;  // Error
}

function f2&lt;T extends string | undefined&gt;(x: T, y: NonNullable&lt;T&gt;) {
    x = y;  // Ok
    y = x;  // Error
    let s1: string = x;  // Error
    let s2: string = y;  // Ok
}
</code></pre>
<p>有条件类型与映射类型结合时特别有用：</p>
<pre><code class="language-typescript">type FunctionPropertyNames&lt;T&gt; = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];
type FunctionProperties&lt;T&gt; = Pick&lt;T, FunctionPropertyNames&lt;T&gt;&gt;;

type NonFunctionPropertyNames&lt;T&gt; = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];
type NonFunctionProperties&lt;T&gt; = Pick&lt;T, NonFunctionPropertyNames&lt;T&gt;&gt;;

interface Part {
    id: number;
    name: string;
    subparts: Part[];
    updatePart(newName: string): void;
}

type T40 = FunctionPropertyNames&lt;Part&gt;;  // "updatePart"
type T41 = NonFunctionPropertyNames&lt;Part&gt;;  // "id" | "name" | "subparts"
type T42 = FunctionProperties&lt;Part&gt;;  // { updatePart(newName: string): void }
type T43 = NonFunctionProperties&lt;Part&gt;;  // { id: number, name: string, subparts: Part[] }
</code></pre>
<p>与联合类型和交叉类型相似，有条件类型不允许递归地引用自己。比如下面的错误。</p>
<h4 id="例子-32"><a class="header" href="#例子-32">例子</a></h4>
<pre><code class="language-typescript">type ElementType&lt;T&gt; = T extends any[] ? ElementType&lt;T[number]&gt; : T;  // Error
</code></pre>
<h3 id="有条件类型中的类型推断-1"><a class="header" href="#有条件类型中的类型推断-1">有条件类型中的类型推断</a></h3>
<p>现在在有条件类型的<code>extends</code>子语句中，允许出现<code>infer</code>声明，它会引入一个待推断的类型变量。 这个推断的类型变量可以在有条件类型的true分支中被引用。 允许出现多个同类型变量的<code>infer</code>。</p>
<p>例如，下面代码会提取函数类型的返回值类型：</p>
<pre><code class="language-typescript">type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;
</code></pre>
<p>有条件类型可以嵌套来构成一系列的匹配模式，按顺序进行求值：</p>
<pre><code class="language-typescript">type Unpacked&lt;T&gt; =
    T extends (infer U)[] ? U :
    T extends (...args: any[]) =&gt; infer U ? U :
    T extends Promise&lt;infer U&gt; ? U :
    T;

type T0 = Unpacked&lt;string&gt;;  // string
type T1 = Unpacked&lt;string[]&gt;;  // string
type T2 = Unpacked&lt;() =&gt; string&gt;;  // string
type T3 = Unpacked&lt;Promise&lt;string&gt;&gt;;  // string
type T4 = Unpacked&lt;Promise&lt;string&gt;[]&gt;;  // Promise&lt;string&gt;
type T5 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;;  // string
</code></pre>
<p>下面的例子解释了在协变位置上，同一个类型变量的多个候选类型会被推断为联合类型：</p>
<pre><code class="language-typescript">type Foo&lt;T&gt; = T extends { a: infer U, b: infer U } ? U : never;
type T10 = Foo&lt;{ a: string, b: string }&gt;;  // string
type T11 = Foo&lt;{ a: string, b: number }&gt;;  // string | number
</code></pre>
<p>相似地，在抗变位置上，同一个类型变量的多个候选类型会被推断为交叉类型：</p>
<pre><code class="language-typescript">type Bar&lt;T&gt; = T extends { a: (x: infer U) =&gt; void, b: (x: infer U) =&gt; void } ? U : never;
type T20 = Bar&lt;{ a: (x: string) =&gt; void, b: (x: string) =&gt; void }&gt;;  // string
type T21 = Bar&lt;{ a: (x: string) =&gt; void, b: (x: number) =&gt; void }&gt;;  // string &amp; number
</code></pre>
<p>当推断具有多个调用签名（例如函数重载类型）的类型时，用_最后_的签名（大概是最自由的包含所有情况的签名）进行推断。 无法根据参数类型列表来解析重载。</p>
<pre><code class="language-typescript">declare function foo(x: string): number;
declare function foo(x: number): string;
declare function foo(x: string | number): string | number;
type T30 = ReturnType&lt;typeof foo&gt;;  // string | number
</code></pre>
<p>无法在正常类型参数的约束子语句中使用<code>infer</code>声明：</p>
<pre><code class="language-typescript">type ReturnType&lt;T extends (...args: any[]) =&gt; infer R&gt; = R;  // 错误，不支持
</code></pre>
<p>但是，可以这样达到同样的效果，在约束里删掉类型变量，用有条件类型替换：</p>
<pre><code class="language-typescript">type AnyFunction = (...args: any[]) =&gt; any;
type ReturnType&lt;T extends AnyFunction&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;
</code></pre>
<h3 id="预定义的有条件类型-1"><a class="header" href="#预定义的有条件类型-1">预定义的有条件类型</a></h3>
<p>TypeScript 2.8在<code>lib.d.ts</code>里增加了一些预定义的有条件类型：</p>
<ul>
<li><code>Exclude&lt;T, U&gt;</code> -- 从<code>T</code>中剔除可以赋值给<code>U</code>的类型。</li>
<li><code>Extract&lt;T, U&gt;</code> -- 提取<code>T</code>中可以赋值给<code>U</code>的类型。</li>
<li><code>NonNullable&lt;T&gt;</code> -- 从<code>T</code>中剔除<code>null</code>和<code>undefined</code>。</li>
<li><code>ReturnType&lt;T&gt;</code> -- 获取函数返回值类型。</li>
<li><code>InstanceType&lt;T&gt;</code> -- 获取构造函数类型的实例类型。</li>
</ul>
<h4 id="example-3"><a class="header" href="#example-3">Example</a></h4>
<pre><code class="language-typescript">type T00 = Exclude&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "b" | "d"
type T01 = Extract&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "a" | "c"

type T02 = Exclude&lt;string | number | (() =&gt; void), Function&gt;;  // string | number
type T03 = Extract&lt;string | number | (() =&gt; void), Function&gt;;  // () =&gt; void

type T04 = NonNullable&lt;string | number | undefined&gt;;  // string | number
type T05 = NonNullable&lt;(() =&gt; string) | string[] | null | undefined&gt;;  // (() =&gt; string) | string[]

function f1(s: string) {
    return { a: 1, b: s };
}

class C {
    x = 0;
    y = 0;
}

type T10 = ReturnType&lt;() =&gt; string&gt;;  // string
type T11 = ReturnType&lt;(s: string) =&gt; void&gt;;  // void
type T12 = ReturnType&lt;(&lt;T&gt;() =&gt; T)&gt;;  // {}
type T13 = ReturnType&lt;(&lt;T extends U, U extends number[]&gt;() =&gt; T)&gt;;  // number[]
type T14 = ReturnType&lt;typeof f1&gt;;  // { a: number, b: string }
type T15 = ReturnType&lt;any&gt;;  // any
type T16 = ReturnType&lt;never&gt;;  // any
type T17 = ReturnType&lt;string&gt;;  // Error
type T18 = ReturnType&lt;Function&gt;;  // Error

type T20 = InstanceType&lt;typeof C&gt;;  // C
type T21 = InstanceType&lt;any&gt;;  // any
type T22 = InstanceType&lt;never&gt;;  // any
type T23 = InstanceType&lt;string&gt;;  // Error
type T24 = InstanceType&lt;Function&gt;;  // Error
</code></pre>
<blockquote>
<p>注意：<code>Exclude</code>类型是<a href="https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458">建议的</a><code>Diff</code>类型的一种实现。我们使用<code>Exclude</code>这个名字是为了避免破坏已经定义了<code>Diff</code>的代码，并且我们感觉这个名字能更好地表达类型的语义。我们没有增加<code>Omit&lt;T, K&gt;</code>类型，因为它可以很容易的用<code>Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</code>来表示。</p>
</blockquote>
<h2 id="改进对映射类型修饰符的控制"><a class="header" href="#改进对映射类型修饰符的控制">改进对映射类型修饰符的控制</a></h2>
<p>映射类型支持在属性上添加<code>readonly</code>或<code>?</code>修饰符，但是它们不支持_移除_修饰符。 这对于<a href="https://github.com/Microsoft/TypeScript/pull/12563"><em>同态映射类型</em></a>有些影响，因为同态映射类型默认保留底层类型的修饰符。</p>
<p>TypeScript 2.8为映射类型增加了增加或移除特定修饰符的能力。 特别地，映射类型里的<code>readonly</code>或<code>?</code>属性修饰符现在可以使用<code>+</code>或<code>-</code>前缀，来表示修饰符是添加还是移除。</p>
<h4 id="例子-33"><a class="header" href="#例子-33">例子</a></h4>
<pre><code class="language-typescript">type MutableRequired&lt;T&gt; = { -readonly [P in keyof T]-?: T[P] };  // 移除readonly和?
type ReadonlyPartial&lt;T&gt; = { +readonly [P in keyof T]+?: T[P] };  // 添加readonly和?
</code></pre>
<p>不带<code>+</code>或<code>-</code>前缀的修饰符与带<code>+</code>前缀的修饰符具有相同的作用。因此上面的<code>ReadonlyPartial&lt;T&gt;</code>类型与下面的一致</p>
<pre><code class="language-typescript">type ReadonlyPartial&lt;T&gt; = { readonly [P in keyof T]?: T[P] };  // 添加readonly和?
</code></pre>
<p>利用这个特性，<code>lib.d.ts</code>现在有了一个新的<code>Required&lt;T&gt;</code>类型。 它移除了<code>T</code>的所有属性的<code>?</code>修饰符，因此所有属性都是必需的。</p>
<h4 id="例子-34"><a class="header" href="#例子-34">例子</a></h4>
<pre><code class="language-typescript">type Required&lt;T&gt; = { [P in keyof T]-?: T[P] };
</code></pre>
<p>注意在<code>--strictNullChecks</code>模式下，当同态映射类型移除了属性底层类型的<code>?</code>修饰符，它同时也移除了那个属性上的<code>undefined</code>类型：</p>
<h4 id="例子-35"><a class="header" href="#例子-35">例子</a></h4>
<pre><code class="language-typescript">type Foo = { a?: string };  // 等同于 { a?: string | undefined }
type Bar = Required&lt;Foo&gt;;  // 等同于 { a: string }
</code></pre>
<h2 id="改进交叉类型上的keyof"><a class="header" href="#改进交叉类型上的keyof">改进交叉类型上的<code>keyof</code></a></h2>
<p>TypeScript 2.8作用于交叉类型的<code>keyof</code>被转换成作用于交叉成员的<code>keyof</code>的联合。 换句话说，<code>keyof (A &amp; B)</code>会被转换成<code>keyof A | keyof B</code>。 这个改动应该能够解决<code>keyof</code>表达式推断不一致的问题。</p>
<h4 id="例子-36"><a class="header" href="#例子-36">例子</a></h4>
<pre><code class="language-typescript">type A = { a: string };
type B = { b: string };

type T1 = keyof (A &amp; B);  // "a" | "b"
type T2&lt;T&gt; = keyof (T &amp; B);  // keyof T | "b"
type T3&lt;U&gt; = keyof (A &amp; U);  // "a" | keyof U
type T4&lt;T, U&gt; = keyof (T &amp; U);  // keyof T | keyof U
type T5 = T2&lt;A&gt;;  // "a" | "b"
type T6 = T3&lt;B&gt;;  // "a" | "b"
type T7 = T4&lt;A, B&gt;;  // "a" | "b"
</code></pre>
<h2 id="更好的处理js文件中的命名空间模式"><a class="header" href="#更好的处理js文件中的命名空间模式">更好的处理<code>.js</code>文件中的命名空间模式</a></h2>
<p>TypeScript 2.8加强了识别<code>.js</code>文件里的命名空间模式。 JavaScript顶层的空对象字面量声明，就像函数和类，会被识别成命名空间声明。</p>
<pre><code class="language-javascript">var ns = {};     // recognized as a declaration for a namespace `ns`
ns.constant = 1; // recognized as a declaration for var `constant`
</code></pre>
<p>顶层的赋值应该有一致的行为；也就是说，<code>var</code>或<code>const</code>声明不是必需的。</p>
<pre><code class="language-javascript">app = {}; // does NOT need to be `var app = {}`
app.C = class {
};
app.f = function() {
};
app.prop = 1;
</code></pre>
<h3 id="立即执行的函数表达式做为命名空间"><a class="header" href="#立即执行的函数表达式做为命名空间">立即执行的函数表达式做为命名空间</a></h3>
<p>立即执行的函数表达式返回一个函数，类或空的对象字面量，也会被识别为命名空间：</p>
<pre><code class="language-javascript">var C = (function () {
  function C(n) {
    this.p = n;
  }
  return C;
})();
C.staticProperty = 1;
</code></pre>
<h3 id="默认声明"><a class="header" href="#默认声明">默认声明</a></h3>
<p>“默认声明”允许引用了声明的名称的初始化器出现在逻辑或的左边：</p>
<pre><code class="language-javascript">my = window.my || {};
my.app = my.app || {};
</code></pre>
<h3 id="原型赋值"><a class="header" href="#原型赋值">原型赋值</a></h3>
<p>你可以把一个对象字面量直接赋值给原型属性。独立的原型赋值也可以：</p>
<pre><code class="language-typescript">var C = function (p) {
  this.p = p;
};
C.prototype = {
  m() {
    console.log(this.p);
  }
};
C.prototype.q = function(r) {
  return this.p === r;
};
</code></pre>
<h3 id="嵌套与合并声明"><a class="header" href="#嵌套与合并声明">嵌套与合并声明</a></h3>
<p>现在嵌套的层次不受限制，并且多文件之间的声明合并也没有问题。以前不是这样的。</p>
<pre><code class="language-javascript">var app = window.app || {};
app.C = class { };
</code></pre>
<h2 id="各文件的jsx工厂"><a class="header" href="#各文件的jsx工厂">各文件的JSX工厂</a></h2>
<p>TypeScript 2.8增加了使用<code>@jsx dom</code>指令为每个文件设置JSX工厂名。 JSX工厂也可以使用<code>--jsxFactory</code>编译参数设置（默认值为<code>React.createElement</code>）。TypeScript 2.8你可以基于文件进行覆写。</p>
<h4 id="例子-37"><a class="header" href="#例子-37">例子</a></h4>
<pre><code class="language-typescript">/** @jsx dom */
import { dom } from "./renderer"
&lt;h&gt;&lt;/h&gt;
</code></pre>
<p>生成：</p>
<pre><code class="language-javascript">var renderer_1 = require("./renderer");
renderer_1.dom("h", null);
</code></pre>
<h2 id="本地范围的jsx命名空间"><a class="header" href="#本地范围的jsx命名空间">本地范围的JSX命名空间</a></h2>
<p>JSX类型检查基于JSX命名空间里的定义，比如<code>JSX.Element</code>用于JSX元素的类型，<code>JSX.IntrinsicElements</code>用于内置的元素。 在TypeScript 2.8之前<code>JSX</code>命名空间被视为全局命名空间，并且一个工程只允许存在一个。 TypeScript 2.8开始，<code>JSX</code>命名空间将在<code>jsxNamespace</code>下面查找（比如<code>React</code>），允许在一次编译中存在多个jsx工厂。 为了向后兼容，全局的<code>JSX</code>命名空间被当做回退选项。 使用独立的<code>@jsx</code>指令，每个文件可以有自己的JSX工厂。</p>
<h2 id="新的--emitdeclarationsonly"><a class="header" href="#新的--emitdeclarationsonly">新的<code>--emitDeclarationsOnly</code></a></h2>
<p><code>--emitDeclarationsOnly</code>允许_仅_生成声明文件；使用这个标记<code>.js</code>/<code>.jsx</code>输出会被跳过。当使用其它的转换工具如Babel处理<code>.js</code>输出的时候，可以使用这个标记。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-27"><a class="header" href="#typescript-27">TypeScript 2.7</a></h1>
<h2 id="typescript-27-1"><a class="header" href="#typescript-27-1">TypeScript 2.7</a></h2>
<h3 id="常量名属性"><a class="header" href="#常量名属性">常量名属性</a></h3>
<p>TypeScript 2.7 新增了以常量（包括ECMAScript symbols）作为类属性名的类型推断支持。</p>
<h4 id="例子-38"><a class="header" href="#例子-38">例子</a></h4>
<pre><code class="language-typescript">// Lib
export const SERIALIZE = Symbol("serialize-method-key");

export interface Serializable {
    [SERIALIZE](obj: {}): string;
}
</code></pre>
<pre><code class="language-typescript">// consumer
import { SERIALIZE, Serializable } from "lib";

class JSONSerializableItem implements Serializable {
    [SERIALIZE](obj: {}) {
        return JSON.stringify(obj);
    }
}
</code></pre>
<p>这同样适用于数字和字符串的字面量</p>
<h4 id="例子-39"><a class="header" href="#例子-39">例子</a></h4>
<pre><code class="language-typescript">const Foo = "Foo";
const Bar = "Bar";

let x = {
    [Foo]: 100,
    [Bar]: "hello",
};

let a = x[Foo]; // a类型为'number'; 在之前版本，类型为'number | string'，现在可以追踪到类型
let b = x[Bar]; // b类型为'string';
</code></pre>
<h3 id="unique-symbol类型"><a class="header" href="#unique-symbol类型"><code>unique symbol</code>类型</a></h3>
<p>为了将symbol变量视作有唯一值的字面量，我们新增了类型<code>unique symbol</code>。 <code>unique symbol</code>是<code>symbol</code>的子类型，仅由调用<code>Symbol()</code>或<code>Symbol.for()</code>或明确的类型注释生成。 该类型只允许在<code>const</code>声明或者 <code>readonly static</code> 属性声明中使用。如果要引用某个特定的<code>unique symbol</code>变量，你必须使用<code>typeof</code>操作符。 每个对<code>unique symbols</code>的引用都意味着一个完全唯一的声明身份，与被引用的变量声明绑定。</p>
<h4 id="例子-40"><a class="header" href="#例子-40">例子</a></h4>
<pre><code class="language-typescript">// Works
declare const Foo: unique symbol;

// Error! 'Bar'不是const声明的
let Bar: unique symbol = Symbol();

// Works - 对变量Foo的引用，它的声明身份与Foo绑定
let Baz: typeof Foo = Foo;

// Also works.
class C {
    static readonly StaticSymbol: unique symbol = Symbol();
}
</code></pre>
<p>因为每个<code>unique symbols</code>都有个完全独立的身份，因此两个<code>unique symbols</code>类型之间不能赋值或比较。</p>
<h4 id="example-4"><a class="header" href="#example-4">Example</a></h4>
<pre><code class="language-typescript">const Foo = Symbol();
const Bar = Symbol();

// Error: 不能比较两个unique symbols.
if (Foo === Bar) {
    // ...
}
</code></pre>
<h3 id="更严格的类属性检查"><a class="header" href="#更严格的类属性检查">更严格的类属性检查</a></h3>
<p>TypeScript 2.7引入了一个新的控制严格性的标记<code>--strictPropertyInitialization</code>。 使用这个标记后，TypeScript要求类的所有实例属性在构造函数里或属性初始化器中都得到初始化。比如：</p>
<pre><code class="language-typescript">class C {
    foo: number;
    bar = "hello";
    baz: boolean;
//  ~~~
//  Error! Property 'baz' has no initializer and is not assigned directly in the constructor.
    constructor() {
        this.foo = 42;
    }
}
</code></pre>
<p>上例中，<code>baz</code>从未被赋值，因此TypeScript报错了。 如果我们的本意就是让<code>baz</code>可以为<code>undefined</code>，那么应该声明它的类型为<code>boolean | undefined</code>。</p>
<p>在某些场景下，属性会被间接地初始化（使用辅助方法或依赖注入库）。 这种情况下，你可以在属性上使用_显式赋值断言_（<em>definite assignment assertion modifiers</em>）来帮助类型系统识别类型（下面会讨论）</p>
<pre><code class="language-typescript">class C {
    foo!: number;
    // ^
    // Notice this exclamation point!
    // This is the "definite assignment assertion" modifier.
    constructor() {
        this.initialize();
    }

    initialize() {
        this.foo = 0;
    }
}
</code></pre>
<p>注意，<code>--strictPropertyInitialization</code>会在其它<code>--strict</code>模式标记下被启用，这可能会影响你的工程。 你可以在<code>tsconfig.json</code>的<code>compilerOptions</code>里将<code>strictPropertyInitialization</code>设置为<code>false</code>， 或者在命令行上将<code>--strictPropertyInitialization</code>设置为<code>false</code>来关闭检查。</p>
<h3 id="显式赋值断言"><a class="header" href="#显式赋值断言">显式赋值断言</a></h3>
<p>显式赋值断言允许你在实例属性和变量声明之后加一个感叹号<code>!</code>，来告诉TypeScript这个变量确实已被赋值，即使TypeScript不能分析出这个结果。</p>
<h4 id="例子-41"><a class="header" href="#例子-41">例子</a></h4>
<pre><code class="language-typescript">let x: number;
initialize();
console.log(x + x);
//          ~   ~
// Error! Variable 'x' is used before being assigned.

function initialize() {
    x = 10;
}
</code></pre>
<p>使用显式类型断言在<code>x</code>的声明后加上<code>!</code>，Typescript可以认为变量<code>x</code>确实已被赋值</p>
<pre><code class="language-typescript">// Notice the '!'
let x!: number;
initialize();

// No error!
console.log(x + x);

function initialize() {
    x = 10;
}
</code></pre>
<p>在某种意义上，显式类型断言运算符是非空断言运算符（在表达式后缀的<code>!</code>）的对偶，就像下面这个例子</p>
<pre><code class="language-typescript">let x: number;
initialize();

// No error!
console.log(x! + x!);

function initialize() {
    x = 10;
</code></pre>
<p>在上面的例子中，我们知道<code>x</code>都会被初始化，因此使用显式类型断言比使用非空断言更合适。</p>
<h3 id="固定长度元组"><a class="header" href="#固定长度元组">固定长度元组</a></h3>
<p>TypeScript 2.6之前，<code>[number, string, string]</code>被当作<code>[number, string]</code>的子类型。 这对于TypeScript的结构性而言是合理的——<code>[number, string, string]</code>的前两个元素各自是<code>[number, string]</code>里前两个元素的子类型。 但是，我们注意到在在实践中的大多数情形下，这并不是开发者所希望的。</p>
<p>在TypeScript 2.7中，具有不同元数的元组不再允许相互赋值。感谢<a href="https://github.com/tycho01">Tycho Grouwstra</a>提交的PR，元组类型现在会将它们的元数编码进它们对应的<code>length</code>属性的类型里。原理是利用数字字面量类型区分出不同长度的元组。</p>
<p>概念上讲，你可以把<code>[number, string]</code>类型等同于下面的<code>NumStrTuple</code>声明：</p>
<pre><code class="language-typescript">interface NumStrTuple extends Array&lt;number | string&gt; {
    0: number;
    1: string;
    length: 2; // 注意length的类型是字面量'2'，而不是'number'
}
</code></pre>
<p>请注意，这是一个破坏性改动。 如果你想要和以前一样，让元组仅限制最小长度，那么你可以使用一个类似的声明但不显式指定<code>length</code>属性，这样<code>length</code>属性的类型就会回退为<code>number</code></p>
<pre><code class="language-typescript">interface MinimumNumStrTuple extends Array&lt;number | string&gt; {
    0: number;
    1: string;
}
</code></pre>
<p>注：这并不意味着元组是不可变长的数组，而仅仅是一个约定。</p>
<h3 id="更优的对象字面量推断"><a class="header" href="#更优的对象字面量推断">更优的对象字面量推断</a></h3>
<p>TypeScript 2.7改进了在同一上下文中的多对象字面量的类型推断。 当多个对象字面量类型组成一个联合类型，TypeScript现在会将它们_规范化_为一个对象类型，该对象类型包含联合类型中的每个对象的所有属性，以及属性对应的推断类型。</p>
<p>考虑这样的情形:</p>
<pre><code class="language-typescript">const obj = test ? { text: "hello" } : {};  // { text: string } | { text?: undefined }
const s = obj.text;  // string | undefined
</code></pre>
<p>以前<code>obj</code>会被推断为<code>{}</code>，第二行会报错因为<code>obj</code>没有属性。但这显然并不理想。</p>
<p><strong>例子</strong></p>
<pre><code class="language-typescript">// let obj: { a: number, b: number } |
//     { a: string, b?: undefined } |
//     { a?: undefined, b?: undefined }
let obj = [{ a: 1, b: 2 }, { a: "abc" }, {}][0];
obj.a;  // string | number | undefined
obj.b;  // number | undefined
</code></pre>
<p>多个对象字面量中的同一属性的所有推断类型，会合并成一个规范化的联合类型：</p>
<pre><code class="language-typescript">declare function f&lt;T&gt;(...items: T[]): T;
// let obj: { a: number, b: number } |
//     { a: string, b?: undefined } |
//     { a?: undefined, b?: undefined }
let obj = f({ a: 1, b: 2 }, { a: "abc" }, {});
obj.a;  // string | number | undefined
obj.b;  // number | undefined
</code></pre>
<h3 id="结构相同的类和instanceof表达式的处理方式改进"><a class="header" href="#结构相同的类和instanceof表达式的处理方式改进">结构相同的类和<code>instanceof</code>表达式的处理方式改进</a></h3>
<p>TypeScript 2.7对联合类型中结构相同的类和<code>instanceof</code>表达式的处理方式改进如下：</p>
<ul>
<li>联合类型中，结构相同的不同类都会保留（而不是只保留一个）</li>
<li>联合类型中的子类型简化仅在一种情况下发生——若一个类继承自联合类型中另一个类，该子类会被简化。</li>
<li>用于类型检查的<code>instanceof</code>操作符基于继承关系来判断，而不是结构兼容来判断。</li>
</ul>
<p>这意味着联合类型和<code>instanceof</code>能够区分结构相同的类。</p>
<p><strong>例子</strong></p>
<pre><code class="language-typescript">class A {}
class B extends A {}
class C extends A {}
class D extends A { c: string }
class E extends D {}

let x1 = !true ? new A() : new B();  // A
let x2 = !true ? new B() : new C();  // B | C (previously B)
let x3 = !true ? new C() : new D();  // C | D (previously C)

let a1 = [new A(), new B(), new C(), new D(), new E()];  // A[]
let a2 = [new B(), new C(), new D(), new E()];  // (B | C | D)[] (previously B[])

function f1(x: B | C | D) {
    if (x instanceof B) {
        x;  // B (previously B | D)
    }
    else if (x instanceof C) {
        x;  // C
    }
    else {
        x;  // D (previously never)
    }
}
</code></pre>
<h3 id="in运算符实现类型保护"><a class="header" href="#in运算符实现类型保护"><code>in</code>运算符实现类型保护</a></h3>
<p><code>in</code>运算符现在会起到类型细化的作用。</p>
<p>对于一个<code>n in x</code>的表达式，当<code>n</code>是一个字符串字面量或者字符串字面量类型，并且<code>x</code>是一个联合类型： 在值为"true"的分支中，<code>x</code>会有一个推断出来可选或被赋值的属性<code>n</code>；在值为"false"的分支中，<code>x</code>根据推断仅有可选的属性<code>n</code>或没有属性<code>n</code>。</p>
<h4 id="例子-42"><a class="header" href="#例子-42">例子</a></h4>
<pre><code class="language-typescript">interface A { a: number };
interface B { b: string };

function foo(x: A | B) {
    if ("a" in x) {
        return x.a;
    }
    return x.b; // 此时x的类型推断为B, 属性a不存在
}
</code></pre>
<h2 id="使用标记--esmoduleinterop引入非es模块"><a class="header" href="#使用标记--esmoduleinterop引入非es模块">使用标记<code>--esModuleInterop</code>引入非ES模块</a></h2>
<p>在TypeScript 2.7使用<code>--esModuleInterop</code>标记后，为_CommonJS/AMD/UMD_模块生成基于<code>__esModule</code>指示器的命名空间记录。这次更新使得TypeScript编译后的输出与Babel的输出更加接近。</p>
<p>之前版本中，TypeScript处理_CommonJS/AMD/UMD_模块的方式与处理ES6模块一致，导致了一些问题，比如：</p>
<ul>
<li>TypeScript之前处理CommonJS/AMD/UMD模块的命名空间导入（如<code>import * as foo from "foo"</code>）时等同于<code>const foo = require("foo")</code>。这样做很简单，但如果引入的主要对象（比如这里的foo）是基本类型、类或者函数，就有问题。ECMAScript标准规定了命名空间记录是一个纯粹的对象，并且引入的命名空间（比如前面的<code>foo</code>）应该是不可调用的，然而在TypeScript却中可以。</li>
<li>同样地，一个CommonJS/AMD/UMD模块的默认导入（如<code>import d from "foo"</code>）被处理成等同于 <code>const d = require("foo").default</code>的形式。然而现在大多数可用的CommonJS/AMD/UMD模块并没有默认导出，导致这种引入语句在实践中不适用于非ES模块。比如 <code>import fs from "fs"</code> or <code>import express from "express"</code> 都不可用。</li>
</ul>
<p>在使用标签<code>--esModuleInterop</code>后，这两个问题都得到了解决：</p>
<ul>
<li>命名空间导入（如<code>import * as foo from "foo"</code>）的对象现在被修正为不可调用的。调用会报错。</li>
<li>对CommonJS/AMD/UMD模块可以使用默认导入（如<code>import d from "foo"</code>）且能正常工作了。</li>
</ul>
<blockquote>
<p>注: 这个新特性有可能对现有的代码产生破坏，因此以标记的方式引入。但无论是新项目还是之前的项目，<strong>我们都强烈建议使用它</strong>。对于之前的项目，命名空间导入 (<code>import * as express from "express"; express();</code>) 需要被改写成默认引入 (<code>import express from "express"; express();</code>).</p>
</blockquote>
<h4 id="例子-43"><a class="header" href="#例子-43">例子</a></h4>
<p>使用 <code>--esModuleInterop</code> 后，会生成两个新的辅助量 <code>__importStar</code> and <code>__importDefault</code> ，分别对应导入<code>*</code>和导入<code>default</code>，比如这样的输入：</p>
<pre><code class="language-typescript">import * as foo from "foo";
import b from "bar";
</code></pre>
<p>会生成：</p>
<pre><code class="language-typescript">"use strict";
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
}
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
}
exports.__esModule = true;
var foo = __importStar(require("foo"));
var bar_1 = __importDefault(require("bar"));
</code></pre>
<h3 id="数字分隔符"><a class="header" href="#数字分隔符">数字分隔符</a></h3>
<p>TypeScript 2.7支持ECMAScript的<a href="https://github.com/tc39/proposal-numeric-separator">数字分隔符提案</a>。 这个特性允许用户在数字之间使用下划线<code>_</code>来对数字分组。</p>
<pre><code class="language-typescript">const million = 1_000_000;
const phone = 555_734_2231;
const bytes = 0xFF_0C_00_FF;
const word = 0b1100_0011_1101_0001;
</code></pre>
<h3 id="--watch模式下具有更简洁的输出"><a class="header" href="#--watch模式下具有更简洁的输出">--watch模式下具有更简洁的输出</a></h3>
<p>在TypeScript的<code>--watch</code>模式下进行重新编译后会清屏。 这样就更方便阅读最近这次编译的输出信息。</p>
<h3 id="更漂亮的--pretty输出"><a class="header" href="#更漂亮的--pretty输出">更漂亮的<code>--pretty</code>输出</a></h3>
<p>TypeScript的<code>--pretty</code>标记可以让错误信息更易阅读和管理。 我们对这个功能进行了两个主要的改进。 首先，<code>--pretty</code>对文件名，诊段代码和行数添加了颜色（感谢Joshua Goldberg）。 其次，格式化了文件名和位置，以便于在常用的终端里使用Ctrl+Click，Cmd+Click，Alt+Click等来跳转到编译器里的相应位置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-26"><a class="header" href="#typescript-26">TypeScript 2.6</a></h1>
<h2 id="严格函数类型"><a class="header" href="#严格函数类型">严格函数类型</a></h2>
<p>TypeScript 2.6引入了新的类型检查选项，<code>--strictFunctionTypes</code>。<code>--strictFunctionTypes</code>选项是<code>--strict</code>系列选项之一，也就是说 <code>--strict</code>模式下它默认是启用的。你可以通过在命令行或tsconfig.json中设置<code>--strictFunctionTypes false</code>来单独禁用它。</p>
<p><code>--strictFunctionTypes</code>启用时，函数类型参数的检查是_抗变（contravariantly）_而非_双变（bivariantly）_的。关于变体 (variance) 对于函数类型意义的相关背景，请查看<a href="https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance">协变（covariance）和抗变（contravariance）是什么？</a>。</p>
<p>这一更严格的检查应用于除方法或构造函数声明以外的所有函数类型。方法被专门排除在外是为了确保带泛型的类和接口（如<code>Array&lt;T&gt;</code>）总体上仍然保持协变。</p>
<p>考虑下面这个 Animal 是 Dog 和 Cat 的父类型的例子：</p>
<pre><code class="language-typescript">declare let f1: (x: Animal) =&gt; void;
declare let f2: (x: Dog) =&gt; void;
declare let f3: (x: Cat) =&gt; void;
f1 = f2;  // 启用 --strictFunctionTypes 时错误
f2 = f1;  // 正确
f2 = f3;  // 错误
</code></pre>
<p>第一个赋值语句在默认的类型检查模式中是允许的，但是在严格函数类型模式下会被标记错误。 通俗地讲，默认模式允许这么赋值，因为它_可能是_合理的，而严格函数类型模式将它标记为错误，因为它不能_被证明_合理。 任何一种模式中，第三个赋值都是错误的，因为它_永远不_合理。</p>
<p>用另一种方式来描述这个例子则是，默认类型检查模式中<code>T</code>在类型<code>(x: T) =&gt; void</code>是_双变的_（也即协变_或_抗变），但在严格函数类型模式中<code>T</code>是_抗变_的。</p>
<h3 id="例子-44"><a class="header" href="#例子-44">例子</a></h3>
<pre><code class="language-typescript">interface Comparer&lt;T&gt; {
    compare: (a: T, b: T) =&gt; number;
}

declare let animalComparer: Comparer&lt;Animal&gt;;
declare let dogComparer: Comparer&lt;Dog&gt;;

animalComparer = dogComparer;  // 错误
dogComparer = animalComparer;  // 正确
</code></pre>
<p>现在第一个赋值是错误的。更明确地说，<code>Comparer&lt;T&gt;</code>中的<code>T</code>因为仅在函数类型参数的位置被使用，是抗变的。</p>
<p>另外，注意尽管有的语言（比如C#和Scala）要求变体标注（variance annotations）（<code>out</code>/<code>in</code> 或 <code>+</code>/<code>-</code>），而由于TypeScript的结构化类型系统，它的变体是由泛型中的类型参数的实际使用自然得出的。</p>
<h3 id="注意"><a class="header" href="#注意">注意：</a></h3>
<p>启用<code>--strictFunctionTypes</code>时，如果<code>compare</code>被声明为方法，则第一个赋值依然是被允许的。 更明确的说，<code>Comparer&lt;T&gt;</code>中的<code>T</code>因为仅在方法参数的位置被使用所以是双变的。</p>
<pre><code class="language-typescript">interface Comparer&lt;T&gt; {
    compare(a: T, b: T): number;
}

declare let animalComparer: Comparer&lt;Animal&gt;;
declare let dogComparer: Comparer&lt;Dog&gt;;

animalComparer = dogComparer;  // 正确，因为双变
dogComparer = animalComparer;  // 正确
</code></pre>
<p>TypeScript 2.6 还改进了与抗变位置相关的类型推导：</p>
<pre><code class="language-typescript">function combine&lt;T&gt;(...funcs: ((x: ）=&gt; void)[]): (x: T) =&gt; void {
    return x =&gt; {
        for (const f of funcs) f(x);
    }
}

function animalFunc(x: Animal) {}
function dogFunc(x: Dog) {}

let combined = combine(animalFunc，dogFunc);  // (x: Dog) =&gt; void
</code></pre>
<p>这上面所有<code>T</code>的推断都来自抗变的位置，由此我们得出<code>T</code>的_最普遍子类型_。 这与从协变位置推导出的结果恰恰相反，从协变位置我们得出的是_最普遍超类型_。</p>
<h2 id="缓存模块中的标签模板对象"><a class="header" href="#缓存模块中的标签模板对象">缓存模块中的标签模板对象</a></h2>
<p>TypeScript 2.6修复了标签字符串模板的输出，以更好地遵循ECMAScript标准。 根据<a href="https://tc39.github.io/ecma262/#sec-gettemplateobject">ECMAScript 标准</a>，每一次获取模板标签的值时，应该将_同一个_模板字符串数组对象 (同一个 <code>TemplateStringArray</code>) 作为第一个参数传递。 在 TypeScript 2.6 之前，每一次生成的都是全新的模板对象。 虽然字符串的内容是一样的，这样的输出会影响通过识别字符串来实现缓存失效的库，比如 <a href="https://github.com/PolymerLabs/lit-html/issues/58">lit-html</a>。</p>
<h3 id="例子-45"><a class="header" href="#例子-45">例子</a></h3>
<pre><code class="language-typescript">export function id(x: TemplateStringsArray) {
    return x;
}

export function templateObjectFactory() {
    return id`hello world`;
}

let result = templateObjectFactory() === templateObjectFactory(); // TS 2.6 为 true
</code></pre>
<p>编译后的代码：</p>
<pre><code class="language-javascript">"use strict";
var __makeTemplateObject = (this &amp;&amp; this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function id(x) {
    return x;
}

var _a;
function templateObjectFactory() {
    return id(_a || (_a = __makeTemplateObject(["hello world"], ["hello world"])));
}

var result = templateObjectFactory() === templateObjectFactory();
</code></pre>
<blockquote>
<p>注意：这一改变引入了新的工具函数，<code>__makeTemplateObject</code>; 如果你在搭配使用<code>--importHelpers</code>和<a href="https://github.com/Microsoft/tslib"><code>tslib</code></a>，需要更新到 1.8 或更高版本。</p>
</blockquote>
<h2 id="本地化的命令行诊断消息"><a class="header" href="#本地化的命令行诊断消息">本地化的命令行诊断消息</a></h2>
<p>TypeScript 2.6 npm包加入了13种语言的诊断消息本地化版本。 命令行中本地化消息会在使用<code>--locale</code>选项时显示。</p>
<h3 id="例子-46"><a class="header" href="#例子-46">例子</a></h3>
<p>俄语显示的错误消息：</p>
<pre><code class="language-bash">c:\ts&gt;tsc --v
Version 2.6.1

c:\ts&gt;tsc --locale ru --pretty c:\test\a.ts

../test/a.ts(1,5): error TS2322: Тип ""string"" не может быть назначен для типа "number".

1 var x: number = "string";
      ~
</code></pre>
<p>中文显示的帮助信息：</p>
<pre><code class="language-bash">PS C:\ts&gt; tsc --v
Version 2.6.1

PS C:\ts&gt; tsc --locale zh-cn
版本 2.6.1
语法：tsc [选项] [文件 ...]

示例：tsc hello.ts
    tsc --outFile file.js file.ts
    tsc @args.txt

选项：
 -h, --help                    打印此消息。
 --all                         显示所有编译器选项。
 -v, --version                 打印编译器的版本。
 --init                        初始化 TypeScript 项目并创建 tsconfig.json 文件。
 -p 文件或目录, --project 文件或目录     编译给定了其配置文件路径或带 "tsconfig.json" 的文件夹路径的项目。
 --pretty                      使用颜色和上下文风格化错误和消息(实验)。
 -w, --watch                   监视输入文件。
 -t 版本, --target 版本            指定 ECMAScript 目标版本："ES3"(默认)、"ES5"、"ES2015"、"ES2016"、"ES2017" 或 "ESNEXT"。
 -m 种类, --module 种类            指定模块代码生成："none"、"commonjs"、"amd"、"system"、"umd"、"es2015"或 "ESNext"。
 --lib                         指定要在编译中包括的库文件:
                                 'es5' 'es6' 'es2015' 'es7' 'es2016' 'es2017' 'esnext' 'dom' 'dom.iterable' 'webworker' 'scripthost' 'es2015.core' 'es2015.collection' 'es2015.generator' 'es2015.iterable' 'es2015.promise' 'es2015.proxy' 'es2015.reflect' 'es2015.symbol' 'es2015.symbol.wellknown' 'es2016.array.include' 'es2017.object' 'es2017.sharedmemory' 'es2017.string' 'es2017.intl' 'esnext.asynciterable'
 --allowJs                     允许编译 JavaScript 文件。
 --jsx 种类                      指定 JSX 代码生成："preserve"、"react-native" 或 "react"。 -d, --declaration             生成相应的 ".d.ts" 文件。
 --sourceMap                   生成相应的 ".map" 文件。
 --outFile 文件                  连接输出并将其发出到单个文件。
 --outDir 目录                   将输出结构重定向到目录。
 --removeComments              请勿将注释发出到输出。
 --noEmit                      请勿发出输出。
 --strict                      启用所有严格类型检查选项。
 --noImplicitAny               对具有隐式 "any" 类型的表达式和声明引发错误。
 --strictNullChecks            启用严格的 NULL 检查。
 --strictFunctionTypes         对函数类型启用严格检查。
 --noImplicitThis              在带隐式"any" 类型的 "this" 表达式上引发错误。
 --alwaysStrict                以严格模式进行分析，并为每个源文件发出 "use strict" 指令。
 --noUnusedLocals              报告未使用的局部变量上的错误。
 --noUnusedParameters          报告未使用的参数上的错误。
 --noImplicitReturns           在函数中的所有代码路径并非都返回值时报告错误。
 --noFallthroughCasesInSwitch  报告 switch 语句中遇到 fallthrough 情况的错误。
 --types                       要包含在编译中类型声明文件。
 @&lt;文件&gt;                         从文件插入命令行选项和文件。
</code></pre>
<h2 id="通过--ts-ignore-注释隐藏-ts-文件中的错误"><a class="header" href="#通过--ts-ignore-注释隐藏-ts-文件中的错误">通过 '// @ts-ignore' 注释隐藏 .ts 文件中的错误</a></h2>
<p>TypeScript 2.6支持在.ts文件中通过在报错一行上方使用<code>// @ts-ignore</code>来忽略错误。</p>
<h3 id="例子-47"><a class="header" href="#例子-47">例子</a></h3>
<pre><code class="language-typescript">if (false) {
    // @ts-ignore：无法被执行的代码的错误
    console.log("hello");
}
</code></pre>
<p><code>// @ts-ignore</code>注释会忽略下一行中产生的所有错误。 建议实践中在<code>@ts-ignore</code>之后添加相关提示，解释忽略了什么错误。</p>
<p>请注意，这个注释仅会隐藏报错，并且我们建议你_极少_使用这一注释。</p>
<h2 id="更快的-tsc---watch"><a class="header" href="#更快的-tsc---watch">更快的 <code>tsc --watch</code></a></h2>
<p>TypeScript 2.6 带来了更快的<code>--watch</code>实现。 新版本优化了使用ES模块的代码的生成和检查。 在一个模块文件中检测到的改变_只_会使改变的模块，以及依赖它的文件被重新生成，而不再是整个项目。 有大量文件的项目应该从这一改变中获益最多。</p>
<p>这一新的实现也为tsserver中的监听带来了性能提升。 监听逻辑被完全重写以更快响应改变事件。</p>
<h2 id="只写的引用现在会被标记未使用"><a class="header" href="#只写的引用现在会被标记未使用">只写的引用现在会被标记未使用</a></h2>
<p>TypeScript 2.6加入了修正的<code>--noUnusedLocals</code>和<code>--noUnusedParameters</code><a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">编译选项</a>实现。 只被写但从没有被读的声明现在会被标记未使用。</p>
<h3 id="例子-48"><a class="header" href="#例子-48">例子</a></h3>
<p>下面<code>n</code>和<code>m</code>都会被标记为未使用，因为它们的值从未被_读取_。之前 TypeScript 只会检查它们的值是否被_引用_。</p>
<pre><code class="language-typescript">function f(n: number) {
    n = 0;
}

class C {
    private m: number;
    constructor() {
        this.m = 0;
    }
}
</code></pre>
<p>另外仅被自己内部调用的函数也会被认为是未使用的。</p>
<h3 id="例子-49"><a class="header" href="#例子-49">例子</a></h3>
<pre><code class="language-typescript">function f() {
    f(); // 错误：'f' 被声明，但它的值从未被使用
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-25"><a class="header" href="#typescript-25">TypeScript 2.5</a></h1>
<h2 id="可选的catch语句变量"><a class="header" href="#可选的catch语句变量">可选的<code>catch</code>语句变量</a></h2>
<p>得益于<a href="https://github.com/tinganho">@tinganho</a>所做的工作，TypeScript 2.5实现了一个新的ECMAScript特性，允许用户省略<code>catch</code>语句中的变量。 例如，当使用<code>JSON.parse</code>时，你可能需要将对应的函数调用放在<code>try</code> / <code>catch</code>中，但是最后可能并不会用到输入有误时会抛出的<code>SyntaxError</code>（语法错误）。</p>
<pre><code class="language-typescript">let input = "...";
try {
    JSON.parse(input);
}
catch {
    // ^ 注意我们的 `catch` 语句并没有声明一个变量
    console.log("传入的 JSON 不合法\n\n" + input)
}
</code></pre>
<h2 id="checkjsts-check-模式中的类型断言转换语法"><a class="header" href="#checkjsts-check-模式中的类型断言转换语法"><code>checkJs</code>/<code>@ts-check</code> 模式中的类型断言/转换语法</a></h2>
<p>TypeScript 2.5 引入了在<a href="https://github.com/Microsoft/TypeScript/issues/5158">使用纯 JavaScript 的项目中断言表达式类型</a>的能力。对应的语法是<code>/** @type {...} */</code>标注注释后加上被圆括号括起来，类型需要被重新演算的表达式。举例:</p>
<pre><code class="language-typescript">var x = /** @type {SomeType} */ (AnyParenthesizedExpression);
</code></pre>
<h2 id="包去重和重定向"><a class="header" href="#包去重和重定向">包去重和重定向</a></h2>
<p>在 TypeScript 2.5 中使用<code>Node</code>模块解析策略进行导入时，编译器现在会检查文件是否来自 "相同" 的包。如果一个文件所在的包的<code>package.json</code>包含了与之前读取的包相同的<code>name</code>和<code>version</code>，那么TypeScript会将它重定向到最顶层的包。这可以解决两个包可能会包含相同的类声明，但因为包含<code>private</code>成员导致他们在结构上不兼容的问题.</p>
<p>这也带来一个额外的好处，可以通过避免从重复的包中加载<code>.d.ts</code>文件减少内存使用和编译器及语言服务的运行时计算.</p>
<h2 id="--preservesymlinks保留符号链接编译器选项"><a class="header" href="#--preservesymlinks保留符号链接编译器选项"><code>--preserveSymlinks</code>（保留符号链接）编译器选项</a></h2>
<p>TypeScript 2.5带来了<code>preserveSymlinks</code>选项，它对应了<a href="https://nodejs.org/api/cli.html#cli_preserve_symlinks">Node.js 中 <code>--preserve-symlinks</code>选项</a>的行为。这一选项也会带来和Webpack的<code>resolve.symlinks</code>选项相反的行为（也就是说，将TypeScript的<code>preserveSymlinks</code>选项设置为<code>true</code>对应了将Webpack的<code>resolve.symlinks</code>选项设为<code>false</code>，反之亦然）。</p>
<p>在这一模式中，对于模块和包的引用（比如<code>import</code>语句和<code>/// &lt;reference type=".." /&gt;</code>指令）都会以相对符号链接文件的位置被解析，而不是相对于符号链接解析到的路径。更具体的例子，可以参考<a href="https://nodejs.org/api/cli.html#cli_preserve_symlinks">Node.js网站的文档</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-24"><a class="header" href="#typescript-24">TypeScript 2.4</a></h1>
<h2 id="动态导入表达式"><a class="header" href="#动态导入表达式">动态导入表达式</a></h2>
<p>动态的<code>import</code>表达式是一个新特性，它属于ECMAScript的一部分，允许用户在程序的任何位置异步地请求某个模块。</p>
<p>这意味着你可以有条件地延迟加载其它模块和库。 例如下面这个<code>async</code>函数，它仅在需要的时候才导入工具库：</p>
<pre><code class="language-typescript">async function getZipFile(name: string, files: File[]): Promise&lt;File&gt; {
    const zipUtil = await import('./utils/create-zip-file');
    const zipContents = await zipUtil.getContentAsBlob(files);
    return new File(zipContents, name);
}
</code></pre>
<p>许多bundlers工具已经支持依照这些<code>import</code>表达式自动地分割输出，因此可以考虑使用这个新特性并把输出模块目标设置为<code>esnext</code>。</p>
<h2 id="字符串枚举-1"><a class="header" href="#字符串枚举-1">字符串枚举</a></h2>
<p>TypeScript 2.4现在支持枚举成员变量包含字符串构造器。</p>
<pre><code class="language-typescript">enum Colors {
    Red = "RED",
    Green = "GREEN",
    Blue = "BLUE",
}
</code></pre>
<p>需要注意的是字符串枚举成员不能被反向映射到枚举成员的名字。 换句话说，你不能使用<code>Colors["RED"]</code>来得到<code>"Red"</code>。</p>
<h2 id="增强的泛型推断"><a class="header" href="#增强的泛型推断">增强的泛型推断</a></h2>
<p>TypeScript 2.4围绕着泛型的推断方式引入了一些很棒的改变。</p>
<h3 id="返回类型作为推断目标"><a class="header" href="#返回类型作为推断目标">返回类型作为推断目标</a></h3>
<p>其一，TypeScript能够推断调用的返回值类型。 这可以优化你的体验和方便捕获错误。 如下所示：</p>
<pre><code class="language-typescript">function arrayMap&lt;T, U&gt;(f: (x: T) =&gt; U): (a: T[]) =&gt; U[] {
    return a =&gt; a.map(f);
}

const lengths: (a: string[]) =&gt; number[] = arrayMap(s =&gt; s.length);
</code></pre>
<p>下面是一个你可能会见到的出错了的例子：</p>
<pre><code class="language-typescript">let x: Promise&lt;string&gt; = new Promise(resolve =&gt; {
    resolve(10);
    //      ~~ Error!
});
</code></pre>
<h3 id="从上下文类型中推断类型参数"><a class="header" href="#从上下文类型中推断类型参数">从上下文类型中推断类型参数</a></h3>
<p>在TypeScript 2.4之前，在下面的例子里：</p>
<pre><code class="language-typescript">let f: &lt;T&gt;(x: T) =&gt; T = y =&gt; y;
</code></pre>
<p><code>y</code>将会具有<code>any</code>类型。 这意味着虽然程序会检查类型，但是你却可以使用<code>y</code>做任何事情，就比如：</p>
<pre><code class="language-typescript">let f: &lt;T&gt;(x: T) =&gt; T = y =&gt; y() + y.foo.bar;
</code></pre>
<p>这个例子实际上并不是类型安全的。</p>
<p>在TypeScript 2.4里，右手边的函数会隐式地获得类型参数，并且<code>y</code>的类型会被推断为那个类型参数的类型。</p>
<p>如果你使用<code>y</code>的方式是这个类型参数所不支持的，那么你会得到一个错误。 在这个例子里，<code>T</code>的约束是<code>{}</code>（隐式地），所以在最后一个例子里会出错。</p>
<h3 id="对泛型函数进行更严格的检查"><a class="header" href="#对泛型函数进行更严格的检查">对泛型函数进行更严格的检查</a></h3>
<p>TypeScript在比较两个单一签名的类型时会尝试统一类型参数。 因此，在涉及到两个泛型签名的时候会进行更严格的检查，这就可能发现一些bugs。</p>
<pre><code class="language-typescript">type A = &lt;T, U&gt;(x: T, y: U) =&gt; [T, U];
type B = &lt;S&gt;(x: S, y: S) =&gt; [S, S];

function f(a: A, b: B) {
    a = b;  // Error
    b = a;  // Ok
}
</code></pre>
<h2 id="回调参数的严格抗变"><a class="header" href="#回调参数的严格抗变">回调参数的严格抗变</a></h2>
<p>TypeScript一直是以双变（bivariant）的方式来比较参数。 这样做有很多原因，总体上来说这不会有什么大问题直到我们发现它应用在<code>Promise</code>和<code>Observable</code>上时有些副作用。</p>
<p>TypeScript 2.4在处理两个回调类型时引入了收紧机制。例如：</p>
<pre><code class="language-typescript">interface Mappable&lt;T&gt; {
    map&lt;U&gt;(f: (x: T) =&gt; U): Mappable&lt;U&gt;;
}

declare let a: Mappable&lt;number&gt;;
declare let b: Mappable&lt;string | number&gt;;

a = b;
b = a;
</code></pre>
<p>在TypeScript 2.4之前，它会成功执行。 当关联<code>map</code>的类型时，TypeScript会双向地关联它们的类型（例如<code>f</code>的类型）。 当关联每个<code>f</code>的类型时，TypeScript也会双向地关联那些参数的类型。</p>
<p>TS 2.4里关联<code>map</code>的类型时，TypeScript会检查是否每个参数都是回调类型，如果是的话，它会确保那些参数根据它所在的位置以抗变（contravariant）地方式进行检查。</p>
<p>换句话说，TypeScript现在可以捕获上面的bug，这对某些用户来说可能是一个破坏性改动，但却是非常帮助的。</p>
<h2 id="弱类型weak-type探测"><a class="header" href="#弱类型weak-type探测">弱类型（Weak Type）探测</a></h2>
<p>TypeScript 2.4引入了“弱类型”的概念。 任何只包含了可选属性的类型被当作是“weak”。 比如，下面的<code>Options</code>类型是弱类型：</p>
<pre><code class="language-typescript">interface Options {
    data?: string,
    timeout?: number,
    maxRetries?: number,
}
</code></pre>
<p>在TypeScript 2.4里给弱类型赋值时，如果这个值的属性与弱类型的属性没有任何重叠属性时会得到一个错误。 比如：</p>
<pre><code class="language-typescript">function sendMessage(options: Options) {
    // ...
}

const opts = {
    payload: "hello world!",
    retryOnFail: true,
}

// 错误!
sendMessage(opts);
// 'opts' 和 'Options' 没有重叠的属性
// 可能我们想要用'data'/'maxRetries'来代替'payload'/'retryOnFail'
</code></pre>
<p>因为这是一个破坏性改动，你可能想要知道一些解决方法：</p>
<ol>
<li>确定属性存在时再声明</li>
<li>给弱类型增加索引签名（比如 <code>[propName: string]: {}</code>）</li>
<li>使用类型断言（比如<code>opts as Options</code>）</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-23"><a class="header" href="#typescript-23">TypeScript 2.3</a></h1>
<h2 id="es5es3-的生成器和迭代支持"><a class="header" href="#es5es3-的生成器和迭代支持">ES5/ES3 的生成器和迭代支持</a></h2>
<p><em>首先是一些 ES2016 的术语：</em></p>
<h3 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h3>
<p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-iteration">ES2015引入了<code>Iterator</code>（迭代器）</a>，它表示提供了 next，return，以及 throw 三个方法的对象，具体满足以下接口：</p>
<pre><code class="language-typescript">interface Iterator&lt;T&gt; {
  next(value?: any): IteratorResult&lt;T&gt;;
  return?(value?: any): IteratorResult&lt;T&gt;;
  throw?(e?: any): IteratorResult&lt;T&gt;;
}
</code></pre>
<p>这种迭代器对于迭代可用的值时很有用，比如数组的元素或者Map的键。如果一个对象有一个返回<code>Iterator</code>对象的<code>Symbol.iterator</code>方法，那么我们说这个对象是“可迭代的”。</p>
<p>迭代器协议还定义了一些ES2015中的特性像<code>for..of</code>和展开运算符以及解构赋值中的数组的剩余运算的操作对象。</p>
<h3 id="生成器"><a class="header" href="#生成器">生成器</a></h3>
<p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects">ES2015也引入了"生成器"</a>，生成器是可以通过<code>Iterator</code>接口和<code>yield</code>关键字被用来生成部分运算结果的函数。生成器也可以在内部通过<code>yield*</code>代理对与其他可迭代对象的调用。举例来说：</p>
<pre><code class="language-typescript">function* f() {
  yield 1;
  yield* [2, 3];
}
</code></pre>
<h3 id="新的--downleveliteration编译选项"><a class="header" href="#新的--downleveliteration编译选项">新的<code>--downlevelIteration</code>编译选项</a></h3>
<p>之前迭代器只在编译目标为 ES6/ES2015 或者更新版本时可用。此外，设计迭代器协议的结构，比如<code>for..of</code>，如果编译目标低于ES6/ES2015，则只能在操作数组时被支持。</p>
<p>TypeScript 2.3 在 ES3 和 ES5 为编译目标时由<code>--downlevelIteration</code>编译选项增加了完整的对生成器和迭代器协议的支持。</p>
<p>通过<code>--downlevelIteration</code>编译选项，编译器会使用新的类型检查和输出行为，尝试调用被迭代对象的<code>[Symbol.iterator]()</code>方法 (如果有)，或者在对象上创建一个语义上的数组迭代器。</p>
<blockquote>
<p>注意这需要非数组的值有原生的<code>Symbol.iterator</code>或者<code>Symbol.iterator</code>的运行时模拟实现。</p>
</blockquote>
<p>使用<code>--downlevelIteration</code>时，在 ES5/ES3 中<code>for..of</code>语句、数组解构、数组中的元素展开、函数调用、new 表达式在支持<code>Symbol.iterator</code>时可用，但即便没有定义<code>Symbol.iterator</code>，它们在运行时或开发时都可以被使用到数组上.</p>
<h2 id="异步迭代"><a class="header" href="#异步迭代">异步迭代</a></h2>
<p>TypeScript 2.3 添加了对异步迭代器和生成器的支持，描述见当前的<a href="https://github.com/tc39/proposal-async-iteration">TC39 提案</a>。</p>
<h3 id="异步迭代器"><a class="header" href="#异步迭代器">异步迭代器</a></h3>
<p>异步迭代引入了<code>AsyncIterator</code>，它和<code>Iterator</code>相似。实际上的区别在于<code>AsyncIterator</code>的<code>next</code>、<code>return</code>和<code>throw</code>方法的返回的是迭代结果的<code>Promise</code>，而不是结果本身。这允许<code>AsyncIterator</code>在生成值之前的时间点就加入异步通知。<code>AsyncIterator</code>的接口如下：</p>
<pre><code class="language-typescript">interface AsyncIterator&lt;T&gt; {
  next(value?: any): Promise&lt;IteratorResult&lt;T&gt;&gt;;
  return?(value?: any): Promise&lt;IteratorResult&lt;T&gt;&gt;;
  throw?(e?: any): Promise&lt;IteratorResult&lt;T&gt;&gt;;
}
</code></pre>
<p>一个支持异步迭代的对象如果有一个返回<code>AsyncIterator</code>对象的<code>Symbol.asyncIterator</code>方法，被称作是“可迭代的”。</p>
<h3 id="异步生成器"><a class="header" href="#异步生成器">异步生成器</a></h3>
<p><a href="https://github.com/tc39/proposal-async-iteration">异步迭代提案</a>引入了“异步生成器”，也就是可以用来生成部分计算结果的异步函数。异步生成器也可以通过<code>yield*</code>代理对可迭代对象或异步可迭代对象的调用：</p>
<pre><code class="language-typescript">async function* g() {
  yield 1;
  await sleep(100);
  yield* [2, 3];
  yield* (async function *() {
    await sleep(100);
    yield 4;
  })();
}
</code></pre>
<p>和生成器一样，异步生成器只能是函数声明，函数表达式，或者类或对象字面量的方法。箭头函数不能作为异步生成器。异步生成器除了一个可用的<code>Symbol.asyncIterator</code>引用外 (原生或三方实现)，还需要一个可用的全局<code>Promise</code>实现（既可以是原生的，也可以是ES2015兼容的实现）。</p>
<h3 id="for-await-of语句"><a class="header" href="#for-await-of语句"><code>for-await-of</code>语句</a></h3>
<p>最后，ES2015引入了<code>for..of</code>语句来迭代可迭代对象。相似的，异步迭代提案引入了<code>for..await..of</code>语句来迭代可异步迭代的对象。</p>
<pre><code class="language-typescript">async function f() {
  for await (const x of g()) {
     console.log(x);
  }
}
</code></pre>
<p><code>for..await..of</code>语句仅在异步函数或异步生成器中可用。</p>
<h3 id="注意事项-2"><a class="header" href="#注意事项-2">注意事项</a></h3>
<ul>
<li>始终记住我们对于异步迭代器的支持是建立在运行时有<code>Symbol.asyncIterator</code>支持的基础上的。你可能需要<code>Symbol.asyncIterator</code>的三方实现，虽然对于简单的目的可以仅仅是：<code>(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for("Symbol.asyncIterator");</code></li>
<li>如果你没有声明<code>AsyncIterator</code>，还需要在<code>--lib</code>选项中加入<code>esnext</code>来获取<code>AsyncIterator</code>声明。</li>
<li>最后, 如果你的编译目标是ES5或ES3，你还需要设置<code>--downlevelIterators</code>编译选项。</li>
</ul>
<h2 id="泛型参数默认类型"><a class="header" href="#泛型参数默认类型">泛型参数默认类型</a></h2>
<p>TypeScript 2.3 增加了对声明泛型参数默认类型的支持。</p>
<h3 id="示例-2"><a class="header" href="#示例-2">示例</a></h3>
<p>考虑一个会创建新的<code>HTMLElement</code>的函数，调用时不加参数会生成一个<code>Div</code>，你也可以选择性地传入子元素的列表。之前你必须这么去定义：</p>
<pre><code class="language-typescript">declare function create(): Container&lt;HTMLDivElement, HTMLDivElement[]&gt;;
declare function create&lt;T extends HTMLElement&gt;(element: T): Container&lt;T, T[]&gt;;
declare function create&lt;T extends HTMLElement, U extends HTMLElement&gt;(element: T, children: U[]): Container&lt;T, U[]&gt;;
</code></pre>
<p>有了泛型参数默认类型，我们可以将定义化简为：</p>
<pre><code class="language-typescript">declare function create&lt;T extends HTMLElement = HTMLDivElement, U = T[]&gt;(element?: T, children?: U): Container&lt;T, U&gt;;
</code></pre>
<p>泛型参数的默认类型遵循以下规则：</p>
<ul>
<li>有默认类型的类型参数被认为是可选的。</li>
<li>必选的类型参数不能在可选的类型参数后。</li>
<li>如果类型参数有约束，类型参数的默认类型必须满足这个约束。</li>
<li>当指定类型实参时，你只需要指定必选类型参数的类型实参。 未指定的类型参数会被解析为它们的默认类型。</li>
<li>如果指定了默认类型，且类型推断无法选择一个候选类型，那么将使用默认类型作为推断结果。</li>
<li>一个被现有类或接口合并的类或者接口的声明可以为现有类型参数引入默认类型。</li>
<li>一个被现有类或接口合并的类或者接口的声明可以引入新的类型参数，只要它指定了默认类型。</li>
</ul>
<h2 id="新的--strict主要编译选项"><a class="header" href="#新的--strict主要编译选项">新的<code>--strict</code>主要编译选项</a></h2>
<p>TypeScript加入的新检查项为了避免不兼容现有项目通常都是默认关闭的。虽然避免不兼容是好事，但这个策略的一个弊端则是使配置最高类型安全越来越复杂，这么做每次TypeScript版本发布时都需要显示地加入新选项。有了<code>--strict</code>编译选项，就可以选择最高级别的类型安全（了解随着更新版本的编译器增加了增强的类型检查特性可能会报新的错误）。</p>
<p>新的<code>--strict</code>编译器选项包含了一些建议配置的类型检查选项。具体来说，指定<code>--strict</code>相当于是指定了以下所有选项（未来还可能包括更多选项）：</p>
<ul>
<li><code>--strictNullChecks</code></li>
<li><code>--noImplicitAny</code></li>
<li><code>--noImplicitThis</code></li>
<li><code>--alwaysStrict</code></li>
</ul>
<p>确切地说，<code>--strict</code>编译选项会为以上列出的编译器选项设置默认值。这意味着还可以单独控制这些选项。比如：</p>
<pre><code class="language-bash">--strict --noImplicitThis false
</code></pre>
<p>这将是开启除<code>--noImplicitThis</code>编译选项以外的所有严格检查选项。使用这个方式可以表述除某些明确列出的项以外的所有严格检查项。换句话说，现在可以在默认最高级别的类型安全下排除部分检查。</p>
<p>从TypeScript 2.3开始，<code>tsc --init</code>生成的默认<code>tsconfig.json</code>在<code>"compilerOptions"</code>中包含了<code>"strict: true"</code>设置。这样一来，用<code>tsc --init</code>创建的新项目默认会开启最高级别的类型安全。</p>
<h2 id="改进的--init输出"><a class="header" href="#改进的--init输出">改进的<code>--init</code>输出</a></h2>
<p>除了默认的<code>--strict</code>设置外，<code>tsc --init</code>还改进了输出。<code>tsc --init</code>默认生成的<code>tsconfig.json</code>文件现在包含了一些带描述的被注释掉的常用编译器选项. 你可以去掉相关选项的注释来获得期望的结果。我们希望新的输出能简化新项目的配置并且随着项目成长保持配置文件的可读性。</p>
<h2 id="--checkjs选项下-js-文件中的错误"><a class="header" href="#--checkjs选项下-js-文件中的错误"><code>--checkJS</code>选项下 .js 文件中的错误</a></h2>
<p>即便使用了<code>--allowJs</code>，TypeScript编译器默认不会报 .js 文件中的任何错误。TypeScript 2.3 中使用<code>--checkJs</code>选项，<code>.js</code>文件中的类型检查错误也可以被报出.</p>
<p>你可以通过为它们添加<code>// @ts-nocheck</code>注释来跳过对某些文件的检查，反过来你也可以选择通过添加<code>// @ts-check</code>注释只检查一些<code>.js</code>文件而不需要设置<code>--checkJs</code>编译选项。你也可以通过添加<code>// @ts-ignore</code>到特定行的一行前来忽略这一行的错误.</p>
<p><code>.js</code>文件仍然会被检查确保只有标准的 ECMAScript 特性，类型标注仅在<code>.ts</code>文件中被允许，在<code>.js</code>中会被标记为错误。JSDoc注释可以用来为你的JavaScript代码添加某些类型信息，更多关于支持的JSDoc结构的详情，请浏览<a href="https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript">JSDoc支持文档</a>。</p>
<p>有关详细信息，请浏览<a href="https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files">类型检查JavaScript文件文档</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-22"><a class="header" href="#typescript-22">TypeScript 2.2</a></h1>
<h2 id="支持混合类"><a class="header" href="#支持混合类">支持混合类</a></h2>
<p>TypeScript 2.2 增加了对 ECMAScript 2015 混合类模式 (见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins">MDN混合类的描述</a>及<a href="http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/">JavaScript类的"真"混合</a>了解更多) 以及使用交叉来类型表达结合混合构造函数的签名及常规构造函数签名的规则.</p>
<h4 id="首先是一些术语"><a class="header" href="#首先是一些术语">首先是一些术语</a></h4>
<p><strong>混合构造函数类型</strong>指仅有单个构造函数签名，且该签名仅有一个类型为 any[] 的变长参数，返回值为对象类型. 比如, 有 X 为对象类型, new (...args: any[]) =&gt; X 是一个实例类型为 X 的混合构造函数类型。</p>
<p><strong>混合类</strong>指一个<code>extends</code>(扩展)了类型参数类型的表达式的类声明或表达式. 以下规则对混合类声明适用：</p>
<ul>
<li><code>extends</code>表达式的类型参数类型必须是混合构造函数.</li>
<li>混合类的构造函数 (如果有) 必须有且仅有一个类型为<code>any[]</code>的变长参数, 并且必须使用展开运算符在<code>super(...args)</code>调用中将这些参数传递。</li>
</ul>
<p>假设有类型参数为<code>T</code>且约束为<code>X</code>的表达式<code>Bas</code>，处理混合类<code>class C extends Base {...}</code>时会假设<code>Base</code>有<code>X</code>类型，处理结果为交叉类型<code>typeof C &amp; T</code>。换言之，一个混合类被表达为混合类构造函数类型与参数基类构造函数类型的交叉类型.</p>
<p>在获取一个包含了混合构造函数类型的交叉类型的构造函数签名时，混合构造函数签名会被丢弃，而它们的实例类型会被混合到交叉类型中其他构造函数签名的返回类型中. 比如，交叉类型<code>{ new(...args: any[]) =&gt; A } &amp; { new(s: string) =&gt; B }</code>仅有一个构造函数签名<code>new(s: string) =&gt; A &amp; B</code>。</p>
<h4 id="将以上规则放到一个例子中"><a class="header" href="#将以上规则放到一个例子中">将以上规则放到一个例子中</a></h4>
<pre><code class="language-typescript">class Point {
    constructor(public x: number, public y: number) {}
}

class Person {
    constructor(public name: string) {}
}

type Constructor&lt;T&gt; = new(...args: any[]) =&gt; T;

function Tagged&lt;T extends Constructor&lt;{}&gt;&gt;(Base: T) {
    return class extends Base {
        _tag: string;
        constructor(...args: any[]) {
            super(...args);
            this._tag = "";
        }
    }
}

const TaggedPoint = Tagged(Point);

let point = new TaggedPoint(10, 20);
point._tag = "hello";

class Customer extends Tagged(Person) {
    accountBalance: number;
}

let customer = new Customer("Joe");
customer._tag = "test";
customer.accountBalance = 0;
</code></pre>
<p>混合类可以通过在类型参数中限定构造函数签名的返回值类型来限制它们可以被混入的类的类型。举例来说，下面的<code>WithLocation</code>函数实现了一个为满足<code>Point</code>接口 （也就是有类型为<code>number</code>的<code>x</code>和<code>y</code>属性）的类添加<code>getLocation</code>方法的子类工厂。</p>
<pre><code class="language-typescript">interface Point {
    x: number;
    y: number;
}

const WithLocation = &lt;T extends Constructor&lt;Point&gt;&gt;(Base: T) =&gt;
    class extends Base {
        getLocation(): [number, number] {
            return [this.x, this.y];
        }
    }
</code></pre>
<h2 id="object类型"><a class="header" href="#object类型"><code>object</code>类型</a></h2>
<p>TypeScript没有表示非基本类型的类型，即不是<code>number</code> | <code>string</code> | <code>boolean</code> | <code>symbol</code> | <code>null</code> | <code>undefined</code>的类型。一个新的<code>object</code>类型登场。</p>
<p>使用<code>object</code>类型，可以更好地表示类似<code>Object.create</code>这样的API。例如：</p>
<pre><code class="language-typescript">declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
</code></pre>
<h2 id="支持newtarget"><a class="header" href="#支持newtarget">支持<code>new.target</code></a></h2>
<p><code>new.target</code>元属性是ES2015引入的新语法。当通过<code>new</code>构造函数创建实例时，<code>new.target</code>的值被设置为对最初用于分配实例的构造函数的引用。如果一个函数不是通过<code>new</code>构造而是直接被调用，那么<code>new.target</code>的值被设置为<code>undefined</code>。</p>
<p>当在类的构造函数中需要设置<code>Object.setPrototypeOf</code>或<code>__proto__</code>时，<code>new.target</code>就派上用场了。在NodeJS v4及更高版本中继承<code>Error</code>类就是这样的使用案例。</p>
<h3 id="示例-3"><a class="header" href="#示例-3">示例</a></h3>
<pre><code class="language-typescript">class CustomError extends Error {
    constructor(message?: string) {
        super(message); // 'Error' breaks prototype chain here
        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
    }
}
</code></pre>
<p>生成JS代码：</p>
<pre><code class="language-javascript">var CustomError = (function (_super) {
  __extends(CustomError, _super);
  function CustomError() {
    var _newTarget = this.constructor;
    var _this = _super.apply(this, arguments);  // 'Error' breaks prototype chain here
    _this.__proto__ = _newTarget.prototype; // restore prototype chain
    return _this;
  }
  return CustomError;
})(Error);
</code></pre>
<p>new.target也适用于编写可构造的函数，例如：</p>
<pre><code class="language-typescript">function f() {
  if (new.target) { /* called via 'new' */ }
}
</code></pre>
<p>编译为：</p>
<pre><code class="language-javascript">function f() {
  var _newTarget = this &amp;&amp; this instanceof f ? this.constructor : void 0;
  if (_newTarget) { /* called via 'new' */ }
}
</code></pre>
<h2 id="更好地检查表达式的操作数中的null--undefined"><a class="header" href="#更好地检查表达式的操作数中的null--undefined">更好地检查表达式的操作数中的<code>null</code> / <code>undefined</code></a></h2>
<p>TypeScript 2.2改进了对表达式中可空操作数的检查。具体来说，这些现在被标记为错误：</p>
<ul>
<li>如果<code>+</code>运算符的任何一个操作数是可空的，并且两个操作数都不是<code>any</code>或<code>string</code>类型。</li>
<li>如果<code>-</code>，<code>*</code>，<code>**</code>，<code>/</code>，<code>％</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code> 或 <code>^</code>运算符的任何一个操作数是可空的。</li>
<li>如果<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>或<code>in</code>运算符的任何一个操作数是可空的。</li>
<li>如果<code>instanceof</code>运算符的右操作数是可空的。</li>
<li>如果一元运算符<code>+</code>，<code>-</code>，<code>~</code>，<code>++</code>或者<code>--</code>的操作数是可空的。</li>
</ul>
<p>如果操作数的类型是<code>null</code>或<code>undefined</code>或者包含<code>null</code>或<code>undefined</code>的联合类型，则操作数视为可空的。注意：包含<code>null</code>或<code>undefined</code>的联合类型只会出现在<code>--strictNullChecks</code>模式中，因为常规类型检查模式下<code>null</code>和<code>undefined</code>在联合类型中是不存在的。</p>
<h2 id="字符串索引签名类型的点属性"><a class="header" href="#字符串索引签名类型的点属性">字符串索引签名类型的点属性</a></h2>
<p>具有字符串索引签名的类型可以使用<code>[]</code>符号访问，但不允许使用<code>.</code>符号访问。从TypeScript 2.2开始两种方式都允许使用。</p>
<pre><code class="language-typescript">interface StringMap&lt;T&gt; {
    [x: string]: T;
}

const map: StringMap&lt;number&gt;;

map["prop1"] = 1;
map.prop2 = 2;
</code></pre>
<p>这仅适用于具有显式字符串索引签名的类型。在类型使用上使用<code>.</code>符号访问未知属性仍然是一个错误。</p>
<h2 id="支持在jsx子元素上使用扩展运算符"><a class="header" href="#支持在jsx子元素上使用扩展运算符">支持在JSX子元素上使用扩展运算符</a></h2>
<p>TypeScript 2.2增加了对在JSX子元素上使用扩展运算符的支持。更多详情请看<a href="https://github.com/facebook/jsx/issues/57">facebook/jsx#57</a>。</p>
<h3 id="示例-4"><a class="header" href="#示例-4">示例</a></h3>
<pre><code class="language-typescript">function Todo(prop: { key: number, todo: string }) {
    return &lt;div&gt;{prop.key.toString() + prop.todo}&lt;/div&gt;;
}

function TodoList({ todos }: TodoListProps) {
    return &lt;div&gt;
        {...todos.map(todo =&gt; &lt;Todo key={todo.id} todo={todo.todo} /&gt;)}
    &lt;/div&gt;;
}

let x: TodoListProps;

&lt;TodoList {...x} /&gt;
</code></pre>
<h2 id="新的jsx-react-native"><a class="header" href="#新的jsx-react-native">新的<code>jsx: react-native</code></a></h2>
<p>React-native构建管道期望所有文件都具有.js扩展名，即使该文件包含JSX语法。新的<code>--jsx</code>编译参数值<code>react-native</code>将在输出文件中坚持JSX语法，但是给它一个<code>.js</code>扩展名。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-21"><a class="header" href="#typescript-21">TypeScript 2.1</a></h1>
<h2 id="keyof和查找类型"><a class="header" href="#keyof和查找类型"><code>keyof</code>和查找类型</a></h2>
<p>在JavaScript中属性名称作为参数的API是相当普遍的，但是到目前为止还没有表达在那些API中出现的类型关系。</p>
<p>输入索引类型查询或<code>keyof</code>，索引类型查询<code>keyof T</code>产生的类型是<code>T</code>的属性名称。<code>keyof T</code>的类型被认为是<code>string</code>的子类型。</p>
<h4 id="示例-5"><a class="header" href="#示例-5">示例</a></h4>
<pre><code class="language-typescript">interface Person {
    name: string;
    age: number;
    location: string;
}

type K1 = keyof Person; // "name" | "age" | "location"
type K2 = keyof Person[];  // "length" | "push" | "pop" | "concat" | ...
type K3 = keyof { [x: string]: Person };  // string
</code></pre>
<p>与之相对应的是_索引访问类型_，也称为_查找类型_。在语法上，它们看起来像元素访问，但是写成类型：</p>
<h4 id="示例-6"><a class="header" href="#示例-6">示例</a></h4>
<pre><code class="language-typescript">type P1 = Person["name"];  // string
type P2 = Person["name" | "age"];  // string | number
type P3 = string["charAt"];  // (pos: number) =&gt; string
type P4 = string[]["push"];  // (...items: string[]) =&gt; number
type P5 = string[][0];  // string
</code></pre>
<p>你可以将这种模式和类型系统的其它部分一起使用，以获取类型安全的查找。</p>
<pre><code class="language-typescript">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {
    return obj[key];  // 推断类型是T[K]
}

function setProperty&lt;T, K extends keyof T&gt;(obj: T, key: K, value: T[K]) {
    obj[key] = value;
}

let x = { foo: 10, bar: "hello!" };

let foo = getProperty(x, "foo"); // number
let bar = getProperty(x, "bar"); // string

let oops = getProperty(x, "wargarbl"); // 错误！"wargarbl"不存在"foo" | "bar"中

setProperty(x, "foo", "string"); // 错误！, 类型是number而非string
</code></pre>
<h2 id="映射类型-1"><a class="header" href="#映射类型-1">映射类型</a></h2>
<p>一个常见的任务是使用现有类型并使其每个属性完全可选。假设我们有一个<code>Person</code>：</p>
<pre><code class="language-typescript">interface Person {
    name: string;
    age: number;
    location: string;
}
</code></pre>
<p><code>Person</code>的可选属性类型将是这样：</p>
<pre><code class="language-typescript">interface PartialPerson {
    name?: string;
    age?: number;
    location?: string;
}
</code></pre>
<p>使用映射类型，<code>PartialPerson</code>可以写成是<code>Person</code>类型的广义变换：</p>
<pre><code class="language-typescript">type Partial&lt;T&gt; = {
    [P in keyof T]?: T[P];
};

type PartialPerson = Partial&lt;Person&gt;;
</code></pre>
<p>映射类型是通过使用字面量类型的集合而生成的，并为新对象类型计算一组属性。它们就像<a href="https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions">Python中的列表推导式</a>，但不是在列表中产生新的元素，而是在类型中产生新的属性。</p>
<p>除<code>Partial</code>外，映射类型可以表示许多有用的类型转换：</p>
<pre><code class="language-typescript">// 保持类型相同，但每个属性是只读的。
type Readonly&lt;T&gt; = {
    readonly [P in keyof T]: T[P];
};

// 相同的属性名称，但使值是一个Promise，而不是一个具体的值
type Deferred&lt;T&gt; = {
    [P in keyof T]: Promise&lt;T[P]&gt;;
};

// 为T的属性添加代理
type Proxify&lt;T&gt; = {
    [P in keyof T]: { get(): T[P]; set(v: T[P]): void }
};
</code></pre>
<h2 id="partialreadonlyrecord和pick"><a class="header" href="#partialreadonlyrecord和pick"><code>Partial</code>,<code>Readonly</code>,<code>Record</code>和<code>Pick</code></a></h2>
<p><code>Partial</code>和<code>Readonly</code>，如前所述，是非常有用的结构。你可以使用它们来描述像一些常见的JS程序：</p>
<pre><code class="language-typescript">function assign&lt;T&gt;(obj: T, props: Partial&lt;T&gt;): void;
function freeze&lt;T&gt;(obj: T): Readonly&lt;T&gt;;
</code></pre>
<p>因此，它们现在默认包含在标准库中。</p>
<p>我们还包括两个其他实用程序类型：<code>Record</code>和<code>Pick</code>。</p>
<pre><code class="language-typescript">// 从T中选取一组属性K
declare function pick&lt;T, K extends keyof T&gt;(obj: T, ...keys: K[]): Pick&lt;T, K&gt;;

const nameAndAgeOnly = pick(person, "name", "age");  // { name: string, age: number }
</code></pre>
<pre><code class="language-typescript">// 对于类型T的每个属性K，将其转换为U
function mapObject&lt;K extends string | number, T, U&gt;(obj: Record&lt;K, T&gt;, f: (x: T) =&gt; U): Record&lt;K, U&gt;

const names = { foo: "hello", bar: "world", baz: "bye" };
const lengths = mapObject(names, s =&gt; s.length);  // { foo: number, bar: number, baz: number }
</code></pre>
<h2 id="对象扩展运算符和rest运算符"><a class="header" href="#对象扩展运算符和rest运算符">对象扩展运算符和rest运算符</a></h2>
<p>TypeScript 2.1带来了<a href="https://github.com/sebmarkbage/ecmascript-rest-spread">ESnext扩展运算符和rest运算符</a>的支持。</p>
<p>类似于数组扩展，展开对象可以方便得到浅拷贝：</p>
<pre><code class="language-typescript">let copy = { ...original };
</code></pre>
<p>同样，您可以合并几个不同的对象。在以下示例中，合并将具有来自<code>foo</code>，<code>bar</code>和<code>baz</code>的属性。</p>
<pre><code class="language-typescript">let merged = { ...foo, ...bar, ...baz };
</code></pre>
<p>还可以重写现有属性并添加新属性.：</p>
<pre><code class="language-typescript">let obj = { x: 1, y: "string" };
var newObj = {...obj, z: 3, y: 4}; // { x: number, y: number, z: number }
</code></pre>
<p>指定展开操作的顺序确定哪些属性在最终的结果对象中。相同的属性，后面的属性会“覆盖”前面的属性。</p>
<p>与对象扩展运算符相对的是对象rest运算符，因为它可以提取解构元素中剩余的元素：</p>
<pre><code class="language-typescript">let obj = { x: 1, y: 1, z: 1 };
let { z, ...obj1 } = obj;
obj1; // {x: number, y: number};
</code></pre>
<h2 id="低版本异步函数"><a class="header" href="#低版本异步函数">低版本异步函数</a></h2>
<p>该特性在TypeScript 2.1之前就已经支持了，但是只能编译为ES6或者ES2015。TypeScript 2.1使其该特性可以在ES3和ES5运行时上使用，这意味着无论您使用什么环境，都可以使用它。</p>
<blockquote>
<p>注：首先，我们需要确保我们的运行时提供全局的ECMAScript兼容性<code>Promise</code>。这可能需要获取<code>Promise</code>的<a href="https://github.com/stefanpenner/es6-promise">polyfill</a>，或者依赖运行时的版本。我们还需要通过设置<code>lib</code>编译参数，比如<code>"dom","es2015"</code>或<code>"dom","es2015.promise","es5"</code>来确保TypeScript知道<code>Promise</code>可用。</p>
</blockquote>
<h4 id="示例-7"><a class="header" href="#示例-7">示例</a></h4>
<p><strong>tsconfig.json</strong></p>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "lib": ["dom", "es2015.promise", "es5"]
    }
}
</code></pre>
<p><strong>dramaticWelcome.ts</strong></p>
<pre><code class="language-typescript">function delay(milliseconds: number) {
    return new Promise&lt;void&gt;(resolve =&gt; {
        setTimeout(resolve, milliseconds);
    });
}

async function dramaticWelcome() {
    console.log("Hello");

    for (let i = 0; i &lt; 3; i++) {
        await delay(500);
        console.log(".");
    }

    console.log("World!");
}

dramaticWelcome();
</code></pre>
<p>编译和运行输出应该会在ES3/ES5引擎上产生正确的行为。</p>
<h2 id="支持外部辅助库tslib"><a class="header" href="#支持外部辅助库tslib">支持外部辅助库（<code>tslib</code>）</a></h2>
<p>TypeScript注入了一些辅助函数，如继承<code>_extends</code>、JSX中的展开运算符<code>__assign</code>和异步函数<code>__awaiter</code>。</p>
<p>以前有两个选择：</p>
<ol>
<li>在_每一个_需要辅助库的文件都注入辅助库或者</li>
<li>使用<code>--noEmitHelpers</code>编译参数完全不使用辅助库。</li>
</ol>
<p>这两项还有待改进。将帮助文件捆绑在每个文件中对于试图保持其包尺寸小的客户而言是一个痛点。不使用辅助库，那么客户就必须自己维护辅助库。</p>
<p>TypeScript 2.1 允许这些辅助库作为单独的模块一次性添加到项目中，并且编译器根据需求导入它们。</p>
<p>首先，安装<code>tslib</code>：</p>
<pre><code class="language-text">npm install tslib
</code></pre>
<p>然后，使用<code>--importHelpers</code>编译你的文件：</p>
<pre><code class="language-text">tsc --module commonjs --importHelpers a.ts
</code></pre>
<p>因此下面的输入，生成的<code>.js</code>文件将包含<code>tslib</code>的导入和使用<code>__assign</code>辅助函数替代内联操作。</p>
<pre><code class="language-typescript">export const o = { a: 1, name: "o" };
export const copy = { ...o };
</code></pre>
<pre><code class="language-javascript">"use strict";
var tslib_1 = require("tslib");
exports.o = { a: 1, name: "o" };
exports.copy = tslib_1.__assign({}, exports.o);
</code></pre>
<h2 id="无类型导入"><a class="header" href="#无类型导入">无类型导入</a></h2>
<p>TypeScript历来对于如何导入模块过于严格。这是为了避免输入错误，并防止用户错误地使用模块。</p>
<p>但是，很多时候你可能只想导入的现有模块，但是这些模块可能没有<code>.d.ts</code>文件。以前这是错误的。从TypeScript 2.1开始，这更容易了。</p>
<p>使用TypeScript 2.1，您可以导入JavaScript模块，而不需要类型声明。如果类型声明（如<code>declare module "foo" { ... }</code>或<code>node_modules/@types/foo</code>）存在，则仍然优先。</p>
<p>对于没有声明文件的模块的导入，在使用了<code>--noImplicitAny</code>编译参数后仍将被标记为错误。</p>
<pre><code class="language-typescript">// Succeeds if `node_modules/asdf/index.js` exists
import { x } from "asdf";
</code></pre>
<h2 id="支持--target-es2016--target-es2017和--target-esnext"><a class="header" href="#支持--target-es2016--target-es2017和--target-esnext">支持<code>--target ES2016</code>,<code>--target ES2017</code>和<code>--target ESNext</code></a></h2>
<p>TypeScript 2.1支持三个新的编译版本值<code>--target ES2016</code>,<code>--target ES2017</code>和<code>--target ESNext</code>。</p>
<p>使用target<code>--target ES2016</code>将指示编译器不要编译ES2016特有的特性，比如<code>**</code>操作符。</p>
<p>同样，<code>--target ES2017</code>将指示编译器不要编译ES2017特有的特性像<code>async/await</code>。</p>
<p><code>--target ESNext</code>则对应最新的<a href="https://github.com/tc39/proposals">ES提议特性</a>支持.</p>
<h2 id="改进any类型推断"><a class="header" href="#改进any类型推断">改进<code>any</code>类型推断</a></h2>
<p>以前，如果TypeScript无法确定变量的类型，它将选择<code>any</code>类型。</p>
<pre><code class="language-typescript">let x;      // 隐式 'any'
let y = []; // 隐式 'any[]'

let z: any; // 显式 'any'.
</code></pre>
<p>使用TypeScript 2.1，TypeScript不是仅仅选择<code>any</code>类型，而是基于你后面的赋值来推断类型。</p>
<p>仅当设置了<code>--noImplicitAny</code>编译参数时，才会启用此选项。</p>
<h4 id="示例-8"><a class="header" href="#示例-8">示例</a></h4>
<pre><code class="language-typescript">let x;

// 你仍然可以给'x'赋值任何你需要的任何值。
x = () =&gt; 42;

// 在刚赋值后，TypeScript 2.1 知道'x'的类型是'() =&gt; number'。
let y = x();

// 感谢，现在它会告诉你，你不能添加一个数字到一个函数！
console.log(x + y);
//          ~~~~~
// 错误！运算符 '+' 不能应用于类型`() =&gt; number`和'number'。

// TypeScript仍然允许你给'x'赋值你需要的任何值。
x = "Hello world!";

// 并且现在它也知道'x'是'string'类型的！
x.toLowerCase();
</code></pre>
<p>现在对空数组也进行同样的跟踪。</p>
<p>没有类型注解并且初始值为<code>[]</code>的变量被认为是一个隐式的<code>any[]</code>变量。变量会根据下面这些操作<code>x.push(value)</code>、<code>x.unshift(value)</code>或<code>x[n] = value</code>向其中添加的元素来_不断改变_自身的类型。</p>
<pre><code class="language-typescript">function f1() {
    let x = [];
    x.push(5);
    x[1] = "hello";
    x.unshift(true);
    return x;  // (string | number | boolean)[]
}

function f2() {
    let x = null;
    if (cond()) {
        x = [];
        while (cond()) {
            x.push("hello");
        }
    }
    return x;  // string[] | null
}
</code></pre>
<h3 id="隐式any错误"><a class="header" href="#隐式any错误">隐式any错误</a></h3>
<p>这样做的一个很大的好处是，当使用<code>--noImplicitAny</code>运行时，你将看到_较少_的隐式<code>any</code>错误。隐式<code>any</code>错误只会在编译器无法知道一个没有类型注解的变量的类型时才会报告。</p>
<h4 id="示例-9"><a class="header" href="#示例-9">示例</a></h4>
<pre><code class="language-typescript">function f3() {
    let x = [];  // 错误：当变量'x'类型无法确定时，它隐式具有'any[]'类型。
    x.push(5);
    function g() {
        x;    // 错误：变量'x'隐式具有'any【】'类型。
    }
}
</code></pre>
<h2 id="更好的字面量类型推断"><a class="header" href="#更好的字面量类型推断">更好的字面量类型推断</a></h2>
<p>字符串、数字和布尔字面量类型（如：<code>"abc"</code>，<code>1</code>和<code>true</code>）之前仅在存在显式类型注释时才被推断。从TypeScript 2.1开始，字面量类型_总是_推断为默认值。</p>
<p>不带类型注解的<code>const</code>变量或<code>readonly</code>属性的类型推断为字面量初始化的类型。已经初始化且不带类型注解的<code>let</code>变量、<code>var</code>变量、形参或非<code>readonly</code>属性的类型推断为初始值的扩展字面量类型。字符串字面量扩展类型是<code>string</code>，数字字面量扩展类型是<code>number</code>,<code>true</code>或<code>false</code>的字面量类型是<code>boolean</code>，还有枚举字面量扩展类型是枚举。</p>
<h4 id="示例-10"><a class="header" href="#示例-10">示例</a></h4>
<pre><code class="language-typescript">const c1 = 1;  // Type 1
const c2 = c1;  // Type 1
const c3 = "abc";  // Type "abc"
const c4 = true;  // Type true
const c5 = cond ? 1 : "abc";  // Type 1 | "abc"

let v1 = 1;  // Type number
let v2 = c2;  // Type number
let v3 = c3;  // Type string
let v4 = c4;  // Type boolean
let v5 = c5;  // Type number | string
</code></pre>
<p>字面量类型扩展可以通过显式类型注解来控制。具体来说，当为不带类型注解的<code>const</code>局部变量推断字面量类型的表达式时，<code>var</code>变量获得扩展字面量类型推断。但是当<code>const</code>局部变量有显式字面量类型注解时，<code>var</code>变量获得非扩展字面量类型。</p>
<h4 id="示例-11"><a class="header" href="#示例-11">示例</a></h4>
<pre><code class="language-typescript">const c1 = "hello";  // Widening type "hello"
let v1 = c1;  // Type string

const c2: "hello" = "hello";  // Type "hello"
let v2 = c2;  // Type "hello"
</code></pre>
<h2 id="将基类构造函数的返回值作为this"><a class="header" href="#将基类构造函数的返回值作为this">将基类构造函数的返回值作为'this'</a></h2>
<p>在ES2015中，构造函数的返回值（它是一个对象）隐式地将<code>this</code>的值替换为<code>super()</code>的任何调用者。因此，有必要捕获任何潜在的<code>super()</code>的返回值并替换为<code>this</code>。此更改允许<a href="https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor">使用自定义元素</a>，利用此元素可以使用用户编写的构造函数初始化浏览器分配的元素。</p>
<h4 id="示例-12"><a class="header" href="#示例-12">示例</a></h4>
<pre><code class="language-typescript">class Base {
    x: number;
    constructor() {
        // 返回一个除“this”之外的新对象
        return {
            x: 1,
        };
    }
}

class Derived extends Base {
    constructor() {
        super();
        this.x = 2;
    }
}
</code></pre>
<p>生成：</p>
<pre><code class="language-javascript">var Derived = (function (_super) {
    __extends(Derived, _super);
    function Derived() {
        var _this = _super.call(this) || this;
        _this.x = 2;
        return _this;
    }
    return Derived;
}(Base));
</code></pre>
<blockquote>
<p>这在继承内置类如<code>Error</code>，<code>Array</code>，<code>Map</code>等的行为上有了破坏性的改变。请阅读<a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work">extending built-ins breaking change documentation</a>。</p>
</blockquote>
<h2 id="配置继承"><a class="header" href="#配置继承">配置继承</a></h2>
<p>通常一个项目有多个输出版本，比如<code>ES5</code>和<code>ES2015</code>，调试和生产或<code>Commonjs</code>和<code>System</code>。只有几个配置选项在这两个版本之间改变，并且维护多个<code>tsconfig.json</code>文件是麻烦的。</p>
<p>TypeScript 2.1支持使用<code>extends</code>来继承配置，其中：</p>
<ul>
<li><code>extends</code>在<code>tsconfig.json</code>是新的顶级属性（与<code>compilerOptions</code>、<code>files</code>、<code>include</code>和<code>exclude</code>一起）。</li>
<li><code>extends</code>的值是包含继承自其它<code>tsconfig.json</code>路径的字符串。</li>
<li>首先加载基本文件中的配置，然后由继承配置文件重写。</li>
<li>如果遇到循环，我们报告错误。</li>
<li>继承配置文件中的<code>files</code>、<code>include</code>和<code>exclude</code>会重写基本配置文件中相应的值。</li>
<li>在配置文件中找到的所有相对路径将相对于它们来源的配置文件来解析。</li>
</ul>
<h4 id="示例-13"><a class="header" href="#示例-13">示例</a></h4>
<p><code>configs/base.json</code>:</p>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "allowJs": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
</code></pre>
<p><code>configs/tests.json</code>:</p>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "preserveConstEnums": true,
    "stripComments": false,
    "sourceMaps": true
  },
  "exclude": [
    "../tests/baselines",
    "../tests/scenarios"
  ],
  "include": [
    "../tests/**/*.ts"
  ]
}
</code></pre>
<p><code>tsconfig.json</code>:</p>
<pre><code class="language-javascript">{
  "extends": "./configs/base",
  "files": [
    "main.ts",
    "supplemental.ts"
  ]
}
</code></pre>
<p><code>tsconfig.nostrictnull.json</code>:</p>
<pre><code class="language-javascript">{
  "extends": "./tsconfig",
  "compilerOptions": {
    "strictNullChecks": false
  }
}
</code></pre>
<h2 id="新编译参数--alwaysstrict"><a class="header" href="#新编译参数--alwaysstrict">新编译参数<code>--alwaysStrict</code></a></h2>
<p>使用<code>--alwaysStrict</code>调用编译器原因：1.在严格模式下解析的所有代码。2.在每一个生成文件上输出<code>"use strict";</code>指令;</p>
<p>模块会自动使用严格模式解析。对于非模块代码，建议使用该编译参数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-20"><a class="header" href="#typescript-20">TypeScript 2.0</a></h1>
<h2 id="null和undefined类型"><a class="header" href="#null和undefined类型">Null和undefined类型</a></h2>
<p>TypeScript现在有两个特殊的类型：Null和Undefined, 它们的值分别是<code>null</code>和<code>undefined</code>。 以前这是不可能明确地命名这些类型的，但是现在<code>null</code>和<code>undefined</code>不管在什么类型检查模式下都可以作为类型名称使用。</p>
<p>以前类型检查器认为<code>null</code>和<code>undefined</code>赋值给一切。实际上，<code>null</code>和<code>undefined</code>是每一个类型的有效值， 并且不能明确排除它们（因此不可能检测到错误）。</p>
<h3 id="--strictnullchecks"><a class="header" href="#--strictnullchecks"><code>--strictNullChecks</code></a></h3>
<p><code>--strictNullChecks</code>可以切换到新的严格空检查模式中。</p>
<p>在严格空检查模式中，<code>null</code>和<code>undefined</code>值_不再_属于任何类型的值，仅仅属于它们自己类型和<code>any</code>类型的值 （还有一个例外，<code>undefined</code>也能赋值给<code>void</code>）。因此，尽管在常规类型检查模式下<code>T</code>和<code>T | undefined</code>被认为是相同的 （因为<code>undefined</code>被认为是任何<code>T</code>的子类型），但是在严格类型检查模式下它们是不同的， 并且仅仅<code>T | undefined</code>允许有<code>undefined</code>值，<code>T</code>和<code>T | null</code>的关系同样如此。</p>
<h4 id="示例-14"><a class="header" href="#示例-14">示例</a></h4>
<pre><code class="language-typescript">// 使用--strictNullChecks参数进行编译的
let x: number;
let y: number | undefined;
let z: number | null | undefined;
x = 1;  // 正确
y = 1;  // 正确
z = 1;  // 正确
x = undefined;  // 错误
y = undefined;  // 正确
z = undefined;  // 正确
x = null;  // 错误
y = null;  // 错误
z = null;  // 正确
x = y;  // 错误
x = z;  // 错误
y = x;  // 正确
y = z;  // 错误
z = x;  // 正确
z = y;  // 正确
</code></pre>
<h3 id="使用前赋值检查"><a class="header" href="#使用前赋值检查">使用前赋值检查</a></h3>
<p>在严格空检查模式中，编译器要求未包含<code>undefined</code>类型的局部变量在使用之前必须先赋值。</p>
<h4 id="示例-15"><a class="header" href="#示例-15">示例</a></h4>
<pre><code class="language-typescript">// 使用--strictNullChecks参数进行编译
let x: number;
let y: number | null;
let z: number | undefined;
x;  // 错误，使用前未赋值
y;  // 错误，使用前未赋值
z;  // 正确
x = 1;
y = null;
x;  // 正确
y;  // 正确
</code></pre>
<p>编译器通过执行_基于控制流的类型分析_检查变量明确被赋过值。在本篇文章后面会有进一步的细节。</p>
<h3 id="可选参数和属性"><a class="header" href="#可选参数和属性">可选参数和属性</a></h3>
<p>可选参数和属性会自动把<code>undefined</code>添加到他们的类型中，即使他们的类型注解明确不包含<code>undefined</code>。例如，下面两个类型是完全相同的：</p>
<pre><code class="language-typescript">// 使用--strictNullChecks参数进行编译
type T1 = (x?: number) =&gt; string;              // x的类型是 number | undefined
type T2 = (x?: number | undefined) =&gt; string;  // x的类型是 number | undefined
</code></pre>
<h3 id="非null和非undefined类型保护"><a class="header" href="#非null和非undefined类型保护">非null和非undefined类型保护</a></h3>
<p>如果对象或者函数的类型包含<code>null</code>和<code>undefined</code>，那么访问属性或调用函数时就会产生编译错误。因此，对类型保护进行了扩展，以支持对非null和非undefined的检查。</p>
<h4 id="示例-16"><a class="header" href="#示例-16">示例</a></h4>
<pre><code class="language-typescript">// 使用--strictNullChecks参数进行编译
declare function f(x: number): string;
let x: number | null | undefined;
if (x) {
    f(x);  // 正确，这里的x类型是number
}
else {
    f(x);  // 错误，这里的x类型是number？
}
let a = x != null ? f(x) : "";  // a的类型是string
let b = x &amp;&amp; f(x);  // b的类型是 string | 0 | null | undefined
</code></pre>
<p>非null和非undefined类型保护可以使用<code>==</code>、<code>!=</code>、<code>===</code>或<code>!==</code>操作符和<code>null</code>或<code>undefined</code>进行比较，如<code>x != null</code>或<code>x === undefined</code>。对被试变量类型的影响准确地反映了JavaScript的语义（比如，双等号运算符检查两个值无论你指定的是null还是undefined，然而三等于号运算符仅仅检查指定的那一个值）。</p>
<h3 id="类型保护中的点名称"><a class="header" href="#类型保护中的点名称">类型保护中的点名称</a></h3>
<p>类型保护以前仅仅支持对局部变量和参数的检查。现在类型保护支持检查由变量或参数名称后跟一个或多个访问属性组成的“点名称”。</p>
<h4 id="示例-17"><a class="header" href="#示例-17">示例</a></h4>
<pre><code class="language-typescript">interface Options {
    location?: {
        x?: number;
        y?: number;
    };
}

function foo(options?: Options) {
    if (options &amp;&amp; options.location &amp;&amp; options.location.x) {
        const x = options.location.x;  // x的类型是number
    }
}
</code></pre>
<p>点名称的类型保护和用户定义的类型保护函数，还有<code>typeof</code>和<code>instanceof</code>操作符一起工作，并且不依赖<code>--strictNullChecks</code>编译参数。</p>
<p>对点名称进行类型保护后给点名称任一部分赋值都会导致类型保护无效。例如，对<code>x.y.z</code>进行了类型保护后给<code>x</code>、<code>x.y</code>或<code>x.y.z</code>赋值，都会导致<code>x.y.z</code>类型保护无效。</p>
<h3 id="表达式操作符"><a class="header" href="#表达式操作符">表达式操作符</a></h3>
<p>表达式操作符允许运算对象的类型包含<code>null</code>和/或<code>undefined</code>，但是总是产生非null和非undefined类型的结果值。</p>
<pre><code class="language-javascript">// 使用--strictNullChecks参数进行编译
function sum(a: number | null, b: number | null) {
    return a + b;  // 计算的结果值类型是number
}
</code></pre>
<p><code>&amp;&amp;</code>操作符添加<code>null</code>和/或<code>undefined</code>到右边操作对象的类型中取决于当前左边操作对象的类型，<code>||</code>操作符从左边联合类型的操作对象的类型中将<code>null</code>和<code>undefined</code>同时删除。</p>
<pre><code class="language-typescript">// 使用--strictNullChecks参数进行编译
interface Entity {
    name: string;
}
let x: Entity | null;
let s = x &amp;&amp; x.name;  // s的类型是string | null
let y = x || { name: "test" };  // y的类型是Entity
</code></pre>
<h3 id="类型扩展"><a class="header" href="#类型扩展">类型扩展</a></h3>
<p>在严格空检查模式中，<code>null</code>和<code>undefined</code>类型是_不会_扩展到<code>any</code>类型中的。</p>
<pre><code class="language-typescript">let z = null;  // z的类型是null
</code></pre>
<p>在常规类型检查模式中，由于扩展，会推断<code>z</code>的类型是<code>any</code>，但是在严格空检查模式中，推断<code>z</code>是<code>null</code>类型（因此，如果没有类型注释，<code>null</code>是<code>z</code>的唯一值）。</p>
<h3 id="非空断言操作符"><a class="header" href="#非空断言操作符">非空断言操作符</a></h3>
<p>在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符<code>!</code>可以用于断言操作对象是非null和非undefined类型的。具体而言，运算<code>x!</code>产生一个不包含<code>null</code>和<code>undefined</code>的<code>x</code>的值。断言的形式类似于<code>&lt;T&gt;x</code>和<code>x as T</code>，<code>!</code>非空断言操作符会从编译成的JavaScript代码中移除。</p>
<pre><code class="language-typescript">// 使用--strictNullChecks参数进行编译
function validateEntity(e?: Entity) {
    // 如果e是null或者无效的实体，就会抛出异常
}

function processEntity(e?: Entity) {
    validateEntity(e);
    let s = e!.name;  // 断言e是非空并访问name属性
}
</code></pre>
<h3 id="兼容性"><a class="header" href="#兼容性">兼容性</a></h3>
<p>这些新特性是经过设计的，使得它们能够在严格空检查模式和常规类型检查模式下都能够使用。尤其是在常规类型检查模式中，<code>null</code>和<code>undefined</code>类型会自动从联合类型中删除（因为它们是其它所有类型的子类型），<code>!</code>非空断言表达式操作符也被允许使用但是没有任何作用。因此，声明文件使用null和undefined敏感类型更新后，在常规类型模式中仍然是可以向后兼容使用的。</p>
<p>在实际应用中，严格空检查模式要求编译的所有文件都是null和undefined敏感类型。</p>
<h2 id="基于控制流的类型分析"><a class="header" href="#基于控制流的类型分析">基于控制流的类型分析</a></h2>
<p>TypeScript 2.0实现了对局部变量和参数的控制流类型分析。以前，对类型保护进行类型分析仅限于<code>if</code>语句和<code>?:</code>条件表达式，并且不包括赋值和控制流结构的影响，例如<code>return</code>和<code>break</code>语句。使用TypeScript 2.0，类型检查器会分析语句和表达式所有可能的控制流，在任何指定的位置对声明为联合类型的局部变量或参数产生最可能的具体类型（缩小范围的类型）。</p>
<h4 id="示例-18"><a class="header" href="#示例-18">示例</a></h4>
<pre><code class="language-typescript">function foo(x: string | number | boolean) {
    if (typeof x === "string") {
        x; // 这里x的类型是string
        x = 1;
        x; // 这里x的类型是number
    }
    x; // 这里x的类型是number | boolean
}

function bar(x: string | number) {
    if (typeof x === "number") {
        return;
    }
    x; // 这里x的类型是string
}
</code></pre>
<p>基于控制流的类型分析在<code>--strictNullChecks</code>模式中尤为重要，因为可空类型使用联合类型来表示：</p>
<pre><code class="language-typescript">function test(x: string | null) {
    if (x === null) {
        return;
    }
    x; // 在函数的剩余部分中，x类型是string
}
</code></pre>
<p>而且，在<code>--strictNullChecks</code>模式中，基于控制流的分析包括，对类型不允许为<code>undefined</code>的局部变量有_明确赋值_的分析。</p>
<pre><code class="language-typescript">function mumble(check: boolean) {
    let x: number; // 类型不允许为undefined
    x; // 错误，x是undefined
    if (check) {
        x = 1;
        x; // 正确
    }
    x; // 错误，x可能是undefi
    x = 2;
    x; // 正确
}
</code></pre>
<h2 id="标记联合类型"><a class="header" href="#标记联合类型">标记联合类型</a></h2>
<p>TypeScript 2.0实现了标记（或区分）联合类型。具体而言，TS编译器现在支持类型保护，基于判别属性的检查来缩小联合类型的范围，并且<code>switch</code>语句也支持此特性。</p>
<h4 id="示例-19"><a class="header" href="#示例-19">示例</a></h4>
<pre><code class="language-typescript">interface Square {
    kind: "square";
    size: number;
}

interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}

interface Circle {
    kind: "circle";
    radius: number;
}

type Shape = Square | Rectangle | Circle;

function area(s: Shape) {
    // 在下面的switch语句中，s的类型在每一个case中都被缩小
    // 根据判别属性的值，变量的其它属性不使用类型断言就可以被访问
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.width * s.height;
        case "circle": return Math.PI * s.radius * s.radius;
    }
}

function test1(s: Shape) {
    if (s.kind === "square") {
        s;  // Square
    }
    else {
        s;  // Rectangle | Circle
    }
}

function test2(s: Shape) {
    if (s.kind === "square" || s.kind === "rectangle") {
        return;
    }
    s;  // Circle
}
</code></pre>
<p>_判别属性类型保护_是<code>x.p == v</code>、<code>x.p === v</code>、<code>x.p != v</code>或者<code>x.p !== v</code>其中的一种表达式，<code>p</code>和<code>v</code>是一个属性和字符串字面量类型或字符串字面量联合类型的表达式。判别属性类型保护缩小<code>x</code>的类型到由判别属性<code>p</code>和<code>v</code>的可能值之一组成的类型。</p>
<p>请注意，我们目前只支持字符串字面值类型的判别属性。我们打算以后添加对布尔值和数字字面量类型的支持。</p>
<h2 id="never类型"><a class="header" href="#never类型"><code>never</code>类型</a></h2>
<p>TypeScript 2.0引入了一个新原始类型<code>never</code>。<code>never</code>类型表示值的类型从不出现。具体而言，<code>never</code>是永不返回函数的返回类型，也是变量在类型保护中永不为true的类型。</p>
<p><code>never</code>类型具有以下特征：</p>
<ul>
<li><code>never</code>是所有类型的子类型并且可以赋值给所有类型。</li>
<li>没有类型是<code>never</code>的子类型或能赋值给<code>never</code>（<code>never</code>类型本身除外）。</li>
<li>在函数表达式或箭头函数没有返回类型注解时，如果函数没有<code>return</code>语句，或者只有<code>never</code>类型表达式的<code>return</code>语句，并且如果函数是不可执行到终点的（例如通过控制流分析决定的），则推断函数的返回类型是<code>never</code>。</li>
<li>在有明确<code>never</code>返回类型注解的函数中，所有<code>return</code>语句（如果有的话）必须有<code>never</code>类型的表达式并且函数的终点必须是不可执行的。</li>
</ul>
<p>因为<code>never</code>是每一个类型的子类型，所以它总是在联合类型中被省略，并且在函数中只要其它类型被返回，类型推断就会忽略<code>never</code>类型。</p>
<p>一些返回<code>never</code>函数的示例：</p>
<pre><code class="language-typescript">// 函数返回never必须无法执行到终点
function error(message: string): never {
    throw new Error(message);
}

// 推断返回类型是never
function fail() {
    return error("Something failed");
}

// 函数返回never必须无法执行到终点
function infiniteLoop(): never {
    while (true) {
    }
}
</code></pre>
<p>一些函数返回<code>never</code>的使用示例：</p>
<pre><code class="language-typescript">// 推断返回类型是number
function move1(direction: "up" | "down") {
    switch (direction) {
        case "up":
            return 1;
        case "down":
            return -1;
    }
    return error("Should never get here");
}

// 推断返回类型是number
function move2(direction: "up" | "down") {
    return direction === "up" ? 1 :
        direction === "down" ? -1 :
        error("Should never get here");
}

// 推断返回类型是T
function check&lt;T&gt;(x: T | undefined) {
    return x || error("Undefined value");
}
</code></pre>
<p>因为<code>never</code>可以赋值给每一个类型，当需要回调函数返回一个更加具体的类型时，函数返回<code>never</code>类型可以用于检测返回类型是否正确：</p>
<pre><code class="language-typescript">function test(cb: () =&gt; string) {
    let s = cb();
    return s;
}

test(() =&gt; "hello");
test(() =&gt; fail());
test(() =&gt; { throw new Error(); })
</code></pre>
<h2 id="只读属性和索引签名"><a class="header" href="#只读属性和索引签名">只读属性和索引签名</a></h2>
<p>属性或索引签名现在可以使用<code>readonly</code>修饰符声明为只读的。</p>
<p>只读属性可以初始化和在同一个类的构造函数中被赋值，但是在其它情况下对只读属性的赋值是不允许的。</p>
<p>此外，有几种情况下实体_隐式_只读的：</p>
<ul>
<li>属性声明只使用<code>get</code>访问器而没有使用<code>set</code>访问器被视为只读的。</li>
<li>在枚举类型中，枚举成员被视为只读属性。</li>
<li>在模块类型中，导出的<code>const</code>变量被视为只读属性。</li>
<li>在<code>import</code>语句中声明的实体被视为只读的。</li>
<li>通过ES2015命名空间导入访问的实体被视为只读的（例如，当<code>foo</code>当作<code>import * as foo from "foo"</code>声明时，<code>foo.x</code>是只读的）。</li>
</ul>
<h4 id="示例-20"><a class="header" href="#示例-20">示例</a></h4>
<pre><code class="language-typescript">interface Point {
    readonly x: number;
    readonly y: number;
}

var p1: Point = { x: 10, y: 20 };
p1.x = 5;  // 错误，p1.x是只读的

var p2 = { x: 1, y: 1 };
var p3: Point = p2;  // 正确，p2的只读别名
p3.x = 5;  // 错误，p3.x是只读的
p2.x = 5;  // 正确，但是因为别名使用，同时也改变了p3.x
</code></pre>
<pre><code class="language-typescript">class Foo {
    readonly a = 1;
    readonly b: string;
    constructor() {
        this.b = "hello";  // 在构造函数中允许赋值
    }
}
</code></pre>
<pre><code class="language-typescript">let a: Array&lt;number&gt; = [0, 1, 2, 3, 4];
let b: ReadonlyArray&lt;number&gt; = a;
b[5] = 5;      // 错误，元素是只读的
b.push(5);     // 错误，没有push方法（因为这会修改数组）
b.length = 3;  // 错误，length是只读的
a = b;         // 错误，缺少修改数组的方法
</code></pre>
<h2 id="指定函数中this类型"><a class="header" href="#指定函数中this类型">指定函数中<code>this</code>类型</a></h2>
<p>紧跟着类和接口，现在函数和方法也可以声明<code>this</code>的类型了。</p>
<p>函数中<code>this</code>的默认类型是<code>any</code>。从TypeScript 2.0开始，你可以提供一个明确的<code>this</code>参数。<code>this</code>参数是伪参数，它位于函数参数列表的第一位：</p>
<pre><code class="language-typescript">function f(this: void) {
    // 确保`this`在这个独立的函数中无法使用
}
</code></pre>
<h3 id="回调函数中的this参数"><a class="header" href="#回调函数中的this参数">回调函数中的<code>this</code>参数</a></h3>
<p>库也可以使用<code>this</code>参数声明回调函数如何被调用。</p>
<h4 id="示例-21"><a class="header" href="#示例-21">示例</a></h4>
<pre><code class="language-typescript">interface UIElement {
    addClickListener(onclick: (this: void, e: Event) =&gt; void): void;
}
</code></pre>
<p><code>this:void</code>意味着<code>addClickListener</code>预计<code>onclick</code>是一个<code>this</code>参数不需要类型的函数。</p>
<p>现在如果你在调用代码中对<code>this</code>进行了类型注释：</p>
<pre><code class="language-typescript">class Handler {
    info: string;
    onClickBad(this: Handler, e: Event) {
        // 哎哟，在这里使用this.在运行中使用这个回调函数将会崩溃。
        this.info = e.message;
    };
}
let h = new Handler();
uiElement.addClickListener(h.onClickBad); // 错误！
</code></pre>
<h3 id="--noimplicitthis"><a class="header" href="#--noimplicitthis"><code>--noImplicitThis</code></a></h3>
<p>TypeScript 2.0还增加了一个新的编译选项用来标记函数中所有没有明确类型注释的<code>this</code>的使用。</p>
<h2 id="tsconfigjson支持文件通配符"><a class="header" href="#tsconfigjson支持文件通配符"><code>tsconfig.json</code>支持文件通配符</a></h2>
<p>文件通配符来啦！！支持文件通配符一直是<a href="https://github.com/Microsoft/TypeScript/issues/1927">最需要的特性之一</a>。</p>
<p>类似文件通配符的文件模式支持两个属性<code>"include"</code>和<code>"exclude"</code>。</p>
<h4 id="示例-22"><a class="header" href="#示例-22">示例</a></h4>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "module": "commonjs",
        "noImplicitAny": true,
        "removeComments": true,
        "preserveConstEnums": true,
        "outFile": "../../built/local/tsc.js",
        "sourceMap": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.spec.ts"
    ]
}
</code></pre>
<p>支持文件通配符的符号有：</p>
<ul>
<li><code>*</code>匹配零个或多个字符（不包括目录）</li>
<li><code>?</code>匹配任意一个字符（不包括目录）</li>
<li><code>**/</code>递归匹配所有子目录</li>
</ul>
<p>如果文件通配符模式语句中只包含<code>*</code>或<code>.*</code>，那么只匹配带有扩展名的文件（例如默认是<code>.ts</code>、<code>.tsx</code>和<code>.d.ts</code>，如果<code>allowJs</code>设置为<code>true</code>，<code>.js</code>和<code>.jsx</code>也属于默认）。</p>
<p>如果<code>"files"</code>和<code>"include"</code>都没有指定，编译器默认包含所有目录中的TypeScript文件（<code>.ts</code>、<code>.d.ts</code>和<code>.tsx</code>），除了那些使用<code>exclude</code>属性排除的文件外。如果<code>allowJs</code>设置为true，JS文件（<code>.js</code>和<code>.jsx</code>）也会被包含进去。</p>
<p>如果<code>"files"</code>和<code>"include"</code>都指定了，编译器将包含这两个属性指定文件的并集。使用<code>ourDir</code>编译选项指定的目录文件总是被排除，即使<code>"exclude"</code>属性指定的文件也会被删除，但是<code>files</code>属性指定的文件不会排除。</p>
<p><code>"exclude"</code>属性指定的文件会对<code>"include"</code>属性指定的文件过滤。但是对<code>"files"</code>指定的文件没有任何作用。当没有明确指定时，<code>"exclude"</code>属性默认会排除<code>node_modules</code>、<code>bower_components</code>和<code>jspm_packages</code>目录。</p>
<h2 id="模块解析增加baseurl路径映射rootdirs和追踪"><a class="header" href="#模块解析增加baseurl路径映射rootdirs和追踪">模块解析增加：BaseUrl、路径映射、rootDirs和追踪</a></h2>
<p>TypeScript 2.0提供了一系列额外的模块解析属性告诉编译器去哪里可以找到给定模块的声明。</p>
<p>更多详情，请参阅<a href="zh/release-notes/../handbook/module-resolution.html">模块解析</a>文档。</p>
<h3 id="base-url-1"><a class="header" href="#base-url-1">Base URL</a></h3>
<p>使用了AMD模块加载器并且模块在运行时”部署“到单文件夹的应用程序中使用<code>baseUrl</code>是一种常用的做法。所有非相对名称的模块导入被认为是相对于<code>baseUrl</code>的。</p>
<h4 id="示例-23"><a class="header" href="#示例-23">示例</a></h4>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "baseUrl": "./modules"
  }
}
</code></pre>
<p>现在导入<code>moduleA</code>将会在<code>./modules/moduleA</code>中查找。</p>
<pre><code class="language-typescript">import A from "moduleA";
</code></pre>
<h3 id="路径映射-1"><a class="header" href="#路径映射-1">路径映射</a></h3>
<p>有时模块没有直接位于_baseUrl_中。加载器使用映射配置在运行时去映射模块名称和文件，请参阅<a href="http://requirejs.org/docs/api.html#config-paths">RequireJs文档</a>和<a href="https://github.com/systemjs/systemjs/blob/master/docs/overview.md#map-config">SystemJS文档</a>。</p>
<p>TypeScript编译器支持<code>tsconfig</code>文件中使用<code>"paths"</code>属性映射的声明。</p>
<h4 id="示例-24"><a class="header" href="#示例-24">示例</a></h4>
<p>例如，导入<code>"jquery"</code>模块在运行时会被转换为<code>"node_modules/jquery/dist/jquery.slim.min.js"</code>。</p>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "baseUrl": "./node_modules",
        "paths": {
        "jquery": ["jquery/dist/jquery.slim.min"]
        }
    }
}
</code></pre>
<p>使用<code>"paths"</code>也允许更复杂的映射，包括多次后退的位置。考虑一个只有一个地方的模块是可用的，其它的模块都在另一个地方的项目配置。</p>
<h3 id="rootdirs和虚拟目录"><a class="header" href="#rootdirs和虚拟目录"><code>rootDirs</code>和虚拟目录</a></h3>
<p>使用<code>rootDirs</code>，你可以告知编译器的_根目录_组合这些“虚拟”目录。因此编译器在这些“虚拟”目录中解析相对导入模块，仿佛是合并到一个目录中一样。</p>
<h4 id="示例-25"><a class="header" href="#示例-25">示例</a></h4>
<p>给定的项目结构</p>
<pre><code class="language-text"> src
 └── views
     └── view1.ts (imports './template1')
     └── view2.ts

 generated
 └── templates
         └── views
             └── template1.ts (imports './view2')
</code></pre>
<p>构建步骤将复制<code>/src/views</code>和<code>/generated/templates/views</code>目录下的文件输出到同一个目录中。在运行时，视图期望它的模板和它存在同一目录中，因此应该使用相对名称<code>"./template"</code>导入。</p>
<p><code>"rootDir"</code>指定的一组根目录的内容将会在运行时合并。因此在我们的例子，<code>tsconfig.json</code>文件应该类似于：</p>
<pre><code class="language-javascript">{
  "compilerOptions": {
    "rootDirs": [
      "src/views",
      "generated/templates/views"
    ]
  }
}
</code></pre>
<h3 id="追踪模块解析"><a class="header" href="#追踪模块解析">追踪模块解析</a></h3>
<p><code>--traceResolution</code>提供了一种方便的方法，以了解模块如何被编译器解析的。</p>
<pre><code class="language-text">tsc --traceResolution
</code></pre>
<h2 id="快捷外部模块声明"><a class="header" href="#快捷外部模块声明">快捷外部模块声明</a></h2>
<p>当你使用一个新模块时，如果不想要花费时间书写一个声明时，现在你可以使用快捷声明以便以快速开始。</p>
<h4 id="declarationsdts"><a class="header" href="#declarationsdts">declarations.d.ts</a></h4>
<pre><code class="language-typescript">declare module "hot-new-module";
</code></pre>
<p>所有从快捷模块的导入都具有任意类型。</p>
<pre><code class="language-typescript">import x, {y} from "hot-new-module";
x(y);
</code></pre>
<h2 id="模块名称中的通配符"><a class="header" href="#模块名称中的通配符">模块名称中的通配符</a></h2>
<p>以前使用模块加载器（例如<a href="https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md">AMD</a>和<a href="https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.md">SystemJS</a>）导入没有代码的资源是不容易的。之前，必须为每个资源定义一个外部模块声明。</p>
<p>TypeScript 2.0支持使用通配符符号（<code>*</code>）定义一类模块名称。这种方式，一个声明只需要一次扩展名，而不再是每一个资源。</p>
<h4 id="示例-26"><a class="header" href="#示例-26">示例</a></h4>
<pre><code class="language-typescript">declare module "*!text" {
    const content: string;
    export default content;
}
// Some do it the other way around.
declare module "json!*" {
    const value: any;
    export default value;
}
</code></pre>
<p>现在你可以导入匹配<code>"*!text"</code>或<code>"json!*"</code>的东西了。</p>
<pre><code class="language-typescript">import fileContent from "./xyz.txt!text";
import data from "json!http://example.com/data.json";
console.log(data, fileContent);
</code></pre>
<p>当从一个基于非类型化的代码迁移时，通配符模块的名称可能更加有用。结合快捷外部模块声明，一组模块可以很容易地声明为<code>any</code>。</p>
<h4 id="示例-27"><a class="header" href="#示例-27">示例</a></h4>
<pre><code class="language-typescript">declare module "myLibrary/*";
</code></pre>
<p>所有位于<code>myLibrary</code>目录之下的模块的导入都被编译器认为是<code>any</code>类型，因此这些模块的任何类型检查都会被关闭。</p>
<pre><code class="language-typescript">import { readFile } from "myLibrary/fileSystem/readFile`;

readFile(); // readFile是'any'类型
</code></pre>
<h2 id="支持umd模块定义"><a class="header" href="#支持umd模块定义">支持UMD模块定义</a></h2>
<p>一些库被设计为可以使用多种模块加载器或者不是使用模块加载器（全局变量）来使用，这被称为<a href="https://github.com/umdjs/umd">UMD</a>或<a href="http://isomorphic.net/">同构</a>模块。这些库可以通过导入或全局变量访问。</p>
<p>举例：</p>
<p><strong>math-lib.d.ts</strong></p>
<pre><code class="language-typescript">export const isPrime(x: number): boolean;
export as namespace mathLib;
</code></pre>
<p>然后，该库可作为模块导入使用：</p>
<pre><code class="language-typescript">import { isPrime } from "math-lib";
isPrime(2);
mathLib.isPrime(2); // 错误：无法在模块内部使用全局定义
</code></pre>
<p>它也可以被用来作为一个全局变量，只限于没有<code>import</code>和<code>export</code>脚本文件中。</p>
<pre><code class="language-typescript">mathLib.isPrime(2);
</code></pre>
<h2 id="可选类属性"><a class="header" href="#可选类属性">可选类属性</a></h2>
<p>现在可以在类中声明可选属性和方法，与接口类似。</p>
<h4 id="示例-28"><a class="header" href="#示例-28">示例</a></h4>
<pre><code class="language-typescript">class Bar {
    a: number;
    b?: number;
    f() {
        return 1;
    }
    g?(): number;  // 可选方法的方法体可以省略
    h?() {
        return 2;
    }
}
</code></pre>
<p>在<code>--strictNullChecks</code>模式下编译时，可选属性和方法会自动添加<code>undefined</code>到它们的类型中。因此，上面的<code>b</code>属性类型是<code>number | undefined</code>，上面<code>g</code>方法的类型是<code>(()=&gt; number) | undefined</code>。使用类型保护可以去除<code>undefined</code>。</p>
<h2 id="私有的和受保护的构造函数"><a class="header" href="#私有的和受保护的构造函数">私有的和受保护的构造函数</a></h2>
<p>类的构造函数可以被标记为<code>private</code>或<code>protected</code>。私有构造函数的类不能在类的外部实例化，并且也不能被继承。受保护构造函数的类不能再类的外部实例化，但是可以被继承。</p>
<h4 id="示例-29"><a class="header" href="#示例-29">示例</a></h4>
<pre><code class="language-typescript">class Singleton {
    private static instance: Singleton;

    private constructor() { }

    static getInstance() {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }
}

let e = new Singleton(); // 错误：Singleton的构造函数是私有的。
let v = Singleton.getInstance();
</code></pre>
<h2 id="抽象属性和访问器"><a class="header" href="#抽象属性和访问器">抽象属性和访问器</a></h2>
<p>抽象类可以声明抽象属性和、或访问器。所有子类将需要声明抽象属性或者被标记为抽象的。抽象属性不能初始化。抽象访问器不能有具体代码块。</p>
<h4 id="示例-30"><a class="header" href="#示例-30">示例</a></h4>
<pre><code class="language-typescript">abstract class Base {
    abstract name: string;
    abstract get value();
    abstract set value(v: number);
}

class Derived extends Base {
    name = "derived";

    value = 1;
}
</code></pre>
<h2 id="隐式索引签名"><a class="header" href="#隐式索引签名">隐式索引签名</a></h2>
<p>如果对象字面量中所有已知的属性是赋值给索引签名，那么现在对象字面量类型可以赋值给索引签名类型。这使得一个使用对象字面量初始化的变量作为参数传递给期望参数是map或dictionary的函数成为可能：</p>
<pre><code class="language-typescript">function httpService(path: string, headers: { [x: string]: string }) { }

const headers = {
    "Content-Type": "application/x-www-form-urlencoded"
};

httpService("", { "Content-Type": "application/x-www-form-urlencoded" });  // 可以
httpService("", headers);  // 现在可以，以前不可以。
</code></pre>
<h2 id="使用--lib编译参数包含内置类型声明"><a class="header" href="#使用--lib编译参数包含内置类型声明">使用<code>--lib</code>编译参数包含内置类型声明</a></h2>
<p>获取ES6/ES2015内置API声明仅限于<code>target: ES6</code>。输入<code>--lib</code>，你可以使用<code>--lib</code>指定一组项目所需要的内置API。比如说，如果你希望项目运行时支持<code>Map</code>、<code>Set</code>和<code>Promise</code>（例如现在静默更新浏览器），直接写<code>--lib es2015.collection,es2015.promise</code>就好了。同样，你也可以排除项目中不需要的声明，例如在node项目中使用<code>--lib es5,es6</code>排除DOM。</p>
<p>下面是列出了可用的API：</p>
<ul>
<li>dom</li>
<li>webworker</li>
<li>es5</li>
<li>es6 / es2015</li>
<li>es2015.core</li>
<li>es2015.collection</li>
<li>es2015.iterable</li>
<li>es2015.promise</li>
<li>es2015.proxy</li>
<li>es2015.reflect</li>
<li>es2015.generator</li>
<li>es2015.symbol</li>
<li>es2015.symbol.wellknown</li>
<li>es2016</li>
<li>es2016.array.include</li>
<li>es2017</li>
<li>es2017.object</li>
<li>es2017.sharedmemory</li>
<li>scripthost</li>
</ul>
<h4 id="示例-31"><a class="header" href="#示例-31">示例</a></h4>
<pre><code class="language-text">tsc --target es5 --lib es5,es2015.promise
</code></pre>
<pre><code class="language-javascript">"compilerOptions": {
    "lib": ["es5", "es2015.promise"]
}
</code></pre>
<h2 id="使用--nounusedparameters和--nounusedlocals标记未使用的声明"><a class="header" href="#使用--nounusedparameters和--nounusedlocals标记未使用的声明">使用<code>--noUnusedParameters</code>和<code>--noUnusedLocals</code>标记未使用的声明</a></h2>
<p>TypeScript 2.0有两个新的编译参数来帮助你保持一个干净的代码库。<code>-noUnusedParameters</code>编译参数标记所有未使用的函数或方法的参数错误。<code>--noUnusedLocals</code>标记所有未使用的局部（未导出）声明像变量、函数、类和导入等等，另外未使用的私有类成员在<code>--noUnusedLocals</code>作用下也会标记为错误。</p>
<h4 id="示例-32"><a class="header" href="#示例-32">示例</a></h4>
<pre><code class="language-typescript">import B, { readFile } from "./b";
//     ^ 错误：`B`声明了，但是没有使用。
readFile();


export function write(message: string, args: string[]) {
    //                                 ^^^^  错误：'arg'声明了，但是没有使用。
    console.log(message);
}
</code></pre>
<p>使用以<code>_</code>开头命名的参数声明不会被未使用参数检查。例如：</p>
<pre><code class="language-typescript">function returnNull(_a) { // 正确
    return null;
}
</code></pre>
<h2 id="模块名称允许js扩展名"><a class="header" href="#模块名称允许js扩展名">模块名称允许<code>.js</code>扩展名</a></h2>
<p>TypeScript 2.0之前，模块名称总是被认为是没有扩展名的。例如，导入一个模块<code>import d from "./moduleA.js"</code>，则编译器在<code>./moduleA.js.ts</code>或<code>./moduleA.js.d.ts</code>中查找<code>"moduleA.js"</code>的定义。这使得像<a href="https://github.com/systemjs/systemjs">SystemJS</a>这种期望模块名称是URI的打包或加载工具很难使用。</p>
<p>使用TypeScript 2.0，编译器将在<code>./moduleA.ts</code>或<code>./moduleA.d.ts</code>中查找<code>"moduleA.js"</code>的定义。</p>
<h2 id="支持编译参数target--es5和module-es6同时使用"><a class="header" href="#支持编译参数target--es5和module-es6同时使用">支持编译参数<code>target : es5</code>和<code>module: es6</code>同时使用</a></h2>
<p>之前编译参数<code>target : es5</code>和<code>module: es6</code>同时使用被认为是无效的，但是现在是有效的。这将有助于使用基于ES2015的tree-shaking（将无用代码移除）比如<a href="https://github.com/rollup/rollup">rollup</a>。</p>
<h2 id="函数形参和实参列表末尾支持逗号"><a class="header" href="#函数形参和实参列表末尾支持逗号">函数形参和实参列表末尾支持逗号</a></h2>
<p>现在函数形参和实参列表末尾允许有逗号。这是对<a href="https://jeffmo.github.io/es-trailing-function-commas/">第三阶段的ECMAScript提案</a>的实现, 并且会编译为可用的 ES3/ES5/ES6。</p>
<h4 id="示例-33"><a class="header" href="#示例-33">示例</a></h4>
<pre><code class="language-typescript">function foo(
  bar: Bar,
  baz: Baz, // 形参列表末尾添加逗号是没有问题的。
) {
  // 具体实现……
}

foo(
  bar,
  baz, // 实参列表末尾添加逗号同样没有问题
);
</code></pre>
<h2 id="新编译参数--skiplibcheck"><a class="header" href="#新编译参数--skiplibcheck">新编译参数<code>--skipLibCheck</code></a></h2>
<p>TypeScript 2.0添加了一个新的编译参数<code>--skipLibCheck</code>，该参数可以跳过声明文件（以<code>.d.ts</code>为扩展名的文件）的类型检查。当一个程序包含有大量的声明文件时，编译器需要花费大量时间对已知不包含错误的声明进行类型检查，通过跳过声明文件的类型检查，编译时间可能会大大缩短。</p>
<p>由于一个文件中的声明可以影响其他文件中的类型检查，当指定<code>--skipLibCheck</code>时，一些错误可能检测不到。比如说, 如果一个非声明文件中的类型被声明文件用到, 可能仅在声明文件被检查时能发现错误. 不过这种情况在实际使用中并不常见。</p>
<h2 id="允许在声明中重复标识符"><a class="header" href="#允许在声明中重复标识符">允许在声明中重复标识符</a></h2>
<p>这是重复定义错误的一个常见来源。多个声明文件定义相同的接口成员。</p>
<p>TypeScript 2.0放宽了这一约束，并允许可以不同代码块中出现重复的标识符, 只要它们有_完全相同_的类型。</p>
<p>在同一代码块重复定义仍不允许。</p>
<h4 id="示例-34"><a class="header" href="#示例-34">示例</a></h4>
<pre><code class="language-typescript">interface Error {
    stack?: string;
}


interface Error {
    code?: string;
    path?: string;
    stack?: string;  // OK
}
</code></pre>
<h2 id="新编译参数--declarationdir"><a class="header" href="#新编译参数--declarationdir">新编译参数<code>--declarationDir</code></a></h2>
<p><code>--declarationDir</code>可以使生成的声明文件和JavaScript文件不在同一个位置中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-18"><a class="header" href="#typescript-18">TypeScript 1.8</a></h1>
<h2 id="类型参数约束"><a class="header" href="#类型参数约束">类型参数约束</a></h2>
<p>在 TypeScript 1.8 中, 类型参数的限制可以引用自同一个类型参数列表中的类型参数. 在此之前这种做法会报错. 这种特性通常被叫做 <a href="https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification">F-Bounded Polymorphism</a>.</p>
<h3 id="例子-50"><a class="header" href="#例子-50">例子</a></h3>
<pre><code class="language-typescript">function assign&lt;T extends U, U&gt;(target: T, source: U): T {
    for (let id in source) {
        target[id] = source[id];
    }
    return target;
}

let x = { a: 1, b: 2, c: 3, d: 4 };
assign(x, { b: 10, d: 20 });
assign(x, { e: 0 });  // 错误
</code></pre>
<h2 id="控制流错误分析"><a class="header" href="#控制流错误分析">控制流错误分析</a></h2>
<p>TypeScript 1.8 中引入了控制流分析来捕获开发者通常会遇到的一些错误.</p>
<p>详情见接下来的内容, 可以上手尝试:</p>
<p><img src="https://cloud.githubusercontent.com/assets/8052307/5210657/c5ae0f28-7585-11e4-97d8-86169ef2a160.gif" alt="cfa" /></p>
<h3 id="不可及的代码"><a class="header" href="#不可及的代码">不可及的代码</a></h3>
<p>一定无法在运行时被执行的语句现在会被标记上代码不可及错误. 举个例子, 在无条件限制的 <code>return</code>, <code>throw</code>, <code>break</code> 或者 <code>continue</code> 后的语句被认为是不可及的. 使用 <code>--allowUnreachableCode</code> 来禁用不可及代码的检测和报错.</p>
<h4 id="例子-51"><a class="header" href="#例子-51">例子</a></h4>
<p>这里是一个简单的不可及错误的例子:</p>
<pre><code class="language-typescript">function f(x) {
    if (x) {
       return true;
    }
    else {
       return false;
    }

    x = 0; // 错误: 检测到不可及的代码.
}
</code></pre>
<p>这个特性能捕获的一个更常见的错误是在 <code>return</code> 语句后添加换行:</p>
<pre><code class="language-typescript">function f() {
    return            // 换行导致自动插入的分号
    {
        x: "string"   // 错误: 检测到不可及的代码.
    }
}
</code></pre>
<p>因为 JavaScript 会自动在行末结束 <code>return</code> 语句, 下面的对象字面量变成了一个代码块.</p>
<h3 id="未使用的标签"><a class="header" href="#未使用的标签">未使用的标签</a></h3>
<p>未使用的标签也会被标记. 和不可及代码检查一样, 被使用的标签检查也是默认开启的. 使用 <code>--allowUnusedLabels</code> 来禁用未使用标签的报错.</p>
<h4 id="例子-52"><a class="header" href="#例子-52">例子</a></h4>
<pre><code class="language-typescript">loop: while (x &gt; 0) {  // 错误: 未使用的标签.
    x++;
}
</code></pre>
<h3 id="隐式返回"><a class="header" href="#隐式返回">隐式返回</a></h3>
<p>JS 中没有返回值的代码分支会隐式地返回 <code>undefined</code>. 现在编译器可以将这种方式标记为隐式返回. 对于隐式返回的检查默认是被禁用的, 可以使用 <code>--noImplicitReturns</code> 来启用.</p>
<h4 id="例子-53"><a class="header" href="#例子-53">例子</a></h4>
<pre><code class="language-typescript">function f(x) { // 错误: 不是所有分支都返回了值.
    if (x) {
        return false;
    }

    // 隐式返回了 `undefined`
}
</code></pre>
<h3 id="case-语句贯穿"><a class="header" href="#case-语句贯穿">Case 语句贯穿</a></h3>
<p>TypeScript 现在可以在 switch 语句中出现贯穿的几个非空 case 时报错. 这个检测默认是关闭的, 可以使用 <code>--noFallthroughCasesInSwitch</code> 启用.</p>
<h4 id="例子-54"><a class="header" href="#例子-54">例子</a></h4>
<pre><code class="language-typescript">switch (x % 2) {
    case 0: // 错误: switch 中出现了贯穿的 case.
        console.log("even");

    case 1:
        console.log("odd");
        break;
}
</code></pre>
<p>然而, 在下面的例子中, 由于贯穿的 case 是空的, 并不会报错:</p>
<pre><code class="language-typescript">switch (x % 3) {
    case 0:
    case 1:
        console.log("Acceptable");
        break;

    case 2:
        console.log("This is *two much*!");
        break;
}
</code></pre>
<h2 id="react里的函数组件"><a class="header" href="#react里的函数组件">React里的函数组件</a></h2>
<p>TypeScript 现在支持<a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components">函数组件</a>. 它是可以组合其他组件的轻量级组件.</p>
<pre><code class="language-typescript">// 使用参数解构和默认值轻松地定义 'props' 的类型
const Greeter = ({name = 'world'}) =&gt; &lt;div&gt;Hello, {name}!&lt;/div&gt;;

// 参数可以被检验
let example = &lt;Greeter name='TypeScript 1.8' /&gt;;
</code></pre>
<p>如果需要使用这一特性及简化的 props, 请确认使用的是<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react">最新的 react.d.ts</a>.</p>
<h2 id="简化的-react-props-类型管理"><a class="header" href="#简化的-react-props-类型管理">简化的 React <code>props</code> 类型管理</a></h2>
<p>在 TypeScript 1.8 配合最新的 react.d.ts (见上方) 大幅简化了 <code>props</code> 的类型声明.</p>
<p>具体的:</p>
<ul>
<li>你不再需要显式的声明 <code>ref</code> 和 <code>key</code> 或者 <code>extend React.Props</code></li>
<li><code>ref</code> 和 <code>key</code> 属性会在所有组件上拥有正确的类型.</li>
<li><code>ref</code> 属性在无状态函数组件上会被正确地禁用.</li>
</ul>
<h2 id="在模块中扩充全局或者模块作用域"><a class="header" href="#在模块中扩充全局或者模块作用域">在模块中扩充全局或者模块作用域</a></h2>
<p>用户现在可以为任何模块进行他们想要, 或者其他人已经对其作出的扩充. 模块扩充的形式和过去的包模块一致 (例如 <code>declare module "foo" { }</code> 这样的语法), 并且可以直接嵌在你自己的模块内, 或者在另外的顶级外部包模块中.</p>
<p>除此之外, TypeScript 还以 <code>declare global { }</code> 的形式提供了对于_全局_声明的扩充. 这能使模块对像 <code>Array</code> 这样的全局类型在必要的时候进行扩充.</p>
<p>模块扩充的名称解析规则与 <code>import</code> 和 <code>export</code> 声明中的一致. 扩充的模块声明合并方式与在同一个文件中声明是相同的.</p>
<p>不论是模块扩充还是全局声明扩充都不能向顶级作用域添加新的项目 - 它们只能为已经存在的声明添加 "补丁".</p>
<h3 id="例子-55"><a class="header" href="#例子-55">例子</a></h3>
<p>这里的 <code>map.ts</code> 可以声明它会在内部修改在 <code>observable.ts</code> 中声明的 <code>Observable</code> 类型, 添加 <code>map</code> 方法.</p>
<pre><code class="language-typescript">// observable.ts
export class Observable&lt;T&gt; {
    // ...
}
</code></pre>
<pre><code class="language-typescript">// map.ts
import { Observable } from "./observable";

// 扩充 "./observable"
declare module "./observable" {

    // 使用接口合并扩充 'Observable' 类的定义
    interface Observable&lt;T&gt; {
        map&lt;U&gt;(proj: (el: T) =&gt; U): Observable&lt;U&gt;;
    }

}

Observable.prototype.map = /*...*/;
</code></pre>
<pre><code class="language-typescript">// consumer.ts
import { Observable } from "./observable";
import "./map";

let o: Observable&lt;number&gt;;
o.map(x =&gt; x.toFixed());
</code></pre>
<p>相似的, 在模块中全局作用域可以使用 <code>declare global</code> 声明被增强:</p>
<h3 id="例子-56"><a class="header" href="#例子-56">例子</a></h3>
<pre><code class="language-typescript">// 确保当前文件被当做一个模块.
export {};

declare global {
    interface Array&lt;T&gt; {
        mapToNumbers(): number[];
    }
}

Array.prototype.mapToNumbers = function () { /* ... */ }
</code></pre>
<h2 id="字符串字面量类型-2"><a class="header" href="#字符串字面量类型-2">字符串字面量类型</a></h2>
<p>接受一个特定字符串集合作为某个值的 API 并不少见. 举例来说, 考虑一个可以通过控制<a href="https://en.wikipedia.org/wiki/Inbetweening">动画的渐变</a>让元素在屏幕中滑动的 UI 库:</p>
<pre><code class="language-typescript">declare class UIElement {
    animate(options: AnimationOptions): void;
}

interface AnimationOptions {
    deltaX: number;
    deltaY: number;
    easing: string; // 可以是 "ease-in", "ease-out", "ease-in-out"
}
</code></pre>
<p>然而, 这容易产生错误 - 当用户错误不小心错误拼写了一个合法的值时, 并没有任何提示:</p>
<pre><code class="language-typescript">// 没有报错
new UIElement().animate({ deltaX: 100, deltaY: 100, easing: "ease-inout" });
</code></pre>
<p>在 TypeScript 1.8 中, 我们新增了字符串字面量类型. 这些类型和字符串字面量的写法一致, 只是写在类型的位置.</p>
<p>用户现在可以确保类型系统会捕获这样的错误. 这里是我们使用了字符串字面量类型的新的 <code>AnimationOptions</code>:</p>
<pre><code class="language-typescript">interface AnimationOptions {
    deltaX: number;
    deltaY: number;
    easing: "ease-in" | "ease-out" | "ease-in-out";
}

// 错误: 类型 '"ease-inout"' 不能复制给类型 '"ease-in" | "ease-out" | "ease-in-out"'
new UIElement().animate({ deltaX: 100, deltaY: 100, easing: "ease-inout" });
</code></pre>
<h2 id="更好的联合交叉类型接口"><a class="header" href="#更好的联合交叉类型接口">更好的联合/交叉类型接口</a></h2>
<p>TypeScript 1.8 优化了源类型和目标类型都是联合或者交叉类型的情况下的类型推导. 举例来说, 当从 <code>string | string[]</code> 推导到 <code>string | T</code> 时, 我们将类型拆解为 <code>string[]</code> 和 <code>T</code>, 这样就可以将 <code>string[]</code> 推导为 <code>T</code>.</p>
<h3 id="例子-57"><a class="header" href="#例子-57">例子</a></h3>
<pre><code class="language-typescript">type Maybe&lt;T&gt; = T | void;

function isDefined&lt;T&gt;(x: Maybe&lt;T&gt;): x is T {
    return x !== undefined &amp;&amp; x !== null;
}

function isUndefined&lt;T&gt;(x: Maybe&lt;T&gt;): x is void {
    return x === undefined || x === null;
}

function getOrElse&lt;T&gt;(x: Maybe&lt;T&gt;, defaultValue: T): T {
    return isDefined(x) ? x : defaultValue;
}

function test1(x: Maybe&lt;string&gt;) {
    let x1 = getOrElse(x, "Undefined");         // string
    let x2 = isDefined(x) ? x : "Undefined";    // string
    let x3 = isUndefined(x) ? "Undefined" : x;  // string
}

function test2(x: Maybe&lt;number&gt;) {
    let x1 = getOrElse(x, -1);         // number
    let x2 = isDefined(x) ? x : -1;    // number
    let x3 = isUndefined(x) ? -1 : x;  // number
}
</code></pre>
<h2 id="使用---outfile-合并-amd-和-system-模块"><a class="header" href="#使用---outfile-合并-amd-和-system-模块">使用 <code>--outFile</code> 合并 <code>AMD</code> 和 <code>System</code> 模块</a></h2>
<p>在使用 <code>--module amd</code> 或者 <code>--module system</code> 的同时制定 <code>--outFile</code> 将会把所有参与编译的模块合并为单个包括了多个模块闭包的输出文件.</p>
<p>每一个模块都会根据其相对于 <code>rootDir</code> 的位置被计算出自己的模块名称.</p>
<h3 id="例子-58"><a class="header" href="#例子-58">例子</a></h3>
<pre><code class="language-typescript">// 文件 src/a.ts
import * as B from "./lib/b";
export function createA() {
    return B.createB();
}
</code></pre>
<pre><code class="language-typescript">// 文件 src/lib/b.ts
export function createB() {
    return { };
}
</code></pre>
<p>结果为:</p>
<pre><code class="language-javascript">define("lib/b", ["require", "exports"], function (require, exports) {
    "use strict";
    function createB() {
        return {};
    }
    exports.createB = createB;
});
define("a", ["require", "exports", "lib/b"], function (require, exports, B) {
    "use strict";
    function createA() {
        return B.createB();
    }
    exports.createA = createA;
});
</code></pre>
<h2 id="支持-systemjs-使用-default-导入"><a class="header" href="#支持-systemjs-使用-default-导入">支持 SystemJS 使用 <code>default</code> 导入</a></h2>
<p>像 SystemJS 这样的模块加载器将 CommonJS 模块做了包装并暴露为 <code>default</code> ES6 导入项. 这使得在 SystemJS 和 CommonJS 的实现由于不同加载器不同的模块导出方式不能共享定义.</p>
<p>设置新的编译选项 <code>--allowSyntheticDefaultImports</code> 指明模块加载器会进行导入的 <code>.ts</code> 或 <code>.d.ts</code> 中未指定的某种类型的默认导入项构建. 编译器会由此推断存在一个 <code>default</code> 导出项和整个模块自己一致.</p>
<p>此选项在 System 模块默认开启.</p>
<h2 id="允许循环中被引用的-letconst"><a class="header" href="#允许循环中被引用的-letconst">允许循环中被引用的 <code>let</code>/<code>const</code></a></h2>
<p>之前这样会报错, 现在由 TypeScript 1.8 支持. 循环中被函数引用的 <code>let</code>/<code>const</code> 声明现在会被输出为与 <code>let</code>/<code>const</code> 更新语义相符的代码.</p>
<h3 id="例子-59"><a class="header" href="#例子-59">例子</a></h3>
<pre><code class="language-typescript">let list = [];
for (let i = 0; i &lt; 5; i++) {
    list.push(() =&gt; i);
}

list.forEach(f =&gt; console.log(f()));
</code></pre>
<p>被编译为:</p>
<pre><code class="language-javascript">var list = [];
var _loop_1 = function(i) {
    list.push(function () { return i; });
};
for (var i = 0; i &lt; 5; i++) {
    _loop_1(i);
}
list.forEach(function (f) { return console.log(f()); });
</code></pre>
<p>然后结果是:</p>
<pre><code class="language-text">0
1
2
3
4
</code></pre>
<h2 id="改进的-forin-语句检查"><a class="header" href="#改进的-forin-语句检查">改进的 <code>for..in</code> 语句检查</a></h2>
<p>过去 <code>for..in</code> 变量的类型被推断为 <code>any</code>, 这使得编译器忽略了 <code>for..in</code> 语句内的一些不合法的使用.</p>
<p>从 TypeScript 1.8 开始:</p>
<ul>
<li>在 <code>for..in</code> 语句中的变量隐含类型为 <code>string</code>.</li>
<li>当一个有数字索引签名对应类型 <code>T</code> (比如一个数组) 的对象被一个 <code>for..in</code> 索引_有_数字索引签名并且_没有_字符串索引签名 (比如还是数组) 的对象的变量索引, 产生的值的类型为 <code>T</code>.</li>
</ul>
<h3 id="例子-60"><a class="header" href="#例子-60">例子</a></h3>
<pre><code class="language-typescript">var a: MyObject[];
for (var x in a) {   // x 的隐含类型为 string
    var obj = a[x];  // obj 的类型为 MyObject
}
</code></pre>
<h2 id="模块现在输出时会加上-use-strict"><a class="header" href="#模块现在输出时会加上-use-strict">模块现在输出时会加上 <code>"use strict;"</code></a></h2>
<p>对于 ES6 来说模块始终以严格模式被解析, 但这一点过去对于非 ES6 目标在生成的代码中并没有遵循. 从 TypeScript 1.8 开始, 输出的模块总会为严格模式. 由于多数严格模式下的错误也是 TS 编译时的错误, 多数代码并不会有可见的改动, 但是这也意味着有一些东西可能在运行时没有征兆地失败, 比如赋值给 <code>NaN</code> 现在会有运行时错误. 你可以参考这篇 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mod">MDN 上的文章</a> 查看详细的严格模式与非严格模式的区别列表.</p>
<h2 id="使用---allowjs-加入-js-文件"><a class="header" href="#使用---allowjs-加入-js-文件">使用 <code>--allowJs</code> 加入 <code>.js</code> 文件</a></h2>
<p>经常在项目中会有外部的非 TypeScript 编写的源文件. 一种方式是将 JS 代码转换为 TS 代码, 但这时又希望将所有 JS 代码和新的 TS 代码的输出一起打包为一个文件.</p>
<p><code>.js</code> 文件现在允许作为 <code>tsc</code> 的输入文件. TypeScript 编译器会检查 <code>.js</code> 输入文件的语法错误, 并根据 <code>--target</code> 和 <code>--module</code> 选项输出对应的代码. 输出也会和其他 <code>.ts</code> 文件一起. <code>.js</code> 文件的 source maps 也会像 <code>.ts</code> 文件一样被生成.</p>
<h2 id="使用---reactnamespace-自定义-jsx-工厂"><a class="header" href="#使用---reactnamespace-自定义-jsx-工厂">使用 <code>--reactNamespace</code> 自定义 JSX 工厂</a></h2>
<p>在使用 <code>--jsx react</code> 的同时使用 <code>--reactNamespace &lt;JSX 工厂名称&gt;</code> 可以允许使用一个不同的 JSX 工厂代替默认的 <code>React</code>.</p>
<p>新的工厂名称会被用来调用 <code>createElement</code> 和 <code>__spread</code> 方法.</p>
<h3 id="例子-61"><a class="header" href="#例子-61">例子</a></h3>
<pre><code class="language-typescript">import {jsxFactory} from "jsxFactory";

var div = &lt;div&gt;Hello JSX!&lt;/div&gt;
</code></pre>
<p>编译参数:</p>
<pre><code class="language-text">tsc --jsx react --reactNamespace jsxFactory --m commonJS
</code></pre>
<p>结果:</p>
<pre><code class="language-javascript">"use strict";
var jsxFactory_1 = require("jsxFactory");
var div = jsxFactory_1.jsxFactory.createElement("div", null, "Hello JSX!");
</code></pre>
<h2 id="基于-this-的类型收窄"><a class="header" href="#基于-this-的类型收窄">基于 <code>this</code> 的类型收窄</a></h2>
<p>TypeScript 1.8 为类和接口方法扩展了<a href="zh/release-notes/typescript-1.8.html#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84%E5%87%BD%E6%95%B0">用户定义的类型收窄函数</a>.</p>
<p><code>this is T</code> 现在是类或接口方法的合法的返回值类型标注. 当在类型收窄的位置使用时 (比如 <code>if</code> 语句), 函数调用表达式的目标对象的类型会被收窄为 <code>T</code>.</p>
<h3 id="例子-62"><a class="header" href="#例子-62">例子</a></h3>
<pre><code class="language-typescript">class FileSystemObject {
    isFile(): this is File { return this instanceof File; }
    isDirectory(): this is Directory { return this instanceof Directory;}
    isNetworked(): this is (Networked &amp; this) { return this.networked; }
    constructor(public path: string, private networked: boolean) {}
}

class File extends FileSystemObject {
    constructor(path: string, public content: string) { super(path, false); }
}
class Directory extends FileSystemObject {
    children: FileSystemObject[];
}
interface Networked {
    host: string;
}

let fso: FileSystemObject = new File("foo/bar.txt", "foo");
if (fso.isFile()) {
    fso.content; // fso 是 File
}
else if (fso.isDirectory()) {
    fso.children; // fso 是 Directory
}
else if (fso.isNetworked()) {
    fso.host; // fso 是 networked
}
</code></pre>
<h2 id="官方的-typescript-nuget-包"><a class="header" href="#官方的-typescript-nuget-包">官方的 TypeScript NuGet 包</a></h2>
<p>从 TypeScript 1.8 开始, 将为 TypeScript 编译器 (<code>tsc.exe</code>) 和 MSBuild 整合 (<code>Microsoft.TypeScript.targets</code> 和 <code>Microsoft.TypeScript.Tasks.dll</code>) 提供官方的 NuGet 包.</p>
<p>稳定版本可以在这里下载:</p>
<ul>
<li><a href="https://www.nuget.org/packages/Microsoft.TypeScript.Compiler/">Microsoft.TypeScript.Compiler</a></li>
<li><a href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild/">Microsoft.TypeScript.MSBuild</a></li>
</ul>
<p>与此同时, 和<a href="https://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx">每日npm包</a>对应的每日 NuGet 包可以在<a href="https://myget.org">https://myget.org</a>下载:</p>
<ul>
<li><a href="https://www.myget.org/gallery/typescript-preview">TypeScript-Preview</a></li>
</ul>
<h2 id="tsc-错误信息更美观"><a class="header" href="#tsc-错误信息更美观"><code>tsc</code> 错误信息更美观</a></h2>
<p>我们理解大量单色的输出并不直观. 颜色可以帮助识别信息的始末, 这些视觉上的线索在处理复杂的错误信息时非常重要.</p>
<p>通过传递 <code>--pretty</code> 命令行选项, TypeScript 会给出更丰富的输出, 包含错误发生的上下文.</p>
<p><img src="https://raw.githubusercontent.com/wiki/Microsoft/TypeScript/images/new-in-typescript/pretty01.png" alt="展示在 ConEmu 中美化之后的错误信息" /></p>
<h2 id="高亮-vs-2015-中的-jsx-代码"><a class="header" href="#高亮-vs-2015-中的-jsx-代码">高亮 VS 2015 中的 JSX 代码</a></h2>
<p>在 TypeScript 1.8 中, JSX 标签现在可以在 Visual Studio 2015 中被分别和高亮.</p>
<p><img src="https://cloud.githubusercontent.com/assets/8052307/12271404/b875c502-b90f-11e5-93d8-c6740be354d1.png" alt="jsx" /></p>
<p>通过 <code>工具</code>-&gt;<code>选项</code>-&gt;<code>环境</code>-&gt;<code>字体与颜色</code> 页面在 <code>VB XML</code> 颜色和字体设置中还可以进一步改变字体和颜色来自定义.</p>
<h2 id="--project--p-选项现在接受任意文件路径"><a class="header" href="#--project--p-选项现在接受任意文件路径"><code>--project</code> (<code>-p</code>) 选项现在接受任意文件路径</a></h2>
<p><code>--project</code> 命令行选项过去只接受包含了 <code>tsconfig.json</code> 文件的文件夹. 考虑到不同的构建场景, 应该允许 <code>--project</code> 指向任何兼容的 JSON 文件. 比如说, 一个用户可能会希望为 Node 5 编译 CommonJS 的 ES 2015, 为浏览器编译 AMD 的 ES5. 现在少了这项限制, 用户可以更容易地直接使用 <code>tsc</code> 管理不同的构建目标, 无需再通过一些奇怪的方式, 比如将多个 <code>tsconfig.json</code> 文件放在不同的目录中.</p>
<p>如果参数是一个路径, 行为保持不变 - 编译器会尝试在该目录下寻找名为 <code>tsconfig.json</code> 的文件.</p>
<h2 id="允许-tsconfigjson-中的注释"><a class="header" href="#允许-tsconfigjson-中的注释">允许 tsconfig.json 中的注释</a></h2>
<p>为配置添加文档是很棒的! <code>tsconfig.json</code> 现在支持单行和多行注释.</p>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "target": "ES2015", // 跑在 node v5 上, 呀!
        "sourceMap": true   // 让调试轻松一些
    },
    /*
     * 排除的文件
     */
    "exclude": [
        "file.d.ts"
    ]
}
</code></pre>
<h2 id="支持输出到-ipc-驱动的文件"><a class="header" href="#支持输出到-ipc-驱动的文件">支持输出到 IPC 驱动的文件</a></h2>
<p>TypeScript 1.8 允许用户将 <code>--outFile</code> 参数和一些特殊的文件系统对象一起使用, 比如命名的管道 (pipe), 设备 (devices) 等.</p>
<p>举个例子, 在很多与 Unix 相似的系统上, 标准输出流可以通过文件 <code>/dev/stdout</code> 访问.</p>
<pre><code class="language-bash">tsc foo.ts --outFile /dev/stdout
</code></pre>
<p>这一特性也允许输出给其他命令.</p>
<p>比如说, 我们可以输出生成的 JavaScript 给一个像 <a href="https://www.npmjs.com/package/pretty-js">pretty-js</a> 这样的格式美化工具:</p>
<pre><code class="language-bash">tsc foo.ts --outFile /dev/stdout | pretty-js
</code></pre>
<h2 id="改进了-visual-studio-2015-中对-tsconfigjson-的支持"><a class="header" href="#改进了-visual-studio-2015-中对-tsconfigjson-的支持">改进了 Visual Studio 2015 中对 <code>tsconfig.json</code> 的支持</a></h2>
<p>TypeScript 1.8 允许在任何种类的项目中使用 <code>tsconfig.json</code> 文件. 包括 ASP.NET v4 项目, <em>控制台应用</em>, 以及 <em>用 TypeScript 开发的 HTML 应用</em>. 与此同时, 你可以添加不止一个 <code>tsconfig.json</code> 文件, 其中每一个都会作为项目的一部分被构建. 这使得你可以在不使用多个不同项目的情况下为应用的不同部分使用不同的配置.</p>
<p><img src="https://raw.githubusercontent.com/wiki/Microsoft/TypeScript/images/new-in-typescript/tsconfig-in-vs.png" alt="展示 Visual Studio 中的 tsconfig.json" /></p>
<p>当项目中添加了 <code>tsconfig.json</code> 文件时, 我们还禁用了项目属性页面. 也就是说所有配置的改变必须在 <code>tsconfig.json</code> 文件中进行.</p>
<h3 id="一些限制"><a class="header" href="#一些限制">一些限制</a></h3>
<ul>
<li>如果你添加了一个 <code>tsconfig.json</code> 文件, 不在其上下文中的 TypeScript 文件不会被编译.</li>
<li>Apache Cordova 应用依然有单个 <code>tsconfig.json</code> 文件的限制, 而这个文件必须在根目录或者 <code>scripts</code> 文件夹.</li>
<li>多数项目类型中都没有 <code>tsconfig.json</code> 的模板.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-17"><a class="header" href="#typescript-17">TypeScript 1.7</a></h1>
<h2 id="支持-asyncawait-编译到-es6-node-v4"><a class="header" href="#支持-asyncawait-编译到-es6-node-v4">支持 <code>async</code>/<code>await</code> 编译到 ES6 (Node v4+)</a></h2>
<p>TypeScript 目前在已经原生支持 ES6 generator 的引擎 (比如 Node v4 及以上版本) 上支持异步函数. 异步函数前置 <code>async</code> 关键字; <code>await</code> 会暂停执行, 直到一个异步函数执行后返回的 promise 被 fulfill 后获得它的值.</p>
<h3 id="例子-63"><a class="header" href="#例子-63">例子</a></h3>
<p>在下面的例子中, 输入的内容将会延时 400 毫秒逐个打印:</p>
<pre><code class="language-typescript">"use strict";

// printDelayed 返回值是一个 'Promise&lt;void&gt;'
async function printDelayed(elements: string[]) {
    for (const element of elements) {
        await delay(400);
        console.log(element);
    }
}

async function delay(milliseconds: number) {
    return new Promise&lt;void&gt;(resolve =&gt; {
        setTimeout(resolve, milliseconds);
    });
}

printDelayed(["Hello", "beautiful", "asynchronous", "world"]).then(() =&gt; {
    console.log();
    console.log("打印每一个内容!");
});
</code></pre>
<p>查看 <a href="http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx">Async Functions</a> 一文了解更多.</p>
<h2 id="支持同时使用---target-es6-和---module"><a class="header" href="#支持同时使用---target-es6-和---module">支持同时使用 <code>--target ES6</code> 和 <code>--module</code></a></h2>
<p>TypeScript 1.7 将 <code>ES6</code> 添加到了 <code>--module</code> 选项支持的选项的列表, 当编译到 <code>ES6</code> 时允许指定模块类型. 这让使用具体运行时中你需要的特性更加灵活.</p>
<h3 id="例子-64"><a class="header" href="#例子-64">例子</a></h3>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "module": "amd",
        "target": "es6"
    }
}
</code></pre>
<h2 id="this-类型"><a class="header" href="#this-类型"><code>this</code> 类型</a></h2>
<p>在方法中返回当前对象 (也就是 <code>this</code>) 是一种创建链式 API 的常见方式. 比如, 考虑下面的 <code>BasicCalculator</code> 模块:</p>
<pre><code class="language-typescript">export default class BasicCalculator {
    public constructor(protected value: number = 0) { }

    public currentValue(): number {
        return this.value;
    }

    public add(operand: number) {
        this.value += operand;
        return this;
    }

    public subtract(operand: number) {
        this.value -= operand;
        return this;
    }

    public multiply(operand: number) {
        this.value *= operand;
        return this;
    }

    public divide(operand: number) {
        this.value /= operand;
        return this;
    }
}
</code></pre>
<p>使用者可以这样表述 <code>2 * 5 + 1</code>:</p>
<pre><code class="language-typescript">import calc from "./BasicCalculator";

let v = new calc(2)
    .multiply(5)
    .add(1)
    .currentValue();
</code></pre>
<p>这使得这么一种优雅的编码方式成为可能; 然而, 对于想要去继承 <code>BasicCalculator</code> 的类来说有一个问题. 想象使用者可能需要编写一个 <code>ScientificCalculator</code>:</p>
<pre><code class="language-typescript">import BasicCalculator from "./BasicCalculator";

export default class ScientificCalculator extends BasicCalculator {
    public constructor(value = 0) {
        super(value);
    }

    public square() {
        this.value = this.value ** 2;
        return this;
    }

    public sin() {
        this.value = Math.sin(this.value);
        return this;
    }
}
</code></pre>
<p>因为 <code>BasicCalculator</code> 的方法返回了 <code>this</code>, TypeScript 过去推断的类型是 <code>BasicCalculator</code>, 如果在 <code>ScientificCalculator</code> 的实例上调用属于 <code>BasicCalculator</code> 的方法, 类型系统不能很好地处理.</p>
<p>举例来说:</p>
<pre><code class="language-typescript">import calc from "./ScientificCalculator";

let v = new calc(0.5)
    .square()
    .divide(2)
    .sin()    // Error: 'BasicCalculator' 没有 'sin' 方法.
    .currentValue();
</code></pre>
<p>这已经不再是问题 - TypeScript 现在在类的实例方法中, 会将 <code>this</code> 推断为一个特殊的叫做 <code>this</code> 的类型. <code>this</code> 类型也就写作 <code>this</code>, 可以大致理解为 "方法调用时点左边的类型".</p>
<p><code>this</code> 类型在描述一些使用了 mixin 风格继承的库 (比如 Ember.js) 的交叉类型:</p>
<pre><code class="language-typescript">interface MyType {
    extend&lt;T&gt;(other: T): this &amp; T;
}
</code></pre>
<h2 id="es7-幂运算符"><a class="header" href="#es7-幂运算符">ES7 幂运算符</a></h2>
<p>TypeScript 1.7 支持将在 ES7/ES2016 中增加的<a href="https://github.com/rwaldron/exponentiation-operator">幂运算符</a>: <code>**</code> 和 <code>**=</code>. 这些运算符会被转换为 ES3/ES5 中的 <code>Math.pow</code>.</p>
<h3 id="举例-1"><a class="header" href="#举例-1">举例</a></h3>
<pre><code class="language-typescript">var x = 2 ** 3;
var y = 10;
y **= 2;
var z =  -(4 ** 3);
</code></pre>
<p>会生成下面的 JavaScript:</p>
<pre><code class="language-typescript">var x = Math.pow(2, 3);
var y = 10;
y = Math.pow(y, 2);
var z = -(Math.pow(4, 3));
</code></pre>
<h2 id="改进对象字面量解构的检查"><a class="header" href="#改进对象字面量解构的检查">改进对象字面量解构的检查</a></h2>
<p>TypeScript 1.7 使对象和数组字面量解构初始值的检查更加直观和自然.</p>
<p>当一个对象字面量通过与之对应的对象解构绑定推断类型时:</p>
<ul>
<li>对象解构绑定中有默认值的属性对于对象字面量来说可选.</li>
<li>对象解构绑定中的属性如果在对象字面量中没有匹配的值, 则该属性必须有默认值, 并且会被添加到对象字面量的类型中.</li>
<li>对象字面量中的属性必须在对象解构绑定中存在.</li>
</ul>
<p>当一个数组字面量通过与之对应的数组解构绑定推断类型时:</p>
<ul>
<li>数组解构绑定中的元素如果在数组字面量中没有匹配的值, 则该元素必须有默认值, 并且会被添加到数组字面量的类型中.</li>
</ul>
<h3 id="举例-2"><a class="header" href="#举例-2">举例</a></h3>
<pre><code class="language-typescript">// f1 的类型为 (arg?: { x?: number, y?: number }) =&gt; void
function f1({ x = 0, y = 0 } = {}) { }

// And can be called as:
f1();
f1({});
f1({ x: 1 });
f1({ y: 1 });
f1({ x: 1, y: 1 });

// f2 的类型为 (arg?: (x: number, y?: number) =&gt; void
function f2({ x, y = 0 } = { x: 0 }) { }

f2();
f2({});        // 错误, x 非可选
f2({ x: 1 });
f2({ y: 1 });  // 错误, x 非可选
f2({ x: 1, y: 1 });
</code></pre>
<h2 id="装饰器-decorators-支持的编译目标版本增加-es3"><a class="header" href="#装饰器-decorators-支持的编译目标版本增加-es3">装饰器 (decorators) 支持的编译目标版本增加 ES3</a></h2>
<p>装饰器现在可以编译到 ES3. TypeScript 1.7 在 <code>__decorate</code> 函数中移除了 ES5 中增加的 <code>reduceRight</code>. 相关改动也内联了对 <code>Object.getOwnPropertyDescriptor</code> 和 <code>Object.defineProperty</code> 的调用, 并向后兼容, 使 ES5 的输出可以消除前面提到的 <code>Object</code> 方法的重复[1].</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-16"><a class="header" href="#typescript-16">TypeScript 1.6</a></h1>
<h2 id="jsx-支持"><a class="header" href="#jsx-支持">JSX 支持</a></h2>
<p>JSX 是一种可嵌入的类似 XML 的语法. 它将最终被转换为合法的 JavaScript, 但转换的语义和具体实现有关. JSX 随着 React 流行起来, 也出现在其他应用中. TypeScript 1.6 支持 JavaScript 文件中 JSX 的嵌入, 类型检查, 以及直接编译为 JavaScript 的选项.</p>
<h3 id="新的-tsx-文件扩展名和-as-运算符"><a class="header" href="#新的-tsx-文件扩展名和-as-运算符">新的 <code>.tsx</code> 文件扩展名和 <code>as</code> 运算符</a></h3>
<p>TypeScript 1.6 引入了新的 <code>.tsx</code> 文件扩展名. 这一扩展名一方面允许 TypeScript 文件中的 JSX 语法, 一方面将 <code>as</code> 运算符作为默认的类型转换方式 (避免 JSX 表达式和 TypeScript 前置类型转换运算符之间的歧义). 比如:</p>
<pre><code class="language-typescript">var x = &lt;any&gt; foo;
// 与如下等价:
var x = foo as any;
</code></pre>
<h3 id="使用-react"><a class="header" href="#使用-react">使用 React</a></h3>
<p>使用 React 及 JSX 支持, 你需要使用 <a href="https://github.com/borisyankov/DefinitelyTyped/tree/master/react">React 类型声明</a>. 这些类型定义了 <code>JSX</code> 命名空间, 以便 TypeScript 能正确地检查 React 的 JSX 表达式. 比如:</p>
<pre><code class="language-typescript">/// &lt;reference path="react.d.ts" /&gt;

interface Props {
  name: string;
}

class MyComponent extends React.Component&lt;Props, {}&gt; {
  render() {
    return &lt;span&gt;{this.props.foo}&lt;/span&gt;
  }
}

&lt;MyComponent name="bar" /&gt;; // 没问题
&lt;MyComponent name={0} /&gt;; // 错误, `name` 不是一个字符串
</code></pre>
<h3 id="使用其他-jsx-框架"><a class="header" href="#使用其他-jsx-框架">使用其他 JSX 框架</a></h3>
<p>JSX 元素的名称和属性是根据 <code>JSX</code> 命名空间来检验的. 请查看 <a href="https://github.com/Microsoft/TypeScript/wiki/JSX">JSX</a> 页面了解如何为自己的框架定义 <code>JSX</code> 命名空间.</p>
<h3 id="编译输出"><a class="header" href="#编译输出">编译输出</a></h3>
<p>TypeScript 支持两种 <code>JSX</code> 模式: <code>preserve</code> (保留) 和 <code>react</code>.</p>
<ul>
<li><code>preserve</code> 模式将会在输出中保留 JSX 表达式, 使之后的转换步骤可以处理. <em>并且输出的文件扩展名为 <code>.jsx</code>.</em></li>
<li><code>react</code> 模式将会生成 <code>React.createElement</code>, 不再需要再通过 JSX 转换即可运行, 输出的文件扩展名为 <code>.js</code>.</li>
</ul>
<p>查看 <a href="https://github.com/Microsoft/TypeScript/wiki/JSX">JSX</a> 页面了解更多 JSX 在 TypeScript 中的使用.</p>
<h2 id="交叉类型-intersection-types"><a class="header" href="#交叉类型-intersection-types">交叉类型 (intersection types)</a></h2>
<p>TypeScript 1.6 引入了交叉类型作为联合类型 (union types) 逻辑上的补充. 联合类型 <code>A | B</code> 表示一个类型为 <code>A</code> 或 <code>B</code> 的实体, 而交叉类型 <code>A &amp; B</code> 表示一个类型同时为 <code>A</code> 或 <code>B</code> 的实体.</p>
<h3 id="例子-65"><a class="header" href="#例子-65">例子</a></h3>
<pre><code class="language-typescript">function extend&lt;T, U&gt;(first: T, second: U): T &amp; U {
    let result = &lt;T &amp; U&gt; {};
    for (let id in first) {
        result[id] = first[id];
    }
    for (let id in second) {
        if (!result.hasOwnProperty(id)) {
            result[id] = second[id];
        }
    }
    return result;
}

var x = extend({ a: "hello" }, { b: 42 });
var s = x.a;
var n = x.b;
</code></pre>
<pre><code class="language-typescript">type LinkedList&lt;T&gt; = T &amp; { next: LinkedList&lt;T&gt; };

interface Person {
    name: string;
}

var people: LinkedList&lt;Person&gt;;
var s = people.name;
var s = people.next.name;
var s = people.next.next.name;
var s = people.next.next.next.name;
interface A { a: string }
interface B { b: string }
interface C { c: string }

var abc: A &amp; B &amp; C;
abc.a = "hello";
abc.b = "hello";
abc.c = "hello";
</code></pre>
<p>查看 <a href="https://github.com/Microsoft/TypeScript/issues/1256">issue #1256</a> 了解更多.</p>
<h2 id="本地类型声明"><a class="header" href="#本地类型声明">本地类型声明</a></h2>
<p>本地的类, 接口, 枚举和类型别名现在可以在函数声明中出现. 本地类型为块级作用域, 与 <code>let</code> 和 <code>const</code> 声明的变量类似. 比如说:</p>
<pre><code class="language-typescript">function f() {
    if (true) {
        interface T { x: number }
        let v: T;
        v.x = 5;
    }
    else {
        interface T { x: string }
        let v: T;
        v.x = "hello";
    }
}
</code></pre>
<p>推导出的函数返回值类型可能在函数内部声明的. 调用函数的地方无法引用到这样的本地类型, 但是它当然能从类型结构上匹配. 比如:</p>
<pre><code class="language-typescript">interface Point {
    x: number;
    y: number;
}

function getPointFactory(x: number, y: number) {
    class P {
        x = x;
        y = y;
    }
    return P;
}

var PointZero = getPointFactory(0, 0);
var PointOne = getPointFactory(1, 1);
var p1 = new PointZero();
var p2 = new PointZero();
var p3 = new PointOne();
</code></pre>
<p>本地的类型可以引用类型参数, 本地的类和接口本身即可能是泛型. 比如:</p>
<pre><code class="language-typescript">function f3() {
    function f&lt;X, Y&gt;(x: X, y: Y) {
        class C {
            public x = x;
            public y = y;
        }
        return C;
    }
    let C = f(10, "hello");
    let v = new C();
    let x = v.x;  // number
    let y = v.y;  // string
}
</code></pre>
<h2 id="类表达式"><a class="header" href="#类表达式">类表达式</a></h2>
<p>TypeScript 1.6 增加了对 ES6 类表达式的支持. 在一个类表达式中, 类的名称是可选的, 如果指明, 作用域仅限于类表达式本身. 这和函数表达式可选的名称类似. 在类表达式外无法引用其实例类型, 但是自然也能够从类型结构上匹配. 比如:</p>
<pre><code class="language-typescript">let Point = class {
    constructor(public x: number, public y: number) { }
    public length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
};
var p = new Point(3, 4);  // p has anonymous class type
console.log(p.length());
</code></pre>
<h2 id="继承表达式"><a class="header" href="#继承表达式">继承表达式</a></h2>
<p>TypeScript 1.6 增加了对类继承任意值为一个构造函数的表达式的支持. 这样一来内建的类型也可以在类的声明中被继承.</p>
<p><code>extends</code> 语句过去需要指定一个类型引用, 现在接受一个可选类型参数的表达式. 表达式的类型必须为有至少一个构造函数签名的构造函数, 并且需要和 <code>extends</code> 语句中类型参数数量一致. 匹配的构造函数签名的返回值类型是类实例类型继承的基类型. 如此一来, 这使得普通的类和与类相似的表达式可以在 <code>extends</code> 语句中使用.</p>
<p>一些例子:</p>
<pre><code class="language-typescript">// 继承内建类

class MyArray extends Array&lt;number&gt; { }
class MyError extends Error { }

// 继承表达式类

class ThingA {
    getGreeting() { return "Hello from A"; }
}

class ThingB {
    getGreeting() { return "Hello from B"; }
}

interface Greeter {
    getGreeting(): string;
}

interface GreeterConstructor {
    new (): Greeter;
}

function getGreeterBase(): GreeterConstructor {
    return Math.random() &gt;= 0.5 ? ThingA : ThingB;
}

class Test extends getGreeterBase() {
    sayHello() {
        console.log(this.getGreeting());
    }
}
</code></pre>
<h2 id="abstract-抽象的-类和方法"><a class="header" href="#abstract-抽象的-类和方法"><code>abstract</code> (抽象的) 类和方法</a></h2>
<p>TypeScript 1.6 为类和它们的方法增加了 <code>abstract</code> 关键字. 一个抽象类允许没有被实现的方法, 并且不能被构造.</p>
<h3 id="例子-66"><a class="header" href="#例子-66">例子</a></h3>
<pre><code class="language-typescript">abstract class Base {
    abstract getThing(): string;
    getOtherThing() { return 'hello'; }
}

let x = new Base(); // 错误, 'Base' 是抽象的

// 错误, 必须也为抽象类, 或者实现 'getThing' 方法
class Derived1 extends Base { }

class Derived2 extends Base {
    getThing() { return 'hello'; }
    foo() {
        super.getThing();// 错误: 不能调用 'super' 的抽象方法
    }
}

var x = new Derived2(); // 正确
var y: Base = new Derived2(); // 同样正确
y.getThing(); // 正确
y.getOtherThing(); // 正确
</code></pre>
<h2 id="泛型别名"><a class="header" href="#泛型别名">泛型别名</a></h2>
<p>TypeScript 1.6 中, 类型别名支持泛型. 比如:</p>
<pre><code class="language-typescript">type Lazy&lt;T&gt; = T | (() =&gt; T);

var s: Lazy&lt;string&gt;;
s = "eager";
s = () =&gt; "lazy";

interface Tuple&lt;A, B&gt; {
    a: A;
    b: B;
}

type Pair&lt;T&gt; = Tuple&lt;T, T&gt;;
</code></pre>
<h2 id="更严格的对象字面量赋值检查"><a class="header" href="#更严格的对象字面量赋值检查">更严格的对象字面量赋值检查</a></h2>
<p>为了能发现多余或者错误拼写的属性, TypeScript 1.6 使用了更严格的对象字面量检查. 确切地说, 在将一个新的对象字面量赋值给一个变量, 或者传递给类型非空的参数时, 如果对象字面量的属性在目标类型中不存在, 则会视为错误.</p>
<h3 id="例子-67"><a class="header" href="#例子-67">例子</a></h3>
<pre><code class="language-typescript">var x: { foo: number };
x = { foo: 1, baz: 2 };  // 错误, 多余的属性 `baz`

var y: { foo: number, bar?: number };
y = { foo: 1, baz: 2 };  // 错误, 多余或者拼错的属性 `baz`
</code></pre>
<p>一个类型可以通过包含一个索引签名来显示指明未出现在类型中的属性是被允许的.</p>
<pre><code class="language-typescript">var x: { foo: number, [x: string]: any };
x = { foo: 1, baz: 2 };  // 现在 `baz` 匹配了索引签名
</code></pre>
<h2 id="es6-生成器-generators"><a class="header" href="#es6-生成器-generators">ES6 生成器 (generators)</a></h2>
<p>TypeScript 1.6 添加了对于 ES6 输出的生成器支持.</p>
<p>一个生成器函数可以有返回值类型标注, 就像普通的函数. 标注表示生成器函数返回的生成器的类型. 这里有个例子:</p>
<pre><code class="language-typescript">function *g(): Iterable&lt;string&gt; {
    for (var i = 0; i &lt; 100; i++) {
        yield ""; // string 可以赋值给 string
    }
    yield * otherStringGenerator(); // otherStringGenerator 必须可遍历, 并且元素类型需要可赋值给 string
}
</code></pre>
<p>没有标注类型的生成器函数会有自动推演的类型. 在下面的例子中, 类型会由 yield 语句推演出来:</p>
<pre><code class="language-typescript">function *g() {
    for (var i = 0; i &lt; 100; i++) {
        yield ""; // 推导出 string
    }
    yield * otherStringGenerator(); // 推导出 otherStringGenerator 的元素类型
}
</code></pre>
<h2 id="对-async-异步-函数的试验性支持"><a class="header" href="#对-async-异步-函数的试验性支持">对 <code>async</code> (异步) 函数的试验性支持</a></h2>
<p>TypeScript 1.6 增加了编译到 ES6 时对 <code>async</code> 函数试验性的支持. 异步函数会执行一个异步的操作, 在等待的同时不会阻塞程序的正常运行. 这是通过与 ES6 兼容的 <code>Promise</code> 实现完成的, 并且会将函数体转换为支持在等待的异步操作完成时继续的形式.</p>
<p>由 <code>async</code> 标记的函数或方法被称作_异步函数_. 这个标记告诉了编译器该函数体需要被转换, 关键字 <em>await</em> 则应该被当做一个一元运算符, 而不是标示符. 一个_异步函数_必须返回类型与 <code>Promise</code> 兼容的值. 返回值类型的推断只能在有一个全局的, 与 ES6 兼容的 <code>Promise</code> 类型时使用.</p>
<h3 id="例子-68"><a class="header" href="#例子-68">例子</a></h3>
<pre><code class="language-typescript">var p: Promise&lt;number&gt; = /* ... */;
async function fn(): Promise&lt;number&gt; {
  var i = await p; // 暂停执行直到 'p' 得到结果. 'i' 的类型为 "number"
  return 1 + i;
}

var a = async (): Promise&lt;number&gt; =&gt; 1 + await p; // 暂停执行.
var a = async () =&gt; 1 + await p; // 暂停执行. 使用 --target ES6 选项编译时返回值类型被推断为 "Promise&lt;number&gt;"
var fe = async function(): Promise&lt;number&gt; {
  var i = await p; // 暂停执行知道 'p' 得到结果. 'i' 的类型为 "number"
  return 1 + i;
}

class C {
  async m(): Promise&lt;number&gt; {
    var i = await p; // 暂停执行知道 'p' 得到结果. 'i' 的类型为 "number"
    return 1 + i;
  }

  async get p(): Promise&lt;number&gt; {
    var i = await p; // 暂停执行知道 'p' 得到结果. 'i' 的类型为 "number"
    return 1 + i;
  }
}
</code></pre>
<h2 id="每天发布新版本"><a class="header" href="#每天发布新版本">每天发布新版本</a></h2>
<p>由于并不算严格意义上的语言变化[2], 每天的新版本可以使用如下命令安装获得:</p>
<pre><code class="language-bash">npm install -g typescript@next
</code></pre>
<h2 id="对模块解析逻辑的调整"><a class="header" href="#对模块解析逻辑的调整">对模块解析逻辑的调整</a></h2>
<p>从 1.6 开始, TypeScript 编译器对于 "commonjs" 的模块解析会使用一套不同的规则. 这些<a href="https://github.com/Microsoft/TypeScript/issues/2338">规则</a> 尝试模仿 Node 查找模块的过程. 这就意味着 node 模块可以包含它的类型信息, 并且 TypeScript 编译器可以找到这些信息. 不过用户可以通过使用 <code>--moduleResolution</code> 命令行选项覆盖模块解析规则. 支持的值有:</p>
<ul>
<li>'classic' - TypeScript 1.6 以前的编译器使用的模块解析规则</li>
<li>'node' - 与 node 相似的模块解析</li>
</ul>
<h2 id="合并外围类和接口的声明"><a class="header" href="#合并外围类和接口的声明">合并外围类和接口的声明</a></h2>
<p>外围类的实例类型可以通过接口声明来扩展. 类构造函数对象不会被修改. 比如说:</p>
<pre><code class="language-typescript">declare class Foo {
    public x : number;
}

interface Foo {
    y : string;
}

function bar(foo : Foo)  {
    foo.x = 1; // 没问题, 在类 Foo 中有声明
    foo.y = "1"; // 没问题, 在接口 Foo 中有声明
}
</code></pre>
<h2 id="用户定义的类型收窄函数"><a class="header" href="#用户定义的类型收窄函数">用户定义的类型收窄函数</a></h2>
<p>TypeScript 1.6 增加了一个新的在 <code>if</code> 语句中收窄变量类型的方式, 作为对 <code>typeof</code> 和 <code>instanceof</code> 的补充. 用户定义的类型收窄函数的返回值类型标注形式为 <code>x is T</code>, 这里 <code>x</code> 是函数声明中的形参, <code>T</code> 是任何类型. 当一个用户定义的类型收窄函数在 <code>if</code> 语句中被传入某个变量执行时, 该变量的类型会被收窄到 <code>T</code>.</p>
<h3 id="例子-69"><a class="header" href="#例子-69">例子</a></h3>
<pre><code class="language-typescript">function isCat(a: any): a is Cat {
  return a.name === 'kitty';
}

var x: Cat | Dog;
if(isCat(x)) {
  x.meow(); // 那么, x 在这个代码块内是 Cat 类型
}
</code></pre>
<h2 id="tsconfigjson-对-exclude-属性的支持"><a class="header" href="#tsconfigjson-对-exclude-属性的支持"><code>tsconfig.json</code> 对 <code>exclude</code> 属性的支持</a></h2>
<p>一个没有写明 <code>files</code> 属性的 <code>tsconfig.json</code> 文件 (默认会引用所有子目录下的 *.ts 文件) 现在可以包含一个 <code>exclude</code> 属性, 指定需要在编译中排除的文件或者目录列表. <code>exclude</code> 属性必须是一个字符串数组, 其中每一个元素指定对应的一个文件或者文件夹名称对于 <code>tsconfig.json</code> 文件所在位置的相对路径. 举例来说:</p>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "out": "test.js"
    },
    "exclude": [
        "node_modules",
        "test.ts",
        "utils/t2.ts"
    ]
}
</code></pre>
<p><code>exclude</code> 列表不支持通配符. 仅仅可以是文件或者目录的列表.</p>
<h2 id="--init-命令行选项"><a class="header" href="#--init-命令行选项"><code>--init</code> 命令行选项</a></h2>
<p>在一个目录中执行 <code>tsc --init</code> 可以在该目录中创建一个包含了默认值的 <code>tsconfig.json</code>. 可以通过一并传递其他选项来生成初始的 <code>tsconfig.json</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-15"><a class="header" href="#typescript-15">TypeScript 1.5</a></h1>
<h2 id="es6-模块"><a class="header" href="#es6-模块">ES6 模块</a></h2>
<p>TypeScript 1.5 支持 ECMAScript 6 (ES6) 模块. ES6 模块可以看做之前 TypeScript 的外部模块换上了新的语法: ES6 模块是分开加载的源文件, 这些文件还可能引入其他模块, 并且导出部分供外部可访问. ES6 模块新增了几种导入和导出声明. 我们建议使用 TypeScript 开发的库和应用能够更新到新的语法, 但不做强制要求. 新的 ES6 模块语法和 TypeScript 原来的内部和外部模块结构同时被支持, 如果需要也可以混合使用.</p>
<h3 id="导出声明-1"><a class="header" href="#导出声明-1">导出声明</a></h3>
<p>作为 TypeScript 已有的 <code>export</code> 前缀支持, 模块成员也可以使用单独导出的声明导出, 如果需要, <code>as</code> 语句可以指定不同的导出名称.</p>
<pre><code class="language-typescript">interface Stream { ... }
function writeToStream(stream: Stream, data: string) { ... }
export { Stream, writeToStream as write };  // writeToStream 导出为 write
</code></pre>
<p>引入声明也可以使用 <code>as</code> 语句来指定一个不同的导入名称. 比如:</p>
<pre><code class="language-typescript">import { read, write, standardOutput as stdout } from "./inout";
var s = read(stdout);
write(stdout, s);
</code></pre>
<p>作为单独导入的候选项, 命名空间导入可以导入整个模块:</p>
<pre><code class="language-typescript">import * as io from "./inout";
var s = io.read(io.standardOutput);
io.write(io.standardOutput, s);
</code></pre>
<h2 id="重新导出-1"><a class="header" href="#重新导出-1">重新导出</a></h2>
<p>使用 <code>from</code> 语句一个模块可以复制指定模块的导出项到当前模块, 而无需创建本地名称.</p>
<pre><code class="language-typescript">export { read, write, standardOutput as stdout } from "./inout";
</code></pre>
<p><code>export *</code> 可以用来重新导出另一个模块的所有导出项. 在创建一个聚合了其他几个模块导出项的模块时很方便.</p>
<pre><code class="language-typescript">export function transform(s: string): string { ... }
export * from "./mod1";
export * from "./mod2";
</code></pre>
<h3 id="默认导出项"><a class="header" href="#默认导出项">默认导出项</a></h3>
<p>一个 export default 声明表示一个表达式是这个模块的默认导出项.</p>
<pre><code class="language-typescript">export default class Greeter {
    sayHello() {
        console.log("Greetings!");
    }
}
</code></pre>
<p>对应的可以使用默认导入:</p>
<pre><code class="language-typescript">import Greeter from "./greeter";
var g = new Greeter();
g.sayHello();
</code></pre>
<h3 id="无导入加载"><a class="header" href="#无导入加载">无导入加载</a></h3>
<p>"无导入加载" 可以被用来加载某些只需要其副作用的模块.</p>
<pre><code class="language-typescript">import "./polyfills";
</code></pre>
<p>了解更多关于模块的信息, 请参见 <a href="https://github.com/Microsoft/TypeScript/issues/2242">ES6 模块支持规范</a>.</p>
<h2 id="声明与赋值的解构"><a class="header" href="#声明与赋值的解构">声明与赋值的解构</a></h2>
<p>TypeScript 1.5 添加了对 ES6 解构声明与赋值的支持.</p>
<h3 id="解构-1"><a class="header" href="#解构-1">解构</a></h3>
<p>解构声明会引入一个或多个命名变量, 并且初始化它们的值为对象的属性或者数组的元素对应的值.</p>
<p>比如说, 下面的例子声明了变量 <code>x</code>, <code>y</code> 和 <code>z</code>, 并且分别将它们的值初始化为 <code>getSomeObject().x</code>, <code>getSomeObject().y</code> 和 <code>getSomeObject().z</code>:</p>
<pre><code class="language-typescript">var { x, y, z } = getSomeObject();
</code></pre>
<p>解构声明也可以用于从数组中得到值.</p>
<pre><code class="language-typescript">var [x, y, z = 10] = getSomeArray();
</code></pre>
<p>相似的, 解构可以用在函数的参数声明中:</p>
<pre><code class="language-typescript">function drawText({ text = "", location: [x, y] = [0, 0], bold = false }) {
    // 画出文本
}

// 以一个对象字面量为参数调用 drawText
var item = { text: "someText", location: [1,2,3], style: "italics" };
drawText(item);
</code></pre>
<h3 id="赋值"><a class="header" href="#赋值">赋值</a></h3>
<p>解构也可以被用于普通的赋值表达式. 举例来讲, 交换两个变量的值可以被写作一个解构赋值:</p>
<pre><code class="language-typescript">var x = 1;
var y = 2;
[x, y] = [y, x];
</code></pre>
<h2 id="namespace-命名空间-关键字"><a class="header" href="#namespace-命名空间-关键字"><code>namespace</code> (命名空间) 关键字</a></h2>
<p>过去 TypeScript 中 <code>module</code> 关键字既可以定义 "内部模块", 也可以定义 "外部模块"; 这让刚刚接触 TypeScript 的开发者有些困惑. "内部模块" 的概念更接近于大部分人眼中的命名空间; 而 "外部模块" 对于 JS 来讲, 现在也就是模块了.</p>
<blockquote>
<p>注意: 之前定义内部模块的语法依然被支持.</p>
</blockquote>
<p><strong>之前</strong>:</p>
<pre><code class="language-typescript">module Math {
    export function add(x, y) { ... }
}
</code></pre>
<p><strong>之后</strong>:</p>
<pre><code class="language-typescript">namespace Math {
    export function add(x, y) { ... }
}
</code></pre>
<h2 id="let-和-const-的支持"><a class="header" href="#let-和-const-的支持"><code>let</code> 和 <code>const</code> 的支持</a></h2>
<p>ES6 的 <code>let</code> 和 <code>const</code> 声明现在支持编译到 ES3 和 ES5.</p>
<h3 id="const"><a class="header" href="#const">Const</a></h3>
<pre><code class="language-typescript">const MAX = 100;

++MAX; // 错误: 自增/减运算符不能用于一个常量
</code></pre>
<h3 id="块级作用域"><a class="header" href="#块级作用域">块级作用域</a></h3>
<pre><code class="language-typescript">if (true) {
  let a = 4;
  // 使用变量 a
}
else {
  let a = "string";
  // 使用变量 a
}

alert(a); // 错误: 变量 a 在当前作用域未定义
</code></pre>
<h2 id="forof-的支持"><a class="header" href="#forof-的支持"><code>for...of</code> 的支持</a></h2>
<p>TypeScript 1.5 增加了 ES6 <code>for...of</code> 循环编译到 ES3/ES5 时对数组的支持, 以及编译到 ES6 时对满足 <code>Iterator</code> 接口的全面支持.</p>
<h3 id="例子-70"><a class="header" href="#例子-70">例子</a></h3>
<p>TypeScript 编译器会转译 <code>for...of</code> 数组到具有语义的 ES3/ES5 JavaScript (如果被设置为编译到这些版本).</p>
<pre><code class="language-typescript">for (var v of expr) { }
</code></pre>
<p>会输出为:</p>
<pre><code class="language-javascript">for (var _i = 0, _a = expr; _i &lt; _a.length; _i++) {
    var v = _a[_i];
}
</code></pre>
<h2 id="装饰器-1"><a class="header" href="#装饰器-1">装饰器</a></h2>
<blockquote>
<p>TypeScript 装饰器是局域 <a href="https://github.com/wycats/javascript-decorators">ES7 装饰器</a> 提案的.</p>
</blockquote>
<p>一个装饰器是:</p>
<ul>
<li>一个表达式</li>
<li>并且值为一个函数</li>
<li>接受 <code>target</code>, <code>name</code>, 以及属性描述对象作为参数</li>
<li>可选返回一个会被应用到目标对象的属性描述对象</li>
</ul>
<blockquote>
<p>了解更多, 请参见 <a href="https://github.com/Microsoft/TypeScript/issues/2249">装饰器</a> 提案.</p>
</blockquote>
<h3 id="例子-71"><a class="header" href="#例子-71">例子</a></h3>
<p>装饰器 <code>readonly</code> 和 <code>enumerable(false)</code> 会在属性 <code>method</code> 添加到类 <code>C</code> 上之前被应用. 这使得装饰器可以修改其实现, 具体到这个例子, 设置了 <code>descriptor</code> 为 <code>writable: false</code> 以及 <code>enumerable: false</code>.</p>
<pre><code class="language-typescript">class C {
  @readonly
  @enumerable(false)
  method() { }
}

function readonly(target, key, descriptor) {
    descriptor.writable = false;
}

function enumerable(value) {
  return function (target, key, descriptor) {
     descriptor.enumerable = value;
  }
}
</code></pre>
<h2 id="计算属性"><a class="header" href="#计算属性">计算属性</a></h2>
<p>使用动态的属性初始化一个对象可能会很麻烦. 参考下面的例子:</p>
<pre><code class="language-typescript">type NeighborMap = { [name: string]: Node };
type Node = { name: string; neighbors: NeighborMap;}

function makeNode(name: string, initialNeighbor: Node): Node {
    var neighbors: NeighborMap = {};
    neighbors[initialNeighbor.name] = initialNeighbor;
    return { name: name, neighbors: neighbors };
}
</code></pre>
<p>这里我们需要创建一个包含了 neighbor-map 的变量, 便于我们初始化它. 使用 TypeScript 1.5, 我们可以让编译器来干重活:</p>
<pre><code class="language-typescript">function makeNode(name: string, initialNeighbor: Node): Node {
    return {
        name: name,
        neighbors: {
            [initialNeighbor.name]: initialNeighbor
        }
    }
}
</code></pre>
<h2 id="指出-umd-和-system-模块输出"><a class="header" href="#指出-umd-和-system-模块输出">指出 <code>UMD</code> 和 <code>System</code> 模块输出</a></h2>
<p>作为 <code>AMD</code> 和 <code>CommonJS</code> 模块加载器的补充, TypeScript 现在支持输出为 <code>UMD</code> (<a href="https://github.com/umdjs/umd">Universal Module Definition</a>) 和 <a href="https://github.com/systemjs/systemjs"><code>System</code></a> 模块的格式.</p>
<p><strong>用法</strong>:</p>
<blockquote>
<p>tsc --module umd</p>
</blockquote>
<p>以及</p>
<blockquote>
<p>tsc --module system</p>
</blockquote>
<h2 id="unicode-字符串码位转义"><a class="header" href="#unicode-字符串码位转义">Unicode 字符串码位转义</a></h2>
<p>ES6 中允许用户使用单个转义表示一个 Unicode 码位.</p>
<p>举个例子, 考虑我们需要转义一个包含了字符 '𠮷' 的字符串. 在 UTF-16/USC2 中, '𠮷' 被表示为一个代理对, 意思就是它被编码为一对 16 位值的代码单元, 具体来说是 <code>0xD842</code> 和 <code>0xDFB7</code>. 之前这意味着你必须将该码位转义为 <code>"\uD842\uDFB7"</code>. 这样做有一个重要的问题, 就事很难讲两个独立的字符同一个代理对区分开来.</p>
<p>通过 ES6 的码位转义, 你可以在字符串或模板字符串中清晰地通过一个转义表示一个确切的字符: <code>"\u{20bb7}"</code>. TypeScript 在编译到 ES3/ES5 时会将该字符串输出为 <code>"\uD842\uDFB7"</code>.</p>
<h2 id="标签模板字符串编译到-es3es5"><a class="header" href="#标签模板字符串编译到-es3es5">标签模板字符串编译到 ES3/ES5</a></h2>
<p>TypeScript 1.4 中, 我们添加了模板字符串编译到所有 ES 版本的支持, 并且支持标签模板字符串编译到 ES6. 得益于 <a href="https://github.com/ivogabe">@ivogabe</a> 的大量付出, 我们填补了标签模板字符串对编译到 ES3/ES5 的支持.</p>
<p>当编译到 ES3/ES5 时, 下面的代码:</p>
<pre><code class="language-typescript">function oddRawStrings(strs: TemplateStringsArray, n1, n2) {
    return strs.raw.filter((raw, index) =&gt; index % 2 === 1);
}

oddRawStrings `Hello \n${123} \t ${456}\n world`
</code></pre>
<p>会被输出为:</p>
<pre><code class="language-typescript">function oddRawStrings(strs, n1, n2) {
    return strs.raw.filter(function (raw, index) {
        return index % 2 === 1;
    });
}
(_a = ["Hello \n", " \t ", "\n world"], _a.raw = ["Hello \\n", " \\t ", "\\n world"], oddRawStrings(_a, 123, 456));
var _a;
</code></pre>
<h2 id="amd-可选依赖名称"><a class="header" href="#amd-可选依赖名称">AMD 可选依赖名称</a></h2>
<p><code>/// &lt;amd-dependency path="x" /&gt;</code> 会告诉编译器需要被注入到模块 <code>require</code> 方法中的非 TS 模块依赖; 然而在 TS 代码中无法使用这个模块.</p>
<p>新的 <code>amd-dependency name</code> 属性允许为 AMD 依赖传递一个可选的名称.</p>
<pre><code class="language-typescript">/// &lt;amd-dependency path="legacy/moduleA" name="moduleA"/&gt;
declare var moduleA:MyType
moduleA.callStuff()
</code></pre>
<p>生成的 JS 代码:</p>
<pre><code class="language-typescript">define(["require", "exports", "legacy/moduleA"], function (require, exports, moduleA) {
    moduleA.callStuff()
});
</code></pre>
<h2 id="通过-tsconfigjson-指示一个项目"><a class="header" href="#通过-tsconfigjson-指示一个项目">通过 <code>tsconfig.json</code> 指示一个项目</a></h2>
<p>通过添加 <code>tsconfig.json</code> 到一个目录指明这是一个 TypeScript 项目的根目录. <code>tsconfig.json</code> 文件指定了根文件以及编译项目需要的编译器选项. 一个项目可以由以下方式编译:</p>
<ul>
<li>调用 tsc 并不指定输入文件, 此时编译器会从当前目录开始往上级目录寻找 <code>tsconfig.json</code> 文件.</li>
<li>调用 tsc 并不指定输入文件, 使用 <code>-project</code> (或者 <code>-p</code>) 命令行选项指定包含了 <code>tsconfig.json</code> 文件的目录.</li>
</ul>
<h3 id="例子-72"><a class="header" href="#例子-72">例子</a></h3>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "module": "commonjs",
        "noImplicitAny": true,
        "sourceMap": true,
    }
}
</code></pre>
<p>参见 <a href="https://github.com/Microsoft/TypeScript/wiki/tsconfig.json">tsconfig.json wiki 页面</a> 查看更多信息.</p>
<h2 id="--rootdir-命令行选项"><a class="header" href="#--rootdir-命令行选项"><code>--rootDir</code> 命令行选项</a></h2>
<p>选项 <code>--outDir</code> 在输出中会保留输入的层级关系. 编译器将所有输入文件共有的最长路径作为根路径; 并且在输出中应用对应的子层级关系.</p>
<p>有的时候这并不是期望的结果, 比如输入 <code>FolderA\FolderB\1.ts</code> 和 <code>FolderA\FolderB\2.ts</code>, 输出结构会是 <code>FolderA\FolderB\</code> 对应的结构. 如果输入中新增 <code>FolderA\3.ts</code> 文件, 输出的结构将突然变为 <code>FolderA\</code> 对应的结构.</p>
<p><code>--rootDir</code> 指定了会输出对应结构的输入目录, 不再通过计算获得.</p>
<h2 id="--noemithelpers-命令行选项"><a class="header" href="#--noemithelpers-命令行选项"><code>--noEmitHelpers</code> 命令行选项</a></h2>
<p>TypeScript 编译器在需要的时候会输出一些像 <code>__extends</code> 这样的工具函数. 这些函数会在使用它们的所有文件中输出. 如果你想要聚合所有的工具函数到同一个位置, 或者覆盖默认的行为, 使用 <code>--noEmitHelpers</code> 来告知编译器不要输出它们.</p>
<h2 id="--newline-命令行选项"><a class="header" href="#--newline-命令行选项"><code>--newLine</code> 命令行选项</a></h2>
<p>默认输出的换行符在 Windows 上是 <code>\r\n</code>, 在 *nix 上是 <code>\n</code>. <code>--newLine</code> 命令行标记可以覆盖这个行为, 并指定输出文件中使用的换行符.</p>
<h2 id="--inlinesourcemap-and-inlinesources-命令行选项"><a class="header" href="#--inlinesourcemap-and-inlinesources-命令行选项"><code>--inlineSourceMap</code> and <code>inlineSources</code> 命令行选项</a></h2>
<p><code>--inlineSourceMap</code> 将内嵌源文件映射到 <code>.js</code> 文件, 而不是在单独的 <code>.js.map</code> 文件中. <code>--inlineSources</code> 允许进一步将 <code>.ts</code> 文件内容包含到输出文件中.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-14"><a class="header" href="#typescript-14">TypeScript 1.4</a></h1>
<h2 id="联合类型-1"><a class="header" href="#联合类型-1">联合类型</a></h2>
<h3 id="概述-2"><a class="header" href="#概述-2">概述</a></h3>
<p>联合类型有助于表示一个值的类型可以是多种类型之一的情况。比如，有一个API接命令行传入<code>string</code>类型，<code>string[]</code>类型或者是一个返回<code>string</code>的函数。你就可以这样写：</p>
<pre><code class="language-typescript">interface RunOptions {
   program: string;
   commandline: string[]|string|(() =&gt; string);
}
</code></pre>
<p>给联合类型赋值也很直观 -- 只要这个值能满足联合类型中任意一个类型那么就可以赋值给这个联合类型：</p>
<pre><code class="language-typescript">var opts: RunOptions = /* ... */;
opts.commandline = '-hello world'; // OK
opts.commandline = ['-hello', 'world']; // OK
opts.commandline = [42]; // Error, 数字不是字符串或字符串数组
</code></pre>
<p>当读取联合类型时，你可以访问类型共有的属性：</p>
<pre><code class="language-typescript">if(opts.length === 0) { // OK, string和string[]都有'length'属性
  console.log("it's empty");
}
</code></pre>
<p>使用类型保护，你可以轻松地使用联合类型：</p>
<pre><code class="language-typescript">function formatCommandline(c: string|string[]) {
    if(typeof c === 'string') {
        return c.trim();
    } else {
        return c.join(' ');
    }
}
</code></pre>
<h3 id="严格的泛型"><a class="header" href="#严格的泛型">严格的泛型</a></h3>
<p>随着联合类型可以表示有很多类型的场景，我们决定去改进泛型调用的规范性。之前，这段代码编译不会报错（出乎意料）：</p>
<pre><code class="language-typescript">function equal&lt;T&gt;(lhs: T, rhs: T): boolean {
  return lhs === rhs;
}

// 之前没有错误
// 现在会报错：在string和number之前没有最佳的基本类型
var e = equal(42, 'hello');
</code></pre>
<p>通过联合类型，你可以指定你想要的行为，在函数定义时或在调用的时候：</p>
<pre><code class="language-typescript">// 'choose' function where types must match
function choose1&lt;T&gt;(a: T, b: T): T { return Math.random() &gt; 0.5 ? a : b }
var a = choose1('hello', 42); // Error
var b = choose1&lt;string|number&gt;('hello', 42); // OK

// 'choose' function where types need not match
function choose2&lt;T, U&gt;(a: T, b: U): T|U { return Math.random() &gt; 0.5 ? a : b }
var c = choose2('bar', 'foo'); // OK, c: string
var d = choose2('hello', 42); // OK, d: string|number
</code></pre>
<h3 id="更好的类型推断"><a class="header" href="#更好的类型推断">更好的类型推断</a></h3>
<p>当一个集合里有多种类型的值时，联合类型会为数组或其它地方提供更好的类型推断：</p>
<pre><code class="language-typescript">var x = [1, 'hello']; // x: Array&lt;string|number&gt;
x[0] = 'world'; // OK
x[0] = false; // Error, boolean is not string or number
</code></pre>
<h2 id="let-声明-1"><a class="header" href="#let-声明-1"><code>let</code> 声明</a></h2>
<p>在JavaScript里，<code>var</code>声明会被“提升”到所在作用域的顶端。这可能会引发一些让人不解的bugs：</p>
<pre><code class="language-typescript">console.log(x); // meant to write 'y' here
/* later in the same block */
var x = 'hello';
</code></pre>
<p>TypeScript已经支持新的ES6的关键字<code>let</code>，声明一个块级作用域的变量。一个<code>let</code>变量只能在声明之后的位置被引用，并且作用域为声明它的块里：</p>
<pre><code class="language-typescript">if(foo) {
    console.log(x); // Error, cannot refer to x before its declaration
    let x = 'hello';
} else {
    console.log(x); // Error, x is not declared in this block
}
</code></pre>
<p><code>let</code>只在设置目标为ECMAScript 6 （<code>--target ES6</code>）时生效。</p>
<h2 id="const-声明-1"><a class="header" href="#const-声明-1"><code>const</code> 声明</a></h2>
<p>另一个TypeScript支持的ES6里新出现的声明类型是<code>const</code>。不能给一个<code>const</code>类型变量赋值，只能在声明的时候初始化。这对于那些在初始化之后就不想去改变它的值的情况下是很有帮助的：</p>
<pre><code class="language-typescript">const halfPi = Math.PI / 2;
halfPi = 2; // Error, can't assign to a `const`
</code></pre>
<p><code>const</code>只在设置目标为ECMAScript 6 （<code>--target ES6</code>）时生效。</p>
<h2 id="模版字符串"><a class="header" href="#模版字符串">模版字符串</a></h2>
<p>TypeScript现已支持ES6模块字符串。通过它可以方便地在字符串中嵌入任何表达式：</p>
<pre><code class="language-typescript">var name = "TypeScript";
var greeting  = `Hello, ${name}! Your name has ${name.length} characters`;
</code></pre>
<p>当编译目标为ES6之前的版本时，这个字符串被分解为：</p>
<pre><code class="language-javascript">var name = "TypeScript!";
var greeting = "Hello, " + name + "! Your name has " + name.length + " characters";
</code></pre>
<h2 id="类型守护"><a class="header" href="#类型守护">类型守护</a></h2>
<p>JavaScript常用模式之一是在运行时使用<code>typeof</code>或<code>instanceof</code>检查表达式的类型。 在<code>if</code>语句里使用它们的时候，TypeScript可以识别出这些条件并且随之改变类型推断的结果。</p>
<p>使用<code>typeof</code>来检查一个变量：</p>
<pre><code class="language-typescript">var x: any = /* ... */;
if(typeof x === 'string') {
    console.log(x.subtr(1)); // Error, 'subtr' does not exist on 'string'
}
// x is still any here
x.unknown(); // OK
</code></pre>
<p>结合联合类型使用<code>typeof</code>和<code>else</code>：</p>
<pre><code class="language-typescript">var x: string|HTMLElement = /* ... */;
if(typeof x === 'string') {
    // x is string here, as shown above
} else {
    // x is HTMLElement here
    console.log(x.innerHTML);
}
</code></pre>
<p>结合类和联合类型使用<code>instanceof</code>：</p>
<pre><code class="language-typescript">class Dog { woof() { } }
class Cat { meow() { } }
var pet: Dog|Cat = /* ... */;
if(pet instanceof Dog) {
    pet.woof(); // OK
} else {
    pet.woof(); // Error
}
</code></pre>
<h2 id="类型别名-1"><a class="header" href="#类型别名-1">类型别名</a></h2>
<p>你现在可以使用<code>type</code>关键字来为类型定义一个“别名”：</p>
<pre><code class="language-typescript">type PrimitiveArray = Array&lt;string|number|boolean&gt;;
type MyNumber = number;
type NgScope = ng.IScope;
type Callback = () =&gt; void;
</code></pre>
<p>类型别名与其原始的类型完全一致；它们只是简单的替代名。</p>
<h2 id="const-enum完全嵌入的枚举"><a class="header" href="#const-enum完全嵌入的枚举"><code>const enum</code>（完全嵌入的枚举）</a></h2>
<p>枚举很有帮助，但是有些程序实际上并不需要它生成的代码并且想要将枚举变量所代码的数字值直接替换到对应位置上。新的<code>const enum</code>声明与正常的<code>enum</code>在类型安全方面具有同样的作用，只是在编译时会清除掉。</p>
<pre><code class="language-typescript">const enum Suit { Clubs, Diamonds, Hearts, Spades }
var d = Suit.Diamonds;
</code></pre>
<p>Compiles to exactly:</p>
<pre><code class="language-javascript">var d = 1;
</code></pre>
<p>TypeScript也会在可能的情况下计算枚举值：</p>
<pre><code class="language-typescript">enum MyFlags {
  None = 0,
  Neat = 1,
  Cool = 2,
  Awesome = 4,
  Best = Neat | Cool | Awesome
}
var b = MyFlags.Best; // emits var b = 7;
</code></pre>
<h2 id="-noemitonerror-命令行选项"><a class="header" href="#-noemitonerror-命令行选项"><code>-noEmitOnError</code> 命令行选项</a></h2>
<p>TypeScript编译器的默认行为是当存在类型错误（比如，将<code>string</code>类型赋值给<code>number</code>类型）时仍会生成.js文件。这在构建服务器上或是其它场景里可能会是不想看到的情况，因为希望得到的是一次“纯净”的构建。新的<code>noEmitOnError</code>标记可以阻止在编译时遇到错误的情况下继续生成.js代码。</p>
<p>它现在是MSBuild工程的默认行为；这允许MSBuild持续构建以我们想要的行为进行，输出永远是来自纯净的构建。</p>
<h2 id="amd-模块名"><a class="header" href="#amd-模块名">AMD 模块名</a></h2>
<p>默认情况下AMD模块以匿名形式生成。这在使用其它工具（比如，r.js）处理生成的模块的时可能会带来麻烦。</p>
<p>新的<code>amd-module name</code>标签允许给编译器传入一个可选的模块名：</p>
<pre><code class="language-typescript">//// [amdModule.ts]
///&lt;amd-module name='NamedModule'/&gt;
export class C {
}
</code></pre>
<p>结果会把<code>NamedModule</code>赋值成模块名，做为调用AMD<code>define</code>的一部分：</p>
<pre><code class="language-javascript">//// [amdModule.js]
define("NamedModule", ["require", "exports"], function (require, exports) {
    var C = (function () {
        function C() {
        }
        return C;
    })();
    exports.C = C;
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-13"><a class="header" href="#typescript-13">TypeScript 1.3</a></h1>
<h2 id="受保护的"><a class="header" href="#受保护的">受保护的</a></h2>
<p>类里面新的<code>protected</code>修饰符作用与其它语言如C++，C#和Java中的一样。一个类的<code>protected</code>成员只在这个类的子类中可见：</p>
<pre><code class="language-typescript">class Thing {
  protected doSomething() { /* ... */ }
}

class MyThing extends Thing {
  public myMethod() {
    // OK，可以在子类里访问受保护的成员
    this.doSomething();
  }
}
var t = new MyThing();
t.doSomething(); // Error，不能在类外部访问受保护成员
</code></pre>
<h2 id="元组类型"><a class="header" href="#元组类型">元组类型</a></h2>
<p>元组类型表示一个数组，其中元素的类型都是已知的，但是不一样是同样的类型。比如，你可能想要表示一个第一个元素是<code>string</code>类型第二个元素是<code>number</code>类型的数组：</p>
<pre><code class="language-typescript">// Declare a tuple type
var x: [string, number];
// 初始化
x = ['hello', 10]; // OK
// 错误的初始化
x = [10, 'hello']; // Error
</code></pre>
<p>但是访问一个已知的索引，会得到正确的类型：</p>
<pre><code class="language-typescript">console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, 'number'没有'substr'方法
</code></pre>
<p>注意在TypeScript1.4里，当访问超出已知索引的元素时，会返回联合类型：</p>
<pre><code class="language-typescript">x[3] = 'world'; // OK
console.log(x[5].toString()); // OK, 'string'和'number'都有toString
x[6] = true; // Error, boolean不是number或string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-11"><a class="header" href="#typescript-11">TypeScript 1.1</a></h1>
<h2 id="改进性能"><a class="header" href="#改进性能">改进性能</a></h2>
<p>1.1版本的编译器速度比所有之前发布的版本快4倍。阅读<a href="http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx">这篇博客里的有关图表</a></p>
<h2 id="更好的模块可见性规则"><a class="header" href="#更好的模块可见性规则">更好的模块可见性规则</a></h2>
<p>TypeScript现在只在使用<code>--declaration</code>标记时才严格强制模块里类型的可见性。这在Angular里很有用，例如：</p>
<pre><code class="language-typescript">module MyControllers {
  interface ZooScope extends ng.IScope {
    animals: Animal[];
  }
  export class ZooController {
    // Used to be an error (cannot expose ZooScope), but now is only
    // an error when trying to generate .d.ts files
    constructor(public $scope: ZooScope) { }
    /* more code */
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="breaking-changes"><a class="header" href="#breaking-changes">Breaking Changes</a></h1>
<ul>
<li><a href="zh/breaking-changes/typescript-3.6.html">TypeScript 3.6</a></li>
<li><a href="zh/breaking-changes/typescript-3.5.html">TypeScript 3.5</a></li>
<li><a href="zh/breaking-changes/typescript-3.4.html">TypeScript 3.4</a></li>
<li><a href="zh/breaking-changes/typescript-3.2.html">TypeScript 3.2</a></li>
<li><a href="zh/breaking-changes/typescript-3.1.html">TypeScript 3.1</a></li>
<li><a href="zh/breaking-changes/typescript-3.0.html">TypeScript 3.0</a></li>
<li><a href="zh/breaking-changes/typescript-2.9.html">TypeScript 2.9</a></li>
<li><a href="zh/breaking-changes/typescript-2.8.html">TypeScript 2.8</a></li>
<li><a href="zh/breaking-changes/typescript-2.7.html">TypeScript 2.7</a></li>
<li><a href="zh/breaking-changes/typescript-2.6.html">TypeScript 2.6</a></li>
<li><a href="zh/breaking-changes/typescript-2.4.html">TypeScript 2.4</a></li>
<li><a href="zh/breaking-changes/typescript-2.3.html">TypeScript 2.3</a></li>
<li><a href="zh/breaking-changes/typescript-2.2.html">TypeScript 2.2</a></li>
<li><a href="zh/breaking-changes/typescript-2.1.html">TypeScript 2.1</a></li>
<li><a href="zh/breaking-changes/typescript-2.0.html">TypeScript 2.0</a></li>
<li><a href="zh/breaking-changes/typescript-1.8.html">TypeScript 1.8</a></li>
<li><a href="zh/breaking-changes/typescript-1.7.html">TypeScript 1.7</a></li>
<li><a href="zh/breaking-changes/typescript-1.6.html">TypeScript 1.6</a></li>
<li><a href="zh/breaking-changes/typescript-1.5.html">TypeScript 1.5</a></li>
<li><a href="zh/breaking-changes/typescript-1.4.html">TypeScript 1.4</a></li>
<li><a href="zh/breaking-changes/typescript-1.1.html">TypeScript 1.1</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-36-1"><a class="header" href="#typescript-36-1">TypeScript 3.6</a></h1>
<h2 id="类成员的-constructor-现在被叫做-constructors"><a class="header" href="#类成员的-constructor-现在被叫做-constructors">类成员的 <code>constructor</code> 现在被叫做 <code>Constructors</code></a></h2>
<p>根据 ECMAScript 规范，使用名为 <code>constructor</code> 的方法的类声明现在是构造函数，无论它们是使用标识符名称还是字符串名称声明。</p>
<pre><code class="language-typescript">class C {
  "constructor"() {
    console.log("现在我是构造函数了。");
  }
}
</code></pre>
<p>一个值得注意的例外，以及此改变的解决方法是使用名称计算结果为 <code>constructor</code> 的计算属性。</p>
<pre><code class="language-typescript">class D {
  ["constructor"]() {
    console.log("我只是一个纯粹的方法，不是构造函数！")
  }
}
</code></pre>
<h2 id="dom-定义更新"><a class="header" href="#dom-定义更新">DOM 定义更新</a></h2>
<p><code>lib.dom.d.ts</code> 中移除或者修改了大量的定义。其中包括（但不仅限于）以下这些：</p>
<ul>
<li>全局的 <code>window</code> 不再定义为 <code>Window</code>，它被更明确的定义 <code>type Window &amp; typeof globalThis</code> 替代。在某些情况下，将它作为 <code>typeof window</code> 更好。</li>
<li><code>GlobalFetch</code> 已经被移除。使用 <code>WindowOrWorkerGlobalScrope</code> 替代。</li>
<li><code>Navigator</code> 上明确的非标准的属性已经被移除了。</li>
<li><code>experimental-webgl</code> 上下文已经被移除了。使用 <code>webgl</code> 或 <code>webgl2</code> 替代。</li>
</ul>
<p>如果你认为其中的改变已经制造了错误，<a href="https://github.com/Microsoft/TSJS-lib-generator/">请提交一个 issue</a>。</p>
<h2 id="jsdoc-注释不再合并"><a class="header" href="#jsdoc-注释不再合并">JSDoc 注释不再合并</a></h2>
<p>在 JavaScript 文件中，TypeScript 只会在 JSDoc 注释之前立即查询以确定声明的类型。</p>
<pre><code class="language-typescript">/**
 * @param {string} arg
 */
/**
 * 你的其他注释信息
 */
function whoWritesFunctionsLikeThis(arg) {
  // 'arg' 是 'any' 类型
}
</code></pre>
<h2 id="关键字不能包含转义字符"><a class="header" href="#关键字不能包含转义字符">关键字不能包含转义字符</a></h2>
<p>之前的版本允许关键字包含转义字符。TypeScript 3.6 不允许。</p>
<pre><code class="language-typescript">while (true) {
  \u0063ontinue;
//  ~~~~~~~~~~~~~
// 错误！关键字不能包含转义字符
}
</code></pre>
<h2 id="参考-3"><a class="header" href="#参考-3">参考</a></h2>
<ul>
<li><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-6/#breaking-changes">Announcing TypeScript 3.6</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-35-1"><a class="header" href="#typescript-35-1">TypeScript 3.5</a></h1>
<h2 id="libdts-包含了-omit-辅助类型"><a class="header" href="#libdts-包含了-omit-辅助类型"><code>lib.d.ts</code> 包含了 <code>Omit</code> 辅助类型</a></h2>
<p>TypeScript 3.5 包含一个 <code>Omit</code> 辅助类型。</p>
<p>因此, 你项目中任何全局定义的 <code>Omit</code> 将产生以下错误信息:</p>
<pre><code class="language-typescript">Duplicate identifier 'Omit'.
</code></pre>
<p>两个变通的方法可以在这里使用：</p>
<ol>
<li>删除重复定义的并使用 <code>lib.d.ts</code> 提供的。</li>
<li>从模块中导出定义避免全局冲突。现有的用法可以使用 <code>import</code> 直接引用项目的旧 <code>Omit</code> 类型。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-34-1"><a class="header" href="#typescript-34-1">TypeScript 3.4</a></h1>
<h2 id="顶级-this-现在有类型了"><a class="header" href="#顶级-this-现在有类型了">顶级 <code>this</code> 现在有类型了</a></h2>
<p>顶级 <code>this</code> 的类型现在被分配为 <code>typeof globalThis</code> 而不是 <code>any</code>。</p>
<p>因此, 在 <code>noImplicitAny</code> 下访问 <code>this</code> 上的未知值，你可能收到错误提示。</p>
<pre><code class="language-typescript">// 在 `noImplicitAny` 下，以前可以，现在不行
this.whargarbl = 10;
</code></pre>
<p>请注意，在 <code>noImplicitThis</code> 下编译的代码不会在此处遇到任何更改。</p>
<h2 id="泛型参数的传递"><a class="header" href="#泛型参数的传递">泛型参数的传递</a></h2>
<p>在某些情况下，TypeScript 3.4 的推断改进可能会产生泛型的函数，而不是那些接收并返回其约束的函数（通常是 <code>{}</code>）。</p>
<pre><code class="language-typescript">declare function compose&lt;T, U, V&gt;(f: (arg: T) =&gt; U, g: (arg: U) =&gt; V): (arg: T) =&gt; V;

function list&lt;T&gt;(x: T) { return [x]; }
function box&lt;T&gt;(value: T) { return { value }; }

let f = compose(list, box);
let x = f(100)

// 在 TypeScript 3.4 中, 'x.value' 的类型为
//
//   number[]
//
// 但是在之前的版本中类型为
//
//   {}[]
//
// 因此，插入一个 `string` 类型是错误的
x.value.push("hello");
</code></pre>
<p><code>x</code> 上的显式类型注释可以清除这个错误。</p>
<h3 id="上下文返回类型作为上下文参数类型传入"><a class="header" href="#上下文返回类型作为上下文参数类型传入">上下文返回类型作为上下文参数类型传入</a></h3>
<p>TypeScript 现在使用函数调用时传入的类型（如下例中的 <code>then</code>）作为函数上下文参数类型（如下例中的箭头函数）。</p>
<pre><code class="language-typescript">function isEven(prom: Promise&lt;number&gt;): Promise&lt;{ success: boolean }&gt; {
  return prom.then&lt;{success: boolean}&gt;((x) =&gt; {
    return x % 2 === 0 ?
      { success: true } :
      Promise.resolve({ success: false });
    });
}
</code></pre>
<p>这通常是一种改进，但在上面的例子中，它导致 <code>true</code> 和 <code>false</code> 获取不合需要的字面量类型。</p>
<pre><code class="language-bash">Argument of type '(x: number) =&gt; Promise&lt;{ success: false; }&gt; | { success: true; }' is not assignable to parameter of type '(value: number) =&gt; { success: false; } | PromiseLike&lt;{ success: false; }&gt;'.
  Type 'Promise&lt;{ success: false; }&gt; | { success: true; }' is not assignable to type '{ success: false; } | PromiseLike&lt;{ success: false; }&gt;'.
    Type '{ success: true; }' is not assignable to type '{ success: false; } | PromiseLike&lt;{ success: false; }&gt;'.
      Type '{ success: true; }' is not assignable to type '{ success: false; }'.
        Types of property 'success' are incompatible.
</code></pre>
<p>合适的解决方法是将类型参数添加到适当的调用——本例中的 <code>then</code> 方法调用。</p>
<pre><code class="language-typescript">function isEven(prom: Promise&lt;number&gt;): Promise&lt;{ success: boolean }&gt; {
  //               vvvvvvvvvvvvvvvvvv
  return prom.then&lt;{success: boolean}&gt;((x) =&gt; {
    return x % 2 === 0 ?
      { success: true } :
      Promise.resolve({ success: false });
  });
}
</code></pre>
<h3 id="在-strictfunctiontypes-之外一致性推断优先"><a class="header" href="#在-strictfunctiontypes-之外一致性推断优先">在 <code>strictFunctionTypes</code> 之外一致性推断优先</a></h3>
<p>在 TypeScript 3.3 中，关闭 <code>--strictFunctionTypes</code> 选项时，假定使用 <code>interface</code> 声明的泛型类型在其类型参数方面始终是协变的。对于函数类型，通常无法观察到此行为。</p>
<p>但是，对于带有 <code>keyof</code> 状态的类型参数的泛型 <code>interface</code> 类型——逆变用法——这些类型表现不正确。</p>
<p>在 TypeScript 3.4 中，现在可以在所有情况下正确探测使用 <code>interface</code> 声明的类型的变动。</p>
<p>这导致一个可见的重大变更，只要有类型参数的接口使用了 <code>keyof</code>（包括诸如 <code>Record&lt;K, T&gt;</code> 之类的地方，这是涉及 <code>keyof K</code> 的类型别名）。下例就是这样一个可能的变更。</p>
<pre><code class="language-typescript">interface HasX { x: any }
interface HasY { y: any }

declare const source: HasX | HasY;
declare const properties: KeyContainer&lt;HasX&gt;;

interface KeyContainer&lt;T&gt; {
  key: keyof T;
}

function readKey&lt;T&gt;(source: T, prop: KeyContainer&lt;T&gt;) {
  console.log(source[prop.key])
}

// 这个调用应该被拒绝，因为我们可能会这样做
// 错误地从 'HasY' 中读取 'x'。它现在恰当的提示错误。
readKey(source, properties);
</code></pre>
<p>此错误很可能表明原代码存在问题。</p>
<h2 id="参考-4"><a class="header" href="#参考-4">参考</a></h2>
<ul>
<li><a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#typescript-34">原文</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-32-1"><a class="header" href="#typescript-32-1">TypeScript 3.2</a></h1>
<h2 id="libdts-更新-1"><a class="header" href="#libdts-更新-1"><code>lib.d.ts</code> 更新</a></h2>
<h3 id="wheeldelta-和它的小伙伴们被移除了"><a class="header" href="#wheeldelta-和它的小伙伴们被移除了"><code>wheelDelta</code> 和它的小伙伴们被移除了。</a></h3>
<p><code>wheelDeltaX</code>、<code>wheelDelta</code> 和 <code>wheelDeltaZ</code> 全都被移除了，因为他们在 <code>WheelEvent</code>s 上是废弃的属性。</p>
<p><strong>解决办法</strong>：使用 <code>deltaX</code>、<code>deltaY</code> 和 <code>deltaZ</code> 代替。</p>
<h3 id="更具体的类型"><a class="header" href="#更具体的类型">更具体的类型</a></h3>
<p>根据 DOM 规范的描述，某些参数现在接受更具体的类型，不再接受 <code>null</code>。</p>
<h2 id="参考-5"><a class="header" href="#参考-5">参考</a></h2>
<ul>
<li><a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#typescript-32">原文</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-31-1"><a class="header" href="#typescript-31-1">TypeScript 3.1</a></h1>
<h2 id="一些浏览器厂商特定的类型从libdts中被移除"><a class="header" href="#一些浏览器厂商特定的类型从libdts中被移除">一些浏览器厂商特定的类型从<code>lib.d.ts</code>中被移除</a></h2>
<p>TypeScript内置的<code>.d.ts</code>库(<code>lib.d.ts</code>等)现在会部分地从DOM规范的Web IDL文件中生成。 因此有一些浏览器厂商特定的类型被移除了。</p>
<p>点击这里查看被移除类型的完整列表：</p>
<p>* `CanvasRenderingContext2D.mozImageSmoothingEnabled` * `CanvasRenderingContext2D.msFillRule` * `CanvasRenderingContext2D.oImageSmoothingEnabled` * `CanvasRenderingContext2D.webkitImageSmoothingEnabled` * `Document.caretRangeFromPoint` * `Document.createExpression` * `Document.createNSResolver` * `Document.execCommandShowHelp` * `Document.exitFullscreen` * `Document.exitPointerLock` * `Document.focus` * `Document.fullscreenElement` * `Document.fullscreenEnabled` * `Document.getSelection` * `Document.msCapsLockWarningOff` * `Document.msCSSOMElementFloatMetrics` * `Document.msElementsFromRect` * `Document.msElementsFromPoint` * `Document.onvisibilitychange` * `Document.onwebkitfullscreenchange` * `Document.onwebkitfullscreenerror` * `Document.pointerLockElement` * `Document.queryCommandIndeterm` * `Document.URLUnencoded` * `Document.webkitCurrentFullScreenElement` * `Document.webkitFullscreenElement` * `Document.webkitFullscreenEnabled` * `Document.webkitIsFullScreen` * `Document.xmlEncoding` * `Document.xmlStandalone` * `Document.xmlVersion` * `DocumentType.entities` * `DocumentType.internalSubset` * `DocumentType.notations` * `DOML2DeprecatedSizeProperty` * `Element.msContentZoomFactor` * `Element.msGetUntransformedBounds` * `Element.msMatchesSelector` * `Element.msRegionOverflow` * `Element.msReleasePointerCapture` * `Element.msSetPointerCapture` * `Element.msZoomTo` * `Element.onwebkitfullscreenchange` * `Element.onwebkitfullscreenerror` * `Element.webkitRequestFullScreen` * `Element.webkitRequestFullscreen` * `ElementCSSInlineStyle` * `ExtendableEventInit` * `ExtendableMessageEventInit` * `FetchEventInit` * `GenerateAssertionCallback` * `HTMLAnchorElement.Methods` * `HTMLAnchorElement.mimeType` * `HTMLAnchorElement.nameProp` * `HTMLAnchorElement.protocolLong` * `HTMLAnchorElement.urn` * `HTMLAreasCollection` * `HTMLHeadElement.profile` * `HTMLImageElement.msGetAsCastingSource` * `HTMLImageElement.msGetAsCastingSource` * `HTMLImageElement.msKeySystem` * `HTMLImageElement.msPlayToDisabled` * `HTMLImageElement.msPlayToDisabled` * `HTMLImageElement.msPlayToPreferredSourceUri` * `HTMLImageElement.msPlayToPreferredSourceUri` * `HTMLImageElement.msPlayToPrimary` * `HTMLImageElement.msPlayToPrimary` * `HTMLImageElement.msPlayToSource` * `HTMLImageElement.msPlayToSource` * `HTMLImageElement.x` * `HTMLImageElement.y` * `HTMLInputElement.webkitdirectory` * `HTMLLinkElement.import` * `HTMLMetaElement.charset` * `HTMLMetaElement.url` * `HTMLSourceElement.msKeySystem` * `HTMLStyleElement.disabled` * `HTMLSummaryElement` * `MediaQueryListListener` * `MSAccountInfo` * `MSAudioLocalClientEvent` * `MSAudioLocalClientEvent` * `MSAudioRecvPayload` * `MSAudioRecvSignal` * `MSAudioSendPayload` * `MSAudioSendSignal` * `MSConnectivity` * `MSCredentialFilter` * `MSCredentialParameters` * `MSCredentials` * `MSCredentialSpec` * `MSDCCEvent` * `MSDCCEventInit` * `MSDelay` * `MSDescription` * `MSDSHEvent` * `MSDSHEventInit` * `MSFIDOCredentialParameters` * `MSIceAddrType` * `MSIceType` * `MSIceWarningFlags` * `MSInboundPayload` * `MSIPAddressInfo` * `MSJitter` * `MSLocalClientEvent` * `MSLocalClientEventBase` * `MSNetwork` * `MSNetworkConnectivityInfo` * `MSNetworkInterfaceType` * `MSOutboundNetwork` * `MSOutboundPayload` * `MSPacketLoss` * `MSPayloadBase` * `MSPortRange` * `MSRelayAddress` * `MSSignatureParameters` * `MSStatsType` * `MSStreamReader` * `MSTransportDiagnosticsStats` * `MSUtilization` * `MSVideoPayload` * `MSVideoRecvPayload` * `MSVideoResolutionDistribution` * `MSVideoSendPayload` * `NotificationEventInit` * `PushEventInit` * `PushSubscriptionChangeInit` * `RTCIdentityAssertionResult` * `RTCIdentityProvider` * `RTCIdentityProviderDetails` * `RTCIdentityValidationResult` * `Screen.deviceXDPI` * `Screen.logicalXDPI` * `SVGElement.xmlbase` * `SVGGraphicsElement.farthestViewportElement` * `SVGGraphicsElement.getTransformToElement` * `SVGGraphicsElement.nearestViewportElement` * `SVGStylable` * `SVGTests.hasExtension` * `SVGTests.requiredFeatures` * `SyncEventInit` * `ValidateAssertionCallback` * `WebKitDirectoryEntry` * `WebKitDirectoryReader` * `WebKitEntriesCallback` * `WebKitEntry` * `WebKitErrorCallback` * `WebKitFileCallback` * `WebKitFileEntry` * `WebKitFileSystem` * `Window.clearImmediate` * `Window.msSetImmediate` * `Window.setImmediate`</p>
<h3 id="推荐-1"><a class="header" href="#推荐-1">推荐：</a></h3>
<p>如果你的运行时能够保证这些名称是可用的（比如一个仅针对IE的应用），那么可以在本地添加那些声明，例如：</p>
<p>对于<code>Element.msMatchesSelector</code>，在本地的<code>dom.ie.d.ts</code>文件里添加如下代码：</p>
<pre><code class="language-typescript">interface Element {
    msMatchesSelector(selectors: string): boolean;
}
</code></pre>
<p>相似地，若要添加<code>clearImmediate</code>和<code>setImmediate</code>，你可以在本地的<code>dom.ie.d.ts</code>里添加<code>Window</code>声明：</p>
<pre><code class="language-typescript">interface Window {
    clearImmediate(handle: number): void;
    setImmediate(handler: (...args: any[]) =&gt; void): number;
    setImmediate(handler: any, ...args: any[]): number;
}
</code></pre>
<h2 id="细化的函数现在会使用object和未约束的泛型参数的交叉类型"><a class="header" href="#细化的函数现在会使用object和未约束的泛型参数的交叉类型">细化的函数现在会使用<code>{}</code>，<code>Object</code>和未约束的泛型参数的交叉类型</a></h2>
<p>下面的代码如今会提示<code>x</code>不能被调用：</p>
<pre><code class="language-typescript">function foo&lt;T&gt;(x: T | (() =&gt; string)) {
    if (typeof x === "function") {
        x();
//      ~~~
// Cannot invoke an expression whose type lacks a call signature. Type '(() =&gt; string) | (T &amp; Function)' has no compatible call signatures.
    }
}
</code></pre>
<p>这是因为，不同于以前的<code>T</code>会被细化掉，如今<code>T</code>会被扩展成<code>T &amp; Function</code>。 然而，因为这个类型没有声明调用签名，类型系统无法找到通用的调用签名可以适用于<code>T &amp; Function</code>和<code>() =&gt; string</code>。</p>
<p>因此，考虑使用一个更确切的类型，而不是<code>{}</code>或<code>Object</code>，并且考虑给<code>T</code>添加额外的约束条件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-30-1"><a class="header" href="#typescript-30-1">TypeScript 3.0</a></h1>
<h2 id="保留关键字-unknown"><a class="header" href="#保留关键字-unknown">保留关键字 <code>unknown</code></a></h2>
<p><code>unknown</code> 现在是一个保留类型名称，因为它现在是一个内置类型。为了支持新引入的 <code>unknown</code> 类型，取决于你对 <code>unknown</code> 的使用方式，你可能需要完全移除变量申明，或者将其重命名。</p>
<h2 id="未开启-strictnullchecks-时与-nullundefined-交叉的类型会简化到-nullundefined"><a class="header" href="#未开启-strictnullchecks-时与-nullundefined-交叉的类型会简化到-nullundefined">未开启 <code>strictNullChecks</code> 时，与 <code>null</code>/<code>undefined</code> 交叉的类型会简化到 <code>null</code>/<code>undefined</code></a></h2>
<p>关闭 <code>strictNullChecks</code> 时，下例中 <code>A</code> 的类型为 <code>null</code>，而 <code>B</code> 的类型为 <code>undefined</code>：</p>
<pre><code class="language-typescript">type A = { a: number } &amp; null;      // null
type B = { a: number } &amp; undefined; // undefined
</code></pre>
<p>这是因为 TypeScript 3.0 更适合分别简化交叉类型和联合类型中的子类型和超类型。但是，因为当 <code>strictNullChecks</code> 关闭时，<code>null</code> 和 <code>undefined</code> 都被认为是所有其他类型的子类型，与某种对象类型的交集将始终简化为 <code>null</code> 或 <code>undefined</code>。</p>
<h3 id="建议"><a class="header" href="#建议">建议</a></h3>
<p>如果你在类型交叉的情况下依赖 <code>null</code> 和 <code>undefined</code> 作为<a href="https://baike.baidu.com/item/%E5%8D%95%E4%BD%8D%E5%85%83">单位元</a>，你应该寻找一种方法来使用 <code>unknown</code> 而不是无论它们在哪里都是 <code>null</code> 或 <code>undefined</code>。</p>
<h2 id="参考-6"><a class="header" href="#参考-6">参考</a></h2>
<ul>
<li><a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#typescript-30">原文</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-29-1"><a class="header" href="#typescript-29-1">TypeScript 2.9</a></h1>
<h2 id="keyof-现在包括-stringnumber-和-symbol-键名"><a class="header" href="#keyof-现在包括-stringnumber-和-symbol-键名"><code>keyof</code> 现在包括 <code>string</code>、<code>number</code> 和 <code>symbol</code> 键名</a></h2>
<p>TypeScript 2.9 将索引类型泛化为包括 <code>number</code> 和 <code>symbol</code> 命名属性。以前，<code>keyof</code> 运算符和映射类型仅支持 <code>string</code> 命名属性。</p>
<pre><code class="language-typescript">function useKey&lt;T, K extends keyof T&gt;(o: T, k: K) {
  var name: string = k;  // 错误: keyof T 不能分配给 `string`
}
</code></pre>
<h3 id="建议-1"><a class="header" href="#建议-1">建议</a></h3>
<ul>
<li>
<p>如果你的函数只能处理名字符串属性的键，请在声明中使用 <code>Extract&lt;keyof T，string&gt;</code>：</p>
<pre><code class="language-typescript">function useKey&lt;T, K extends Extract&lt;keyof T, string&gt;&gt;(o: T, k: K) {
  var name: string = k;  // OK
}
</code></pre>
</li>
<li>
<p>如果你的函数可以处理所有属性键，那么更改应该是顺畅的：</p>
<pre><code class="language-typescript">function useKey&lt;T, K extends keyof T&gt;(o: T, k: K) {
  var name: string | number | symbol = k;
}
</code></pre>
</li>
<li>
<p>除此之外，还可以使用 <code>--keyofStringsOnly</code> 编译器选项禁用新行为。</p>
</li>
</ul>
<h2 id="剩余参数后面不允许尾后逗号"><a class="header" href="#剩余参数后面不允许尾后逗号">剩余参数后面不允许尾后逗号</a></h2>
<p>以下代码是一个自 <a href="https://github.com/Microsoft/TypeScript/pull/22262">#22262</a> 开始的编译器错误：</p>
<pre><code class="language-typescript">function f(
  a: number,
  ...b: number[], // 违规的尾随逗号
) {}
</code></pre>
<p>剩余参数上的尾随逗号不是有效的 JavaScript，并且，这个语法现在在 TypeScript 中也是一个错误。</p>
<h2 id="在-strictnullchecks-中无类型约束参数不再分配给-object"><a class="header" href="#在-strictnullchecks-中无类型约束参数不再分配给-object">在 <code>strictNullChecks</code> 中，无类型约束参数不再分配给 <code>object</code></a></h2>
<p>以下代码是自<a href="https://github.com/microsoft/typescript/issues/24013">24013</a>起在 <code>strickNullChecks</code> 下出现的编译器错误：</p>
<pre><code class="language-typescript">function f&lt;T&gt;(x: T) {
  const y: object | null | undefined = x;
}
</code></pre>
<p>它可以用任意类型（例如，<code>string</code> 或 <code>number</code> ）来实现，因此允许它是不正确的。 如果您遇到此问题，请将您的类型参数约束为 <code>object</code> 以仅允许对象类型。如果想允许任何类型，使用 <code>{}</code> 进行比较而不是 <code>object</code>。</p>
<h2 id="参考-7"><a class="header" href="#参考-7">参考</a></h2>
<ul>
<li><a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#typescript-29">原文</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-28-1"><a class="header" href="#typescript-28-1">TypeScript 2.8</a></h1>
<h2 id="在--nounusedparameters下检查未使用的类型参数"><a class="header" href="#在--nounusedparameters下检查未使用的类型参数">在<code>--noUnusedParameters</code>下检查未使用的类型参数</a></h2>
<p>根据 <a href="https://github.com/Microsoft/TypeScript/issues/20568">#20568</a>，未使用的类型参数之前在<code>--noUnusedLocals</code>下报告，但现在报告在<code>--noUnusedParameters</code>下。</p>
<h2 id="从libdts中删除了一些microsoft-专用的类型"><a class="header" href="#从libdts中删除了一些microsoft-专用的类型">从<code>lib.d.ts</code>中删除了一些Microsoft 专用的类型</a></h2>
<p>从DOM定义中删除一些Microsoft 专用的类型以更好地与标准对齐。 删除的类型包括：</p>
<ul>
<li><code>MSApp</code></li>
<li><code>MSAppAsyncOperation</code></li>
<li><code>MSAppAsyncOperationEventMap</code></li>
<li><code>MSBaseReader</code></li>
<li><code>MSBaseReaderEventMap</code></li>
<li><code>MSExecAtPriorityFunctionCallback</code></li>
<li><code>MSHTMLWebViewElement</code></li>
<li><code>MSManipulationEvent</code></li>
<li><code>MSRangeCollection</code></li>
<li><code>MSSiteModeEvent</code></li>
<li><code>MSUnsafeFunctionCallback</code></li>
<li><code>MSWebViewAsyncOperation</code></li>
<li><code>MSWebViewAsyncOperationEventMap</code></li>
<li><code>MSWebViewSettings</code></li>
</ul>
<h2 id="htmlobjectelement不再具有alt属性"><a class="header" href="#htmlobjectelement不再具有alt属性"><code>HTMLObjectElement</code>不再具有<code>alt</code>属性</a></h2>
<p>根据 <a href="https://github.com/Microsoft/TypeScript/issues/21386">#21386</a>，DOM库已更新以反映WHATWG标准。</p>
<p>如果需要继续使用<code>alt</code>属性，请考虑通过全局范围中的接口合并重新打开<code>HTMLObjectElement</code>：</p>
<pre><code class="language-typescript">// Must be in a global .ts file or a 'declare global' block.
interface HTMLObjectElement {
    alt: string;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-27-2"><a class="header" href="#typescript-27-2">TypeScript 2.7</a></h1>
<p>完整的破坏性改动列表请到这里查看:<a href="https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+milestone%3A%22TypeScript+2.7%22+label%3A%22Breaking+Change%22+is%3Aclosed">breaking change issues</a>.</p>
<h2 id="元组现在具有固定长度的属性"><a class="header" href="#元组现在具有固定长度的属性">元组现在具有固定长度的属性</a></h2>
<p>以下代码用于没有编译错误：</p>
<pre><code class="language-typescript">var pair: [number, number] = [1, 2];
var triple: [number, number, number] = [1, 2, 3];
pair = triple;
</code></pre>
<p>但是，这_是_一个错误：</p>
<pre><code class="language-typescript">triple = pair;
</code></pre>
<p>现在，相互赋值是一个错误。 这是因为元组现在有一个长度属性，其类型是它们的长度。 所以<code>pair.length: 2</code>，但是<code>triple.length: 3</code>。</p>
<p>请注意，之前允许某些非元组模式，但现在不再允许：</p>
<pre><code class="language-typescript">const struct: [string, number] = ['key'];
for (const n of numbers) {
  struct.push(n);
}
</code></pre>
<p>对此最好的解决方法是创建扩展Array的自己的类型：</p>
<pre><code class="language-typescript">interface Struct extends Array&lt;string | number&gt; {
  '0': string;
  '1'?: number;
}
const struct: Struct = ['key'];
for (const n of numbers) {
  struct.push(n);
}
</code></pre>
<h2 id="在allowsyntheticdefaultimports下对于ts和js文件来说默认导入的类型合成不常见"><a class="header" href="#在allowsyntheticdefaultimports下对于ts和js文件来说默认导入的类型合成不常见">在<code>allowSyntheticDefaultImports</code>下，对于TS和JS文件来说默认导入的类型合成不常见</a></h2>
<p>在过去，我们在类型系统中合成一个默认导入，用于TS或JS文件，如下所示：</p>
<pre><code class="language-typescript">export const foo = 12;
</code></pre>
<p>意味着模块的类型为<code>{foo: number, default: {foo: number}}</code>。 这是错误的，因为文件将使用<code>__esModule</code>标记发出，因此在加载文件时没有流行的模块加载器会为它创建合成默认值，并且类型系统推断的<code>default</code>成员永远不会在运行时存在。现在我们在<code>ESModuleInterop</code>标志下的发出中模拟了这个合成默认行为，我们收紧了类型检查器的行为，以匹配你期望在运行时所看到的内容。如果运行时没有其他工具的介入，此更改应仅指出错误的错误默认导入用法，应将其更改为命名空间导入。</p>
<h2 id="更严格地检查索引访问泛型类型约束"><a class="header" href="#更严格地检查索引访问泛型类型约束">更严格地检查索引访问泛型类型约束</a></h2>
<p>以前，仅当类型具有索引签名时才计算索引访问类型的约束，否则它是<code>any</code>。这样就可以取消选中无效赋值。在TS 2.7.1中，编译器在这里有点聪明，并且会将约束计算为此处所有可能属性的并集。</p>
<pre><code class="language-typescript">interface O {
    foo?: string;
}

function fails&lt;K extends keyof O&gt;(o: O, k: K) {
    var s: string = o[k]; // Previously allowed, now an error
                          // string | undefined is not assignable to a string
}
</code></pre>
<h2 id="in表达式被视为类型保护"><a class="header" href="#in表达式被视为类型保护"><code>in</code>表达式被视为类型保护</a></h2>
<p>对于<code>n in x</code>表达式，其中<code>n</code>是字符串文字或字符串文字类型而<code>x</code>是联合类型，"true"分支缩小为具有可选或必需属性<code>n</code>的类型，并且 "false"分支缩小为具有可选或缺少属性<code>n</code>的类型。 如果声明类型始终具有属性<code>n</code>，则可能导致在false分支中将变量的类型缩小为<code>never</code>的情况。</p>
<pre><code class="language-typescript">var x: { foo: number };

if ("foo" in x) {
    x; // { foo: number }
}
else {
    x; // never
}
</code></pre>
<h2 id="在条件运算符中不减少结构上相同的类"><a class="header" href="#在条件运算符中不减少结构上相同的类">在条件运算符中不减少结构上相同的类</a></h2>
<p>以前在结构上相同的类在条件或<code>||</code>运算符中被简化为最佳公共类型。现在这些类以联合类型维护，以便更准确地检查<code>instanceof</code>运算符。</p>
<pre><code class="language-typescript">class Animal {

}

class Dog {
    park() { }
}

var a = Math.random() ? new Animal() : new Dog();
// typeof a now Animal | Dog, previously Animal
</code></pre>
<h2 id="customevent现在是一个泛型类型"><a class="header" href="#customevent现在是一个泛型类型"><code>CustomEvent</code>现在是一个泛型类型</a></h2>
<p><code>CustomEvent</code>现在有一个<code>details</code>属性类型的类型参数。如果要从中扩展，则需要指定其他类型参数。</p>
<pre><code class="language-typescript">class MyCustomEvent extends CustomEvent {
}
</code></pre>
<p>应该成为</p>
<pre><code class="language-typescript">class MyCustomEvent extends CustomEvent&lt;any&gt; {
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-26-1"><a class="header" href="#typescript-26-1">TypeScript 2.6</a></h1>
<p>完整的破坏性改动列表请到这里查看:<a href="https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+milestone%3A%22TypeScript+2.6%22+label%3A%22Breaking+Change%22+is%3Aclosed">breaking change issues</a>.</p>
<h2 id="只写引用未使用"><a class="header" href="#只写引用未使用">只写引用未使用</a></h2>
<p>以下代码用于没有编译错误:</p>
<pre><code class="language-typescript">function f(n: number) {
    n = 0;
}

class C {
    private m: number;
    constructor() {
        this.m = 0;
    }
}
</code></pre>
<p>现在，当启用<code>--noUnusedLocals</code>和<code>--noUnusedParameters</code><a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">编译器选项</a>时，<code>n</code>和<code>m</code>都将被标记为未使用，因为它们的值永远不会被_读_ 。以前TypeScript只会检查它们的值是否被_引用_。</p>
<p>此外，仅在其自己的实体中调用的递归函数被视为未使用。</p>
<pre><code class="language-typescript">function f() {
    f(); // Error: 'f' is declared but its value is never read
}
</code></pre>
<h2 id="环境上下文中的导出赋值中禁止使用任意表达式"><a class="header" href="#环境上下文中的导出赋值中禁止使用任意表达式">环境上下文中的导出赋值中禁止使用任意表达式</a></h2>
<p>以前，像这样的结构</p>
<pre><code class="language-typescript">declare module "foo" {
    export default "some" + "string";
}
</code></pre>
<p>在环境上下文中未被标记为错误。声明文件和环境模块中通常禁止使用表达式，因为<code>typeof</code>之类的意图不明确，因此这与我们在这些上下文中的其他地方处理可执行代码不一致。现在，任何不是标识符或限定名称的内容都会被标记为错误。为具有上述值形状的模块制作DTS的正确方法如下：</p>
<pre><code class="language-typescript">declare module "foo" {
    const _default: string;
    export default _default;
}
</code></pre>
<p>编译器已经生成了这样的定义，因此这只应该是手工编写的定义的问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-24-1"><a class="header" href="#typescript-24-1">TypeScript 2.4</a></h1>
<p>完整的破坏性改动列表请到这里查看:<a href="https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+milestone%3A%22TypeScript+2.4%22+label%3A%22Breaking+Change%22+is%3Aclosed">breaking change issues</a>。</p>
<h2 id="弱类型检测"><a class="header" href="#弱类型检测">弱类型检测</a></h2>
<p>TypeScript 2.4引入了“弱类型（weak type）”的概念。 若一个类型只包含可选的属性，那么它就被认为是_弱（weak）_的。 例如，下面的<code>Options</code>类型就是一个弱类型：</p>
<pre><code class="language-typescript">interface Options {
    data?: string,
    timeout?: number,
    maxRetries?: number,
}
</code></pre>
<p>TypeScript 2.4，当给一个弱类型赋值，但是它们之前没有共同的属性，那么就会报错。 例如：</p>
<pre><code class="language-typescript">function sendMessage(options: Options) {
    // ...
}

const opts = {
    payload: "hello world!",
    retryOnFail: true,
}

// 错误！
sendMessage(opts);
// 'opts'与'Options'之间没有共同的属性
// 你是否想用'data'/'maxRetries'来替换'payload'/'retryOnFail'
</code></pre>
<p><strong>推荐做法</strong></p>
<ol>
<li>仅声明那些确定存在的属性。</li>
<li>给弱类型添加索引签名（如：<code>[propName: string]: {}</code>）</li>
<li>使用类型断言（如：<code>opts as Options</code>）</li>
</ol>
<h2 id="推断返回值的类型"><a class="header" href="#推断返回值的类型">推断返回值的类型</a></h2>
<p>TypeScript现在可从上下文类型中推断出一个调用的返回值类型。 这意味着一些代码现在会适当地报错。 下面是一个例子：</p>
<pre><code class="language-typescript">let x: Promise&lt;string&gt; = new Promise(resolve =&gt; {
    resolve(10);
    //      ~~ 错误! 'number'类型不能赋值给'string'类型
});
</code></pre>
<h2 id="更严格的回调函数参数变化"><a class="header" href="#更严格的回调函数参数变化">更严格的回调函数参数变化</a></h2>
<p>TypeScript对回调函数参数的检测将与立即签名检测协变。 之前是双变的，这会导致有时候错误的类型也能通过检测。 根本上讲，这意味着回调函数参数和包含回调的类会被更细致地检查，因此Typescript会要求更严格的类型。 这在Promises和Observables上是十分明显的。</p>
<h3 id="promises"><a class="header" href="#promises">Promises</a></h3>
<p>下面是改进后的Promise检查的例子：</p>
<pre><code class="language-typescript">let p = new Promise((c, e) =&gt; { c(12) });
let u: Promise&lt;number&gt; = p;
    ~
    类型 'Promise&lt;{}&gt;' 不能赋值给 'Promise&lt;number&gt;'
</code></pre>
<p>TypeScript无法在调用<code>new Promise</code>时推断类型参数<code>T</code>的值。 因此，它仅推断为<code>Promise&lt;{}&gt;</code>。 不幸的是，它会允许你这样写<code>c(12)</code>和<code>c('foo')</code>，就算<code>p</code>的声明明确指出它应该是<code>Promise&lt;number&gt;</code>。</p>
<p>在新的规则下，<code>Promise&lt;{}&gt;</code>不能够赋值给<code>Promise&lt;number&gt;</code>，因为它破坏了Promise的回调函数。 TypeScript仍无法推断类型参数，所以你只能通过传递类型参数来解决这个问题：</p>
<pre><code class="language-typescript">let p: Promise&lt;number&gt; = new Promise&lt;number&gt;((c, e) =&gt; { c(12) });
//                                  ^^^^^^^^ 明确的类型参数
</code></pre>
<p>它能够帮助从promise代码体里发现错误。 现在，如果你错误地调用<code>c('foo')</code>，你就会得到一个错误提示:</p>
<pre><code class="language-typescript">let p: Promise&lt;number&gt; = new Promise&lt;number&gt;((c, e) =&gt; { c('foo') });
//                                                         ~~~~~
//  参数类型 '"foo"' 不能赋值给 'number'
</code></pre>
<h3 id="嵌套回调"><a class="header" href="#嵌套回调">（嵌套）回调</a></h3>
<p>其它类型的回调也会被这个改进所影响，其中主要是嵌套的回调。 下面是一个接收回调函数的函数，回调函数又接收嵌套的回调。 嵌套的回调现在会以协变的方式检查。</p>
<pre><code class="language-typescript">declare function f(
  callback: (nested: (error: number, result: any) =&gt; void, index: number) =&gt; void
): void;

f((nested: (error: number) =&gt; void) =&gt; { log(error) });
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'(error: number) =&gt; void' 不能赋值给 '(error: number, result: any) =&gt; void'
</code></pre>
<p>修复这个问题很容易。给嵌套的回调传入缺失的参数：</p>
<pre><code class="language-typescript">f((nested: (error: number, result: any) =&gt; void) =&gt; { });
</code></pre>
<h2 id="更严格的泛型函数检查"><a class="header" href="#更严格的泛型函数检查">更严格的泛型函数检查</a></h2>
<p>TypeScript在比较两个单一签名的类型时会尝试统一类型参数。 结果就是，当关系到两个泛型签名时检查变得更严格了，但同时也会捕获一些bug。</p>
<pre><code class="language-typescript">type A = &lt;T, U&gt;(x: T, y: U) =&gt; [T, U];
type B = &lt;S&gt;(x: S, y: S) =&gt; [S, S];

function f(a: A, b: B) {
    a = b;  // Error
    b = a;  // Ok
}
</code></pre>
<p><strong>推荐做法</strong></p>
<p>或者修改定义或者使用<code>--noStrictGenericChecks</code>。</p>
<h2 id="从上下文类型中推荐类型参数"><a class="header" href="#从上下文类型中推荐类型参数">从上下文类型中推荐类型参数</a></h2>
<p>在TypeScript之前，下面例子中</p>
<pre><code class="language-typescript">let f: &lt;T&gt;(x: T) =&gt; T = y =&gt; y;
</code></pre>
<p><code>y</code>的类型将是<code>any</code>。 这意味着，程序虽会进行类型检查，但是你可以在<code>y</code>上做任何事，比如：</p>
<pre><code class="language-typescript">let f: &lt;T&gt;(x: T) =&gt; T = y =&gt; y() + y.foo.bar;
</code></pre>
<p><strong>推荐做法:</strong></p>
<p>适当地重新审视你的泛型是否为正确的约束。实在不行，就为参数加上<code>any</code>注解。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-23-1"><a class="header" href="#typescript-23-1">TypeScript 2.3</a></h1>
<p>完整的破坏性改动列表请到这里查看:<a href="https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+milestone%3A%22TypeScript+2.3%22+label%3A%22Breaking+Change%22+is%3Aclosed">breaking change issues</a>.</p>
<h2 id="空的泛型列表会被标记为错误"><a class="header" href="#空的泛型列表会被标记为错误">空的泛型列表会被标记为错误</a></h2>
<p><strong>示例</strong></p>
<pre><code class="language-typescript">class X&lt;&gt; {}  // Error: Type parameter list cannot be empty.
function f&lt;&gt;() {}  // Error: Type parameter list cannot be empty.
const x: X&lt;&gt; = new X&lt;&gt;();  // Error: Type parameter list cannot be empty.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-22-1"><a class="header" href="#typescript-22-1">TypeScript 2.2</a></h1>
<p>完整的破坏性改动列表请到这里查看:<a href="https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+milestone%3A%22TypeScript+2.2%22+label%3A%22Breaking+Change%22+is%3Aclosed">breaking change issues</a>.</p>
<h2 id="标准库里的dom-api变动"><a class="header" href="#标准库里的dom-api变动">标准库里的DOM API变动</a></h2>
<ul>
<li>现在标准库里有<code>Window.fetch</code>的声明；仍依赖于<code>@types\whatwg-fetch</code>会产生声明冲突错误，需要被移除。</li>
<li>现在标准库里有<code>ServiceWorker</code>的声明；仍依赖于<code>@types\service_worker_api</code>会产生声明冲突错误，需要被移除。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-21-1"><a class="header" href="#typescript-21-1">TypeScript 2.1</a></h1>
<p>完整的破坏性改动列表请到这里查看:<a href="https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+milestone%3A%22TypeScript+2.1%22+label%3A%22Breaking+Change%22+is%3Aclosed">breaking change issues</a>.</p>
<h2 id="生成的构造函数代码将this的值替换为super调用的返回值"><a class="header" href="#生成的构造函数代码将this的值替换为super调用的返回值">生成的构造函数代码将<code>this</code>的值替换为<code>super(...)</code>调用的返回值</a></h2>
<p>在ES2015中，如果构造函数返回一个对象，那么对于任何<code>super(...)</code>的调用者将隐式地替换掉<code>this</code>的值。 因此，有必要获取任何可能的<code>super(...)</code>的返回值并用<code>this</code>进行替换。</p>
<p><strong>示例</strong></p>
<p>定义一个类<code>C</code>：</p>
<pre><code class="language-typescript">class C extends B {
    public a: number;
    constructor() {
        super();
        this.a = 0;
    }
}
</code></pre>
<p>将生成如下代码：</p>
<pre><code class="language-javascript">var C = (function (_super) {
    __extends(C, _super);
    function C() {
        var _this = _super.call(this) || this;
        _this.a = 0;
        return _this;
    }
    return C;
}(B));
</code></pre>
<p>注意：</p>
<ul>
<li><code>_super.call(this)</code>存入局部变量<code>_this</code></li>
<li>构造函数体里所有使用<code>this</code>的地方都被替换为<code>super</code>调用的返回值（例如<code>_this</code>）</li>
<li>每个构造函数将明确地返回它的<code>this</code>，以确保正确的继承</li>
</ul>
<p>值得注意的是在<code>super(...)</code>调用前就使用<code>this</code>从<a href="zh/breaking-changes/typescript-2.1.html#disallow-this-accessing-before-super-call">TypeScript 1.8</a>开始将会引发错误。</p>
<h2 id="继承内置类型如errorarray和map将是无效的"><a class="header" href="#继承内置类型如errorarray和map将是无效的">继承内置类型如<code>Error</code>，<code>Array</code>和<code>Map</code>将是无效的</a></h2>
<p>做为将<code>this</code>的值替换为<code>super(...)</code>调用返回值的一部分，子类化<code>Error</code>，<code>Array</code>等的结果可以是非预料的。 这是因为<code>Error</code>，<code>Array</code>等的构造函数会使用ECMAScript 6的<code>new.target</code>来调整它们的原型链； 然而，在ECMAScript 5中调用构造函数时却没有有效的方法来确保<code>new.target</code>的值。 在默认情况下，其它低级别的编译器也普遍存在这个限制。</p>
<p><strong>示例</strong></p>
<p>针对如下的子类：</p>
<pre><code class="language-typescript">class FooError extends Error {
    constructor(m: string) {
        super(m);
    }
    sayHello() {
        return "hello " + this.message;
    }
}
</code></pre>
<p>你会发现：</p>
<ul>
<li>由这个子类构造出来的对象上的方法可能为<code>undefined</code>，因此调用<code>sayHello</code>会引发错误。</li>
<li><code>instanceof</code>应用于子类与其实例之前会失效，因此<code>(new FooError()) instanceof FooError</code>会返回<code>false</code>。</li>
</ul>
<p><strong>推荐</strong></p>
<p>做为一个推荐，你可以在任何<code>super(...)</code>调用后立即手动地调整原型。</p>
<pre><code class="language-typescript">class FooError extends Error {
    constructor(m: string) {
        super(m);

        // Set the prototype explicitly.
        Object.setPrototypeOf(this, FooError.prototype);
    }

    sayHello() {
        return "hello " + this.message;
    }
}
</code></pre>
<p>但是，任何<code>FooError</code>的子类也必须要手动地设置原型。 对于那些不支持<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf</code></a>的运行时环境，你可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>__proto__</code></a>。</p>
<p>不幸的是，[这些变通方法在IE10及其之前的版本](<a href="https://msdn.microsoft.com/en-us/library/s4esdbwz%28v=vs.94%29.aspx">https://msdn.microsoft.com/en-us/library/s4esdbwz(v=vs.94).aspx</a>) 你可以手动地将方法从原型上拷贝到实例上（比如从<code>FooError.prototype</code>到<code>this</code>），但是原型链却是无法修复的。</p>
<h2 id="const变量和readonly属性会默认地推断成字面类型"><a class="header" href="#const变量和readonly属性会默认地推断成字面类型"><code>const</code>变量和<code>readonly</code>属性会默认地推断成字面类型</a></h2>
<p>默认情况下，<code>const</code>声明和<code>readonly</code>属性不会被推断成字符串，数字，布尔和枚举字面量类型。这意味着你的变量/属性可能具有比之前更细的类型。这将体现在使用<code>===</code>和<code>!==</code>的时候。</p>
<p><strong>示例</strong></p>
<pre><code class="language-typescript">const DEBUG = true; // 现在为`true`类型，之前为`boolean`类型

if (DEBUG === false) { // 错误： 操作符'==='不能应用于'true'和'false'
    ...
}
</code></pre>
<p><strong>推荐</strong></p>
<p>针对故意要求更加宽泛类型的情况下，将类型转换成基础类型：</p>
<pre><code class="language-typescript">const DEBUG = &lt;boolean&gt;true; // `boolean`类型
</code></pre>
<h2 id="不对函数和类表达式里捕获的变量进行类型细化"><a class="header" href="#不对函数和类表达式里捕获的变量进行类型细化">不对函数和类表达式里捕获的变量进行类型细化</a></h2>
<p>当泛型类型参数具有<code>string</code>，<code>number</code>或<code>boolean</code>约束时，会被推断为字符串，数字和布尔字面量类型。此外，如果字面量类型有相同的基础类型（如<code>string</code>），当没有字面量类型做为推断的最佳超类型时这个规则会失效。</p>
<p><strong>示例</strong></p>
<pre><code class="language-typescript">declare function push&lt;T extends string&gt;(...args: T[]): T;

var x = push("A", "B", "C"); // 推断成 "A" | "B" | "C" 在TS 2.1, 在TS 2.0里为 string
</code></pre>
<p><strong>推荐</strong></p>
<p>在调用处明确指定参数类型：</p>
<pre><code class="language-typescript">var x = push&lt;string&gt;("A", "B", "C"); // x是string
</code></pre>
<h2 id="没有注解的callback参数如果没有与之匹配的重载参数会触发implicit-any错误"><a class="header" href="#没有注解的callback参数如果没有与之匹配的重载参数会触发implicit-any错误">没有注解的callback参数如果没有与之匹配的重载参数会触发implicit-any错误</a></h2>
<p>在之前编译器默默地赋予callback（下面的<code>c</code>）的参数一个<code>any</code>类型。原因关乎到编译器如何解析重载的函数表达式。从TypeScript 2.1开始，在使用<code>--noImplicitAny</code>时，这会触发一个错误。</p>
<p><strong>示例</strong></p>
<pre><code class="language-typescript">declare function func(callback: () =&gt; void): any;
declare function func(callback: (arg: number) =&gt; void): any;

func(c =&gt; { });
</code></pre>
<p><strong>推荐</strong></p>
<p>删除第一个重载，因为它实在没什么意义；上面的函数可以使用1个或0个必须参数调用，因为函数可以安全地忽略额外的参数。</p>
<pre><code class="language-typescript">declare function func(callback: (arg: number) =&gt; void): any;

func(c =&gt; { });
func(() =&gt; { });
</code></pre>
<p>或者，你可以给callback的参数指定一个明确的类型：</p>
<pre><code class="language-typescript">func((c:number) =&gt; { });
</code></pre>
<h2 id="逗号操作符使用在无副作用的表达式里时会被标记成错误"><a class="header" href="#逗号操作符使用在无副作用的表达式里时会被标记成错误">逗号操作符使用在无副作用的表达式里时会被标记成错误</a></h2>
<p>大多数情况下，这种在之前是有效的逗号表达式现在是错误。</p>
<p><strong>示例</strong></p>
<pre><code class="language-typescript">let x = Math.pow((3, 5)); // x = NaN, was meant to be `Math.pow(3, 5)`

// This code does not do what it appears to!
let arr = [];
switch(arr.length) {
  case 0, 1:
    return 'zero or one';
  default:
    return 'more than one';
}
</code></pre>
<p><strong>推荐</strong></p>
<p><code>--allowUnreachableCode</code>会禁用产生警告在整个编译过程中。或者，你可以使用<code>void</code>操作符来镇压这个逗号表达式错误：</p>
<pre><code class="language-typescript">let a = 0;
let y = (void a, 1); // no warning for `a`
</code></pre>
<h2 id="标准库里的dom-api变动-1"><a class="header" href="#标准库里的dom-api变动-1">标准库里的DOM API变动</a></h2>
<ul>
<li>
<p><strong>Node.firstChild</strong>，<strong>Node.lastChild</strong>，<strong>Node.nextSibling</strong>，<strong>Node.previousSibling</strong>，<strong>Node.parentElement</strong>和<strong>Node.parentNode</strong>现在是<code>Node | null</code>而非<code>Node</code>。</p>
<p>查看<a href="https://github.com/Microsoft/TypeScript/issues/11113">#11113</a>了解详细信息。</p>
<p>推荐明确检查<code>null</code>或使用<code>!</code>断言操作符（比如<code>node.lastChild!</code>）。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-20-1"><a class="header" href="#typescript-20-1">TypeScript 2.0</a></h1>
<p>完整的破坏性改动列表请到这里查看:<a href="https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+milestone%3A%22TypeScript+2.0%22+label%3A%22Breaking+Change%22+is%3Aclosed">breaking change issues</a>.</p>
<h2 id="对函数或类表达式的捕获变量不进行类型细化narrowing"><a class="header" href="#对函数或类表达式的捕获变量不进行类型细化narrowing">对函数或类表达式的捕获变量不进行类型细化(narrowing)</a></h2>
<p>类型细化不会在函数，类和lambda表达式上进行。</p>
<p><strong>例子</strong></p>
<pre><code class="language-typescript">var x: number | string;

if (typeof x === "number") {
    function inner(): number {
        return x; // Error, type of x is not narrowed, c is number | string
    }
    var y: number = x; // OK, x is number
}
</code></pre>
<p>编译器不知道回调函数什么时候被执行。考虑下面的情况：</p>
<pre><code class="language-typescript">var x: number | string = "a";
if (typeof x === "string") {
    setTimeout(() =&gt; console.log(x.charAt(0)), 0);
}
x = 5;
</code></pre>
<p>当<code>x.charAt()</code>被调用的时候把<code>x</code>的类型当作<code>string</code>是错误的，事实上它确实不是<code>string</code>类型。</p>
<p><strong>推荐</strong></p>
<p>使用常量代替：</p>
<pre><code class="language-typescript">const x: number | string = "a";
if (typeof x === "string") {
    setTimeout(() =&gt; console.log(x.charAt(0)), 0);
}
</code></pre>
<h2 id="泛型参数会进行类型细化"><a class="header" href="#泛型参数会进行类型细化">泛型参数会进行类型细化</a></h2>
<p><strong>例子</strong></p>
<pre><code class="language-typescript">function g&lt;T&gt;(obj: T) {
    var t: T;
    if (obj instanceof RegExp) {
         t = obj; // RegExp is not assignable to T
    }
}
</code></pre>
<p><strong>推荐</strong> 可以把局部变量声明为特定类型而不是泛型参数或者使用类型断言。</p>
<h2 id="只有get而没有set的存取器会被自动推断为readonly属性"><a class="header" href="#只有get而没有set的存取器会被自动推断为readonly属性">只有get而没有set的存取器会被自动推断为<code>readonly</code>属性</a></h2>
<p><strong>例子</strong></p>
<pre><code class="language-typescript">class C {
  get x() { return 0; }
}

var c = new C();
c.x = 1; // Error Left-hand side is a readonly property
</code></pre>
<p><strong>推荐</strong></p>
<p>定义一个不对属性写值的setter。</p>
<h2 id="在严格模式下函数声明不允许出现在块block里"><a class="header" href="#在严格模式下函数声明不允许出现在块block里">在严格模式下函数声明不允许出现在块(block)里</a></h2>
<p>在严格模式下这已经是一个运行时错误。从TypeScript 2.0开始，它会被标记为编译时错误。</p>
<p><strong>例子</strong></p>
<pre><code class="language-typescript">if( true ) {
    function foo() {}
}

export = foo;
</code></pre>
<p><strong>推荐</strong></p>
<p>使用函数表达式代替：</p>
<pre><code class="language-typescript">if( true ) {
    const foo = function() {}
}
</code></pre>
<h2 id="templatestringsarray现是是不可变的"><a class="header" href="#templatestringsarray现是是不可变的"><code>TemplateStringsArray</code>现是是不可变的</a></h2>
<p>ES2015模版字符串总是将它们的标签以不可变的类数组对象进行传递，这个对象带有一个<code>raw</code>属性（同样是不可变的）。 TypeScript把这个对象命名为<code>TemplateStringsArray</code>。</p>
<p>便利的是，<code>TemplateStringsArray</code>可以赋值给<code>Array&lt;string&gt;</code>，因此你可以利用这个较短的类型来使用标签参数：</p>
<pre><code class="language-typescript">function myTemplateTag(strs: string[]) {
    // ...
}
</code></pre>
<p>然而，在TypeScript 2.0，支持用<code>readonly</code>修饰符表示这些对象是不可变的。 这样的话，<code>TemplateStringsArray</code> 就变成了不可变的，并且不再可以赋值给<code>string[]</code>。</p>
<p><strong>推荐</strong></p>
<p>直接使用<code>TemplateStringsArray</code>（或者使用<code>ReadonlyArray&lt;string&gt;</code>）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-18-1"><a class="header" href="#typescript-18-1">TypeScript 1.8</a></h1>
<p>完整的破坏性改动列表请到这里查看:<a href="https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+milestone%3A%22TypeScript+1.8%22+label%3A%22Breaking+Change%22+is%3Aclosed">breaking change issues</a>。</p>
<h2 id="现在生成模块代码时会带有use-strict头"><a class="header" href="#现在生成模块代码时会带有use-strict头">现在生成模块代码时会带有<code>"use strict";</code>头</a></h2>
<p>在ES6模式下模块总是在严格模式下解析，对于生成目标为非ES6的却不是这样。从TypeScript 1.8开始，生成的模块将总为严格模式。这应该不会对现有的大部分代码产生影响，因为TypeScript把大多数因为严格模式而产生的错误当做编译时错误，但还是有一些在运行时才发生错误的TypeScript代码，比如赋值给<code>NaN</code>，现在将会直接报错。你可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">MDN Article</a>学习关于严格模式与非严格模式的区别。</p>
<p>若想禁用这个行为，在命令行里传<code>--noImplicitUseStrict</code>选项或在tsconfig.json文件里指定。</p>
<h2 id="从模块里导出非局部名称"><a class="header" href="#从模块里导出非局部名称">从模块里导出非局部名称</a></h2>
<p>依据ES6/ES2015规范，从模块里导出非局部名称将会报错。</p>
<p><strong>例子</strong></p>
<pre><code class="language-typescript">export { Promise }; // Error
</code></pre>
<p><strong>推荐</strong></p>
<p>在导出之前，使用局部变量声明捕获那个全局名称。</p>
<pre><code class="language-typescript">const localPromise = Promise;
export { localPromise as Promise };
</code></pre>
<h2 id="默认启用代码可达性reachability检查"><a class="header" href="#默认启用代码可达性reachability检查">默认启用代码可达性（Reachability）检查</a></h2>
<p>TypeScript 1.8里，我们添加了一些<a href="https://github.com/Microsoft/TypeScript/pull/4788">可达性检查</a>来阻止一些种类的错误。特别是：</p>
<ol>
<li>
<p>检查代码的可达性（默认启用，可以通过<code>allowUnreachableCode</code>编译器选项禁用）</p>
<pre><code class="language-typescript">   function test1() {
       return 1;
       return 2; // error here
   }

   function test2(x) {
       if (x) {
           return 1;
       }
       else {
           throw new Error("NYI")
       }
       var y = 1; // error here
   }
</code></pre>
</li>
<li>
<p>检查标签是否被使用（默认启用，可以通过<code>allowUnusedLabels</code>编译器选项禁用）</p>
<pre><code class="language-typescript">l: // error will be reported - label `l` is unused
while (true) {
}

(x) =&gt; { x:x } // error will be reported - label `x` is unused
</code></pre>
</li>
<li>
<p>检查是否函数里所有带有返回值类型注解的代码路径都返回了值（默认启用，可以通过<code>noImplicitReturns</code>编译器选项禁用）</p>
<pre><code class="language-typescript">// error will be reported since function does not return anything explicitly when `x` is falsy.
function test(x): number {
   if (x) return 10;
}
</code></pre>
</li>
<li>
<p>检查控制流是否能进到switch语句的case里（默认禁用，可以通过<code>noFallthroughCasesInSwitch</code>编译器选项启用）。注意没有语句的case不会被检查。</p>
<pre><code class="language-typescript">switch(x) {
   // OK
   case 1:
   case 2:
       return 1;
}
switch(x) {
   case 1:
       if (y) return 1;
   case 2:
       return 2;
}
</code></pre>
</li>
</ol>
<p>如果你看到了这些错误，但是你认为这时的代码是合理的话，你可以通过编译选项来阻止报错。</p>
<h2 id="--module不允许与--outfile一起出现除非---module被指定为amd或system"><a class="header" href="#--module不允许与--outfile一起出现除非---module被指定为amd或system"><code>--module</code>不允许与<code>--outFile</code>一起出现，除非 <code>--module</code>被指定为<code>amd</code>或<code>system</code></a></h2>
<p>之前使用模块指定这两个的时候，会生成空的<code>out</code>文件且不会报错。</p>
<h2 id="标准库里的dom-api变动-2"><a class="header" href="#标准库里的dom-api变动-2">标准库里的DOM API变动</a></h2>
<ul>
<li><strong>ImageData.data</strong>现在的类型为<code>Uint8ClampedArray</code>而不是<code>number[]</code>。查看<a href="https://github.com/Microsoft/TypeScript/issues/949">#949</a>。</li>
<li><strong>HTMLSelectElement .options</strong>现在的类型为<code>HTMLCollection</code>而不是<code>HTMLSelectElement</code>。查看<a href="https://github.com/Microsoft/TypeScript/issues/1558">#1558</a>。</li>
<li><strong>HTMLTableElement.createCaption</strong>，<strong>HTMLTableElement.createTBody</strong>，<strong>HTMLTableElement.createTFoot</strong>，<strong>HTMLTableElement.createTHead</strong>，<strong>HTMLTableElement.insertRow</strong>，<strong>HTMLTableSectionElement.insertRow</strong>和<strong>HTMLTableElement.insertRow</strong>现在返回<code>HTMLTableRowElement</code>而不是<code>HTMLElement</code>。查看<a href="https://github.com/Microsoft/TypeScript/issues/3583">#3583</a>。</li>
<li><strong>HTMLTableRowElement.insertCell</strong>现在返回<code>HTMLTableCellElement</code>而不是<code>HTMLElement</code>查看<a href="https://github.com/Microsoft/TypeScript/issues/3583">#3583</a>。</li>
<li><strong>IDBObjectStore.createIndex</strong>和<strong>IDBDatabase.createIndex</strong>第二个参数类型为<code>IDBObjectStoreParameters</code>而不是<code>any</code>。查看<a href="https://github.com/Microsoft/TypeScript/issues/5932">#5932</a>。</li>
<li><strong>DataTransferItemList.Item</strong>返回值类型变为<code>DataTransferItem</code>而不是<code>File</code>。查看<a href="https://github.com/Microsoft/TypeScript/issues/6106">#6106</a>。</li>
<li><strong>Window.open</strong>返回值类型变为<code>Window</code>而不是<code>any</code>。查看<a href="https://github.com/Microsoft/TypeScript/issues/6418">#6418</a>。</li>
<li><strong>WeakMap.clear</strong>被移除。查看<a href="https://github.com/Microsoft/TypeScript/issues/6500">#6500</a>。</li>
</ul>
<h2 id="在super-call之前不允许使用this"><a class="header" href="#在super-call之前不允许使用this">在super-call之前不允许使用<code>this</code></a></h2>
<p>ES6不允许在构造函数声明里访问<code>this</code>。</p>
<p>比如：</p>
<pre><code class="language-typescript">class B {
    constructor(that?: any) {}
}

class C extends B {
    constructor() {
        super(this);  // error;
    }
}

class D extends B {
    private _prop1: number;
    constructor() {
        this._prop1 = 10;  // error
        super();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-17-1"><a class="header" href="#typescript-17-1">TypeScript 1.7</a></h1>
<p>完整的破坏性改动列表请到这里查看:<a href="https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+milestone%3A%22TypeScript+1.7%22+label%3A%22breaking+change%22">breaking change issues</a>。</p>
<h2 id="从this中推断类型发生了变化"><a class="header" href="#从this中推断类型发生了变化">从<code>this</code>中推断类型发生了变化</a></h2>
<p>在类里，<code>this</code>值的类型将被推断成<code>this</code>类型。 这意味着随后使用原始类型赋值时可能会发生错误。</p>
<p><strong>例子：</strong></p>
<pre><code class="language-typescript">class Fighter {
    /** @returns the winner of the fight. */
    fight(opponent: Fighter) {
        let theVeryBest = this;
        if (Math.rand() &lt; 0.5) {
            theVeryBest = opponent; // error
        }
        return theVeryBest
    }
}
</code></pre>
<p><strong>推荐：</strong></p>
<p>添加类型注解：</p>
<pre><code class="language-typescript">class Fighter {
    /** @returns the winner of the fight. */
    fight(opponent: Fighter) {
        let theVeryBest: Fighter = this;
        if (Math.rand() &lt; 0.5) {
            theVeryBest = opponent; // no error
        }
        return theVeryBest
    }
}
</code></pre>
<h2 id="类成员修饰符后面会自动插入分号"><a class="header" href="#类成员修饰符后面会自动插入分号">类成员修饰符后面会自动插入分号</a></h2>
<p>关键字<code>abstract，public，protected</code>和<code>private</code>是ECMAScript 3里的_保留关键字_并适用于自动插入分号机制。 之前，在这些关键字出现的行尾，TypeScript是不会插入分号的。 现在，这已经被改正了，在上例中<code>abstract class D</code>不再能够正确地继承<code>C</code>了，而是声明了一个<code>m</code>方法和一个额外的属性<code>abstract</code>。</p>
<p>注意，<code>async</code>和<code>declare</code>已经能够正确自动插入分号了。</p>
<p><strong>例子：</strong></p>
<pre><code class="language-typescript">abstract class C {
    abstract m(): number;
}
abstract class D extends C {
    abstract
    m(): number;
}
</code></pre>
<p><strong>推荐：</strong></p>
<p>在定义类成员时删除关键字后面的换行。通常来讲，要避免依赖于自动插入分号机制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-16-1"><a class="header" href="#typescript-16-1">TypeScript 1.6</a></h1>
<p>完整的破坏性改动列表请到这里查看:<a href="https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+milestone%3A%22TypeScript+1.6%22+label%3A%22breaking+change%22">breaking change issues</a>。</p>
<h2 id="严格的对象字面量赋值检查"><a class="header" href="#严格的对象字面量赋值检查">严格的对象字面量赋值检查</a></h2>
<p>当在给变量赋值或给非空类型的参数赋值时，如果对象字面量里指定的某属性不存在于目标类型中时会得到一个错误。</p>
<p>你可以通过使用<a href="https://github.com/Microsoft/TypeScript/pull/4484">--suppressExcessPropertyErrors</a>编译器选项来禁用这个新的严格检查。</p>
<p><strong>例子：</strong></p>
<pre><code class="language-typescript">var x: { foo: number };
x = { foo: 1, baz: 2 };  // Error, excess property `baz`

var y: { foo: number, bar?: number };
y = { foo: 1, baz: 2 };  // Error, excess or misspelled property `baz`
</code></pre>
<p><strong>推荐：</strong></p>
<p>为了避免此错误，不同情况下有不同的补救方法：</p>
<p><strong>如果目标类型接收额外的属性，可以增加一个索引：</strong></p>
<pre><code class="language-typescript">var x: { foo: number, [x: string]: any };
x = { foo: 1, baz: 2 };  // OK, `baz` matched by index signature
</code></pre>
<p><strong>如果原始类型是一组相关联的类型，使用联合类型明确指定它们的类型而不是仅指定一个基本类型。</strong></p>
<pre><code class="language-typescript">let animalList: (Dog | Cat | Turkey)[] = [    // use union type instead of Animal
    {name: "Milo", meow: true },
    {name: "Pepper", bark: true},
    {name: "koko", gobble: true}
];
</code></pre>
<p><strong>还有可以明确地转换到目标类型以避免此错误：</strong></p>
<pre><code class="language-typescript">interface Foo {
    foo: number;
}
interface FooBar {
    foo: number;
    bar: number;
}
var y: Foo;
y = &lt;FooBar&gt;{ foo: 1, bar: 2 };
</code></pre>
<h2 id="commonjs的模块解析不再假设路径为相对的"><a class="header" href="#commonjs的模块解析不再假设路径为相对的">CommonJS的模块解析不再假设路径为相对的</a></h2>
<p>之前，对于<code>one.ts</code>和<code>two.ts</code>文件，如果它们在相同目录里，那么在<code>two.ts</code>里面导入<code>"one"</code>时是相对于<code>one.ts</code>的路径的。</p>
<p>TypeScript 1.6在编译CommonJS时，<code>"one"</code>不再等同于"./one"。取而代之的是会相对于合适的<code>node_modules</code>文件夹进行查找，与Node.js在运行时解析模块相似。更多详情，阅读<a href="https://github.com/Microsoft/TypeScript/issues/2338">the issue that describes the resolution algorithm</a>。</p>
<p><strong>例子：</strong></p>
<p><code>./one.ts</code></p>
<pre><code class="language-typescript">export function f() {
    return 10;
}
</code></pre>
<p><code>./two.ts</code></p>
<pre><code class="language-typescript">import { f as g } from "one";
</code></pre>
<p><strong>推荐：</strong></p>
<p><strong>修改所有计划之外的非相对的导入。</strong></p>
<p><code>./one.ts</code></p>
<pre><code class="language-typescript">export function f() {
    return 10;
}
</code></pre>
<p><code>./two.ts</code></p>
<pre><code class="language-typescript">import { f as g } from "./one";
</code></pre>
<p><strong>将<code>--moduleResolution</code>编译器选项设置为<code>classic</code>。</strong></p>
<h2 id="函数和类声明为默认导出时不再能够与在意义上有交叉的同名实体进行合并"><a class="header" href="#函数和类声明为默认导出时不再能够与在意义上有交叉的同名实体进行合并">函数和类声明为默认导出时不再能够与在意义上有交叉的同名实体进行合并</a></h2>
<p>在同一空间内默认导出声明的名字与空间内一实体名相同时会得到一个错误；比如，</p>
<pre><code class="language-typescript">export default function foo() {
}

namespace foo {
    var x = 100;
}
</code></pre>
<p>和</p>
<pre><code class="language-typescript">export default class Foo {
    a: number;
}

interface Foo {
    b: string;
}
</code></pre>
<p>两者都会报错。</p>
<p>然而，在下面的例子里合并是被允许的，因为命名空间并不具备做为值的意义：</p>
<pre><code class="language-typescript">export default class Foo {
}

namespace Foo {
}
</code></pre>
<p><strong>推荐：</strong></p>
<p>为默认导出声明本地变量并使用单独的<code>export default</code>语句：</p>
<pre><code class="language-typescript">class Foo {
    a: number;
}

interface foo {
    b: string;
}

export default Foo;
</code></pre>
<p>更多详情，请阅读<a href="https://github.com/Microsoft/TypeScript/issues/3095">the originating issue</a>。</p>
<h2 id="模块体以严格模式解析"><a class="header" href="#模块体以严格模式解析">模块体以严格模式解析</a></h2>
<p>按照<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-strict-mode-code">ES6规范</a>，模块体现在以严格模式进行解析。行为将相当于在模块作用域顶端定义了<code>"use strict"</code>；它包括限制了把<code>arguments</code>和<code>eval</code>做为变量名或参数名的使用，把未来保留字做为变量或参数使用，八进制数字字面量的使用等。</p>
<h2 id="标准库里dom-api的改动"><a class="header" href="#标准库里dom-api的改动">标准库里DOM API的改动</a></h2>
<ul>
<li><strong>MessageEvent</strong>和<strong>ProgressEvent</strong>构造函数希望传入参数；查看<a href="https://github.com/Microsoft/TypeScript/issues/4295">issue #4295</a>。</li>
<li><strong>ImageData</strong>构造函数希望传入参数；查看<a href="https://github.com/Microsoft/TypeScript/issues/4220">issue #4220</a>。</li>
<li><strong>File</strong>构造函数希望传入参数；查看<a href="https://github.com/Microsoft/TypeScript/issues/3999">issue #3999</a>。</li>
</ul>
<h2 id="系统模块输出使用批量导出"><a class="header" href="#系统模块输出使用批量导出">系统模块输出使用批量导出</a></h2>
<p>编译器以系统模块的格式使用新的<code>_export</code>函数<a href="https://github.com/ModuleLoader/es6-module-loader/issues/386">批量导出</a>的变体，它接收任何包含键值对的对象做为参数而不是key, value。</p>
<p>模块加载器需要升级到<a href="https://github.com/ModuleLoader/es6-module-loader/releases/tag/v0.17.1">v0.17.1</a>或更高。</p>
<h2 id="npm包的js内容从bin移到了lib"><a class="header" href="#npm包的js内容从bin移到了lib">npm包的.js内容从'bin'移到了'lib'</a></h2>
<p>TypeScript的npm包入口位置从<code>bin</code>移动到了<code>lib</code>，以防‘node_modules/typescript/bin/typescript.js’通过IIS访问的时候造成阻塞（<code>bin</code>默认是隐藏段因此IIS会阻止访问这个文件夹）。</p>
<h2 id="typescript的npm包不会默认全局安装"><a class="header" href="#typescript的npm包不会默认全局安装">TypeScript的npm包不会默认全局安装</a></h2>
<p>TypeScript 1.6从package.json里移除了<code>preferGlobal</code>标记。如果你依赖于这种行为，请使用<code>npm install -g typescript</code>。</p>
<h2 id="装饰器做为调用表达式进行检查"><a class="header" href="#装饰器做为调用表达式进行检查">装饰器做为调用表达式进行检查</a></h2>
<p>从1.6开始，装饰器类型检查更准确了；编译器会将装饰器表达式做为以被装饰的实体做为参数的调用表达式来进行检查。这可能会造成以前的代码报错。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-15-1"><a class="header" href="#typescript-15-1">TypeScript 1.5</a></h1>
<p>完整的破坏性改动列表请到这里查看:<a href="https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+milestone%3A%22TypeScript+1.5%22+label%3A%22breaking+change%22">breaking change issues</a>。</p>
<h2 id="不允许在箭头函数里引用arguments"><a class="header" href="#不允许在箭头函数里引用arguments">不允许在箭头函数里引用<code>arguments</code></a></h2>
<p>这是为了遵循ES6箭头函数的语义。之前箭头函数里的<code>arguments</code>会绑定到箭头函数的参数。参照<a href="http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts">ES6规范草稿</a> 9.2.12，箭头函数不存在<code>arguments</code>对象。 从TypeScript 1.5开始，在箭头函数里使用<code>arguments</code>会被标记成错误以确保你的代码转成ES6时没语义上的错误。</p>
<p><strong>例子：</strong></p>
<pre><code class="language-typescript">function f() {
    return () =&gt; arguments; // Error: The 'arguments' object cannot be referenced in an arrow function.
}
</code></pre>
<p><strong>推荐：</strong></p>
<pre><code class="language-typescript">// 1. 使用带名字的剩余参数
function f() {
    return (...args) =&gt; { args; }
}

// 2. 使用函数表达式
function f() {
    return function(){ arguments; }
}
</code></pre>
<h2 id="内联枚举引用的改动"><a class="header" href="#内联枚举引用的改动">内联枚举引用的改动</a></h2>
<p>对于正常的枚举，在1.5之前，编译器_仅会_内联常量成员，且成员仅在使用字面量初始化时才被当做是常量。这在判断检举值是使用字面量初始化还是表达式时会行为不一致。从TypeScript 1.5开始，所有非const枚举成员都不会被内联。</p>
<p><strong>例子：</strong></p>
<pre><code class="language-typescript">var x = E.a;  // previously inlined as "var x = 1; /*E.a*/"

enum E {
   a = 1
}
</code></pre>
<p><strong>推荐：</strong> 在枚举声明里添加<code>const</code>修饰符来确保它总是被内联。 更多信息，查看<a href="https://github.com/Microsoft/TypeScript/issues/2183">#2183</a>。</p>
<h2 id="上下文的类型将作用于super和括号表达式"><a class="header" href="#上下文的类型将作用于super和括号表达式">上下文的类型将作用于<code>super</code>和括号表达式</a></h2>
<p>在1.5之前，上下文的类型不会作用于括号表达式内部。这就要求做显示的类型转换，尤其是在_必须_使用括号来进行表达式转换的场合。</p>
<p>在下面的例子里，<code>m</code>具有上下文的类型，它在之前的版本里是没有的。</p>
<pre><code class="language-typescript">var x: SomeType = (n) =&gt; ((m) =&gt; q);
var y: SomeType = t ? (m =&gt; m.length) : undefined;

class C extends CBase&lt;string&gt; {
    constructor() {
        super({
            method(m) { return m.length; }
        });
    }
}
</code></pre>
<p>更多信息，查看<a href="https://github.com/Microsoft/TypeScript/issues/1425">#1425</a>和<a href="https://github.com/Microsoft/TypeScript/issues/920">#920</a>。</p>
<h2 id="dom接口的改动"><a class="header" href="#dom接口的改动">DOM接口的改动</a></h2>
<p>TypeScript 1.5改进了<code>lib.d.ts</code>库里的DOM类型。这是自TypeScript 1.0以来第一次大的改动；为了拥抱标准DOM规范，很多特定于IE的定义被移除了，同时添加了新的类型如Web Audio和触摸事件。</p>
<p><strong>变通方案：</strong></p>
<p>你可以使用旧的<code>lib.d.ts</code>配合新版本的编译器。你需要在你的工程里引入之前版本的一个拷贝。这里是<a href="https://github.com/Microsoft/TypeScript/blob/v1.5.0-alpha/bin/lib.d.ts">本次改动之前的lib.d.ts文件(TypeScript 1.5-alpha)</a>。</p>
<p><strong>变动列表：</strong></p>
<ul>
<li>属性<code>selection</code>从<code>Document</code>类型上移除</li>
<li>属性<code>clipboardData</code>从<code>Window</code>类型上移除</li>
<li>删除接口<code>MSEventAttachmentTarget</code></li>
<li>属性<code>onresize</code>，<code>disabled</code>，<code>uniqueID</code>，<code>removeNode</code>，<code>fireEvent</code>，<code>currentStyle</code>，<code>runtimeStyle</code>从<code>HTMLElement</code>类型上移除</li>
<li>属性<code>url</code>从<code>Event</code>类型上移除</li>
<li>属性<code>execScript</code>，<code>navigate</code>，<code>item</code>从<code>Window</code>类型上移除</li>
<li>属性<code>documentMode</code>，<code>parentWindow</code>，<code>createEventObject</code>从<code>Document</code>类型上移除</li>
<li>属性<code>parentWindow</code>从<code>HTMLDocument</code>类型上移除</li>
<li>属性<code>setCapture</code>被完全移除</li>
<li>属性<code>releaseCapture</code>被完全移除</li>
<li>属性<code>setAttribute</code>，<code>styleFloat</code>，<code>pixelLeft</code>从<code>CSSStyleDeclaration</code>类型上移除</li>
<li>属性<code>selectorText</code>从<code>CSSRule</code>类型上移除</li>
<li><code>CSSStyleSheet.rules</code>现在是<code>CSSRuleList</code>类型，而非<code>MSCSSRuleList</code></li>
<li><code>documentElement</code>现在是<code>Element</code>类型，而非<code>HTMLElement</code></li>
<li><code>Event</code>具有一个新的必需属性<code>returnValue</code></li>
<li><code>Node</code>具有一个新的必需属性<code>baseURI</code></li>
<li><code>Element</code>具有一个新的必需属性<code>classList</code></li>
<li><code>Location</code>具有一个新的必需属性<code>origin</code></li>
<li>属性<code>MSPOINTER_TYPE_MOUSE</code>，<code>MSPOINTER_TYPE_TOUCH</code>从<code>MSPointerEvent</code>类型上移除</li>
<li><code>CSSStyleRule</code>具有一个新的必需属性<code>readonly</code></li>
<li>属性<code>execUnsafeLocalFunction</code>从<code>MSApp</code>类型上移除</li>
<li>全局方法<code>toStaticHTML</code>被移除</li>
<li><code>HTMLCanvasElement.getContext</code>现在返回<code>CanvasRenderingContext2D | WebGLRenderingContex</code></li>
<li>移除扩展类型<code>Dataview</code>，<code>Weakmap</code>，<code>Map</code>，<code>Set</code></li>
<li><code>XMLHttpRequest.send</code>具有两个重载<code>send(data?: Document): void;</code>和<code>send(data?: String): void;</code></li>
<li><code>window.orientation</code>现在是<code>string</code>类型，而非<code>number</code></li>
<li>特定于IE的<code>attachEvent</code>和<code>detachEvent</code>从<code>Window</code>上移除</li>
</ul>
<p><strong>以下是被新加的DOM类型所部分或全部取代的代码库的代表：</strong></p>
<ul>
<li><code>DefinitelyTyped/auth0/auth0.d.ts</code></li>
<li><code>DefinitelyTyped/gamepad/gamepad.d.ts</code></li>
<li><code>DefinitelyTyped/interactjs/interact.d.ts</code></li>
<li><code>DefinitelyTyped/webaudioapi/waa.d.ts</code></li>
<li><code>DefinitelyTyped/webcrypto/WebCrypto.d.ts</code></li>
</ul>
<p>更多信息，查看<a href="https://github.com/Microsoft/TypeScript/pull/2739">完整改动</a>。</p>
<h2 id="类代码体将以严格格式解析"><a class="header" href="#类代码体将以严格格式解析">类代码体将以严格格式解析</a></h2>
<p>按照<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-strict-mode-code">ES6规范</a>，类代码体现在以严格模式进行解析。行为将相当于在类作用域顶端定义了<code>"use strict"</code>；它包括限制了把<code>arguments</code>和<code>eval</code>做为变量名或参数名的使用，把未来保留字做为变量或参数使用，八进制数字字面量的使用等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-14-1"><a class="header" href="#typescript-14-1">TypeScript 1.4</a></h1>
<p>完整的破坏性改动列表请到这里查看:<a href="https://github.com/Microsoft/TypeScript/issues?q=is%3Aissue+milestone%3A%22TypeScript+1.4%22+label%3A%22breaking+change%22">breaking change issues</a>。</p>
<p>阅读<a href="https://github.com/Microsoft/TypeScript/issues/868">issue #868</a>以了解更多关于联合类型的破坏性改动。</p>
<h2 id="多个最佳通用类型候选"><a class="header" href="#多个最佳通用类型候选">多个最佳通用类型候选</a></h2>
<p>当有多个最佳通用类型可用时，现在编译器会做出选择（依据编译器的具体实现）而不是直接使用第一个。</p>
<pre><code class="language-typescript">var a: { x: number; y?: number };
var b: { x: number; z?: number };

// 之前 { x: number; z?: number; }[]
// 现在 { x: number; y?: number; }[]
var bs = [b, a];
</code></pre>
<p>这会在多种情况下发生。具有一组共享的必需属性和一组其它互斥的（可选或其它）属性，空类型，兼容的签名类型（包括泛型和非泛型签名，当类型参数上应用了<code>any</code>时）。</p>
<p><strong>推荐</strong> 使用类型注解指定你要使用的类型。</p>
<pre><code class="language-typescript">var bs: { x: number; y?: number; z?: number }[] = [b, a];
</code></pre>
<h2 id="泛型接口"><a class="header" href="#泛型接口">泛型接口</a></h2>
<p>当在多个T类型的参数上使用了不同的类型时会得到一个错误，就算是添加约束也不行：</p>
<pre><code class="language-typescript">declare function foo&lt;T&gt;(x: T, y:T): T;
var r = foo(1, ""); // r used to be {}, now this is an error
</code></pre>
<p>添加约束：</p>
<pre><code class="language-typescript">interface Animal { x }
interface Giraffe extends Animal { y }
interface Elephant extends Animal { z }
function f&lt;T extends Animal&gt;(x: T, y: T): T { return undefined; }
var g: Giraffe;
var e: Elephant;
f(g, e);
</code></pre>
<p>在这里查看<a href="https://github.com/Microsoft/TypeScript/pull/824#discussion_r18665727">详细解释</a>。</p>
<p><strong>推荐</strong> 如果这种不匹配的行为是故意为之，那么明确指定类型参数：</p>
<pre><code class="language-typescript">var r = foo&lt;{}&gt;(1, ""); // Emulates 1.0 behavior
var r = foo&lt;string|number&gt;(1, ""); // Most useful
var r = foo&lt;any&gt;(1, ""); // Easiest
f&lt;Animal&gt;(g, e);
</code></pre>
<p>_或_重写函数定义指明就算不匹配也没问题：</p>
<pre><code class="language-typescript">declare function foo&lt;T,U&gt;(x: T, y:U): T|U;
function f&lt;T extends Animal, U extends Animal&gt;(x: T, y: U): T|U { return undefined; }
</code></pre>
<h2 id="泛型剩余参数-1"><a class="header" href="#泛型剩余参数-1">泛型剩余参数</a></h2>
<p>不能再使用混杂的参数类型：</p>
<pre><code class="language-typescript">function makeArray&lt;T&gt;(...items: T[]): T[] { return items; }
var r = makeArray(1, ""); // used to return {}[], now an error
</code></pre>
<p><code>new Array(...)</code>也一样</p>
<p><strong>推荐</strong> 声明向后兼容的签名，如果1.0的行为是你想要的：</p>
<pre><code class="language-typescript">function makeArray&lt;T&gt;(...items: T[]): T[];
function makeArray(...items: {}[]): {}[];
function makeArray&lt;T&gt;(...items: T[]): T[] { return items; }
</code></pre>
<h2 id="带类型参数接口的重载解析"><a class="header" href="#带类型参数接口的重载解析">带类型参数接口的重载解析</a></h2>
<pre><code class="language-typescript">var f10: &lt;T&gt;(x: T, b: () =&gt; (a: T) =&gt; void, y: T) =&gt; T;
var r9 = f10('', () =&gt; (a =&gt; a.foo), 1); // r9 was any, now this is an error
</code></pre>
<p><strong>推荐</strong> 手动指定一个类型参数</p>
<pre><code class="language-typescript">var r9 = f10&lt;any&gt;('', () =&gt; (a =&gt; a.foo), 1);
</code></pre>
<h2 id="类声明与类型表达式以严格模式解析"><a class="header" href="#类声明与类型表达式以严格模式解析">类声明与类型表达式以严格模式解析</a></h2>
<p>ECMAScript 2015语言规范(ECMA-262 6th Edition)指明_ClassDeclaration_和_ClassExpression_使用严格模式。 因此，在解析类声明或类表达式时将使用额外的限制。</p>
<p>例如：</p>
<pre><code class="language-typescript">class implements {}  // Invalid: implements is a reserved word in strict mode
class C {
    foo(arguments: any) {   // Invalid: "arguments" is not allow as a function argument
        var eval = 10;      // Invalid: "eval" is not allowed as the left-hand-side expression
        arguments = [];     // Invalid: arguments object is immutable
    }
}
</code></pre>
<p>关于严格模式限制的完整列表，请阅读 Annex C - The Strict Mode of ECMAScript of ECMA-262 6th Edition。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
